#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass amsbook
\begin_preamble
\setcounter{MaxMatrixCols}{30}%
\usepackage{amsfonts}\usepackage{graphicx}
%TCIDATA{OutputFilter=latex2.dll}
%TCIDATA{Version=5.50.0.2953}
%TCIDATA{CSTFile=LaTeX article (bright).cst}
%TCIDATA{Created=Thursday, March 08, 2007 06:44:18}
%TCIDATA{LastRevised=Friday, April 05, 2024 17:38:03}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{BibliographyScheme=BibTeX}
%TCIDATA{<META NAME="DocumentShell" CONTENT="Standard LaTeX\Blank - Standard LaTeX Article">}
%TCIDATA{Language=American English}
%TCIDATA{ComputeDefs=
%$\varepsilon$
%$F_{V(\mathbf{A})}(x_{1},...,x_{n})=\{t_{1},...,t_{k}\}$
%}
%BeginMSIPreambleData
\providecommand{\U}[1]{\protect\rule{.1in}{.1in}}
%EndMSIPreambleData
\newtheorem{theorem}{Theorem}\newtheorem{acknowledgement}[theorem]{Acknowledgement}\newtheorem{algorithm}[theorem]{Algorithm}\newtheorem{axiom}[theorem]{Axiom}\newtheorem{case}[theorem]{Case}\newtheorem{claim}[theorem]{Claim}\newtheorem{conclusion}[theorem]{Conclusion}\newtheorem{condition}[theorem]{Condition}\newtheorem{conjecture}[theorem]{Conjecture}\newtheorem{corollary}[theorem]{Corollary}\newtheorem{criterion}[theorem]{Criterion}\newtheorem{definition}[theorem]{Definition}\newtheorem{example}[theorem]{Example}\newtheorem{exercise}[theorem]{Exercise}\newtheorem{lemma}[theorem]{Lemma}\newtheorem{notation}[theorem]{Notation}\newtheorem{problem}[theorem]{Problem}\newtheorem{proposition}[theorem]{Proposition}\newtheorem{remark}[theorem]{Remark}\newtheorem{solution}[theorem]{Solution}\newtheorem{summary}[theorem]{Summary}\newenvironment{proof}[1][Proof]{\noindent\textbf{#1.} }{\ \rule{0.5em}{0.5em}}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Computabilidad y logica
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Notacion y conceptos basicos
\end_layout

\begin_layout Standard
Usaremos 
\begin_inset Formula $\mathbf{R}$
\end_inset

 para denotar el conjunto de los numeros reales, 
\begin_inset Formula $\mathbf{Z}$
\end_inset

 para denotar el conjunto de los numeros enteros, 
\begin_inset Formula $\mathbf{N}$
\end_inset

 para denotar el conjunto de los numeros naturales y 
\begin_inset Formula $\omega$
\end_inset

 para denotar al conjunto 
\begin_inset Formula $\mathbf{N}\cup\{0\}$
\end_inset

.
\end_layout

\begin_layout Standard
Dado un conjunto 
\begin_inset Formula $A$
\end_inset

, usaremos 
\begin_inset Formula $\mathcal{P}(A)$
\end_inset

 para denotar el conjunto formado por todos los subconjuntos de 
\begin_inset Formula $A$
\end_inset

, es decir:
\begin_inset Formula 
\[
\mathcal{P}(A)=\{S:S\subseteq A\}
\]

\end_inset

Si 
\begin_inset Formula $A$
\end_inset

 es un conjunto finito, entonces 
\begin_inset Formula $\left\vert A\right\vert $
\end_inset

 denotara la cantidad de elementos de 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $x,y\in\omega$
\end_inset

, definamos
\begin_inset Formula 
\[
x\dot{-}y=\left\{ \begin{array}{lll}
x-y &  & \text{si }x\geq y\\
0 &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

Dados 
\begin_inset Formula $x,y\in\omega$
\end_inset

 diremos que 
\begin_inset Formula $x$
\end_inset

 
\shape italic
divide a 
\shape default

\begin_inset Formula $y$
\end_inset

 cuando haya un 
\begin_inset Formula $z\in\omega$
\end_inset

 tal que 
\begin_inset Formula $y=z.x$
\end_inset

.
 Notar que 
\begin_inset Formula $0$
\end_inset

 divide a 
\begin_inset Formula $0$
\end_inset

, 
\begin_inset Formula $3$
\end_inset

 divide a 
\begin_inset Formula $0$
\end_inset

 y 
\begin_inset Formula $0$
\end_inset

 no divide a 
\begin_inset Formula $23$
\end_inset

.
 Escribiremos 
\begin_inset Formula $x\mid y$
\end_inset

 para expresar que 
\begin_inset Formula $x$
\end_inset

 divide a 
\begin_inset Formula $y$
\end_inset

.
 Dados 
\begin_inset Formula $x,y\in\omega$
\end_inset

, diremos que 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 son 
\shape italic
coprimos
\shape default
 cuando 
\begin_inset Formula $1$
\end_inset

 sea el unico elemento de 
\begin_inset Formula $\omega$
\end_inset

 que divide a ambos.
 Notese que 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 no son son coprimos sii existe un numero primo 
\begin_inset Formula $p\in\omega$
\end_inset

 que los divide a ambos
\end_layout

\begin_layout Standard
Si bien no hay una definicion natural en matematica de cuanto vale 
\begin_inset Formula $0^{0}$
\end_inset

 (
\begin_inset Formula $0$
\end_inset

 elevado a la 
\begin_inset Formula $0$
\end_inset

), por convencion para nosotros 
\begin_inset Formula $0^{0}=1$
\end_inset


\end_layout

\begin_layout Section
Conjuntos
\end_layout

\begin_layout Standard
Supondremos que el lector sabe las nociones basicas sobre conjuntos, aunque
 resaltaremos algunas de las mas importantes para que el lector las repase.
\end_layout

\begin_layout Standard
La propiedad de 
\shape italic
extensionalidad
\shape default
 nos dice que, dados conjuntos 
\begin_inset Formula $A,B$
\end_inset

, se tiene que 
\begin_inset Formula $A=B$
\end_inset

 si y solo si para cada objeto 
\begin_inset Formula $x$
\end_inset

 se da que
\begin_inset Formula 
\[
x\in A\text{ si y solo si }x\in B
\]

\end_inset

Esta propiedad es importante metodologicamente ya que a la hora de probar
 que dos conjuntos 
\begin_inset Formula $A,B$
\end_inset

 son iguales, extensionalidad nos asegura que basta con ver que se dan las
 dos inclusiones 
\begin_inset Formula $A\subseteq B$
\end_inset

 y 
\begin_inset Formula $B\subseteq A$
\end_inset

.
\end_layout

\begin_layout Standard
Otro tema importante es manejar correctamente la notacion cuando definimos
 un conjunto usando llaves y mediante propiedades que caracterizan la pertenenci
a al mismo.
 Algunos ejemplos
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\{x\in\mathbf{N}:x=1$
\end_inset

 o 
\begin_inset Formula $x\geq5\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\{x:x\in\mathbf{R}$
\end_inset

 y 
\begin_inset Formula $x^{2}\geq100\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\{x:x=100\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\{x^{2}+1:x\in\omega\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\{x+y+z:x,y,z\in\{1,2\}\}$
\end_inset

 
\end_layout

\begin_layout Standard
Dejamos al lector la tarea de entender en forma precisa que conjunto se
 esta denotando en cada caso.
\end_layout

\begin_layout Section
Producto carteciano
\end_layout

\begin_layout Standard
Dados conjuntos 
\begin_inset Formula $A_{1},...,A_{n}$
\end_inset

, con 
\begin_inset Formula $n\geq2$
\end_inset

, usaremos 
\begin_inset Formula $A_{1}\times...\times A_{n}$
\end_inset

 para denotar el 
\shape italic
producto Cartesiano
\shape default
 de 
\begin_inset Formula $A_{1},...,A_{n}$
\end_inset

, es decir el conjunto formado por todas las 
\begin_inset Formula $n$
\end_inset

-uplas 
\begin_inset Formula $(a_{1},...,a_{n})$
\end_inset

 tales que 
\begin_inset Formula $a_{1}\in A_{1},...,a_{n}\in A_{n}$
\end_inset

.
 Si 
\begin_inset Formula $A_{1}=...=A_{n}=A$
\end_inset

, con 
\begin_inset Formula $n\geq2$
\end_inset

, entonces escribiremos 
\begin_inset Formula $A^{n}$
\end_inset

 en lugar de 
\begin_inset Formula $A_{1}\times...\times A_{n}$
\end_inset

.
 Para 
\begin_inset Formula $n=1$
\end_inset

, definimos 
\begin_inset Formula $A^{n}=A$
\end_inset

, es decir 
\begin_inset Formula $A^{1}=A$
\end_inset

.
 Usaremos 
\begin_inset Formula $\Diamond$
\end_inset

 para denotar la unica 
\begin_inset Formula $0$
\end_inset

-upla.
 Definimos entonces 
\begin_inset Formula $A^{0}=\{\Diamond\}$
\end_inset

.
 Si 
\begin_inset Formula $A$
\end_inset

 es un conjunto denotaremos con 
\begin_inset Formula $A^{\mathbf{N}}$
\end_inset

 al conjunto formado por todas las infinituplas 
\begin_inset Formula $(a_{1},a_{2},...)$
\end_inset

 tales que 
\begin_inset Formula $a_{i}\in A$
\end_inset

 para cada 
\begin_inset Formula $i\in\mathbf{N}$
\end_inset

.
 Por ejemplo
\begin_inset Formula 
\[
(1,2,3,4,...)\in\omega^{\mathbf{N}}
\]

\end_inset

donde 
\begin_inset Formula $(1,2,3,4,...)$
\end_inset

 es una forma intuitiva de denotar la infinitupla cuyo 
\begin_inset Formula $i$
\end_inset

-esimo elemento es el numero natural 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $(A_{1},A_{2},...)$
\end_inset

 es una infinitupla de conjuntos, entonces usaremos 
\begin_inset Formula $\bigcup\nolimits _{i=1}^{\infty}A_{i}$
\end_inset

 o 
\begin_inset Formula $\bigcup\nolimits _{i\geq1}A_{i}$
\end_inset

 para denotar al conjunto
\begin_inset Formula 
\[
\{a:a\in A_{i}\mathrm{,\ para\ algun\ }i\in\mathbf{N}\}
\]

\end_inset


\end_layout

\begin_layout Section
Alfabetos
\end_layout

\begin_layout Standard
Un 
\shape italic
alfabeto
\shape default
 es un conjunto finito de simbolos.
 Notese que 
\begin_inset Formula $\emptyset$
\end_inset

 es un alfabeto.
 Si 
\begin_inset Formula $\Sigma$
\end_inset

 es un alfabeto, entonces 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 denotara el conjunto de todas las palabras formadas con simbolos de 
\begin_inset Formula $\Sigma$
\end_inset

.
 Las palabras de longitud 
\begin_inset Formula $1$
\end_inset

 son exactamente los elementos de 
\begin_inset Formula $\Sigma$
\end_inset

, en particular esto nos dice que 
\begin_inset Formula $\Sigma\subseteq\Sigma^{\ast}$
\end_inset

.
 La unica palabra de longitud 
\begin_inset Formula $0$
\end_inset

 es denotada con 
\begin_inset Formula $\varepsilon$
\end_inset

.
 Ya que en 
\begin_inset Formula $\varepsilon$
\end_inset

 no ocurren simbolos, tenemos que 
\begin_inset Formula $\varepsilon\in\Sigma^{\ast}$
\end_inset

, para cualquier alfabeto, mas aun notese que 
\begin_inset Formula $\emptyset^{\ast}=\{\varepsilon\}$
\end_inset

.
 Usaremos 
\begin_inset Formula $\left\vert \alpha\right\vert $
\end_inset

 para denotar la longitud de la palabra 
\begin_inset Formula $\alpha$
\end_inset

.
 Si 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $\sigma\in\Sigma$
\end_inset

, usaremos 
\begin_inset Formula $\left\vert \alpha\right\vert _{\sigma}$
\end_inset

 para denotar la cantidad de ocurrencias del simbolo 
\begin_inset Formula $\sigma$
\end_inset

 en 
\begin_inset Formula $\alpha$
\end_inset

.
 Usaremos 
\begin_inset Formula $\Sigma^{+}$
\end_inset

 para denotar al conjunto 
\begin_inset Formula $\Sigma^{\ast}-\{\varepsilon\}$
\end_inset

.
 Notese que funciones, 
\begin_inset Formula $n$
\end_inset

-uplas y palabras son objetos de distinto tipo, por lo cual 
\begin_inset Formula $\emptyset$
\end_inset

, 
\begin_inset Formula $\Diamond$
\end_inset

 y 
\begin_inset Formula $\varepsilon$
\end_inset

 son tres objetos matematicos diferentes.
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\alpha_{1},...,\alpha_{n}\in\Sigma^{\ast}$
\end_inset

, con 
\begin_inset Formula $n\geq0$
\end_inset

, usaremos 
\begin_inset Formula $\alpha_{1}...\alpha_{n}$
\end_inset

 para denotar la 
\shape italic
concatenacion
\shape default
 de las palabras 
\begin_inset Formula $\alpha_{1},...,\alpha_{n}$
\end_inset

 (notese que cuando 
\begin_inset Formula $n=0$
\end_inset

, resulta que 
\begin_inset Formula $\alpha_{1}...\alpha_{n}=\varepsilon$
\end_inset

).
 Si 
\begin_inset Formula $\alpha_{1}=...=\alpha_{n}=\alpha$
\end_inset

, entonces escribiremos 
\begin_inset Formula $\alpha^{n}$
\end_inset

 en lugar de 
\begin_inset Formula $\alpha_{1}...\alpha_{n}$
\end_inset

.
 O sea que 
\begin_inset Formula $\alpha^{0}=\varepsilon$
\end_inset

.
\end_layout

\begin_layout Standard
Diremos que 
\begin_inset Formula $\alpha$
\end_inset

 
\shape italic
es subpalabra (propia) de 
\shape default

\begin_inset Formula $\beta$
\end_inset

 cuando (
\begin_inset Formula $\alpha\notin\{\varepsilon,\beta\}$
\end_inset

 y) existan palabras 
\begin_inset Formula $\delta,\gamma$
\end_inset

 tales que 
\begin_inset Formula $\beta=\delta\alpha\gamma$
\end_inset

.
 Diremos que 
\begin_inset Formula $\beta$
\end_inset

 es un 
\shape italic
tramo inicial (propio) 
\shape default
de 
\begin_inset Formula $\alpha$
\end_inset

 si hay una palabra 
\begin_inset Formula $\gamma$
\end_inset

 tal que 
\begin_inset Formula $\alpha=\beta\gamma$
\end_inset

 (y 
\begin_inset Formula $\beta\notin\{\varepsilon,\alpha\}$
\end_inset

).
 En forma similar se define 
\shape italic
tramo final (propio).
\end_layout

\begin_layout Standard
Dados 
\begin_inset Formula $i\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 definamos
\begin_inset Formula 
\[
\left[\alpha\right]_{i}=\left\{ \begin{array}{lll}
i\text{-esimo elemento de }\alpha &  & \text{si }1\leq i\leq\left\vert \alpha\right\vert \\
\varepsilon &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

Dada 
\begin_inset Formula $\gamma\in\Sigma^{\ast}$
\end_inset

, definamos
\begin_inset Formula 
\[
\gamma^{R}=\left\{ \begin{array}{lll}
[\gamma]_{\left\vert \gamma\right\vert }[\gamma]_{\left\vert \gamma\right\vert -1}...[\gamma]_{1} &  & \text{si }\left\vert \gamma\right\vert \geq1\\
\varepsilon &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

La palabra 
\begin_inset Formula $\gamma^{R}$
\end_inset

 es llamada la 
\shape italic
resiproca
\shape default
 de 
\begin_inset Formula $\gamma$
\end_inset

.
\end_layout

\begin_layout Subsection
Ocurrencias
\end_layout

\begin_layout Standard
Dadas palabras 
\begin_inset Formula $\alpha,\beta\in\Sigma^{\ast}$
\end_inset

, con 
\begin_inset Formula $\left\vert \alpha\right\vert ,\left\vert \beta\right\vert \geq1$
\end_inset

, y un natural 
\begin_inset Formula $i\in\{1,...,\left\vert \beta\right\vert \}$
\end_inset

, se dice que 
\begin_inset Formula $\alpha$
\end_inset

 
\shape italic
ocurre a partir de 
\shape default

\begin_inset Formula $i$
\end_inset

 
\shape italic
en 
\shape default

\begin_inset Formula $\beta$
\end_inset

 cuando se de que existan palabras 
\begin_inset Formula $\delta,\gamma$
\end_inset

 tales que 
\begin_inset Formula $\beta=\delta\alpha\gamma$
\end_inset

 y 
\begin_inset Formula $\left\vert \delta\right\vert =i-1$
\end_inset

.
 Intuitivamente hablando 
\begin_inset Formula $\alpha$
\end_inset

 ocurre a partir de 
\begin_inset Formula $i$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

 cuando se de que si comensamos a leer desde el lugar 
\begin_inset Formula $i$
\end_inset

-esimo de 
\begin_inset Formula $\beta$
\end_inset

 en adelante, leeremos la palabra 
\begin_inset Formula $\alpha$
\end_inset

 completa y luego posiblemente seguiran otros simbolos.
\end_layout

\begin_layout Standard
Notese que una palabra 
\begin_inset Formula $\alpha$
\end_inset

 puede ocurrir en 
\begin_inset Formula $\beta$
\end_inset

, a partir de 
\begin_inset Formula $i$
\end_inset

, y tambien a partir de 
\begin_inset Formula $j$
\end_inset

, con 
\begin_inset Formula $i\neq j$
\end_inset

.
 En virtud de esto, hablaremos de las distintas ocurrencias de 
\begin_inset Formula $\alpha$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

.
 Por ejemplo hay dos ocurrencias de la palabra 
\begin_inset Formula $aba$
\end_inset


\begin_inset space \space{}
\end_inset

en la palabra
\begin_inset Formula 
\[
cccccccabaccccabaccccc
\]

\end_inset

y tambien hay dos ocurrencias de la palabra 
\begin_inset Formula $aba$
\end_inset

 en la palabra
\begin_inset Formula 
\[
cccccccababacccccccccc
\]

\end_inset

En el primer caso diremos que dichas ocurrencias de 
\begin_inset Formula $aba$
\end_inset

 son 
\shape italic
disjuntas
\shape default
 ya que ocupan espacios disjuntos dentro de la palabra.
 En cambio en el segundo caso puede apreciarse que las dos ocurrencias se
 superponen en una posicion.
 A veces diremos que una ocurrencia esta 
\shape italic
contenida
\shape default
 o 
\shape italic
sucede
\shape default
 dentro de otra.
 Por ejemplo la segunda ocurrencia de 
\begin_inset Formula $ab$
\end_inset

 en 
\begin_inset Formula $babbbfabcccfabccc$
\end_inset

 esta contenida en la primer ocurrencia de 
\begin_inset Formula $fabc$
\end_inset

 en 
\begin_inset Formula $babbbfabcccfabccc$
\end_inset

.
\end_layout

\begin_layout Standard
No definiremos en forma matematica precisa el concepto de ocurrencia pero
 el lector no tendra problemas en comprenderlo y manejarlo en forma correcta.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
Reemplazos de ocurrencias
\end_layout

\begin_layout Standard
Tambien haremos 
\shape italic
reemplazos
\shape default
 de ocurrencias por palabras.
 Por ejemplo el resultado de reemplazar la primer ocurrencia de 
\begin_inset Formula $abb$
\end_inset

 en 
\begin_inset Formula $ccabbgfgabbgg$
\end_inset

 por 
\begin_inset Formula $oolala$
\end_inset

 es la palabra 
\begin_inset Formula $ccoolalagfgabbgg$
\end_inset

.
 Cuando todas las ocurrencias de una palabra 
\begin_inset Formula $\alpha$
\end_inset

 en una palabra 
\begin_inset Formula $\beta$
\end_inset

 sean disjuntas entre si, podemos hablar del resultado de 
\shape italic
reeplazar simultaneamente cada ocurrencia de 
\shape default

\begin_inset Formula $\alpha$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $\beta$
\end_inset

 
\shape italic
por
\shape default
 
\begin_inset Formula $\gamma$
\end_inset

.
 Por ejemplo si tenemos
\begin_inset Formula 
\begin{align*}
\alpha & =yet\\
\beta & =ghsyetcjjjyetbcpyeteabc\\
\gamma & =\%\%
\end{align*}

\end_inset

entonces 
\begin_inset Formula $ghs\%\%cjjj\%\%bcp\%\%eabc$
\end_inset

 es el resultado de reemplazar simultaneamente cada ocurrencia de 
\begin_inset Formula $\alpha$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

 por 
\begin_inset Formula $\gamma$
\end_inset

.
 Es importante notar que los reemplazos se hacen simultaneamente y no secuencial
mente (i.e.
 reemplazando la primer ocurrencia de 
\begin_inset Formula $\alpha$
\end_inset

 por 
\begin_inset Formula $\gamma$
\end_inset

 y luego al resultado reemplazarle la primer ocurrencia de 
\begin_inset Formula $\alpha$
\end_inset

 por 
\begin_inset Formula $\gamma$
\end_inset

 y asi sucesivamente).
 Obviamente el reemplazo secuencial puede dar un resultado distinto al simultane
o (que es el que usaremos en general) e incluso puede suceder que en el
 reemplazo secuencial el proceso se pueda iterar indefinidamente.
 Dejamos al lector armar ejemplos de estas cituaciones.
\end_layout

\begin_layout Standard
Tambien se pueden hacer reemplazos simultaneos de distintas palabras en
 una palabra dada.
 Supongamos tenemos palabras 
\begin_inset Formula $\alpha_{1},...,\alpha_{n}$
\end_inset

 (con 
\begin_inset Formula $\alpha_{i}\neq\alpha_{j}$
\end_inset

, para 
\begin_inset Formula $i\neq j$
\end_inset

) las cuales tienen la propiedad de que las distintas ocurrencias de ellas
 en la palabra 
\begin_inset Formula $\beta$
\end_inset

 son siempre disjuntas de a pares, y tenemos ademas palabras 
\begin_inset Formula $\gamma_{1},...,\gamma_{n}$
\end_inset

.
 Entonces hablaremos del resultado de reemplazar simultaneamente:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\alpha_{1}$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

, por 
\begin_inset Formula $\gamma_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\alpha_{2}$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

, por 
\begin_inset Formula $\gamma_{2}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\alpha_{n}$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

, por 
\begin_inset Formula $\gamma_{n}$
\end_inset

 
\end_layout

\begin_layout Standard
Por ejemplo si tomamos
\begin_inset Formula 
\begin{align*}
\alpha_{1} & =gh\\
\alpha_{2} & =yet\\
\alpha_{3} & =ana\\
\beta & =ghbbbyetbbgh\%\%ana\#\#ana!!!ana\\
\gamma_{1} & =AA\\
\gamma_{2} & =BBBB\\
\gamma_{3} & =CCC
\end{align*}

\end_inset

entonces 
\begin_inset Formula $AAbbbBBBBbbAA\%\%CCC\#\#CCC!!!CCC$
\end_inset

 es el resultado de reemplazar simultaneamente:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\alpha_{1}$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

, por 
\begin_inset Formula $\gamma_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\alpha_{2}$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

, por 
\begin_inset Formula $\gamma_{2}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 -
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\alpha_{3}$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

, por 
\begin_inset Formula $\gamma_{3}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Matematica orientada a objetos
\end_layout

\begin_layout Standard
Nuestro estilo o enfoque matematico pondra enfasis en los objetos, es decir
 haremos matematica prestando atencion a los distintos objetos matematicos
 involucrados, los cuales siempre seran definidos en forma precisa en terminos
 de objetos mas primitivos.
 Hay ciertos objetos matematicos los cuales no definiremos y supondremos
 que el lector tiene una idea clara y precisa de los mismos.
 Por ejemplo un tipo de objeto matematico, quizas el mas famoso, son los
 
\shape italic
numeros
\shape default
.
 No diremos que es un numero pero supondremos que el lector tiene una intuicion
 clara acerca de este tipo de objetos y de sus propiedades basicas.
 Otro tipo de objeto que no definiremos y que sera clave para nuestro enfoque
 son los 
\shape italic
conjuntos
\shape default
.
 Nuevamente, no diremos que es un conjunto pero supondremos que el lector
 tiene una intuicion clara acerca de estos objetos y sus propiedades basicas.
 Es importante que en nuestro enfoque, numeros y conjuntos son objetos de
 distinta naturaleza por lo cual nunca un numero es un conjunto ni un conjunto
 es un numero.
 En particular esto nos dice que el numero 
\begin_inset Formula $0$
\end_inset

 y el conjunto 
\begin_inset Formula $\emptyset$
\end_inset

 son objetos distintos.
 Otro tipo de objeto matematico muy importante para la matematica discreta
 son los 
\shape italic
simbolos
\shape default
.
 No discutiremos que es un simbolo sino que aceptaremos este concepto en
 forma primitiva.
 Tambien constituyen un tipo de objeto matematico las 
\shape italic
palabras
\shape default
, las cuales intuitivamente hablando son juxtaposiciones de simbolos.
 Otro tipo de objeto matematico muy importante son los 
\shape italic
pares ordenados
\shape default
 o 2-
\shape italic
uplas
\shape default
, es decir los objetos de la forma 
\begin_inset Formula $(a,b)$
\end_inset

, donde 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 son objetos matematicos cualesquiera.
 Tambien son objetos matematicos y de distinta naturaleza las 3-
\shape italic
uplas
\shape default
, las 4-
\shape italic
uplas
\shape default
 y en general las 
\begin_inset Formula $n$
\end_inset

-
\shape italic
uplas
\shape default
 para 
\begin_inset Formula $n$
\end_inset

 un numero natural mayor o igual a 
\begin_inset Formula $2$
\end_inset

.
 Cabe destacar que en nuestro enfoque no habra 1-uplas.
 Sin envargo, si bien hay una sola 0-
\shape italic
upla
\shape default
, ella constituye un tipo de objeto matematico distinto a los antes mensionados.
 El ultimo tipo de objeto matematico que consideraremos es aquel de las
 
\shape italic
infinituplas
\shape default
.
\end_layout

\begin_layout Standard
Tenemos entonces dividido nuestro universo matematico en las distintas categoria
s de objetos:
\begin_inset Formula 
\begin{align*}
 & \mathrm{NUMERO}\\
 & \mathrm{CONJUNTO}\\
 & \mathrm{PALABRA}\\
 & 0\mathrm{-UPLA}\\
 & 2\mathrm{-UPLA}\\
 & 3\mathrm{-UPLA}\\
 & \ \ \ \ \ \ \ \ \vdots\\
 & \mathrm{INFINITUPLA}
\end{align*}

\end_inset

(Notar que los simbolos quedan contenidos en la categoria de las palabras).
 Es importante entender que las anteriores categorias o tipos de objetos
 son disjuntas entre si, es decir nunca un numero sera una palabra o una
 palabra sera una 3-upla etc.
 Esto nos permite definir una funcion 
\begin_inset Formula $Ti$
\end_inset

 la cual a un objeto matematico le asigna su tipo de objeto matematico segun
 la lista anterior.
 Por ejemplo:
\begin_inset Formula 
\begin{align*}
Ti(\pi) & =\mathrm{NUMERO}\\
Ti(\mathbf{N}) & =\mathrm{CONJUNTO}\\
Ti(\mathcal{P}(\mathbf{N})) & =\mathrm{CONJUNTO}\\
Ti((1,2,3)) & =3\mathrm{-UPLA}\\
Ti(\mathbf{\emptyset}) & =\mathrm{CONJUNTO}\\
Ti(\varepsilon) & =\mathrm{PALABRA}\\
Ti(\Diamond) & =0\mathrm{-UPLA}\\
Ti(\alpha) & =\mathrm{PALABRA}\text{, si }\alpha\text{ es un simbolo}\\
Ti(f) & =\mathrm{CONJUNTO}\text{, si }f\text{ es una funcion}
\end{align*}

\end_inset


\end_layout

\begin_layout Section
El concepto de funcion
\end_layout

\begin_layout Standard
Asumiremos que el lector tiene una idea intuitiva del concepto de funcion.
 Daremos aqui una definicion matematica de dicho concepto.
 Una 
\shape italic
funcion
\shape default
 es un conjunto 
\begin_inset Formula $f$
\end_inset

 de pares ordenados con la siguiente propiedad
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(F)
\end_layout

\end_inset

Si 
\begin_inset Formula $(x,y)\in f$
\end_inset

 y 
\begin_inset Formula $(x,z)\in f$
\end_inset

, entonces 
\begin_inset Formula $y=z$
\end_inset

.
 
\end_layout

\begin_layout Standard
Por ejemplo, si tomamos 
\begin_inset Formula $f=\{(x,x^{2}):x\in\omega\}$
\end_inset

 se puede ver facilmente que 
\begin_inset Formula $f$
\end_inset

 cumple la propiedad (F).
 Dada una funcion 
\begin_inset Formula $f$
\end_inset

, definamos
\begin_inset Formula 
\begin{align*}
D_{f} & =\text{ dominio de }f=\{x:(x,y)\in f\text{ para algun }y\}\\
I_{f} & =\text{ imagen de }f=\{y:(x,y)\in f\text{ para algun }x\}
\end{align*}

\end_inset

A veces escribiremos 
\begin_inset Formula $\operatorname{Dom}(f)$
\end_inset

 y 
\begin_inset Formula $\operatorname{Im}(f)$
\end_inset

 para denotar, respectivamente, el dominio y la imagen de una funcion 
\begin_inset Formula $f$
\end_inset

.
 Como es usual dado 
\begin_inset Formula $x\in D_{f}$
\end_inset

, usaremos 
\begin_inset Formula $f(x)$
\end_inset

 para denotar al unico 
\begin_inset Formula $y\in I_{f}$
\end_inset

 tal que 
\begin_inset Formula $(x,y)\in f$
\end_inset

.
 Notese que 
\begin_inset Formula $\emptyset$
\end_inset

 es una funcion y que 
\begin_inset Formula $D_{\emptyset}=I_{\emptyset}=\emptyset$
\end_inset

.
 Por ejemplo para 
\begin_inset Formula $f=\{(x,x^{2}):x\in\omega\}$
\end_inset

 se tiene que 
\begin_inset Formula $D_{f}=\omega$
\end_inset

 y 
\begin_inset Formula $I_{f}=\{y:y=x^{2}$
\end_inset

 para algun 
\begin_inset Formula $x\in\omega\}$
\end_inset

.
 Ademas notese que 
\begin_inset Formula $f(x)=x^{2}$
\end_inset

, para cada 
\begin_inset Formula $x\in D_{f}$
\end_inset

.
\end_layout

\begin_layout Standard
Escribiremos 
\begin_inset Formula $f:S\subseteq A\rightarrow B$
\end_inset

 para expresar que 
\begin_inset Formula $f$
\end_inset

 es una funcion tal que 
\begin_inset Formula $D_{f}=S\subseteq A$
\end_inset

 y 
\begin_inset Formula $I_{f}\subseteq B$
\end_inset

.
 Tambien escribiremos 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 para expresar que 
\begin_inset Formula $f$
\end_inset

 es una funcion tal que 
\begin_inset Formula $D_{f}=A$
\end_inset

 y 
\begin_inset Formula $I_{f}\subseteq B$
\end_inset

.
 En tal contexto llamaremos a 
\begin_inset Formula $B$
\end_inset

 
\shape italic
conjunto de llegada
\shape default
.
 Por supuesto 
\begin_inset Formula $B$
\end_inset

 no esta determinado por 
\begin_inset Formula $f$
\end_inset

 ya que solo debe cumplir 
\begin_inset Formula $I_{f}\subseteq B$
\end_inset

.
\end_layout

\begin_layout Standard
Muchas veces para definir una funcion 
\begin_inset Formula $f$
\end_inset

, lo haremos dando su dominio y su regla de asignacion, es decir especificaremos
 en forma precisa que conjunto es el dominio de 
\begin_inset Formula $f$
\end_inset

 y ademas especificaremos en forma presisa quien es 
\begin_inset Formula $f(x)$
\end_inset

 para cada 
\begin_inset Formula $x$
\end_inset

 de dicho dominio.
 Obviamente esto determina por completo a la funcion 
\begin_inset Formula $f$
\end_inset

 ya que 
\begin_inset Formula $f=\{(x,f(x)):x\in D_{f}\}$
\end_inset

.
 Por ejemplo si decimos que 
\begin_inset Formula $f$
\end_inset

 es la funcion dada por:
\begin_inset Formula 
\begin{align*}
D_{f} & =\omega\\
f(x) & =23x^{2}
\end{align*}

\end_inset

nos estaremos refiriendo a la funcion 
\begin_inset Formula $\{(x,23x^{2}):x\in\omega\}$
\end_inset

.
 Tambien escribiremos
\begin_inset Formula 
\[
\begin{array}{rll}
f:\omega & \rightarrow & \omega\\
x & \rightarrow & 23x^{2}
\end{array}
\]

\end_inset

para describir a 
\begin_inset Formula $f$
\end_inset

.
 Es decir, a veces para hacer mas intuitiva aun la descripcion de la funcion,
 tambien incluiremos un conjunto de llegada de dicha funcion y a la regla
 de asignacion la escribiremos usando una flecha.
 Para dar otro ejemplo, si escribimos sea 
\begin_inset Formula $f$
\end_inset

 dada por:
\begin_inset Formula 
\[
\begin{array}{rll}
f:\mathbf{N} & \rightarrow & \omega\\
x & \rightarrow & \left\{ \begin{array}{ccc}
x+1 &  & \text{si }x\text{ es par}\\
x^{2} &  & \text{si }x\text{ es impar}
\end{array}\right.
\end{array}
\]

\end_inset

estaremos diciendo que 
\begin_inset Formula $f$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\{(x,x+1):x\text{ es par y }x\in\mathbf{N}\}\cup\{(x,x^{2}):x\text{ es impar y }x\in\mathbf{N}\}
\]

\end_inset


\end_layout

\begin_layout Subsection*
Igualdad de funciones
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 dos funciones.
 Ya que las mismas son conjuntos, tendremos que 
\begin_inset Formula $f$
\end_inset

 sera igual a 
\begin_inset Formula $g$
\end_inset

 si y solo si para cada par 
\begin_inset Formula $(a,b)$
\end_inset

, se tiene que 
\begin_inset Formula $(a,b)\in f$
\end_inset

 sii 
\begin_inset Formula $(a,b)\in g$
\end_inset

.
 Muchas veces sera util el siguiente criterio de igualdad de funciones:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sean 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 funciones.
 Entonces 
\begin_inset Formula $f=g$
\end_inset

 sii 
\begin_inset Formula $D_{f}=D_{g}$
\end_inset

 y para cada 
\begin_inset Formula $x\in D_{f}$
\end_inset

 se tiene que 
\begin_inset Formula $f(x)=g(x)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Funcion identidad
\end_layout

\begin_layout Standard
Dado un conjunto 
\begin_inset Formula $A$
\end_inset

, a la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
A & \rightarrow & A\\
a & \rightarrow & a
\end{array}
\]

\end_inset

La denotaremos con 
\begin_inset Formula $Id_{A}$
\end_inset

 y la llamaremos la funcion 
\shape italic
identidad sobre 
\shape default

\begin_inset Formula $A$
\end_inset

.
 Notese que 
\begin_inset Formula $Id_{A}=\{(a,a):a\in A\}$
\end_inset

.
\end_layout

\begin_layout Subsection
Composicion de funciones
\end_layout

\begin_layout Standard
Dadas funciones 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 definamos la funcion 
\begin_inset Formula $f\circ g$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\begin{align*}
D_{f\circ g} & =\{e\in D_{g}:g(e)\in D_{f}\}\\
f\circ g(e) & =f(g(e))
\end{align*}

\end_inset

Notar que 
\begin_inset Formula $f\circ g=\{(u,v):$
\end_inset

 existe 
\begin_inset Formula $z$
\end_inset

 tal que 
\begin_inset Formula $(u,z)\in g$
\end_inset

 y 
\begin_inset Formula $(z,v)\in f\}$
\end_inset

.
 Notese que 
\begin_inset Formula $f\circ g\neq\emptyset$
\end_inset

 si y solo si 
\begin_inset Formula $I_{g}\cap D_{f}\neq\emptyset$
\end_inset

, lo cual nos dice que muchas veces sucedera que 
\begin_inset Formula $f\circ g=\emptyset$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Funciones inyectivas, suryectivas y biyectivas
\end_layout

\begin_layout Standard
Una funcion 
\begin_inset Formula $f$
\end_inset

 es 
\shape italic
inyectiva
\shape default
 cuando no se da que 
\begin_inset Formula $f(a)=f(b)$
\end_inset

 para algun par de elementos distintos 
\begin_inset Formula $a,b\in D_{f}$
\end_inset

.
 Dada una funcion 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 diremos que 
\begin_inset Formula $f$
\end_inset

 es 
\shape italic
suryectiva
\shape default
 cuando 
\begin_inset Formula $I_{f}=B$
\end_inset

.
 Debe notarse que el concepto de suryectividad depende de un conjunto de
 llegada previamente fijado, es decir que no tiene sentido hablar de la
 suryectividad de una funcion 
\begin_inset Formula $f$
\end_inset

 si no decimos respecto de que conjunto de llegada lo es.
 Muchas veces diremos que una funcion 
\begin_inset Formula $f$
\end_inset

 es 
\shape italic
sobre
\shape default
 para expresar que es suryectiva.
\end_layout

\begin_layout Standard
Dada una funcion 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 diremos que 
\begin_inset Formula $f$
\end_inset

 es 
\shape italic
biyectiva
\shape default
 cuando 
\begin_inset Formula $f$
\end_inset

 sea inyectiva y suryectiva.
 Notese que si 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 es biyectiva, entonces podemos definir una nueva funcion 
\begin_inset Formula $f^{-1}:B\rightarrow A$
\end_inset

, de la siguiente manera:
\begin_inset Formula 
\[
f^{-1}(b)=\text{ unico }a\in A\text{ tal que }f(a)=b
\]

\end_inset

La funcion 
\begin_inset Formula $f^{-1}$
\end_inset

 sera llamada la 
\shape italic
inversa de 
\shape default

\begin_inset Formula $f$
\end_inset

.
 Notese que 
\begin_inset Formula $f\circ f^{-1}=Id_{B}$
\end_inset

 y 
\begin_inset Formula $f^{-1}\circ f=Id_{A}$
\end_inset

.
 El siguiente lema muestra que esta ultima propiedad caracteriza la inversa.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "mutuamente inversas"

\end_inset

Supongamos 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 y 
\begin_inset Formula $g:B\rightarrow A$
\end_inset

 son tales que 
\begin_inset Formula $f\circ g=Id_{B}$
\end_inset

 y 
\begin_inset Formula $g\circ f=Id_{A}$
\end_inset

.
 Entonces 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 son biyectivas, 
\begin_inset Formula $f^{-1}=g$
\end_inset

 y 
\begin_inset Formula $g^{-1}=f$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
El nucleo de una funcion
\end_layout

\begin_layout Standard
Dada una funcion 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

, definamos:
\begin_inset Formula 
\[
\ker(f)=\{(a,b)\in A^{2}:f(a)=f(b)\}
\]

\end_inset

El conjunto 
\begin_inset Formula $\ker(f)$
\end_inset

 sera llamado el 
\shape italic
nucleo
\shape default
 de 
\begin_inset Formula $f$
\end_inset

.
 Notese que 
\begin_inset Formula $f$
\end_inset

 es inyectiva si y solo si 
\begin_inset Formula $\ker(f)=\{(a,a):a\in A\}$
\end_inset

.
\end_layout

\begin_layout Subsection
Funcion caracteristica de un subconjunto
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $X$
\end_inset

 un conjunto cualquiera y sea 
\begin_inset Formula $S\subseteq X$
\end_inset

.
 Usaremos 
\begin_inset Formula $\chi_{S}^{X}$
\end_inset

 para denotar la funcion
\begin_inset Formula 
\[
\begin{array}{rcl}
\chi_{S}^{X}:X & \rightarrow & \omega\\
x & \rightarrow & \left\{ \begin{array}{c}
1\text{ si }x\in S\\
0\text{ si }x\notin S
\end{array}\right.
\end{array}
\]

\end_inset

Llamaremos a 
\begin_inset Formula $\chi_{S}^{X}$
\end_inset

 la 
\shape italic
funcion caracteristica de 
\shape default

\begin_inset Formula $S$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

con respecto a 
\shape default

\begin_inset Formula $X$
\end_inset

.
 Muchas veces cuando el conjunto 
\begin_inset Formula $X$
\end_inset

 este fijo y sea claro el contexto, escribiremos 
\begin_inset Formula $\chi_{S}$
\end_inset

 en lugar de 
\begin_inset Formula $\chi_{S}^{X}$
\end_inset

.
\end_layout

\begin_layout Subsection
Restriccion de una funcion
\end_layout

\begin_layout Standard
Dada una funcion 
\begin_inset Formula $f$
\end_inset

 y un conjunto 
\begin_inset Formula $S\subseteq D_{f}$
\end_inset

, usaremos 
\begin_inset Formula $f|_{S}$
\end_inset

 para denotar la 
\shape italic
restriccion
\shape default
 de 
\begin_inset Formula $f$
\end_inset

 al conjunto 
\begin_inset Formula $S$
\end_inset

, i.e.
 
\begin_inset Formula $f|_{S}=f\cap(S\times I_{f})$
\end_inset

.
 Notese que 
\begin_inset Formula $f|_{S}$
\end_inset

 es la funcion dada por
\begin_inset Formula 
\begin{align*}
D_{f|_{S}} & =S\\
f|_{S}(e) & =f(e)\text{, para cada }e\in S
\end{align*}

\end_inset

Notese que cualesquiera sea la funcion 
\begin_inset Formula $f$
\end_inset

 tenemos que 
\begin_inset Formula $f|_{\emptyset}=\emptyset$
\end_inset

 y 
\begin_inset Formula $f|_{D_{f}}=f$
\end_inset

.
\end_layout

\begin_layout Subsection
Funciones de la forma 
\begin_inset Formula $[f_{1},...,f_{n}]$
\end_inset


\end_layout

\begin_layout Standard
Dadas funciones 
\begin_inset Formula $f_{1},...,f_{n}$
\end_inset

, con 
\begin_inset Formula $n\geq2$
\end_inset

, definamos la funcion 
\begin_inset Formula $[f_{1},...,f_{n}]$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\begin{align*}
D_{[f_{1},...,f_{n}]} & =D_{f_{1}}\cap...\cap D_{f_{n}}\\{}
[f_{1},...,f_{n}](e) & =(f_{1}(e),...,f_{n}(e))
\end{align*}

\end_inset

Notese que 
\begin_inset Formula $I_{[f_{1},...,f_{n}]}\subseteq I_{f_{1}}\times\cdots\times I_{f_{n}}$
\end_inset

.
 Por conveniencia notacional (que el lector entendera mas adelante) definiremos
 
\begin_inset Formula $[f_{1}]=f_{1}$
\end_inset

.
 Es decir que hemos definido para cada sucecion de funciones 
\begin_inset Formula $f_{1},...,f_{n}$
\end_inset

, con 
\begin_inset Formula $n\geq1$
\end_inset

, una nueva funcion la cual denotamos con 
\begin_inset Formula $[f_{1},...,f_{n}]$
\end_inset

.
\end_layout

\begin_layout Subsection
Union de funciones con dominios disjuntos
\end_layout

\begin_layout Standard
Una observacion interesante es que si 
\begin_inset Formula $f_{i}:A_{i}\rightarrow B_{i}$
\end_inset

, 
\begin_inset Formula $i=1,...,k$
\end_inset

, son funciones tales que 
\begin_inset Formula $A_{i}\cap A_{j}=\emptyset$
\end_inset

 para 
\begin_inset Formula $i\neq j$
\end_inset

, entonces 
\begin_inset Formula $f_{1}\cup...\cup f_{k}$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
A_{1}\cup...\cup A_{k} & \rightarrow & B_{1}\cup...\cup B_{k}\\
e & \rightarrow & \left\{ \begin{array}{clc}
f_{1}(e) &  & \text{si }e\in A_{1}\\
\vdots &  & \vdots\\
f_{k}(e) &  & \text{si }e\in A_{k}
\end{array}\right.
\end{array}
\]

\end_inset


\end_layout

\begin_layout Section
Relaciones binarias
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $A$
\end_inset

 un conjunto.
 Por una 
\shape italic
relacion binaria sobre 
\shape default

\begin_inset Formula $A$
\end_inset

 entenderemos un subconjunto de 
\begin_inset Formula $A^{2}$
\end_inset

.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(1,2),(2,3)\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $\mathbf{N}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(x,y)\in\omega^{2}:$
\end_inset

 
\begin_inset Formula $x$
\end_inset

 divide a 
\begin_inset Formula $y\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $\omega$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(r,t)\in\mathbf{R}^{2}:r\leq t\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset


\begin_inset Formula $\emptyset$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $A$
\end_inset

, cualesquiera sea el conjunto 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E5)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(x,y)\in\omega^{2}:x<y$
\end_inset

 o 
\begin_inset Formula $y=0\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $\omega$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que si 
\begin_inset Formula $R$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $A$
\end_inset

 y 
\begin_inset Formula $A\subseteq B$
\end_inset

 entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $B$
\end_inset

.
 Por ejemplo las relaciones dadas en los ejemplos (E1), (E2), (E4) y (E5)
 tambien son relaciones binarias sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset

.
 Sin envargo si 
\begin_inset Formula $R$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $B$
\end_inset

 y 
\begin_inset Formula $A\subseteq B$
\end_inset

 entonces no necesariamente 
\begin_inset Formula $R$
\end_inset

 sera una relacion binaria sobre 
\begin_inset Formula $A$
\end_inset

 (por que?).
\end_layout

\begin_layout Standard
Como es usual, cuando 
\begin_inset Formula $R$
\end_inset

 sea una relacion binaria sobre un conjunto 
\begin_inset Formula $A$
\end_inset

, algunas veces escribiremos 
\begin_inset Formula $aRb$
\end_inset

 en lugar de 
\begin_inset Formula $(a,b)\in R$
\end_inset

.
\end_layout

\begin_layout Subsection
Propiedades notables de relaciones binarias
\end_layout

\begin_layout Standard
Hay algunas propiedades que pueden tener o no las relaciones binarias sobre
 un conjunto 
\begin_inset Formula $A$
\end_inset

, las cuales son muy importantes en matematica.
 Algunas de estas son:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Reflexividad
\end_layout

\end_inset


\begin_inset Formula $xRx$
\end_inset

, cualesquiera sea 
\begin_inset Formula $x\in A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Transitividad
\end_layout

\end_inset


\begin_inset Formula $xRy$
\end_inset

 y 
\begin_inset Formula $yRz$
\end_inset

 implica 
\begin_inset Formula $xRz$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Simetria
\end_layout

\end_inset


\begin_inset Formula $xRy$
\end_inset

 implica 
\begin_inset Formula $yRx$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Antisimetria
\end_layout

\end_inset


\begin_inset Formula $xRy$
\end_inset

 y 
\begin_inset Formula $yRx$
\end_inset

 implica 
\begin_inset Formula $x=y$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in A$
\end_inset

 
\end_layout

\begin_layout Standard
Cuando 
\begin_inset Formula $R$
\end_inset

 cumpla la primer propiedad diremos que 
\begin_inset Formula $R$
\end_inset

 es 
\shape italic
reflexiva, con respecto a 
\shape default

\begin_inset Formula $A$
\end_inset

.
 Analogamente diremos que 
\begin_inset Formula $R$
\end_inset

 es 
\shape italic
transitiva, simetrica o antisimetrica, con respecto a 
\shape default

\begin_inset Formula $A$
\end_inset

, cuando se den, respectivamente las otras propiedades.
 Notese que estas propiedades dependen del conjunto 
\begin_inset Formula $A$
\end_inset

, por ejemplo si tomamos 
\begin_inset Formula $R=\{(r,t)\in\mathbf{N}^{2}:r\leq t\}$
\end_inset

 entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $\mathbf{N}$
\end_inset

 y tambien es una relacion binaria sobre 
\begin_inset Formula $\omega$
\end_inset

, pero es relexiva con respepcto a 
\begin_inset Formula $\mathbf{N}$
\end_inset

 y no lo es con respecto a 
\begin_inset Formula $\omega$
\end_inset

 ya que 
\begin_inset Formula $(0,0)$
\end_inset

 no pertenece a 
\begin_inset Formula $R$
\end_inset

.
 Sin envargo 
\begin_inset Formula $R$
\end_inset

 es transitiva con respecto a 
\begin_inset Formula $\mathbf{N}$
\end_inset

 y tambien lo es con respecto a 
\begin_inset Formula $\omega$
\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "ordenes parciales"

\end_inset

Ordenes parciales
\end_layout

\begin_layout Standard
Una relacion binaria 
\begin_inset Formula $R$
\end_inset

 sobre un conjunto 
\begin_inset Formula $A$
\end_inset

 sera llamada un 
\shape italic
orden parcial sobre 
\shape default

\begin_inset Formula $A$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset


\shape default
si es reflexiva, transitiva y antisimetrica respecto de 
\begin_inset Formula $A$
\end_inset

.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(r,t)\in\mathbf{R}^{2}:r\leq t\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset

, llamado el orden usual de 
\begin_inset Formula $\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(1,2),(1,3),(1,1),(2,2),(3,3)\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $\{1,2,3\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(S,T)\in\mathcal{P}(\omega)^{2}:S\subseteq T\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $\mathcal{P}(\omega)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(x,y)\in\omega^{2}:$
\end_inset

 
\begin_inset Formula $x\leq y\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $\omega$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E5)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(1,1)\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $\{1\}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E6)
\end_layout

\end_inset


\begin_inset Formula $\{(a,b):a=b\}$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $A$
\end_inset

, cualesquira sea el conjunto 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E7)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\mathrm{\leq}=\{(n,m)\in\mathbf{N}^{2}:n\mid m\}$
\end_inset

.
 Es facil ver que 
\begin_inset Formula $\leq$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $\mathbf{N}$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que las relaciones dadas en (E1) y (E4) son distintas, ademas la
 relacion dada en (E4) no es un orden parcial sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset

 (por que?).
\end_layout

\begin_layout Standard
Muchas veces denotaremos con 
\begin_inset Formula $\leq$
\end_inset

 a una relacion binaria que sea un orden parcial.
 Esto hace mas intuitiva nuestra escritura pero siempre hay que tener en
 cuenta que 
\begin_inset Formula $\leq$
\end_inset

 en estos casos esta denotando cierto conjunto de pares ordenados previamente
 definido.
\end_layout

\begin_layout Standard
Usaremos la siguiente
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Convencion notacional
\end_layout

\end_inset

Si hemos denotado con 
\begin_inset Formula $\leq$
\end_inset

 a cierto orden parcial sobre un conjunto 
\begin_inset Formula $A$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
Denotaremos con 
\begin_inset Formula $<$
\end_inset

 a la relacion binaria 
\begin_inset Formula $\{(a,b)\in A^{2}:a\leq b$
\end_inset

 y 
\begin_inset Formula $a\neq b\}$
\end_inset

.
 Es decir que 
\begin_inset Formula $\mathrm{<}=\{(a,b)\in A^{2}:a\leq b$
\end_inset

 y 
\begin_inset Formula $a\neq b\}$
\end_inset

.
 Cuando se de 
\begin_inset Formula $a<b$
\end_inset

 diremos que 
\begin_inset Formula $a$
\end_inset

 
\shape italic
es menor que 
\shape default

\begin_inset Formula $b$
\end_inset

 o que 
\begin_inset Formula $b$
\end_inset

 
\shape italic
es mayor que 
\shape default

\begin_inset Formula $a$
\end_inset

 (
\shape italic
respecto de 
\shape default

\begin_inset Formula $\leq$
\end_inset

)
\end_layout

\begin_layout Enumerate
Denotaremos con 
\begin_inset Formula $\prec$
\end_inset

 a la relacion binaria
\begin_inset Formula 
\[
\{(a,b)\in A^{2}:a<b\text{ y no existe }z\text{ tal que }a<z<b\}
\]

\end_inset

Cuando se de 
\begin_inset Formula $a\prec b$
\end_inset

 diremos que 
\begin_inset Formula $a$
\end_inset

 
\shape italic
es cubierto por 
\shape default

\begin_inset Formula $b$
\end_inset

 o que 
\begin_inset Formula $b$
\end_inset

 
\shape italic
cubre a 
\shape default

\begin_inset Formula $a$
\end_inset

 (
\shape italic
respecto de 
\shape default

\begin_inset Formula $\leq$
\end_inset

) 
\end_layout

\end_deeper
\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Si 
\begin_inset Formula $A=\mathbf{R}$
\end_inset

 y 
\begin_inset Formula $\mathrm{\leq}=\{(r,t)\in\mathbf{R}^{2}:r=t\}$
\end_inset

, entonces 
\begin_inset Formula $\mathrm{<}=\emptyset$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Si 
\begin_inset Formula $A=\{1,2,3,4\}$
\end_inset

 y 
\begin_inset Formula $\mathrm{\leq}=\{(1,2),(2,3),(1,3),(1,1),(2,2),(3,3),(4,4)\}$
\end_inset

, entonces 
\begin_inset Formula $\mathrm{<}=\{(1,2),(2,3),(1,3)\}$
\end_inset

 y 
\begin_inset Formula $\mathrm{\prec}=\{(1,2),(2,3)\}$
\end_inset

.
 En particular tenemos que 
\begin_inset Formula $1\prec2$
\end_inset

, 
\begin_inset Formula $1<3$
\end_inset

 pero no se da que 
\begin_inset Formula $1\prec3$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Si 
\begin_inset Formula $A=\mathcal{P}(\omega)$
\end_inset

 y 
\begin_inset Formula $\mathrm{\leq}=\{(S,T)\in\mathcal{P}(\omega)^{2}:S\subseteq T\}$
\end_inset

, entonces 
\begin_inset Formula $\mathrm{<}=\{(S,T)\in\mathcal{P}(\omega)^{2}:S\subsetneq T\}$
\end_inset

 y 
\begin_inset Formula $S\prec T$
\end_inset

 sii hay un 
\begin_inset Formula $n\in T-S$
\end_inset

 tal que 
\begin_inset Formula $T=S\cup\{n\}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Ordenes totales sobre un conjunto
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $A$
\end_inset

 un conjunto cualquiera.
 Por un 
\shape italic
orden total sobre
\shape default
 
\begin_inset Formula $A$
\end_inset

 entenderemos un orden parcial 
\begin_inset Formula $\leq$
\end_inset

 sobre 
\begin_inset Formula $A$
\end_inset

 el cual cumpla:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(C)
\end_layout

\end_inset


\begin_inset Formula $a\leq b$
\end_inset

 o 
\begin_inset Formula $b\leq a$
\end_inset

, cualesquiera sean 
\begin_inset Formula $a,b\in A$
\end_inset

 
\end_layout

\begin_layout Standard
Supongamos 
\begin_inset Formula $A$
\end_inset

 es finito no vacio y 
\begin_inset Formula $\leq$
\end_inset

 es un orden total sobre 
\begin_inset Formula $A$
\end_inset

.
 La propiedad (C) nos permite probar que para cada conjunto no vacio 
\begin_inset Formula $S\subseteq A$
\end_inset

, hay un elemento 
\begin_inset Formula $s\in S$
\end_inset

 el cual cumple 
\begin_inset Formula $s\leq s^{\prime}$
\end_inset

 para cada 
\begin_inset Formula $s^{\prime}\in S$
\end_inset

.
 Por supuesto, 
\begin_inset Formula $s$
\end_inset

 es unico (por que?) y habitualmente es llamado el 
\shape italic
menor elemento de 
\shape default

\begin_inset Formula $S$
\end_inset

, ya que es menor que todo otro elemento de 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $A$
\end_inset

 es finito no vacio y 
\begin_inset Formula $\leq$
\end_inset

 es un orden total sobre 
\begin_inset Formula $A$
\end_inset

, podemos definir recursivamente una funcion 
\begin_inset Formula $f:\{1,...,\left\vert A\right\vert \}\rightarrow A$
\end_inset

 de la siguiente manera:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f(1)=$
\end_inset

 menor elemento de 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $i\in\{1,...,\left\vert A\right\vert -1\}$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f(i+1)=$
\end_inset

 menor elemento de 
\begin_inset Formula $A-\{f(1),...,f(i)\}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
Como es habitual, 
\begin_inset Formula $f(i)$
\end_inset

 es llamado el 
\begin_inset Formula $i$
\end_inset


\shape italic
-esimo elemento de 
\shape default

\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Muchas veces para dar un orden total sobre un conjunto finito 
\begin_inset Formula $A$
\end_inset

, daremos simplemente sus elementos en forma creciente ya que esto determina
 el orden por completo.
 Por ejemplo si 
\begin_inset Formula $A=\{1,2,3\}$
\end_inset

, el orden total dado por 
\begin_inset Formula $2<1<3$
\end_inset

 es la relacion 
\begin_inset Formula $\mathrm{\leq}=\{(2,1),(1,3),(2,3),(1,1),(2,2),(3,3)\}$
\end_inset

.
\end_layout

\begin_layout Standard
Un concepto importante relativo a los ordenes totales es el de 
\shape italic
sucesor
\shape default
.
 Si 
\begin_inset Formula $\leq$
\end_inset

 es un orden total sobre 
\begin_inset Formula $A$
\end_inset

 y 
\begin_inset Formula $a,b\in A$
\end_inset

, diremos que 
\begin_inset Formula $b$
\end_inset

 
\shape italic
es el sucesor de
\shape default
 
\begin_inset Formula $a$
\end_inset

 cuando se de que 
\begin_inset Formula $a<b$
\end_inset

 y 
\begin_inset Formula $b\leq c$
\end_inset

, para cada 
\begin_inset Formula $c\in A$
\end_inset

 tal que 
\begin_inset Formula $a<c$
\end_inset

, i.e., 
\begin_inset Formula $b$
\end_inset

 es el menor elemento del conjunto 
\begin_inset Formula $\{c\in A:$
\end_inset

 tal que 
\begin_inset Formula $a<c\}$
\end_inset

.
 No siempre existe el sucesor de un elemento.
 Por ejemplo si 
\begin_inset Formula $\leq$
\end_inset

 es el orden usual de 
\begin_inset Formula $\mathbf{R}$
\end_inset

, entonces ningun elemento tiene sucesor (justifique).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Diagramas de Hasse
\end_layout

\begin_layout Standard
Dado un orden parcial 
\begin_inset Formula $\leq$
\end_inset

 sobre un conjunto finito 
\begin_inset Formula $A$
\end_inset

 podemos realizar un diagrama de 
\begin_inset Formula $\leq$
\end_inset

, llamado 
\shape italic
diagrama de Hasse,
\shape default
 siguiendo las siguientes instrucciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Asociar en forma inyectiva, a cada 
\begin_inset Formula $a\in$
\end_inset

 
\begin_inset Formula $A$
\end_inset

 un punto 
\begin_inset Formula $p_{a}$
\end_inset

 del plano
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Trazar un segmento de recta uniendo los puntos 
\begin_inset Formula $p_{a}$
\end_inset

 y 
\begin_inset Formula $p_{b}$
\end_inset

, cada vez que 
\begin_inset Formula $a\prec b$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Realizar lo indicado en los puntos (1) y (2) en tal forma que
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(i)
\end_layout

\end_inset

Si 
\begin_inset Formula $a\prec b$
\end_inset

, entonces 
\begin_inset Formula $p_{a}$
\end_inset

 esta por debajo de 
\begin_inset Formula $p_{b}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(ii)
\end_layout

\end_inset

Si un punto 
\begin_inset Formula $p_{a}$
\end_inset

 ocurre en un segmento del diagrama entonces lo hace en alguno de sus extremos.
 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
La relacion de orden 
\begin_inset Formula $\leq$
\end_inset

 puede ser facilmente obtenida de su diagrama, a saber, 
\begin_inset Formula $a\leq b$
\end_inset

 sucedera si y solo si 
\begin_inset Formula $p_{a}=p_{b}$
\end_inset

 o hay una sucesion de segmentos ascendentes desde 
\begin_inset Formula $p_{a}$
\end_inset

 hasta 
\begin_inset Formula $p_{b}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ejemplos:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Relaciones de equivalencia
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $A$
\end_inset

 un conjunto cualquiera.
 Por una 
\shape italic
relacion de equivalencia sobre 
\shape default

\begin_inset Formula $A$
\end_inset

 entenderemos una relacion binaria sobre 
\begin_inset Formula $A$
\end_inset

 la cual es reflexiva, transitiva y simetrica, con respecto a 
\begin_inset Formula $A$
\end_inset

, es decir, la cual cumple:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Reflexividad
\end_layout

\end_inset


\begin_inset Formula $xRx$
\end_inset

, cualesquiera sea 
\begin_inset Formula $x\in A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Transitividad
\end_layout

\end_inset


\begin_inset Formula $xRy$
\end_inset

 y 
\begin_inset Formula $yRz$
\end_inset

 implica 
\begin_inset Formula $xRz$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Simetria
\end_layout

\end_inset


\begin_inset Formula $xRy$
\end_inset

 implica 
\begin_inset Formula $yRx$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in A$
\end_inset

 
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(r,t)\in\mathbf{R}^{2}:r=t\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Dada una funcion 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

, el nucleo de 
\begin_inset Formula $f$
\end_inset

, i.e.
 
\begin_inset Formula $\ker(f)=\{(a,b)\in A^{2}:f(a)=f(b)\}$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(1,1),(2,2),(3,3),(1,2),(2,1)\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $\{1,2,3\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(x,y)\in\omega^{2}:x=y\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $\omega$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E5)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(S,T)\in\mathcal{P}(\omega)^{2}:(S-T)\cup(T-S)$
\end_inset

 es finito
\begin_inset Formula $\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $\mathcal{P}(\omega)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E7)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(1,1)\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $\{1\}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E8)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(x,y)\in\mathbf{Z}^{2}:x-y$
\end_inset

 es multiplo de 
\begin_inset Formula $2\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $\mathbf{Z}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Dada una relacion de equivalencia 
\begin_inset Formula $R$
\end_inset

 sobre 
\begin_inset Formula $A$
\end_inset

 y 
\begin_inset Formula $a\in A$
\end_inset

, definimos:
\begin_inset Formula 
\[
a/R=\{b\in A:aRb\}
\]

\end_inset

El conjunto 
\begin_inset Formula $a/R$
\end_inset

 sera llamado la 
\shape italic
clase de equivalencia de 
\shape default

\begin_inset Formula $a$
\end_inset


\shape italic
, con respecto a 
\shape default

\begin_inset Formula $R$
\end_inset

.
 Ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Si 
\begin_inset Formula $R=\{(r,t)\in\mathbf{R}^{2}:r=t\}$
\end_inset

, entonces 
\begin_inset Formula $r/R=\{r\}$
\end_inset

, cualesquier sea 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Si 
\begin_inset Formula $R=\{(1,1),(2,2),(3,3),(1,2),(2,1)\}$
\end_inset

, entonces 
\begin_inset Formula $1/R=2/R=\{1,2\}$
\end_inset

 y 
\begin_inset Formula $3/R=\{3\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Si 
\begin_inset Formula $R=\{(x,y)\in\mathbf{Z}^{2}:x-y$
\end_inset

 es multiplo de 
\begin_inset Formula $2\}$
\end_inset

, entonces 
\begin_inset Formula $0/R=\{t\in\mathbf{Z}:t$
\end_inset

 es par
\begin_inset Formula $\}$
\end_inset

, 
\begin_inset Formula $1/R=\{t\in\mathbf{Z}:t$
\end_inset

 es impar
\begin_inset Formula $\}$
\end_inset

 y en general notese que 
\begin_inset Formula $n/R=\{t\in\mathbf{Z}:t$
\end_inset

 es par
\begin_inset Formula $\}$
\end_inset

 si 
\begin_inset Formula $n$
\end_inset

 es par y 
\begin_inset Formula $n/R=\{t\in\mathbf{Z}:t$
\end_inset

 es impar
\begin_inset Formula $\}$
\end_inset

 si 
\begin_inset Formula $n$
\end_inset

 es impar.
 Es decir que hay solo dos clases de equivalencia con respecto a 
\begin_inset Formula $R$
\end_inset

 
\end_layout

\begin_layout Standard
Algunas propiedades basicas son:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basicas a/R"

\end_inset

Sea 
\begin_inset Formula $R$
\end_inset

 una relacion de equivalencia sobre 
\begin_inset Formula $A$
\end_inset

.
 Sean 
\begin_inset Formula $a,b\in A$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $a\in a/R$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $aRb$
\end_inset

 si y solo si 
\begin_inset Formula $a/R=b/R$
\end_inset

.
 Es decir que 
\begin_inset Formula $b\in a/R$
\end_inset

 implica 
\begin_inset Formula $b/R=a/R$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $a/R\cap b/R=\emptyset$
\end_inset

 o 
\begin_inset Formula $a/R=b/R$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) es muy facil.
\end_layout

\begin_layout Standard
(2).
 Supongamos 
\begin_inset Formula $aRb$
\end_inset

.
 Veremos que 
\begin_inset Formula $a/R\subseteq b/R$
\end_inset

.
 Supongamos 
\begin_inset Formula $c\in a/R$
\end_inset

.
 Entonces 
\begin_inset Formula $aRc$
\end_inset

.
 Como 
\begin_inset Formula $aRb$
\end_inset

, tenemos que 
\begin_inset Formula $bRa$
\end_inset

, por lo cual hemos probado que 
\begin_inset Formula $bRa$
\end_inset

 y 
\begin_inset Formula $aRc$
\end_inset

, lo cual implica que 
\begin_inset Formula $bRc$
\end_inset

.
 O sea que 
\begin_inset Formula $cRb$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $c\in b/R$
\end_inset

.
 Esto prueba que 
\begin_inset Formula $a/R\subseteq b/R$
\end_inset

.
 Similarmente se prueba que 
\begin_inset Formula $b/R\subseteq a/R$
\end_inset

, con lo cual se tiene que 
\begin_inset Formula $a/R=b/R$
\end_inset

.
\end_layout

\begin_layout Standard
Reciprocamente, si 
\begin_inset Formula $a/R=b/R$
\end_inset

, entonces 
\begin_inset Formula $b\in a/R$
\end_inset

 ya que 
\begin_inset Formula $b\in b/R$
\end_inset

.
 Pero esto nos dice que 
\begin_inset Formula $aRb$
\end_inset

.
\end_layout

\begin_layout Standard
o=(3).
 Supongamos que 
\begin_inset Formula $a/R\cap b/R$
\end_inset

 no es vacio, es decir hay un 
\begin_inset Formula $c\in a/R\cap b/R$
\end_inset

.
 Entonces es facil ver que 
\begin_inset Formula $aRb$
\end_inset

.
 Pero entonces por (2) tenemos que 
\begin_inset Formula $a/R=b/R$
\end_inset

.
 
\end_layout

\begin_layout Standard
Denotaremos con 
\begin_inset Formula $A/R$
\end_inset

 al conjunto 
\begin_inset Formula $\{a/R:a\in A\}$
\end_inset

.
 Llamaremos a 
\begin_inset Formula $A/R$
\end_inset

 el 
\shape italic
cociente de 
\shape default

\begin_inset Formula $A$
\end_inset

 
\shape italic
por 
\shape default

\begin_inset Formula $R$
\end_inset

.
 Ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Si 
\begin_inset Formula $R=\{(r,t)\in\mathbf{R}^{2}:r=t\}$
\end_inset

, entonces 
\begin_inset Formula $\mathbf{R}/R=\{\{r\}:r\in\mathbf{R}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Si 
\begin_inset Formula $R=\{(1,1),(2,2),(3,3),(1,2),(2,1)\}$
\end_inset

, entonces 
\begin_inset Formula $\{1,2,3\}/R=\{\{1,2\},\{3\}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Si 
\begin_inset Formula $R=\{(x,y)\in\mathbf{Z}^{2}:x-y$
\end_inset

 es multiplo de 
\begin_inset Formula $2\}$
\end_inset

, ya vimos que 
\begin_inset Formula $\mathbf{Z}/R=\{\{t\in\mathbf{Z}:t$
\end_inset

 es par
\begin_inset Formula $\},\{t\in\mathbf{Z}:t$
\end_inset

 es impar
\begin_inset Formula $\}\}$
\end_inset

 
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $R$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $A$
\end_inset

, definamos la funcion 
\begin_inset Formula $\pi_{R}:A\rightarrow A/R$
\end_inset

 por 
\begin_inset Formula $\pi_{R}(a)=a/R$
\end_inset

, para cada 
\begin_inset Formula $a\in A$
\end_inset

.
 La funcion 
\begin_inset Formula $\pi_{R}$
\end_inset

 es llamada la 
\shape italic
proyeccion canonica 
\shape default
(
\shape italic
respecto de 
\shape default

\begin_inset Formula $R$
\end_inset

).
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $R$
\end_inset

 una relacion de equivalencia sobre 
\begin_inset Formula $A$
\end_inset

.
 Entonces 
\begin_inset Formula $\ker\pi_{R}=R$
\end_inset

.
 Es decir que 
\begin_inset Formula $\pi_{R}$
\end_inset

 es inyectiva sii 
\begin_inset Formula $R=\{(x,y)\in A^{2}:x=y\}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Definicion de funciones con dominio 
\begin_inset Formula $A/R$
\end_inset


\end_layout

\begin_layout Standard
Supongamos 
\begin_inset Formula $R$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset

 y supongamos definimos una funcion 
\begin_inset Formula $f:\mathbf{R}/R\rightarrow\mathbf{R}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\[
f(r/R)=r^{2}
\]

\end_inset

A priori puede pareser que esta definicion es natural y que no esconde ninguna
 posible complicacion.
 Pero supongamos que 
\begin_inset Formula $R$
\end_inset

 es tal que 
\begin_inset Formula $2R6$
\end_inset

.
 Entonces tendriamos que 
\begin_inset Formula $2/R=6/R$
\end_inset

 lo cual produciria la siguiente contradiccion:
\begin_inset Formula 
\begin{align*}
4 & =2^{2}\\
 & =f(2/R)\\
 & =f(6/R)\\
 & =6^{2}\\
 & =36
\end{align*}

\end_inset

El problema aqui es que la ecuacion 
\begin_inset Formula $f(r/R)=r^{2}$
\end_inset

 no esta definiendo en forma correcta o inhambigua una funcion ya que el
 supuesto valor de la funcion en una clase de equivalencia dada depende
 de que representante de la clase usamos para denotarla.
 Si usamos el 2 la ecuacion nos dice que entonces 
\begin_inset Formula $f$
\end_inset

 debe valer 4 y si usamos el 6 la ecuacion nos dice que 
\begin_inset Formula $f$
\end_inset

 debe valer 36.
 Claramente no estamos definiendo una funcion.
\end_layout

\begin_layout Standard
Para dar un ejemplo mas concreto de este fenomeno de ambiguedad, supongamos
\begin_inset Formula 
\[
R=\{(x,y)\in\mathbf{Z}^{2}:x-y\text{ es multiplo de }2\}
\]

\end_inset

y definimos una funcion 
\begin_inset Formula $f:\mathbf{Z}/R\rightarrow\mathbf{R}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\[
f(n/R)=1/(n^{2}+1)
\]

\end_inset

Como ya vimos 
\begin_inset Formula $\mathbf{Z}/R=\{\{t\in\mathbf{Z}:t$
\end_inset

 es par
\begin_inset Formula $\},\{t\in\mathbf{Z}:t$
\end_inset

 es impar
\begin_inset Formula $\}\}$
\end_inset

, por lo cual facilmente se puede llegar a que la ecuacion 
\begin_inset Formula $f(n/R)=1/(n^{2}+1)$
\end_inset

 no define correctamente una funcion.
 Dejamos al lector explicar esto mas detalladamente.
\end_layout

\begin_layout Standard
Sin envargo hay muchos casos en los cuales este tipo de definiciones son
 inhambiguas y desde luego muy importantes en el algebra moderna.
 Como un primer ejemplo tenemos el siguiente lema el cual es una de las
 ideas fundamentales del algebra moderna.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 es sobre, entonces la ecuacion 
\begin_inset Formula $\bar{f}(a/\ker f)=f(a)$
\end_inset

 define en forma inhambigua una funcion 
\begin_inset Formula $\bar{f}:A/\ker f\rightarrow B$
\end_inset

 la cual es biyectiva.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Que la ecuacion 
\begin_inset Formula $\bar{f}(a/\ker f)=f(a)$
\end_inset

 define sin ambiguedad una funcion 
\begin_inset Formula $\bar{f}:A/\ker f\rightarrow B$
\end_inset

 es obvio ya que si 
\begin_inset Formula $a/\ker f=b/\ker f$
\end_inset

, entonces por definicion de 
\begin_inset Formula $\ker f$
\end_inset

 debera suceder que 
\begin_inset Formula $a=b$
\end_inset

.
 Dejamos al lector la prueba de que 
\begin_inset Formula $\bar{f}$
\end_inset

 es biyectiva 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Correspondencia entre relaciones de equivalencia y particiones
\end_layout

\begin_layout Standard
Dado un conjunto 
\begin_inset Formula $A$
\end_inset

 por una 
\shape italic
particion de 
\shape default

\begin_inset Formula $A$
\end_inset

 entenderemos un conjunto 
\begin_inset Formula $\mathcal{P}$
\end_inset

 tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Cada elemento de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 es un subconjunto no vacio de 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $S_{1},S_{2}\in\mathcal{P}$
\end_inset

 y 
\begin_inset Formula $S_{1}\neq S_{2}$
\end_inset

, entonces 
\begin_inset Formula $S_{1}\cap S_{2}=\emptyset$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $A=\{a:a\in S$
\end_inset

, para algun 
\begin_inset Formula $S\in\mathcal{P}\}$
\end_inset

 
\end_layout

\begin_layout Standard
La ultima condicion dice simplemente que la union de todos los elementos
 de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 debe ser 
\begin_inset Formula $A$
\end_inset

.
 Ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Si 
\begin_inset Formula $A=\{1,2,3,4,5\}$
\end_inset

, entonces
\begin_inset Formula 
\[
\mathcal{P}=\{\{1,5\},\{2,3\},\{4\}\}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
es una particion de 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset


\begin_inset Formula $\mathcal{P}=\{\mathbf{N},\mathbf{R}-\mathbf{N}\}$
\end_inset

 es una particion de 
\begin_inset Formula $\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset


\begin_inset Formula $\mathcal{P}=\{\{0\},\{1,2\},\{3,4\},\{5,6\},\{7,8\},\{9,10\},...\}$
\end_inset

 es una particion de 
\begin_inset Formula $\omega$
\end_inset

 
\end_layout

\begin_layout Standard
Una observacion importante es que si 
\begin_inset Formula $\mathcal{P}$
\end_inset

 es una particion de 
\begin_inset Formula $A$
\end_inset

, entonces para cada 
\begin_inset Formula $a\in A$
\end_inset

 hay un unico 
\begin_inset Formula $S\in\mathcal{P}$
\end_inset

 tal que 
\begin_inset Formula $a\in S$
\end_inset

 (por que?).
 O sea que podemos hablar de EL elemento de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 que contiene a 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
Dada una particion 
\begin_inset Formula $\mathcal{P}$
\end_inset

 de un conjunto 
\begin_inset Formula $A$
\end_inset

 podemos definir una relacion binaria asociada a 
\begin_inset Formula $\mathcal{P}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\[
R_{\mathcal{P}}=\{(a,b)\in A^{2}:a,b\in S\text{, para algun }S\in\mathcal{P}\}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $A$
\end_inset

 un conjunto cualquiera.
 Entonces:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 una particion de 
\begin_inset Formula $A$
\end_inset

.
 Entonces 
\begin_inset Formula $R_{\mathcal{P}}$
\end_inset

 es una relacion de equivalencia sobre 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R$
\end_inset

 una relacion de equivalencia sobre 
\begin_inset Formula $A$
\end_inset

.
 Entonces 
\begin_inset Formula $A/R$
\end_inset

 es una particion de 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1).
 Es facil ver que 
\begin_inset Formula $R_{\mathcal{P}}$
\end_inset

 es reflexiva y simetrica.
 Veamos que es transitiva.
 Supongamos que 
\begin_inset Formula $aR_{\mathcal{P}}b$
\end_inset

 y 
\begin_inset Formula $bR_{\mathcal{P}}c$
\end_inset

.
 O sea que hay 
\begin_inset Formula $S_{1},S_{2}\in\mathcal{P}$
\end_inset

 tales que 
\begin_inset Formula $a,b\in S_{1}$
\end_inset

 y 
\begin_inset Formula $b,c\in S_{2}$
\end_inset

.
 Ya que 
\begin_inset Formula $S_{1}$
\end_inset

 y 
\begin_inset Formula $S_{2}$
\end_inset

 tienen un elemento en comun, debera suceder que 
\begin_inset Formula $S_{1}=S_{2}$
\end_inset

.
 Pero entonces tenemos que 
\begin_inset Formula $a,c\in S_{1}$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $aR_{\mathcal{P}}c$
\end_inset

.
\end_layout

\begin_layout Standard
(2).
 Sigue facilmente del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicas a/R"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente teorema da una correspondencia natural entre relaciones de
 equivalencia sobre 
\begin_inset Formula $A$
\end_inset

 y particiones de 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $A$
\end_inset

 un conjunto cualquiera.
 Sean
\begin_inset Formula 
\begin{align*}
Part & =\{\text{particiones de }A\}\\
ReEq & =\{\text{relaciones de equivalencia sobre }A\}
\end{align*}

\end_inset

Entonces las funciones:
\begin_inset Formula 
\[
\begin{array}{rll}
Part & \rightarrow & ReEq\\
\mathcal{P} & \rightarrow & R_{\mathcal{P}}
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll}
ReEq & \rightarrow & Part\\
R & \rightarrow & A/R
\end{array}
\]

\end_inset

son biyecciones una inversa de la otra.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "mutuamente inversas"
plural "false"
caps "false"
noprefix "false"

\end_inset

 basta con probar:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $A/R_{\mathcal{P}}=\mathcal{P}$
\end_inset

, cualesquiera sea la particion 
\begin_inset Formula $\mathcal{P}$
\end_inset

 de 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R_{A/R}=R$
\end_inset

, cualesquiera sea la relacion de equivalencia 
\begin_inset Formula $R$
\end_inset

 sobre 
\begin_inset Formula $A$
\end_inset

 
\end_layout

\begin_layout Standard
Prueba de (1).
 Primero veamos que 
\begin_inset Formula $A/R_{\mathcal{P}}\subseteq\mathcal{P}$
\end_inset

.
 Sea 
\begin_inset Formula $a\in A$
\end_inset

, veremos que 
\begin_inset Formula $a/R_{\mathcal{P}}=\{b:aR_{\mathcal{P}}b\}\in\mathcal{P}$
\end_inset

.
 Sea 
\begin_inset Formula $S$
\end_inset

 el unico elemento de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 que contiene a 
\begin_inset Formula $a$
\end_inset

.
 Es facil ver de la definicion de 
\begin_inset Formula $R_{\mathcal{P}}$
\end_inset

 que 
\begin_inset Formula $a/R_{\mathcal{P}}=S$
\end_inset

 por lo cual 
\begin_inset Formula $a/R_{\mathcal{P}}\in\mathcal{P}$
\end_inset

.
 Veamos ahora que 
\begin_inset Formula $\mathcal{P}\subseteq A/R_{\mathcal{P}}$
\end_inset

.
 Sea 
\begin_inset Formula $S\in\mathcal{P}$
\end_inset

.
 Sea 
\begin_inset Formula $a\in S$
\end_inset

.
 Es facil ver de la definicion de 
\begin_inset Formula $R_{\mathcal{P}}$
\end_inset

 que 
\begin_inset Formula $a/R_{\mathcal{P}}=S$
\end_inset

 por lo cual 
\begin_inset Formula $S\in A/R_{\mathcal{P}}$
\end_inset

.
\end_layout

\begin_layout Standard
Prueba de (2).
 Primero veamos que 
\begin_inset Formula $R_{A/R}\subseteq R$
\end_inset

.
 Supongamos 
\begin_inset Formula $aR_{A/R}b$
\end_inset

.
 Entonces 
\begin_inset Formula $a,b\in c/R$
\end_inset

, para algun 
\begin_inset Formula $c\in A$
\end_inset

.
 Es claro que entonces 
\begin_inset Formula $aRb$
\end_inset

.
 Veamos ahora que 
\begin_inset Formula $R\subseteq R_{A/R}$
\end_inset

.
 Supongamos que 
\begin_inset Formula $aRb$
\end_inset

.
 Entonces 
\begin_inset Formula $a,b\in a/R$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $aR_{A/R}b$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El teorema anterior muestra que a nivel de informacion es lo mismo tener
 una relacion de equivalencia sobre 
\begin_inset Formula $A$
\end_inset

 que tener una particion de 
\begin_inset Formula $A$
\end_inset

.
 Esto es muy util ya que muchas veces es mas facil especificar una relacion
 de equivalencia via su particion asociada.
 Por ejemplo si hablamos de la relacion de equivalencia sobre 
\begin_inset Formula $\{1,2,3,4,5\}$
\end_inset

 dada por la particion
\begin_inset Formula 
\[
\mathcal{P}=\{\{1,5\},\{4\},\{2,3\}\}
\]

\end_inset

nos estaremos refiriendo a 
\begin_inset Formula $R_{\mathcal{P}}$
\end_inset

, es decir a la relacion:
\begin_inset Formula 
\[
\{(1,1),(2,2),(3,3),(4,4),(5,5),(1,5),(5,1),(2,3),(3,2)\}
\]

\end_inset


\end_layout

\begin_layout Section
Operaciones 
\begin_inset Formula $n$
\end_inset

-arias sobre un conjunto
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $A$
\end_inset

 un conjunto.
 Dado 
\begin_inset Formula $n\in\omega$
\end_inset

, por una 
\shape italic
operacion 
\shape default

\begin_inset Formula $n$
\end_inset


\shape italic
-aria sobre 
\shape default

\begin_inset Formula $A$
\end_inset

 entenderemos una funcion cuyo dominio es 
\begin_inset Formula $A^{n}$
\end_inset

 y cuya imagen esta contenida en 
\begin_inset Formula $A$
\end_inset

.
 A las operaciones 
\begin_inset Formula $2$
\end_inset

-arias (resp.
 
\begin_inset Formula $3$
\end_inset

-arias, 
\begin_inset Formula $4$
\end_inset

-arias) tambien las llamaremos 
\shape italic
operacion binarias
\shape default
 (resp.
 
\shape italic
ternarias, cuaternarias
\shape default
).
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $f:\mathbf{R\times R}\rightarrow\mathbf{R}$
\end_inset

 dada por 
\begin_inset Formula $f(x,y)=x+y$
\end_inset

.
 Entonces 
\begin_inset Formula $f$
\end_inset

 es una operacion 
\begin_inset Formula $2$
\end_inset

-aria sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $f:\{\Diamond\}\rightarrow\omega$
\end_inset

, dada por 
\begin_inset Formula $f(\Diamond)=5$
\end_inset

.
 Entonces 
\begin_inset Formula $f$
\end_inset

 es una operacion 
\begin_inset Formula $0$
\end_inset

-aria sobre 
\begin_inset Formula $\omega$
\end_inset

 (recuerde que 
\begin_inset Formula $\omega^{0}=\{\Diamond\}$
\end_inset

).
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Sea 
\begin_inset Formula $f:\mathbf{N\times N\times N\times N\times N}\rightarrow\mathbf{N}$
\end_inset

, dada por 
\begin_inset Formula $f(x_{1},x_{2},x_{3},x_{4},x_{5})=(x_{1}.x_{2})+x_{3}$
\end_inset

.
 Entonces 
\begin_inset Formula $f$
\end_inset

 es una operacion 
\begin_inset Formula $5$
\end_inset

-aria sobre 
\begin_inset Formula $\mathbf{N}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $f$
\end_inset

 es una operacion 
\begin_inset Formula $n$
\end_inset

-aria sobre 
\begin_inset Formula $A$
\end_inset

 y 
\begin_inset Formula $S\subseteq A$
\end_inset

, entonces diremos que 
\begin_inset Formula $S$
\end_inset

 es 
\shape italic
cerrado bajo
\shape default
 
\begin_inset Formula $f$
\end_inset

 cuando se de que 
\begin_inset Formula $f(a_{1},...,a_{n})\in S$
\end_inset

, cada ves que 
\begin_inset Formula $a_{1},...,a_{n}\in S$
\end_inset

.
 Notese que si 
\begin_inset Formula $n=0$
\end_inset

, entonces 
\begin_inset Formula $S$
\end_inset

 es cerrado bajo 
\begin_inset Formula $f$
\end_inset

 si y solo si 
\begin_inset Formula $f(\Diamond)\in S$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Relaciones 
\begin_inset Formula $n$
\end_inset

-arias sobre un conjunto
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $A$
\end_inset

 un conjunto.
 Dado 
\begin_inset Formula $n\in\omega$
\end_inset

, por una 
\shape italic
relacion 
\shape default

\begin_inset Formula $n$
\end_inset


\shape italic
-aria sobre 
\shape default

\begin_inset Formula $A$
\end_inset

 entenderemos un subconjunto de 
\begin_inset Formula $A^{n}$
\end_inset

.
 A las relaciones 
\begin_inset Formula $2$
\end_inset

-arias (resp.
 
\begin_inset Formula $3$
\end_inset

-arias, 
\begin_inset Formula $4$
\end_inset

-arias) tambien las llamaremos 
\shape italic
relaciones binarias
\shape default
 (resp.
 
\shape italic
ternarias, cuaternarias
\shape default
).
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(r,t)\in\mathbf{R\times R}:r\leq t\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion 
\begin_inset Formula $2$
\end_inset

-aria sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Hay exactamente dos relaciones 
\begin_inset Formula $0$
\end_inset

-arias sobre 
\begin_inset Formula $A$
\end_inset

, a saber: 
\begin_inset Formula $\emptyset$
\end_inset

 y 
\begin_inset Formula $\{\Diamond\}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Sea 
\begin_inset Formula $R=\{(x_{1},x_{2},x_{3},x_{4},x_{5})\in\mathbf{N}^{5}:x_{5}=x_{4}\}$
\end_inset

.
 Entonces 
\begin_inset Formula $R$
\end_inset

 es una relacion 
\begin_inset Formula $5$
\end_inset

-aria sobre 
\begin_inset Formula $\mathbf{N}$
\end_inset

.
 Notese que tambien 
\begin_inset Formula $R$
\end_inset

 es una relacion 
\begin_inset Formula $5$
\end_inset

-aria sobre 
\begin_inset Formula $\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset


\begin_inset Formula $\emptyset$
\end_inset

 es una relacion 
\begin_inset Formula $n$
\end_inset

-aria sobre 
\begin_inset Formula $A$
\end_inset

, cualesquiera sea 
\begin_inset Formula $n\in\omega$
\end_inset

 y 
\begin_inset Formula $A$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
 Dados 
\begin_inset Formula $n,m\in\omega$
\end_inset

, usaremos 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 para abreviar la expresion
\begin_inset Formula 
\[
\overset{n\text{ veces}}{\overbrace{\omega\times...\times\omega}}\times\overset{m\text{ veces}}{\overbrace{\Sigma^{\ast}\times...\times\Sigma^{\ast}}}
\]

\end_inset

Por ejemplo, 
\begin_inset Formula $\omega^{3}\times\Sigma^{\ast4}$
\end_inset

 sera una forma abreviada de escribir 
\begin_inset Formula $\omega\times\omega\times\omega\times\Sigma^{\ast}\times\Sigma^{\ast}\times\Sigma^{\ast}\times\Sigma^{\ast}$
\end_inset

.
 Debe quedar claro que estamos haciendo cierto abuso notacional ya que en
 principio si no hacemos esta convencion notacional, 
\begin_inset Formula $\omega^{3}\times\Sigma^{\ast4}$
\end_inset

 denota un conjunto de pares y 
\begin_inset Formula $\omega\times\omega\times\omega\times\Sigma^{\ast}\times\Sigma^{\ast}\times\Sigma^{\ast}\times\Sigma^{\ast}$
\end_inset

 es un conjunto de 
\begin_inset Formula $7$
\end_inset

-uplas.
\end_layout

\begin_layout Standard
Notese que cuando 
\begin_inset Formula $n=m=0$
\end_inset

, tenemos que 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 denota el conjunto 
\begin_inset Formula $\{\Diamond\}$
\end_inset

 y si 
\begin_inset Formula $m=0$
\end_inset

, entonces 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 denota el conjunto 
\begin_inset Formula $\omega^{n}$
\end_inset

.
\end_layout

\begin_layout Standard
Con esta convencion notacional, un elemento generico de 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es una 
\begin_inset Formula $(n+m)$
\end_inset

-upla de la forma 
\begin_inset Formula $(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})$
\end_inset

.
 Para abreviar, escribiremos 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

 en lugar de 
\begin_inset Formula $(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
Definicion de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
 Dada una funcion 
\begin_inset Formula $f$
\end_inset

, diremos que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
mixta
\shape default
 si cumple las siguientes propiedades
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(M1)
\end_layout

\end_inset

Existen 
\begin_inset Formula $n,m\geq0$
\end_inset

, tales que 
\begin_inset Formula $D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(M2)
\end_layout

\end_inset

Ya sea 
\begin_inset Formula $I_{f}\subseteq\omega$
\end_inset

 o 
\begin_inset Formula $I_{f}\subseteq\Sigma^{\ast}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset

Sea 
\begin_inset Formula $\Sigma=\{\square,\%,\blacktriangle\}$
\end_inset

.
 La funcion
\begin_inset Formula 
\[
\begin{array}{rll}
f:\omega\times\{\square,\%,\blacktriangle\}^{\ast} & \rightarrow & \omega\\
(x,\alpha) & \rightarrow & x+\left\vert \alpha\right\vert 
\end{array}
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta ya que se cumple (M1) con 
\begin_inset Formula $n=m=1$
\end_inset

 y (M2).
 Notese que 
\begin_inset Formula $f$
\end_inset

 no es 
\begin_inset Formula $\{\square,\%\}$
\end_inset

-mixta ya que no cumple (M1) respecto del alfabeto 
\begin_inset Formula $\{\square,\%\}$
\end_inset

.
 Sin envargo note que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\{\square,\%,\blacktriangle,@\}$
\end_inset

-mixta
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset

La funcion
\begin_inset Formula 
\[
\begin{array}{rll}
\omega^{4} & \rightarrow & \omega\\
(x,y,z,w) & \rightarrow & x+y
\end{array}
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta cualesquiera sea el alfabeto 
\begin_inset Formula $\Sigma$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{3}$
\end_inset


\end_layout

\end_inset

Sea 
\begin_inset Formula $\Sigma=\{\square,@\}$
\end_inset

.
 La funcion
\begin_inset Formula 
\[
\begin{array}{rll}
\{\square\square\square,@@\} & \rightarrow & \omega\\
\alpha & \rightarrow & \left\vert \alpha\right\vert 
\end{array}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta ya que se cumple (M1) (con 
\begin_inset Formula $n=0$
\end_inset

 y 
\begin_inset Formula $m=1$
\end_inset

) y (M2)
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{4}$
\end_inset


\end_layout

\end_inset

Supongamos 
\begin_inset Formula $\Sigma=\emptyset$
\end_inset

.
 Tenemos entonces que 
\begin_inset Formula $\Sigma^{\ast}=\{\varepsilon\}$
\end_inset

.
 Por ejemplo
\begin_inset Formula 
\[
\begin{array}{rll}
D & \rightarrow & \omega\\
(x,\varepsilon,\varepsilon,\varepsilon) & \rightarrow & x^{2}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $D=\{(x,\varepsilon,\varepsilon,\varepsilon):x$
\end_inset

 es impar
\begin_inset Formula $\}$
\end_inset

, es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta (con 
\begin_inset Formula $n=1$
\end_inset

 y 
\begin_inset Formula $m=3$
\end_inset

 en (M1)).
 Tambien notese que
\begin_inset Formula 
\[
\begin{array}{rll}
\{(\varepsilon,\varepsilon)\} & \rightarrow & \{\varepsilon\}\\
(\varepsilon,\varepsilon) & \rightarrow & \varepsilon
\end{array}
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos al lector la facil prueba del siguiente resultado basico.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $\Sigma\subseteq\Gamma$
\end_inset

 son alfabetos finitos.
 Entonces si 
\begin_inset Formula $f$
\end_inset

 es una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta, 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-mixta 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
total
\shape default
 cuando haya 
\begin_inset Formula $n,m\in\omega$
\end_inset

 tales que 
\begin_inset Formula $D_{f}=\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 El lema anterior nos dice que si 
\begin_inset Formula $\Sigma\subseteq\Gamma$
\end_inset

, entonces toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta es 
\begin_inset Formula $\Gamma$
\end_inset

-mixta.
 Sin envargo una funcion puede ser 
\begin_inset Formula $\Sigma$
\end_inset

-total y no ser 
\begin_inset Formula $\Gamma$
\end_inset

-total, cuando 
\begin_inset Formula $\Sigma\subseteq\Gamma$
\end_inset

.
 Por ejemplo tomemos 
\begin_inset Formula $\Sigma=\{\square,\%,\blacktriangle\}$
\end_inset

 y 
\begin_inset Formula $\Gamma=\{\square,\%,\blacktriangle,!\}$
\end_inset

, y consideremos la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
f:\omega\times\Sigma^{\ast} & \rightarrow & \omega\\
(x,\alpha) & \rightarrow & x+\left\vert \alpha\right\vert 
\end{array}
\]

\end_inset

Es claro que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta y 
\begin_inset Formula $\Sigma$
\end_inset

-total.
 Tambien es 
\begin_inset Formula $\Gamma$
\end_inset

-mixta ya que 
\begin_inset Formula $D_{f}\subseteq\omega\times\Gamma^{\ast}$
\end_inset

 y 
\begin_inset Formula $I_{f}\subseteq\omega$
\end_inset

, por lo cual cumple (M1) y (M2).
 Sin envargo 
\begin_inset Formula $f$
\end_inset

 no es 
\begin_inset Formula $\Gamma$
\end_inset

-total ya que 
\begin_inset Formula $D_{f}$
\end_inset

 no es igual a 
\begin_inset Formula $\omega^{n}\times\Gamma^{\ast m}$
\end_inset

, cualesquiera sean 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Standard
Como hemos visto recien, una funcion 
\begin_inset Formula $f$
\end_inset

 puede ser 
\begin_inset Formula $\Sigma$
\end_inset

-mixta y 
\begin_inset Formula $\Gamma$
\end_inset

-mixta para dos alfabetos distintos 
\begin_inset Formula $\Sigma$
\end_inset

 y 
\begin_inset Formula $\Gamma$
\end_inset

 e incluso es facil construir un ejemplo en el cual 
\begin_inset Formula $\Sigma$
\end_inset

 y 
\begin_inset Formula $\Gamma$
\end_inset

 sean incomparables como conjuntos, es decir que ninguno incluya al otro.
 Dejamos al lector convencerse de que si 
\begin_inset Formula $f$
\end_inset

 es una funcion que es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta para algun alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

, entonces hay un alfabeto 
\begin_inset Formula $\Sigma_{0}$
\end_inset

 el cual es el menor de todos los alfabetos respecto de los cuales 
\begin_inset Formula $f$
\end_inset

 es mixta, es decir 
\begin_inset Formula $\Sigma_{0}$
\end_inset

 cumple que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma_{0}$
\end_inset

-mixta y si 
\begin_inset Formula $\Gamma$
\end_inset

 es tal que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-mixta, entonces 
\begin_inset Formula $\Sigma_{0}\subseteq\Gamma$
\end_inset

.
\end_layout

\begin_layout Standard
A continuacion daremos algunas funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas basicas las cuales seran frecuentemente usadas.
\end_layout

\begin_layout Subsection
Funciones 
\begin_inset Formula $Suc$
\end_inset

 y 
\begin_inset Formula $Pred$
\end_inset


\end_layout

\begin_layout Standard
La 
\shape italic
funcion sucesor
\shape default
 es definida por
\begin_inset Formula 
\[
\begin{array}{rll}
Suc:\omega & \rightarrow & \omega\\
n & \rightarrow & n+1
\end{array}
\]

\end_inset

La 
\shape italic
funcion predecesor
\shape default
 es definida por
\begin_inset Formula 
\[
\begin{array}{rll}
Pred:\mathbf{N} & \rightarrow & \omega\\
n & \rightarrow & n-1
\end{array}
\]

\end_inset


\end_layout

\begin_layout Subsection
Las funciones 
\begin_inset Formula $d_{a}$
\end_inset


\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto no vacio.
 Para cada 
\begin_inset Formula $a\in\Sigma$
\end_inset

, definamos
\begin_inset Formula 
\[
\begin{array}{rll}
d_{a}:\Sigma^{\ast} & \rightarrow & \Sigma^{\ast}\\
\alpha & \rightarrow & \alpha a
\end{array}
\]

\end_inset

La funcion 
\begin_inset Formula $d_{a}$
\end_inset

 es llamada la funcion 
\shape italic
derecha sub 
\shape default

\begin_inset Formula $a$
\end_inset

, respecto del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\begin_layout Subsection
Las funciones 
\begin_inset Formula $p_{i}^{n,m}$
\end_inset


\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto.
 Para 
\begin_inset Formula $n,m,i\in\omega$
\end_inset

 tales que 
\begin_inset Formula $1\leq i\leq n$
\end_inset

, definamos
\begin_inset Formula 
\[
\begin{array}{rll}
p_{i}^{n,m}:\omega^{n}\times\Sigma^{\ast m} & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & x_{i}
\end{array}
\]

\end_inset

Para 
\begin_inset Formula $n,m,i\in\omega$
\end_inset

 tales que 
\begin_inset Formula $n+1\leq i\leq n+m$
\end_inset

, definamos
\begin_inset Formula 
\[
\begin{array}{rll}
p_{i}^{n,m}:\omega^{n}\times\Sigma^{\ast m} & \rightarrow & \Sigma^{\ast}\\
(\vec{x},\vec{\alpha}) & \rightarrow & \alpha_{i-n}
\end{array}
\]

\end_inset

Las funciones 
\begin_inset Formula $p_{i}^{n,m}$
\end_inset

 son llamadas 
\shape italic
proyecciones
\shape default
.
 La funcion 
\begin_inset Formula $p_{i}^{n,m}$
\end_inset

 es llamada la 
\shape italic
proyeccion 
\shape default

\begin_inset Formula $n,m,i$
\end_inset

, respecto del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Notese que esta definicion requiere que 
\begin_inset Formula $n+m\geq1$
\end_inset

 ya que 
\begin_inset Formula $i$
\end_inset

 debe cumplir 
\begin_inset Formula $1\leq i\leq n+m$
\end_inset

.
\end_layout

\begin_layout Subsection
Las funciones 
\begin_inset Formula $C_{k}^{n,m}$
\end_inset

 y 
\begin_inset Formula $C_{\alpha}^{n,m}$
\end_inset


\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto.
 Para 
\begin_inset Formula $n,m,k\in\omega$
\end_inset

, y 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, definamos
\begin_inset Formula 
\[
\begin{array}{rll}
C_{k}^{n,m}:\omega^{n}\times\Sigma^{\ast m} & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & k
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll}
C_{\alpha}^{n,m}:\omega^{n}\times\Sigma^{\ast m} & \rightarrow & \Sigma^{\ast}\\
(\vec{x},\vec{\alpha}) & \rightarrow & \alpha
\end{array}
\]

\end_inset

Notese que 
\begin_inset Formula $C_{k}^{0,0}:\{\Diamond\}\rightarrow\{k\}$
\end_inset

 y que 
\begin_inset Formula $C_{\alpha}^{0,0}:\{\Diamond\}\rightarrow\{\alpha\}$
\end_inset

.
\end_layout

\begin_layout Subsection
La funcion 
\begin_inset Formula $pr$
\end_inset


\end_layout

\begin_layout Standard
Definamos
\begin_inset Formula 
\[
\begin{array}{rll}
pr:\mathbf{N} & \rightarrow & \omega\\
n & \rightarrow & n\text{-esimo numero primo}
\end{array}
\]

\end_inset

Notese que 
\begin_inset Formula $pr(1)=2$
\end_inset

, 
\begin_inset Formula $pr(2)=3$
\end_inset

, 
\begin_inset Formula $pr(3)=5$
\end_inset

, etc.
\end_layout

\begin_layout Subsection
El tipo de una funcion mixta
\end_layout

\begin_layout Standard
Dada una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta 
\begin_inset Formula $f$
\end_inset

, si 
\begin_inset Formula $n,m\in\omega$
\end_inset

 son tales que 
\begin_inset Formula $D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 y ademas 
\begin_inset Formula $I_{f}\subseteq\omega$
\end_inset

, entonces diremos que 
\begin_inset Formula $f$
\end_inset

 
\shape italic
es una funcion de tipo 
\shape default

\begin_inset Formula $(n,m,\#)$
\end_inset

.
 Similarmente si 
\begin_inset Formula $n,m\in\omega$
\end_inset

 son tales que 
\begin_inset Formula $D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 y ademas 
\begin_inset Formula $I_{f}\subseteq\Sigma^{\ast}$
\end_inset

, entonces diremos que 
\begin_inset Formula $f$
\end_inset

 
\shape italic
es una funcion de tipo 
\shape default

\begin_inset Formula $(n,m,\ast)$
\end_inset

.
 Notese que si 
\begin_inset Formula $f\neq\emptyset$
\end_inset

, entonces hay unicos 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

 tales que 
\begin_inset Formula $f$
\end_inset

 es una funcion de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset

.
 Sin envargo 
\begin_inset Formula $\emptyset$
\end_inset

 es una funcion de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset

 cualesquiera sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

.
 De esta forma, cuando 
\begin_inset Formula $f\neq\emptyset$
\end_inset

 hablaremos de 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

el tipo de 
\begin_inset Formula $f$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 para refererirnos a esta unica terna 
\begin_inset Formula $(n,m,s)$
\end_inset

.
 Notese que 
\begin_inset Formula $Suc$
\end_inset

 es de tipo 
\begin_inset Formula $(1,0,\#)$
\end_inset

 y 
\begin_inset Formula $d_{a}$
\end_inset

 es de tipo 
\begin_inset Formula $(0,1,\ast)$
\end_inset

.
\end_layout

\begin_layout Standard
Tambien notese que la relacion 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset


\begin_inset Formula $f$
\end_inset

 es una funcion de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 no depende del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

 (que significa esto?).
\end_layout

\begin_layout Subsection
Funciones con imagen contenida en 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset


\end_layout

\begin_layout Standard
Supongamos que 
\begin_inset Formula $k,l,n,m\in\omega$
\end_inset

 y que 
\begin_inset Formula $F:D_{F}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Supongamos ademas que 
\begin_inset Formula $n+m\geq1$
\end_inset

.
 Entonces denotaremos con 
\begin_inset Formula $F_{(i)}$
\end_inset

 a la funcion 
\begin_inset Formula $p_{i}^{n,m}\circ F$
\end_inset

.
 Notar que
\begin_inset Formula 
\begin{align*}
F_{(i)} & :D_{F}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\omega\text{, para cada }i=1,...,n\\
F_{(i)} & :D_{F}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\Sigma^{\ast}\text{, para cada }i=n+1,...,n+m
\end{align*}

\end_inset

Por lo cual cada una de las funciones 
\begin_inset Formula $F_{(i)}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas.
 Ademas notese que
\begin_inset Formula 
\[
F=[F_{(1)},...,F_{(n+m)}]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "wiki-predicado._sigma._-mixto"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "wiki-predicados._sigma._-mixtos"

\end_inset


\end_layout

\begin_layout Subsection
Predicados 
\begin_inset Formula $\Sigma$
\end_inset

-mixtos
\end_layout

\begin_layout Standard
Un 
\shape italic
predicado 
\shape default

\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
mixto 
\shape default
es una funcion 
\begin_inset Formula $f$
\end_inset

 la cual es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta y ademas cumple que 
\begin_inset Formula $I_{f}\subseteq\{0,1\}$
\end_inset

.
 Por ejemplo
\begin_inset Formula 
\[
\begin{array}{rll}
\omega\times\omega & \rightarrow & \omega\\
(x,y) & \rightarrow & \left\{ \begin{array}{l}
1\text{ si }x=y\\
0\text{ si }x\neq y
\end{array}\right.
\end{array}\ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll}
\{1,2,3,4,5\}\times\Sigma^{\ast} & \rightarrow & \omega\\
(x,\alpha) & \rightarrow & \left\{ \begin{array}{l}
1\text{ si }x=\left\vert \alpha\right\vert \\
0\text{ si }x\neq\left\vert \alpha\right\vert 
\end{array}\right.
\end{array}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Operaciones logicas entre predicados
\end_layout

\begin_layout Standard
Dados predicados 
\begin_inset Formula $P:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\{0,1\}$
\end_inset

 y 
\begin_inset Formula $Q:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\{0,1\}$
\end_inset

, con el mismo dominio, definamos nuevos predicados 
\begin_inset Formula $(P\vee Q)$
\end_inset

, 
\begin_inset Formula $(P\wedge Q)$
\end_inset

 y 
\begin_inset Formula $\lnot P$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
\begin{array}{rll}
(P\vee Q):S & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
1 &  & \text{si }P(\vec{x},\vec{\alpha})=1\text{ o }Q(\vec{x},\vec{\alpha})=1\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{rll}
(P\wedge Q):S & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
1 &  & \text{si }P(\vec{x},\vec{\alpha})=1\text{ y }Q(\vec{x},\vec{\alpha})=1\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{rll}
\lnot P:S & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
1 &  & \text{si }P(\vec{x},\vec{\alpha})=0\\
0 &  & \text{si }P(\vec{x},\vec{\alpha})=1
\end{array}\right.
\end{array}
\]

\end_inset


\end_layout

\begin_layout Subsection
Familias 
\begin_inset Formula $\Sigma$
\end_inset

-indexadas de funciones
\end_layout

\begin_layout Standard
Dado un alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

, una 
\shape italic
familia 
\shape default

\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
indexada de funciones
\shape default
 sera una funcion 
\begin_inset Formula $\mathcal{G}$
\end_inset

 tal que 
\begin_inset Formula $D_{\mathcal{G}}=\Sigma$
\end_inset

 y para cada 
\begin_inset Formula $a\in D_{\mathcal{G}}$
\end_inset

 se tiene que 
\begin_inset Formula $\mathcal{G}(a)$
\end_inset

 es una funcion.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset

Sea 
\begin_inset Formula $\mathcal{G}$
\end_inset

 dada por
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathcal{G}:\{\square,\%,\blacktriangle\} & \rightarrow & \{Suc,Pred\}\\
\square & \rightarrow & Suc\\
\% & \rightarrow & Suc\\
\blacktriangle & \rightarrow & Pred
\end{array}
\]

\end_inset

Claramente 
\begin_inset Formula $\mathcal{G}$
\end_inset

 es una familia 
\begin_inset Formula $\{\square,\%,\blacktriangle\}$
\end_inset

-indexada de funciones.
 Notar que
\begin_inset Formula 
\[
\mathcal{G}=\{(\square,Suc),(\%,Suc),(\blacktriangle,Pred)\}
\]

\end_inset

Se tiene tambien por ejemplo que 
\begin_inset Formula $\mathcal{G}(\%)=Suc$
\end_inset

 por lo cual tambien es cierto que 
\begin_inset Formula $\mathcal{G}(\%)(22)=23$
\end_inset

, etc.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset

Si 
\begin_inset Formula $\Sigma$
\end_inset

 es un alfabeto no vacio, la funcion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathcal{G}:\Sigma & \rightarrow & \{f:f\text{ es una funcion de }\Sigma^{\ast}\text{ en }\Sigma^{\ast}\}\\
a & \rightarrow & d_{a}
\end{array}
\]

\end_inset

es una familia 
\begin_inset Formula $\Sigma$
\end_inset

-indexada de funciones.
 Notar que
\begin_inset Formula 
\[
\mathcal{G}=\{(a,d_{a}):a\in\Sigma\}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{3}$
\end_inset


\end_layout

\end_inset


\begin_inset Formula $\emptyset$
\end_inset

 es una flia 
\begin_inset Formula $\emptyset$
\end_inset

-indexada de funciones 
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\mathcal{G}$
\end_inset

 es una familia 
\begin_inset Formula $\Sigma$
\end_inset

-indexada de funciones, entonces para 
\begin_inset Formula $a\in\Sigma$
\end_inset

, escribiremos 
\begin_inset Formula $\mathcal{G}_{a}$
\end_inset

 en lugar de 
\begin_inset Formula $\mathcal{G}(a)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "wiki-conjunto._:sigma._-mixto"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "wiki-conjuntos._:sigma._-mixtos"

\end_inset


\end_layout

\begin_layout Section
Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-mixtos
\end_layout

\begin_layout Standard
Un conjunto 
\begin_inset Formula $S$
\end_inset

 es llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-mixto
\shape default
 si hay 
\begin_inset Formula $n,m\in\omega$
\end_inset

 tales que 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Por ejemplo,
\begin_inset Formula 
\[
\{(x,\alpha)\in\omega\times\{\blacktriangle,!\}^{\ast}:\left\vert \alpha\right\vert =x\}
\]

\end_inset


\begin_inset Formula 
\[
\{(0,\blacktriangle\blacktriangle\blacktriangle,\varepsilon),(1,\%\blacktriangle\%,\blacktriangle\blacktriangle)\}
\]

\end_inset

son conjuntos 
\begin_inset Formula $\{\blacktriangle,\%,!\}$
\end_inset

-mixtos.
 Tambien notese que 
\begin_inset Formula $\emptyset$
\end_inset

 y 
\begin_inset Formula $\{\Diamond\}$
\end_inset

 son conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-mixtos, cualesquiera sea el alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Por ultimo el conjunto
\begin_inset Formula 
\[
\{(x,\varepsilon,\varepsilon,\varepsilon):x\in\omega\text{ y }x\text{ es impar}\}
\]

\end_inset

es 
\begin_inset Formula $\emptyset$
\end_inset

-mixto (con 
\begin_inset Formula $n=1$
\end_inset

 y 
\begin_inset Formula $m=3$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
El tipo de un conjunto mixto
\end_layout

\begin_layout Standard
Dado un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-mixto 
\begin_inset Formula $S$
\end_inset

, si 
\begin_inset Formula $n,m\in\omega$
\end_inset

 son tales que 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

, entonces diremos que 
\begin_inset Formula $S$
\end_inset

 
\shape italic
es un conjunto de tipo 
\shape default

\begin_inset Formula $(n,m)$
\end_inset

.
 Notese que si 
\begin_inset Formula $S\neq\emptyset$
\end_inset

, entonces hay unicos 
\begin_inset Formula $n,m\in\omega$
\end_inset

 tales que 
\begin_inset Formula $S$
\end_inset

 es un conjunto de tipo 
\begin_inset Formula $(n,m)$
\end_inset

.
 De esta forma, cuando 
\begin_inset Formula $S\neq\emptyset$
\end_inset

 hablaremos de 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

el tipo de 
\begin_inset Formula $S$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 para refererirnos a este unico par 
\begin_inset Formula $(n,m)$
\end_inset

.
 Tambien es importante notar que de la definicion anterior sale inmediatemante
 que 
\begin_inset Formula $\emptyset$
\end_inset

 es un conjunto de tipo 
\begin_inset Formula $(n,m)$
\end_inset

 cualesquiera sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

, por lo cual cuando hablemos de EL tipo de un comjunto deberemos estar
 seguros de que dicho conjunto es no vacio.
\end_layout

\begin_layout Standard
Notese que 
\begin_inset Formula $\omega$
\end_inset

 es de tipo 
\begin_inset Formula $(1,0)$
\end_inset

 y 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 es de tipo 
\begin_inset Formula $(0,1)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Conjuntos rectangulares
\end_layout

\begin_layout Standard
Un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-mixto 
\begin_inset Formula $S$
\end_inset

 es llamado 
\shape italic
rectangular 
\shape default
si es de la forma
\begin_inset Formula 
\[
S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m},
\]

\end_inset

con cada 
\begin_inset Formula $S_{i}\subseteq\omega$
\end_inset

 y cada 
\begin_inset Formula $L_{i}\subseteq\Sigma^{\ast}$
\end_inset

.
 Notar que todo subconjunto de 
\begin_inset Formula $\omega$
\end_inset

 es rectangular (es el caso 
\begin_inset Formula $n=1$
\end_inset

 y 
\begin_inset Formula $m=0$
\end_inset

).
 Tambien 
\begin_inset Formula $\{\Diamond\}$
\end_inset

 es rectangular (es el caso 
\begin_inset Formula $n=m=0$
\end_inset

).
 Otros ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{N}\times\{1,2\}\times\{@@,\varepsilon\}$
\end_inset

 es rectangular (aqui 
\begin_inset Formula $n=2$
\end_inset

 y 
\begin_inset Formula $m=1$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\{!!!,!!\}\times\{@@,\varepsilon\}$
\end_inset

 es rectangular (aqui 
\begin_inset Formula $n=0$
\end_inset

 y 
\begin_inset Formula $m=2$
\end_inset

) 
\end_layout

\begin_layout Standard
Tambien notese que 
\begin_inset Formula $\emptyset=\emptyset\times\emptyset$
\end_inset

 por lo cual 
\begin_inset Formula $\emptyset$
\end_inset

 es un conjunto rectangular.
\end_layout

\begin_layout Standard
El concepto de conjunto rectangular es muy importante en nuestro enfoque.
 Aunque en general no habra restricciones acerca del dominio de las funciones
 y predicados, nuestra filosofia sera tratar en lo posible que los dominios
 de las funciones que utilicemos para hacer nuestro analisis de recursividad
 de los distintos paradigmas, sean rectangulares.
 Aunque en principio puede pareser que todos los conjuntos son rectangulares,
 el siguiente lema mostrara cuan ingenua es esta vision.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $S\subseteq\omega\times\Sigma^{\ast}$
\end_inset

.
 Entonces 
\begin_inset Formula $S$
\end_inset

 es rectangular si y solo si se cumple la siguiente propiedad:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(R)
\end_layout

\end_inset

Si 
\begin_inset Formula $(x,\alpha),(y,\beta)\in S$
\end_inset

, entonces 
\begin_inset Formula $(x,\beta)\in S$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ejercicio.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Supongamos 
\begin_inset Formula $\Sigma=\{\#,\blacktriangle,\%\}$
\end_inset

.
 Notese que podemos usar el lema anterior para probar por ejemplo que los
 siguientes conjuntos no son rectangulares
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\{(0,\#\#),(1,\%\%\%)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\{(x,\alpha):\left\vert \alpha\right\vert =x\}$
\end_inset

 
\end_layout

\begin_layout Standard
Dejamos como ejercicio para el lector enunciar un lema analogo al anterior
 pero que caracterice cuando 
\begin_inset Formula $S\subseteq\omega^{2}\times\Sigma^{\ast3}$
\end_inset

 es rectangular.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Notacion lambda
\end_layout

\begin_layout Standard
Usaremos la notacion lambda de Church en la forma que se explica a continuacion.
 Esta notacion siempre depende de un alfabeto finito previamente fijado.
 En general en nuestro lenguaje matematico utilizamos diversas expresiones
 las cuales involucran variables que una vez fijadas en sus valores hacen
 que la expresion tambien represente un determinado valor
\end_layout

\begin_layout Standard
En el contexto de la notacion lambda solo se podran utilizar expresiones
 con caracteristicas muy especiales por lo cual a continuacion iremos describien
do que condiciones tienen que cumplir las expresiones para que puedan ser
 usadas en la notacion lambda
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Solo utilizaremos expresiones que involucran variables numericas, las cuales
 se valuaran en numeros de 
\begin_inset Formula $\omega$
\end_inset

, y variables alfabeticas, las cuales se valuaran en palabras del alfabeto
 previamente fijado.
 Las variables numericas seran seleccionadas de la lista
\begin_inset Formula 
\begin{align*}
 & x,y,z,w,n,m,k,...\\
 & x_{1},x_{2},...\\
 & y_{1},y_{2},...\\
 & etc
\end{align*}

\end_inset

Las variables alfabeticas seran seleccionadas de la lista
\begin_inset Formula 
\begin{align*}
 & \alpha,\beta,\gamma,\eta,...\\
 & \alpha_{1},\alpha_{2},...\\
 & \beta_{1},\beta_{2},...\\
 & etc
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Por ejemplo la expresion:
\begin_inset Formula 
\[
x+y+1
\]

\end_inset

tiene dos variables numericas 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 (y ninguna alfabetica).
 Si le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 2 y a 
\begin_inset Formula $y$
\end_inset

 el valor 45, entonces la expresion 
\begin_inset Formula $x+y+1$
\end_inset

 produce o representa el valor 
\begin_inset Formula $48=2+45+1$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Otro ejemplo, consideremos la expresion
\begin_inset Formula 
\[
\left\vert \alpha\beta\right\vert +\left\vert \alpha\right\vert ^{x}
\]

\end_inset

la cual tiene una variable numerica 
\begin_inset Formula $x$
\end_inset

 y dos variables alfabeticas 
\begin_inset Formula $\alpha$
\end_inset

 y 
\begin_inset Formula $\beta$
\end_inset

.
 Supongamos ademas que el alfabeto previamente fijado es 
\begin_inset Formula $\{@,\%\}$
\end_inset

.
 Si le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 2, a 
\begin_inset Formula $\alpha$
\end_inset

 el valor 
\begin_inset Formula $@@$
\end_inset

 y a 
\begin_inset Formula $\beta$
\end_inset

 el valor 
\begin_inset Formula $\%\%\%$
\end_inset

, entonces la expresion 
\begin_inset Formula $\left\vert \alpha\beta\right\vert +\left\vert \alpha\right\vert ^{x}$
\end_inset

 produce o representa el valor 
\begin_inset Formula $\left\vert @@\%\%\%\right\vert +\left\vert @@\right\vert ^{2}=9$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Para ciertas valuaciones de sus variables la expresion puede no estar definida.
 Por ejemplo la expresion
\begin_inset Formula 
\[
Pred(\left\vert \alpha\right\vert )
\]

\end_inset

no asume valor o no esta definida cuando el valor asignado a 
\begin_inset Formula $\alpha$
\end_inset

 es 
\begin_inset Formula $\varepsilon$
\end_inset

.
 Otro ejemplo, consideremos la expresion
\begin_inset Formula 
\[
x/(y-\left\vert \alpha\right\vert )^{2}
\]

\end_inset

Esta expresion no esta definida o no asume valor para aquellas asignaciones
 de valores a sus variables en las cuales el valor asignado a 
\begin_inset Formula $y$
\end_inset

 sea igual a la longitud del valor asignado a 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset

En los ejemplos anteriores las expresiones producen valores numericos pero
 tambien trabajaremos con expresiones que producen valores alfabeticos.
 Por ejemplo la expresion
\begin_inset Formula 
\[
\beta^{y}
\]

\end_inset

tiene una variable numerica, 
\begin_inset Formula $y$
\end_inset

, una variable alfabetica, 
\begin_inset Formula $\beta$
\end_inset

, y una vez valuadas estas variables produce un valor alfabetico, a saber
 el resultado de elevar el valor asignado a la variable 
\begin_inset Formula $\beta$
\end_inset

, a el valor asignado a 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset

Una expresion 
\begin_inset Formula $E$
\end_inset

 para poder ser utilizada en la notacion lambda relativa a un alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

 debera cumplir alguna de las dos siguientes propiedades
\end_layout

\begin_deeper
\begin_layout Enumerate
los valores que asuma 
\begin_inset Formula $E$
\end_inset

 cuando hayan sido asignados valores de 
\begin_inset Formula $\omega$
\end_inset

 a sus variables numericas y valores de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 a sus variables alfabeticas deberan ser siempre elementos de 
\begin_inset Formula $\omega$
\end_inset


\end_layout

\begin_layout Enumerate
los valores que asuma 
\begin_inset Formula $E$
\end_inset

 cuando hayan sido asignados valores de 
\begin_inset Formula $\omega$
\end_inset

 a sus variables numericas y valores de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 a sus variables alfabeticas deberan ser siempre elementos de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(7)
\end_layout

\end_inset

Por ejemplo la expresion
\begin_inset Formula 
\[
x/2
\]

\end_inset

no cumple la propiedad dada en (6) ya que para ciertos valores de 
\begin_inset Formula $\omega$
\end_inset

 asignados a la variable 
\begin_inset Formula $x$
\end_inset

, la expresion da valores numericos que se salen de 
\begin_inset Formula $\omega$
\end_inset

 por lo cual no cumple ni (a) ni (b).
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(8)
\end_layout

\end_inset

Otro ejemplo, si el alfabeto fijado es 
\begin_inset Formula $\Sigma=\{@,\%\}$
\end_inset

, entonces la expresion
\begin_inset Formula 
\[
@^{x}\$^{y}
\]

\end_inset

no cumple la propiedad dada en (6) ya que por ejemplo cuando le asignamos
 a 
\begin_inset Formula $x$
\end_inset

 el valor 2 y a 
\begin_inset Formula $y$
\end_inset

 el valor 6, la expresion nos da la palabra 
\begin_inset Formula $@@\$\$\$\$\$\$$
\end_inset

 la cual no pertenece a 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 por lo cual no cumple ni (a) ni (b).
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(9)
\end_layout

\end_inset

No necesariamente las expresiones que usaremos en la notacion lambda deben
 ser hechas como combinacion de operaciones matematicas conocidas.
 Muchas veces usaremos expresiones que involucran incluso lenguaje coloquial
 castellano.
 Por ejemplo la expresion
\begin_inset Formula 
\[
\mathrm{el\ menor\ numero\ primo\ que\ es\ mayor\ que\ }x
\]

\end_inset

Es claro que esta expresion para cada valor de 
\begin_inset Formula $\omega$
\end_inset

 asignado a la variable 
\begin_inset Formula $x$
\end_inset

 produce o representa un valor concreto de 
\begin_inset Formula $\omega$
\end_inset

.
 Otro ejemplo:
\begin_inset Formula 
\[
\mathrm{el\ tercer\ simbolo\ de\ }\alpha
\]

\end_inset

notese que esta expresion, una ves fijado un alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

, estara definida o producira un valor solo cuando le asignamos a 
\begin_inset Formula $\alpha$
\end_inset

 una palabra de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 de longitud mayor o igual a 
\begin_inset Formula $3$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(10)
\end_layout

\end_inset


\series bold
Expresiones Booleanas.

\series default
 A las expresiones Booleanas tales como
\begin_inset Formula 
\[
x=y+1\text{ y }\left\vert \alpha\right\vert \leq22
\]

\end_inset


\end_layout

\begin_layout Standard
las pensaremos que asumen valores del conjunto 
\begin_inset Formula $\{0,1\}\subseteq\omega$
\end_inset

.
 Por ejemplo la expresion anterior asume o produce el valor 
\begin_inset Formula $1$
\end_inset

 cuando le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 11, a 
\begin_inset Formula $y$
\end_inset

 el valor 10 y a 
\begin_inset Formula $\alpha$
\end_inset

 la palabra 
\begin_inset Formula $\varepsilon$
\end_inset

.
 Las expresiones Booleanas pensadas de esta forma podran ser utilizadas
 en la notacion lambda si es que tambien cumplen con las anteriores condiciones.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(11)
\end_layout

\end_inset

La expresion
\begin_inset Formula 
\[
5
\]

\end_inset

no tiene variables por lo cual pensaremos que siempre produce el valor 
\begin_inset Formula $5$
\end_inset

 cualesquiera sean los valores asignados a las variables.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Expresiones lambdificables con respecto a 
\begin_inset Formula $\Sigma$
\end_inset


\end_layout

\begin_layout Standard
Dado un alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

 a las expresiones que cumplan las caracteristicas dadas anteriormente las
 llamaremos 
\shape italic
lambdificables con respecto a 
\shape default

\begin_inset Formula $\Sigma$
\end_inset

.
 Notese que este concepto es intuitivo y no un concepto matematicamente
 definido en forma precisa.
 Mas aun el concepto de expresion tampoco ha sido definido matematicamente
 (aunque obviamente si sabemos que una expresion es una palabra de cierto
 alfabeto).
 Esto no nos traera problemas para el uso notacional que las utilizaremos.
 Recien en las secciones de logica veremos la matematizacion de ciertas
 expresiones (no las lambdificables) y nos servira de ejemplo para imaginar
 como podriamos matematizar el concepto de expresion.
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset


\begin_inset Formula $x/2$
\end_inset

 no es lambdificable con respecto a 
\begin_inset Formula $\Sigma$
\end_inset

 cualesquiera sea 
\begin_inset Formula $\Sigma$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset


\begin_inset Formula $@^{x}\$^{y}$
\end_inset

 es lambdificable con respecto a 
\begin_inset Formula $\{@,\$\}$
\end_inset

 y no es lambdificable con respecto a 
\begin_inset Formula $\{@,\#,\%\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset


\begin_inset Formula $x=y+1$
\end_inset

 es lambdificable con respecto a 
\begin_inset Formula $\Sigma$
\end_inset

 cualesquiera sea 
\begin_inset Formula $\Sigma$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset

la expresion
\begin_inset Formula 
\[
\mathrm{el\ menor\ numero\ primo\ que\ es\ mayor\ que\ }x^{\left\vert \beta\right\vert }
\]

\end_inset

es lambdificable con respecto a 
\begin_inset Formula $\Sigma$
\end_inset

 cualesquiera sea 
\begin_inset Formula $\Sigma$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E5)
\end_layout

\end_inset

la expresion
\begin_inset Formula 
\[
5
\]

\end_inset

es lambdificable con respecto a 
\begin_inset Formula $\Sigma$
\end_inset

 cualesquiera sea 
\begin_inset Formula $\Sigma$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection*
Definicion de 
\begin_inset Formula $\lambda x_{1}...x_{n}\alpha_{1}...\alpha_{m}\left[E\right]$
\end_inset


\end_layout

\begin_layout Standard
Supongamos ya hemos fijado un alfabeto finito 
\begin_inset Formula $\Sigma$
\end_inset

 y supongamos 
\begin_inset Formula $E$
\end_inset

 es una expresion la cual es lambdificable con respecto a 
\begin_inset Formula $\Sigma$
\end_inset

.
 Sea 
\begin_inset Formula $x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}$
\end_inset

 una lista de variables todas distintas tal que las variables numericas
 que ocurren en 
\begin_inset Formula $E$
\end_inset

 estan todas contenidas en la lista 
\begin_inset Formula $x_{1},...,x_{n}$
\end_inset

 y las variables alfabeticas que ocurren en 
\begin_inset Formula $E$
\end_inset

 estan en la lista 
\begin_inset Formula $\alpha_{1},...,\alpha_{m}$
\end_inset


\begin_inset space \space{}
\end_inset

(puede suceder que haya variables de la lista 
\begin_inset Formula $x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}$
\end_inset

 las cuales no ocurran en 
\begin_inset Formula $E$
\end_inset

).
 Entonces
\begin_inset Formula 
\[
\lambda x_{1}...x_{n}\alpha_{1}...\alpha_{m}\left[E\right]
\]

\end_inset

denotara la funcion definida por:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(L1)
\end_layout

\end_inset

El dominio de 
\begin_inset Formula $\lambda x_{1}...x_{n}\alpha_{1}...\alpha_{m}\left[E\right]$
\end_inset

 es el conjunto de las 
\begin_inset Formula $(n+m)$
\end_inset

-uplas 
\begin_inset Formula $(k_{1},...,k_{n},\beta_{1},...,\beta_{m})\in\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tales que 
\begin_inset Formula $E$
\end_inset

 esta definida cuando le asignamos a cada 
\begin_inset Formula $x_{i}$
\end_inset

 el valor 
\begin_inset Formula $k_{i}$
\end_inset

 y a cada 
\begin_inset Formula $\alpha_{i}$
\end_inset

 el valor 
\begin_inset Formula $\beta_{i}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(L2)
\end_layout

\end_inset


\begin_inset Formula $\lambda x_{1}...x_{n}\alpha_{1}...\alpha_{m}\left[E\right](k_{1},...,k_{n},\beta_{1},...,\beta_{m})=$
\end_inset

 valor que asume o representa 
\begin_inset Formula $E$
\end_inset

 cuando le asignamos a cada 
\begin_inset Formula $x_{i}$
\end_inset

 el valor 
\begin_inset Formula $k_{i}$
\end_inset

 y a cada 
\begin_inset Formula $\alpha_{i}$
\end_inset

 el valor 
\begin_inset Formula $\beta_{i}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que por tener 
\begin_inset Formula $E$
\end_inset

 la propiedad (6) de mas arriba, la funcion 
\begin_inset Formula $\lambda x_{1}...x_{n}\alpha_{1}...\alpha_{m}\left[E\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset

 para algun 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Supongamos fijamos el alfabeto 
\begin_inset Formula $\Sigma=\{@,?,$
\end_inset


\begin_inset Formula $\}$
\end_inset

.
 Entonces 
\begin_inset Formula $\lambda x\alpha\left[\alpha^{2x}\right]$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
\omega\times\{@,?,\text{}\}^{\ast} & \rightarrow & \{@,?,\text{}\}^{\ast}\\
(x,\alpha) & \rightarrow & \alpha^{2x}
\end{array}
\]

\end_inset

Aqui el lector puede notar la dependencia de la notacion lambda respecto
 del alfabeto fijado.
 Si en lugar de fijar 
\begin_inset Formula $\Sigma=\{@,?,$
\end_inset


\begin_inset Formula $\}$
\end_inset

 hubieramos fijado 
\begin_inset Formula $\Sigma=\{\%\}$
\end_inset

, entonces 
\begin_inset Formula $\lambda x\alpha\left[\alpha^{2x}\right]$
\end_inset

 denotaria otra funcion, a saber
\begin_inset Formula 
\[
\begin{array}{rll}
\omega\times\{\%\}^{\ast} & \rightarrow & \{\%\}^{\ast}\\
(x,\alpha) & \rightarrow & \alpha^{2x}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Supongamos fijamos el alfabeto 
\begin_inset Formula $\Sigma=\{@,?,$
\end_inset


\begin_inset Formula $\}$
\end_inset

.
 Entonces 
\begin_inset Formula $\lambda x\alpha\left[5\right]$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
\omega\times\{@,?,\text{}\}^{\ast} & \rightarrow & \omega\\
(x,y,z,\alpha) & \rightarrow & 5
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset

Supongamos fijamos el alfabeto 
\begin_inset Formula $\Sigma=\{\%,!\}$
\end_inset

.
 Entonces 
\begin_inset Formula $\lambda\alpha\beta\left[\alpha\beta\right]$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
\{\%,!\}^{\ast}\times\{\%,!\}^{\ast} & \rightarrow & \{\%,!\}^{\ast}\\
(\alpha,\beta) & \rightarrow & \alpha\beta
\end{array}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Tambien tenemos que 
\begin_inset Formula $\lambda\beta\alpha\left[\alpha\beta\right]$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
\{\%,!\}^{\ast}\times\{\%,!\}^{\ast} & \rightarrow & \{\%,!\}^{\ast}\\
(\beta,\alpha) & \rightarrow & \alpha\beta
\end{array}
\]

\end_inset

Notese que estas funciones son distintas.
 Por ejemplo 
\begin_inset Formula $\lambda\alpha\beta\left[\alpha\beta\right](\%,!)=\%!$
\end_inset

 y 
\begin_inset Formula $\lambda\beta\alpha\left[\alpha\beta\right](\%,!)=!\%$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(d)
\end_layout

\end_inset

Independientemente de quien sea 
\begin_inset Formula $\Sigma$
\end_inset

 el alfabeto previamente fijado, tenemos que 
\begin_inset Formula $\lambda xy[x+y]$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
\omega^{2} & \rightarrow & \omega\\
(x,y) & \rightarrow & x+y
\end{array}
\]

\end_inset

Tambien 
\begin_inset Formula $\lambda xyzw[x+w]$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
\omega^{4} & \rightarrow & \omega\\
(x,y,z,w) & \rightarrow & x+w
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(e)
\end_layout

\end_inset

Supongamos fijamos el alfabeto 
\begin_inset Formula $\Sigma=\{@,?,$
\end_inset


\begin_inset Formula $\}$
\end_inset

.
 Entonces por la clausula (L1) tenemos que el dominio de la funcion 
\begin_inset Formula $\lambda xy\alpha\beta\left[Pred(\left\vert \alpha\right\vert )+Pred(y)\right]$
\end_inset

 es
\begin_inset Formula 
\[
D=\left\{ (x,y,\alpha,\beta)\in\omega^{2}\times\Sigma^{\ast2}:\left\vert \alpha\right\vert \geq1\text{ y }y\geq1\right\} 
\]

\end_inset

Es decir que 
\begin_inset Formula $\lambda xy\alpha\beta\left[Pred(\left\vert \alpha\right\vert )+Pred(y)\right]$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
D & \rightarrow & \omega\\
(x,y,\alpha,\beta) & \rightarrow & Pred(\left\vert \alpha\right\vert )+Pred(y)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(f)
\end_layout

\end_inset

Atentos a (10) de mas arriba, la funcion 
\begin_inset Formula $\lambda xy\left[x=y\right]$
\end_inset

 es el predicado
\begin_inset Formula 
\[
\begin{array}{rll}
\omega\times\omega & \rightarrow & \omega\\
(x,y) & \rightarrow & \left\{ \begin{array}{l}
1\text{ si }x=y\\
0\text{ si }x\neq y
\end{array}\right.
\end{array}
\]

\end_inset

y 
\begin_inset Formula $\lambda x\alpha\left[Pred(x)=\left\vert \alpha\right\vert \right]$
\end_inset

 es el predicado
\begin_inset Formula 
\[
\begin{array}{rll}
\mathbf{N}\times\Sigma^{\ast} & \rightarrow & \omega\\
(x,\alpha) & \rightarrow & \left\{ \begin{array}{l}
1\text{ si }Pred(x)=\left\vert \alpha\right\vert \\
0\text{ si }Pred(x)\neq\left\vert \alpha\right\vert 
\end{array}\right.
\end{array}
\]

\end_inset

Tambien 
\begin_inset Formula $\lambda\alpha\beta\left[\alpha=\beta\right]$
\end_inset

 es el predicado
\begin_inset Formula 
\[
\begin{array}{rll}
\Sigma^{\ast}\times\Sigma^{\ast} & \rightarrow & \omega\\
(\alpha,\beta) & \rightarrow & \left\{ \begin{array}{l}
1\text{ si }\alpha=\beta\\
0\text{ si }\alpha\neq\beta
\end{array}\right.
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(g)
\end_layout

\end_inset

Notar que para 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 se tiene que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}=\lambda x_{1}...x_{n}\alpha_{1}...\alpha_{m}\left[(\vec{x},\vec{\alpha})\in S\right]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(h)
\end_layout

\end_inset

Como dijimos, la notacion lambda depende del alfabeto previamnete fijado,
 aunque para el caso en que la lista de variables que sigue a la letra 
\begin_inset Formula $\lambda$
\end_inset

 no tenga variables alfabeticas, la funcion representada no depende del
 alfabeto 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Un par de ejemplos sutiles
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

La expresion
\begin_inset Formula 
\[
Suc
\]

\end_inset

no es lambdificable respecto de cualquier alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Esto es porque si bien cualesquiera sea el valor asignado a las variables,
 ella asume el valor 
\begin_inset Formula $Suc$
\end_inset

, no cumple (6) de mas arriba ya que 
\begin_inset Formula $Suc$
\end_inset

 no es un elemento de 
\begin_inset Formula $\omega$
\end_inset

 ni tampoco una palabra (es una funcion!)
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

La expresion
\begin_inset Formula 
\[
Suc+(\left\vert \beta\right\vert +1)
\]

\end_inset

es lambdificable con respecto a 
\begin_inset Formula $\Sigma$
\end_inset

 cualesquiera sea 
\begin_inset Formula $\Sigma$
\end_inset

.
 Por ejemplo 
\begin_inset Formula $\lambda x\beta[Suc+(\left\vert \beta\right\vert +1)]$
\end_inset

 es la funcion 
\begin_inset Formula $\emptyset$
\end_inset

, ya que la expresion 
\begin_inset Formula $Suc+(\left\vert \beta\right\vert +1)$
\end_inset

 cualesquiera sean los valores de 
\begin_inset Formula $x$
\end_inset

 y 
\begin_inset Formula $\beta$
\end_inset

 no esta definida.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Ordenes naturales sobre 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset


\end_layout

\begin_layout Standard
En esta seccion daremos biyecciones naturales entre 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $\omega$
\end_inset

, para cada alfabeto no vacio 
\begin_inset Formula $\Sigma$
\end_inset

.
 Dichas biyecciones dependen de tener asociado a 
\begin_inset Formula $\Sigma$
\end_inset

 un orden total.
 Primero haremos un caso particular pero que tiene un interes extra ya que
 esta emparentado con nuestra notacion decimal clasica de los numeros de
 
\begin_inset Formula $\omega$
\end_inset

.
\end_layout

\begin_layout Subsection
Notacion decimal sin 
\begin_inset Formula $0$
\end_inset


\end_layout

\begin_layout Standard
Llamaremos 
\shape italic
numerales
\shape default
 a los siguientes simbolos
\begin_inset Formula 
\[
0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9
\]

\end_inset

Usaremos 
\begin_inset Formula $Num$
\end_inset

 para denotar el conjunto de numerales.
 Notese que 
\begin_inset Formula $Num\cap\omega=\emptyset$
\end_inset

.
 Es decir, no debemos confundir los simbolos que usualmente denotan los
 primeros diez numeros enteros con los numeros que ellos denotan.
 De hecho en china o japon los primeros diez numeros enteros se denotan
 con otros simbolos.
 Similarmente las palabras pertenecientes a 
\begin_inset Formula $Num^{\ast}$
\end_inset

 denotan (notacion decimal) a los numeros de 
\begin_inset Formula $\omega$
\end_inset

 pero debemos tener en cuenta que 
\begin_inset Formula $Num^{\ast}\cap\omega=\emptyset$
\end_inset

.
 Cuando tratamos con palabras de 
\begin_inset Formula $Num^{\ast}$
\end_inset

, debemos ser cuidadosos ya que muchas veces en nuestro discurso matematico
 (es decir las guias, el apunte, lo que escriben los profesores en el pizarron,
 etc) representamos dos objetos diferentes de la misma forma.
 Por ejemplo 
\begin_inset Formula $45$
\end_inset

 puede estar denotando al numero entero cuarenta y cinco o tambien 
\begin_inset Formula $45$
\end_inset

 puede estar denotando la palabra de longitud 
\begin_inset Formula $2$
\end_inset

 cuyo primer simbolo es el numeral 
\begin_inset Formula $4$
\end_inset

 y cuyo segundo simbolo es el numeral 
\begin_inset Formula $5$
\end_inset

, es decir ella misma.
 Por dar otro ejemplo, el simbolo 
\begin_inset Formula $1$
\end_inset

 en nuestro discurso algunas veces se denotara a si mismo y otras veces
 denotara al numero uno.
\end_layout

\begin_layout Standard
Es bien conocido que, en notacion decimal, las siguientes palabras del alfabeto
 
\begin_inset Formula $Num$
\end_inset

, denotan, de menor a mayor, a los numeros de 
\begin_inset Formula $\omega$
\end_inset


\begin_inset Formula 
\[
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,...
\]

\end_inset

Por supuesto esta lista de palabras es infinita pero asumimos que el lector
 sabe como obtener la palabra siguiente a cada miembro de la lista (i.e.
 sumar 1 en notacion decimal), lo cual determina por completo la lista conociend
o que la misma comienza con la palabra 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Standard
Cabe destacar que debido a la presencia del numeral 
\begin_inset Formula $0$
\end_inset

 en la lista, la 
\begin_inset Formula $n$
\end_inset

-esima palabra representa o denota al numero 
\begin_inset Formula $n-1$
\end_inset

 o, dicho de otra forma, el numero 
\begin_inset Formula $n\in\omega$
\end_inset

 es representado por la 
\begin_inset Formula $(n+1)$
\end_inset

-esima palabra de la lista.
\end_layout

\begin_layout Standard
Un detalle de la representacion decimal de numeros de 
\begin_inset Formula $\omega$
\end_inset

 mediante palabras de 
\begin_inset Formula $Num^{\ast}$
\end_inset

 es que la misma no nos da una biyeccion entre 
\begin_inset Formula $Num^{\ast}$
\end_inset

 y 
\begin_inset Formula $\omega$
\end_inset

 ya que por ejemplo las palabras 
\begin_inset Formula $00016$
\end_inset

 y 
\begin_inset Formula $16$
\end_inset

 representan el mismo numero.
 Dicho de otra forma en la lista anterior no figuran todas las palabras
 de 
\begin_inset Formula $Num^{\ast}$
\end_inset

, a saber estan omitidas todas las palabras que comienzan con el simbolo
 
\begin_inset Formula $0$
\end_inset

 y tienen longitud mayor que uno.
 A continuacion daremos una representacion de los numeros de 
\begin_inset Formula $\omega$
\end_inset

 mediante palabras, la cual no tendra este problema.
 El alfabeto que usaremos tendra todos los numerales menos el 
\begin_inset Formula $0$
\end_inset

 y ademas tendra un simbolo para denotar al numero diez, a saber el simbolo
 
\begin_inset Formula $d$
\end_inset

.
 Es decir
\begin_inset Formula 
\[
\widetilde{Num}=\{1,2,3,4,5,6,7,8,9,d\}
\]

\end_inset

Representaremos a los numeros de 
\begin_inset Formula $\omega$
\end_inset

 con la siguiente lista infinita de palabras de 
\begin_inset Formula $\widetilde{Num}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\bigskip$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\varepsilon,1,2,3,4,5,6,7,8,9,d,$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $11,12,...,1d,21,22,...,2d,...,91,92,...,9d,d1,d2,...,dd,$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $111,112,...,11d,121,122,...,12d,...$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
El lector ya se habra dado cuenta de que el siguiente a una palabra 
\begin_inset Formula $\alpha$
\end_inset

 de la lista anterior se obtiene aplicando las siguientes clausulas
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
C
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset

si 
\begin_inset Formula $\alpha=d^{n}$
\end_inset

, con 
\begin_inset Formula $n\geq0$
\end_inset

 entonces el siguiente de 
\begin_inset Formula $\alpha$
\end_inset

 es 
\begin_inset Formula $1^{n+1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
C
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset

si 
\begin_inset Formula $\alpha$
\end_inset

 no es de la forma 
\begin_inset Formula $d^{n}$
\end_inset

, con 
\begin_inset Formula $n\geq0$
\end_inset

, entonces el siguiente de 
\begin_inset Formula $\alpha$
\end_inset

 se obtiene de la siguiente manera:
\end_layout

\begin_deeper
\begin_layout Enumerate
buscar de derecha a izquierda el primer simbolo no igual a 
\begin_inset Formula $d$
\end_inset


\end_layout

\begin_layout Enumerate
reemplazar dicho simbolo por su siguiente en la lista 
\begin_inset Formula $1,2,3,4,5,6,7,8,9,d$
\end_inset


\end_layout

\begin_layout Enumerate
reemplazar por el simbolo 
\begin_inset Formula $1$
\end_inset

 a todos los simbolos iguales a 
\begin_inset Formula $d$
\end_inset

 que ocurrian a la derecha del simbolo reemplazado 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Notese que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $0$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $\varepsilon$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $1$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $9$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $9$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $10$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $d$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $11$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $11$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $19$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $19$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $20$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $1d$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $21$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $21$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El numero 
\begin_inset Formula $22$
\end_inset

 es representado en la lista anterior con la palabra 
\begin_inset Formula $22$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Como puede notarse en estos primeros veinte y pico numeros solo dos (el
 
\begin_inset Formula $0$
\end_inset

 y el 
\begin_inset Formula $20$
\end_inset

) se representan en forma distinta a la reprentacion decimal clasica.
 Es natural que 
\begin_inset Formula $\varepsilon$
\end_inset

 denote al numero 
\begin_inset Formula $0$
\end_inset

 y ademas notese que la palabra 
\begin_inset Formula $1d$
\end_inset

 (que en la lista representa el 
\begin_inset Formula $20$
\end_inset

) puede leerse como 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

diecidiez
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 (es decir la palabra que sigue a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

diecinueve
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

) que justamente es 
\begin_inset Formula $20$
\end_inset

.
 Por supuesto con esta manera de pensar la palabra 
\begin_inset Formula $2d$
\end_inset

 deberiamos leerla como 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

ventidiez
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y si nos fijamos en la lista ella representa al numero treinta lo cual
 nuevamente es muy natural.
 Otro ejemplo: a 
\begin_inset Formula $6d$
\end_inset

 deberiamos leerla como 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

sesentidiez
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y es natural ya que en la lista representa al setenta.
 Tambien, la palabra 
\begin_inset Formula $9d$
\end_inset

 puede leerse noventidiez ya que representa en la lista al numero 
\begin_inset Formula $100$
\end_inset

.
\end_layout

\begin_layout Standard
La lista anterior va representando los numeros de 
\begin_inset Formula $\omega$
\end_inset

 en forma muy natural pero aunque nuestra intuicion nos diga que no, en
 principio podria pasar que una misma palabra del alfabeto 
\begin_inset Formula $\widetilde{Num}$
\end_inset

 ocurra dos veces en la lista y esto nos diria que una misma palabra estaria
 representando a dos numeros distintos.
 Tambien, en principio podria suceder que haya una palabra del alfabeto
 
\begin_inset Formula $\widetilde{Num}$
\end_inset

 la cual nunca figure en la lista.
 Mas abajo probaremos que estas dos posibilidades no suceden, es decir muestran
 que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(S)
\end_layout

\end_inset

Toda palabra de 
\begin_inset Formula $\widetilde{Num}^{\ast}$
\end_inset

 aparece en la lista
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I)
\end_layout

\end_inset

Ninguna palabra de 
\begin_inset Formula $\widetilde{Num}^{\ast}$
\end_inset

 aparece mas de una ves 
\end_layout

\begin_layout Standard
\noindent
Notese que la propiedad (S) nos dice que la funcion
\begin_inset Formula 
\[
\begin{array}[t]{rll}
\ast:\omega & \rightarrow & \widetilde{Num}^{\ast}\\
n & \rightarrow & (n+1)\text{-esimo elemento de la lista}
\end{array}
\]

\end_inset

es sobreyectiva y la propiedad (I) nos garantiza que dicha funcion es inyectiva,
 por lo cual entre las dos nos garantizan que dicha representacion establece
 una biyeccion entre 
\begin_inset Formula $\omega$
\end_inset

 y 
\begin_inset Formula $\widetilde{Num}^{\ast}$
\end_inset

.
\end_layout

\begin_layout Standard
Por supuesto, la pregunta que inmediatamente surge es como calcular la inversa
 de 
\begin_inset Formula $\ast$
\end_inset

.
 Llamemos 
\begin_inset Formula $\#$
\end_inset

 a la inversa de 
\begin_inset Formula $\ast$
\end_inset

.
 Notese que dada una palabra 
\begin_inset Formula $\alpha\in\widetilde{Num}^{\ast}$
\end_inset

, el numero 
\begin_inset Formula $\#(\alpha)$
\end_inset

 es justamente el numero representado por la palabra 
\begin_inset Formula $\alpha$
\end_inset

, o dicho de otra forma 
\begin_inset Formula $\#(\alpha)$
\end_inset

 es la posicion que ocupa 
\begin_inset Formula $\alpha$
\end_inset

 en la lista, contando desde el 
\begin_inset Formula $0$
\end_inset

 (es decir 
\begin_inset Formula $\alpha$
\end_inset

 es la 
\begin_inset Formula $(\#(\alpha)+1)$
\end_inset

-esima palabra de la lista).
 Por ejemplo:
\begin_inset Formula 
\begin{gather*}
\#(\varepsilon)=0\\
\#(1)=1\\
\vdots\\
\#(9)=9\\
\#(d)=10\\
\#(11)=11\\
\#(12)=12\\
\vdots\\
\#(19)=19\\
\#(1d)=20
\end{gather*}

\end_inset

Aqui hay que tener cuidado como leemos las igualdades anteriores.
 Por ejemplo en la igualdad
\begin_inset Formula 
\[
\#(1)=1
\]

\end_inset

la primera ocurrencia del simbolo 
\begin_inset Formula $1$
\end_inset

 se refiere al numeral uno, es decir denota una palabra y la segunda ocurrencia
 se esta refiriendo al numero uno, es decir denota un numero.
\end_layout

\begin_layout Standard
Dejamos al lector el ejercicio de ganar intuicion con ejemplos hasta que
 se convensa de que tal como en el caso de la notacion decimal, el numero
 
\begin_inset Formula $\#(\alpha)$
\end_inset

 se expresa como una suma de potencias de 
\begin_inset Formula $10$
\end_inset

, con los coeficientes dados en funcion de los simbolos de 
\begin_inset Formula $\alpha$
\end_inset

.
 Mas concretamente si 
\begin_inset Formula $\alpha=s_{1}s_{2}...s_{k}$
\end_inset

 con 
\begin_inset Formula $k\geq1$
\end_inset

 y 
\begin_inset Formula $s_{1},s_{2},...,s_{k}\in\widetilde{Num}$
\end_inset

, entonces
\begin_inset Formula 
\[
\#(\alpha)=\#(s_{1}).10^{k-1}+\#(s_{2}).10^{k-2}+...+\#(s_{k}).10^{0}
\]

\end_inset

No daremos aqui una prueba de este hecho ya que lo probaremos abajo para
 el caso general.
 Para ganar intuicion sobre el mismo el lector puede ver mas abajo la prueba
 de las propiedades (S) e (I), desde donde se ve con mas claridad como va
 aumentando la funcion 
\begin_inset Formula $\#$
\end_inset

 a medida que recorremos la lista de izquierda a derecha.
 Algunos ejemplos
\begin_inset Formula 
\begin{align*}
\#(1d) & =1.10^{1}+10.10^{0}=10+10=20\\
\#(dd) & =10.10^{1}+10.10^{0}=100+10=110\\
\#(111) & =1.10^{2}+1.10^{1}+1.10^{0}=100+10+1=111\\
\#(1d3d) & =1.10^{3}+10.10^{2}+3.10^{1}+10.10^{0}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Ahora que sabemos que las palabras de 
\begin_inset Formula $\widetilde{Num}$
\end_inset

 representan los numeros como suma de potencias de diez, en forma analoga
 a la notacion decimal clasica, podemos refozar aun mas la analogia poniendo
 nombres adecuados que, tal como en el caso clasico, nos permitan leer las
 palabras de 
\begin_inset Formula $\widetilde{Num}$
\end_inset

 describiendo su suma de potencias asociada.
 Por ejemplo podriamos llamar 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

decenta
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 al numero 
\begin_inset Formula $100$
\end_inset

, por analogia a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

treinta
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

cuarenta
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

,...,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

noventa
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 O sea una decenta es diez veces diez.
 De esta forma la palabra 
\begin_inset Formula $d1$
\end_inset

 se leera 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

decenta y uno
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y esto es natural ya que en la lista representa al 
\begin_inset Formula $101$
\end_inset

.
 La palabra 
\begin_inset Formula $dd$
\end_inset

 se leera 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

decenta y diez
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y esto describe a la perfeccion el numero que representa, i.e.
 el 
\begin_inset Formula $10.10+10=110$
\end_inset

.
 La palabra que sigue en la lista a 
\begin_inset Formula $dd$
\end_inset

 es 
\begin_inset Formula $111$
\end_inset

 la cual representa al 
\begin_inset Formula $111$
\end_inset

, es decir aqui como en los otros casos vistos en los cuales no hay ocurrencias
 del simbolo 
\begin_inset Formula $d$
\end_inset

 la palabra representa al mismo numero que representa en la notacion decimal
 clasica.
 Por dar otro ejemplo, la palabra 
\begin_inset Formula $59d3$
\end_inset

 se leera 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

cinco mil novecientos decenta y tres
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y representara al numero 
\begin_inset Formula $6003$
\end_inset

.
\end_layout

\begin_layout Standard
Para seguir debemos ponerle nombre a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

diez veces cien
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, es decir, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

decientos
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 (por analogia con 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

novecientos = nueve veces cien
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

) denotara al numero 
\begin_inset Formula $1000=10.100$
\end_inset

.
 De esta forma la palabra 
\begin_inset Formula $d51$
\end_inset

 se leera 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

decientos cincuenta y uno
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y esto es natural ya que pensando un rato se puede ver que ella representa
 al 
\begin_inset Formula $1051$
\end_inset

.
 Tambien, la palabra 
\begin_inset Formula $ddd$
\end_inset

 se leera 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

decientos decenta y diez
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y representara al numero 
\begin_inset Formula $1110$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Prueba de las propiedades (S) e (I)
\end_layout

\begin_layout Standard
Dado que el siguiente a un elemento 
\begin_inset Formula $\alpha$
\end_inset

 de la lista es de la misma longitud que 
\begin_inset Formula $\alpha$
\end_inset

 o tiene longitud igual a 
\begin_inset Formula $\left\vert \alpha\right\vert +1$
\end_inset

, podemos representar la lista anterior de la siguiente manera:
\begin_inset Formula 
\[
B_{0};B_{1};B_{2};B_{3};B_{4};...
\]

\end_inset

donde cada 
\begin_inset Formula $B_{n}$
\end_inset

 es, por definicion, la parte de la lista en la cual las palabras tienen
 longitud exactamente 
\begin_inset Formula $n$
\end_inset

.
 Por ejemplo:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $B_{0}$
\end_inset

 es 
\begin_inset Formula $\varepsilon$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $B_{1}$
\end_inset

 es 
\begin_inset Formula $1,2,3,4,5,6,7,8,9,d$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $B_{2}$
\end_inset

 es 
\begin_inset Formula $11,12,...,1d,21,22,...,2d,...,91,92,...,9d,d1,d2,...,dd$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que hasta el momento nada nos asegura que no suceda que para algun
 
\begin_inset Formula $n$
\end_inset

 se de que 
\begin_inset Formula $B_{n}$
\end_inset

 sea una lista infinita, lo cual ademas nos diria que los bloques 
\begin_inset Formula $B_{n+1},B_{n+2},...$
\end_inset

 son todos vacios.
 Es decir podria pasar que la lista se estanque en una longitud 
\begin_inset Formula $n$
\end_inset

 y nunca aparezca una palabra de longitud mayor que 
\begin_inset Formula $n$
\end_inset

.
 Esto por supuesto obligaria a que se repitan muchas veces palabras de dicha
 longitud 
\begin_inset Formula $n$
\end_inset

 ya que hay una cantidad finita de las mismas (
\begin_inset Formula $10^{n}$
\end_inset

).
\end_layout

\begin_layout Standard
Por supuesto nuestra intuicion nos dice que en el bloque 
\begin_inset Formula $B_{n}$
\end_inset

 estan listadas sin repeticion todas las palabras de 
\begin_inset Formula $\widetilde{Num}^{\ast}$
\end_inset

 de longitud 
\begin_inset Formula $n$
\end_inset

, pero debemos justificar esto con argumentos solidos.
 Algunas propiedades basicas que se pueden probar facilmente son:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $B_{n}=\alpha_{1},...,\alpha_{k}$
\end_inset

, entonces 
\begin_inset Formula $\alpha_{1}=1^{n}$
\end_inset

 y 
\begin_inset Formula $\alpha_{k}=d^{n}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $d^{n}$
\end_inset

 ocurre en 
\begin_inset Formula $B_{n}$
\end_inset

 lo hace en la ultima posicion 
\end_layout

\begin_layout Standard
\noindent
estas propiedades son consecuencias inmediatas de como se calcula el elemento
 siguiente a uno dado en la lista y son dejadas como ejercicio.
 Otra propiedad importante es la siguiente
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $B_{n}=\alpha_{1},...,\alpha_{k}$
\end_inset

, entonces 
\begin_inset Formula $B_{n+1}=1\alpha_{1},...,1\alpha_{k},2\alpha_{1},...,2\alpha_{k},...,d\alpha_{1},...,d\alpha_{k}$
\end_inset

 
\end_layout

\begin_layout Standard
Para probar (3) es muy util el siguiente resultado obvio
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\sigma\in\widetilde{Num}$
\end_inset

 y supongamos 
\begin_inset Formula $\alpha\in\widetilde{Num}^{\ast}$
\end_inset

 no es de la forma 
\begin_inset Formula $d^{n}$
\end_inset

.
 Entonces el siguiente a 
\begin_inset Formula $\sigma\alpha$
\end_inset

 es 
\begin_inset Formula $\sigma\beta$
\end_inset

 donde 
\begin_inset Formula $\beta$
\end_inset

 es el siguiente a 
\begin_inset Formula $\alpha$
\end_inset

 
\end_layout

\begin_layout Standard
Dejamos como ejercicio al lector hacer la prueba de (3) usando el lema anterior
 y las propiedades (1) y (2).
 Ahora es facil usando (3) probar inductivamente que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $B_{n}$
\end_inset

 es una lista sin repeticiones de todas las palabras de longitud 
\begin_inset Formula $n$
\end_inset

 
\end_layout

\begin_layout Standard
Pero claramente de (4) se desprenden en forma obvia las propiedades (S)
 y (I).
\end_layout

\begin_layout Subsection
El caso general
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto no vacio y supongamos 
\begin_inset Formula $\leq$
\end_inset

 es un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Supongamos que 
\begin_inset Formula $\Sigma=\{a_{1},...,a_{n}\}$
\end_inset

, con 
\begin_inset Formula $a_{1}<a_{2}<...<a_{n}$
\end_inset

.
 Inspirados en la lista dada anteriormente de las palabras de 
\begin_inset Formula $\widetilde{Num}^{\ast}$
\end_inset

, podemos dar la siguiente lista de palabras de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula ${\small\varepsilon,a}_{1}{\small,a}_{2}{\small,...,a}_{n}{\small,}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula ${\small a}_{1}{\small a}_{1}{\small,a}_{1}{\small a}_{2}{\small,...,a}_{1}{\small a}_{n}{\small,a}_{2}{\small a}_{1}{\small,a}_{2}{\small a}_{2}{\small,...,a}_{2}{\small a}_{n}{\small,...,a}_{n}{\small a}_{1}{\small,a}_{n}{\small a}_{2}{\small,...,a}_{n}{\small a}_{n}{\small,}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula ${\small a}_{1}{\small a}_{1}{\small a}_{1}{\small,a}_{1}{\small a}_{1}{\small a}_{2}{\small,...,a}_{1}{\small a}_{1}{\small a}_{n}{\small,a}_{1}{\small a}_{2}{\small a}_{1}{\small,a}_{1}{\small a}_{2}{\small a}_{2}{\small,...,a}_{1}{\small a}_{2}{\small a}_{n}{\small,...,a}_{1}{\small a}_{n}{\small a}_{1}{\small,a}_{1}{\small a}_{n}{\small a}_{2}{\small,a}_{1}{\small a}_{n}{\small a}_{n}{\small,}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula ${\small a}_{2}{\small a}_{1}{\small a}_{1}{\small,a}_{2}{\small a}_{1}{\small a}_{2}{\small,...,a}_{2}{\small a}_{1}{\small a}_{n}{\small,a}_{2}{\small a}_{2}{\small a}_{1}{\small,a}_{2}{\small a}_{2}{\small a}_{2}{\small,...,a}_{2}{\small a}_{2}{\small a}_{n}{\small,...,a}_{2}{\small a}_{n}{\small a}_{1}{\small,a}_{2}{\small a}_{n}{\small a}_{2}{\small,a}_{2}{\small a}_{n}{\small a}_{n}{\small,}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula ${\small\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\vdots$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula ${\small a}_{n}{\small a}_{1}{\small a}_{1}{\small,a}_{n}{\small a}_{1}{\small a}_{2}{\small,...,a}_{n}{\small a}_{1}{\small a}_{n}{\small,a}_{n}{\small a}_{2}{\small a}_{1}{\small,a}_{n}{\small a}_{2}{\small a}_{2}{\small,...,a}_{n}{\small a}_{2}{\small a}_{n}{\small,...,a}_{n}{\small a}_{n}{\small a}_{1}{\small,a}_{n}{\small a}_{n}{\small a}_{2}{\small,a}_{n}{\small a}_{n}{\small a}_{n}{\small,}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula ${\small a}_{1}{\small a}_{1}{\small a}_{1}{\small a}_{1}{\small,a}_{1}{\small a}_{1}{\small a}_{1}{\small a}_{2}{\small,...}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
El objetivo es probar que la lista anterior enumera sin repeticiones todas
 las palabras de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

, i.e.
 produce naturalmente una biyeccion entre 
\begin_inset Formula $\omega$
\end_inset

 y 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
 Pero antes debemos definir mas formalmente la lista.
 Para esto definamos 
\begin_inset Formula $s^{\leq}:\Sigma^{\ast}\rightarrow\Sigma^{\ast}$
\end_inset

 de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $s^{\leq}((a_{n})^{m})=(a_{1})^{m+1}$
\end_inset

, para cada 
\begin_inset Formula $m\geq0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $s^{\leq}(\alpha a_{i}(a_{n})^{m})=\alpha a_{i+1}(a_{1})^{m}$
\end_inset

, cada vez que 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, 
\begin_inset Formula $1\leq i<n$
\end_inset

 y 
\begin_inset Formula $m\geq0$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que la definicion de 
\begin_inset Formula $s^{\leq}$
\end_inset

 es correcta ya que una palabra de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 ya sea es de la forma 
\begin_inset Formula $(a_{n})^{m}$
\end_inset

, con 
\begin_inset Formula $m\geq0$
\end_inset

, o es de la forma 
\begin_inset Formula $\alpha a_{i}(a_{n})^{m}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, 
\begin_inset Formula $1\leq i<n$
\end_inset

 y 
\begin_inset Formula $m\geq0$
\end_inset

; y estos dos casos posibles son mutuamente excluyentes.
\end_layout

\begin_layout Standard
Claramente se tiene entonces que la lista anterior puede ser escrita de
 la siguiente manera
\begin_inset Formula 
\[
\varepsilon,s^{\leq}(\varepsilon),s^{\leq}(s^{\leq}(\varepsilon)),s^{\leq}(s^{\leq}(s^{\leq}(\varepsilon))),s^{\leq}(s^{\leq}(s^{\leq}(s^{\leq}(\varepsilon)))),...
\]

\end_inset

Con esta definicion formal de la lista, podemos probar de la misma forma
 en la que lo hicimos arriba para el caso 
\begin_inset Formula $\Sigma=\widetilde{Num}$
\end_inset

 que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(S)
\end_layout

\end_inset

Toda palabra de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 aparece en la lista
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I)
\end_layout

\end_inset

Ninguna palabra de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 aparece mas de una ves en la lista 
\end_layout

\begin_layout Standard
\noindent
(dejamos al lector los detalles por tratarse de un argumento completamente
 similar).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Definamos 
\begin_inset Formula $\ast^{\leq}:\omega\rightarrow\Sigma^{\ast}$
\end_inset

 recursivamente de la siguiente manera:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\ast^{\leq}(0)=\varepsilon$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\ast^{\leq}(i+1)=s^{\leq}(\ast^{\leq}(i))$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Es claro que entonces 
\begin_inset Formula $\ast^{\leq}(i)$
\end_inset

 nos da el 
\begin_inset Formula $(i+1)$
\end_inset

-esimo elemento de la lista, o lo que es lo mismo, el 
\begin_inset Formula $i$
\end_inset

-esimo elemento de la lista contando desde el 
\begin_inset Formula $0$
\end_inset

.
 O sea que las propiedades (S) y (I) nos garantizan que la funcion 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 es biyectiva.
 A continuacion describiremos su inversa.
 Primero un lema facil pero muy importante.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto no vacio y supongamos 
\begin_inset Formula $\leq$
\end_inset

 es un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Supongamos que 
\begin_inset Formula $\Sigma=\{a_{1},...,a_{n}\}$
\end_inset

, con 
\begin_inset Formula $a_{1}<a_{2}<...<a_{n}$
\end_inset

.
 Entonces para cada 
\begin_inset Formula $\alpha\in\Sigma^{\ast}-\{\varepsilon\}$
\end_inset

 hay unicos 
\begin_inset Formula $k\in\omega$
\end_inset

 y 
\begin_inset Formula $i_{0},i_{1},...,i_{k}\in\{1,...,n\}$
\end_inset

 tales que
\begin_inset Formula 
\[
\alpha=a_{i_{k}}...a_{i_{0}}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notar que 
\begin_inset Formula $k$
\end_inset

 del lema anterior es 
\begin_inset Formula $\left\vert \alpha\right\vert -1$
\end_inset

 y los numeros 
\begin_inset Formula $i_{k},...,i_{0}$
\end_inset

 van dando el numero de orden de cada simbolo de 
\begin_inset Formula $\alpha$
\end_inset

 yendo de izquierda a derecha.
 Por ejemplo si 
\begin_inset Formula $\Sigma=\{\%,!,@\}$
\end_inset

 y 
\begin_inset Formula $\leq$
\end_inset

 es el orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

 dado por 
\begin_inset Formula $\%<!<@$
\end_inset

 (es decir que aqui 
\begin_inset Formula $a_{1}=\%$
\end_inset

, 
\begin_inset Formula $a_{2}=!$
\end_inset

 y 
\begin_inset Formula $a_{3}=@$
\end_inset

) entonces para la palabra 
\begin_inset Formula $!\%@\%@$
\end_inset

 tenemos 
\begin_inset Formula $k=4$
\end_inset

 y 
\begin_inset Formula $i_{4}=2$
\end_inset

, 
\begin_inset Formula $i_{3}=1$
\end_inset

, 
\begin_inset Formula $i_{2}=3$
\end_inset

, 
\begin_inset Formula $i_{1}=1$
\end_inset

 y 
\begin_inset Formula $i_{0}=3$
\end_inset

.
 Sin envargo si hubieramos tomado el orden dado por 
\begin_inset Formula $@<\%<!$
\end_inset

, para la misma palabra hubieramos tenido 
\begin_inset Formula $i_{4}=3$
\end_inset

, 
\begin_inset Formula $i_{3}=2$
\end_inset

, 
\begin_inset Formula $i_{2}=1$
\end_inset

, 
\begin_inset Formula $i_{1}=2$
\end_inset

 y 
\begin_inset Formula $i_{0}=1$
\end_inset

.
\end_layout

\begin_layout Standard
Ahora podemos definir la funcion 
\begin_inset Formula $\#^{\leq}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
\begin{array}[t]{rll}
\#^{\leq}:\Sigma^{\ast} & \rightarrow & \omega\\
\varepsilon & \rightarrow & 0\\
a_{i_{k}}...a_{i_{0}} & \rightarrow & i_{k}n^{k}+...+i_{0}n^{0}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "numeral es la inversa de estrella"

\end_inset

La funcion 
\begin_inset Formula $\#^{\leq}$
\end_inset

 es la inversa de 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Primero probaremos por induccion en 
\begin_inset Formula $x$
\end_inset

 que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $x\in\omega$
\end_inset

, se tiene que 
\begin_inset Formula $\#^{\leq}(\ast^{\leq}(x))=x$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
El caso 
\begin_inset Formula $x=0$
\end_inset

 es trivial.
 Supongamos que 
\begin_inset Formula $\#^{\leq}(\ast^{\leq}(x))=x$
\end_inset

, veremos entonces que 
\begin_inset Formula $\#^{\leq}(\ast^{\leq}(x+1))=x+1$
\end_inset

.
 Sean 
\begin_inset Formula $k\geq0$
\end_inset

 y 
\begin_inset Formula $i_{k},...,i_{0}$
\end_inset

 tales que 
\begin_inset Formula $\ast^{\leq}(x)=a_{i_{k}}...a_{i_{0}}$
\end_inset

.
 Ya que 
\begin_inset Formula $\#^{\leq}(\ast^{\leq}(x))=x$
\end_inset

 tenemos que 
\begin_inset Formula $x=i_{k}n^{k}+...+i_{0}n^{0}$
\end_inset

.
 Hay varios casos.
\end_layout

\begin_layout Standard
\noindent
Caso 
\begin_inset Formula $i_{0}<n$
\end_inset

.
 Entonces 
\begin_inset Formula $\ast^{\leq}(x+1)=s^{\leq}(\ast^{\leq}(x))=a_{i_{k}}...a_{i_{0}+1}$
\end_inset

 por lo cual 
\begin_inset Formula 
\[
\begin{array}{ll}
\#^{\leq}(\ast^{\leq}(x+1)) & =i_{k}n^{k}+i_{k-1}n^{k-1}+...+(i_{0}+1)n^{0}\\
 & =\left(i_{k}n^{k}+i_{k-1}n^{k-1}+...+i_{0}n^{0}\right)+1\\
 & =x+1
\end{array}
\]

\end_inset

Caso 
\begin_inset Formula $i_{k}=i_{k-1}=...=i_{0}=n$
\end_inset

.
 Entonces 
\begin_inset Formula $\ast^{\leq}(x+1)=s^{\leq}(\ast^{\leq}(x))=(a_{1})^{k+2}$
\end_inset

 por lo cual
\begin_inset Formula 
\[
\begin{array}{ll}
\#^{\leq}(\ast^{\leq}(x+1)) & =1n^{k+1}+1n^{k}+...+1n^{1}+1n^{0}\\
 & =\left(nn^{k}+nn^{k-1}+...+nn^{0}\right)+1\\
 & =x+1
\end{array}
\]

\end_inset

Caso 
\begin_inset Formula $i_{0}=i_{1}=...=i_{h}=n$
\end_inset

, 
\begin_inset Formula $\;i_{h+1}\not=n$
\end_inset

, 
\begin_inset space \space{}
\end_inset

para algun 
\begin_inset Formula $0\leq h<k$
\end_inset

.
 Entonces 
\begin_inset Formula $\ast^{\leq}(x+1)=s^{\leq}(\ast^{\leq}(x))=a_{i_{k}}...a_{i_{h+2}}a_{i_{h+1}+1}(a_{1})^{h}$
\end_inset

 por lo cual
\begin_inset Formula 
\[
\begin{array}{ll}
\#^{\leq}(\ast^{\leq}(x+1)) & =i_{k}n^{k}+...+i_{h+2}n^{h+2}+(i_{h+1}+1)n^{h+1}+1n^{h}+...+1n^{1}+1n^{0}\\
 & =\left(i_{k}n^{k}+...+i_{h+2}n^{h+2}+i_{h+1}n^{h+1}+n^{h+1}+n^{h}+...+n^{1}\right)+1\\
 & =\left(i_{k}n^{k}+...+i_{h+2}n^{h+2}+i_{h+1}n^{h+1}+nn^{h}+...+nn^{0}\right)+1\\
 & =x+1
\end{array}
\]

\end_inset

De esta forma hemos probado (a).
\end_layout

\begin_layout Standard
Por definicion la inversa de 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 es la funcion con dominio 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 que a una palabra 
\begin_inset Formula $\alpha$
\end_inset

 le asocia el unico 
\begin_inset Formula $x\in\omega$
\end_inset

 tal que 
\begin_inset Formula $\ast^{\leq}(x)=\alpha$
\end_inset

.
 Es decir debemos probar que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\#^{\leq}(\alpha)=$
\end_inset

 unico 
\begin_inset Formula $x\in\omega$
\end_inset

 tal que 
\begin_inset Formula $\ast^{\leq}(x)=\alpha$
\end_inset

, para cada 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Pero (b) es una concecuencia inmediata de (a).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Cabe destacar que dada una palabra 
\begin_inset Formula $\alpha$
\end_inset

, el numero 
\begin_inset Formula $\#^{\leq}(\alpha)$
\end_inset

 nos dice en que posicion se hubica 
\begin_inset Formula $\alpha$
\end_inset

 en la lista, es decir 
\begin_inset Formula $\alpha$
\end_inset

 es la (
\begin_inset Formula $\#^{\leq}(\alpha)+1$
\end_inset

)-esima palabra de la lista.
\end_layout

\begin_layout Standard
De los desarrollos hechos se desprende el interesante resultado.
 Dejamos al lector la prueba como ejercicio.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $n\geq1$
\end_inset

 fijo.
 Entonces cada 
\begin_inset Formula $x\geq1$
\end_inset

 se escribe en forma unica de la siguiente manera:
\begin_inset Formula 
\[
x=i_{k}n^{k}+i_{k-1}n^{k-1}+...+i_{0}n^{0},
\]

\end_inset

con 
\begin_inset Formula $k\geq0$
\end_inset

 y 
\begin_inset Formula $1\leq i_{k},i_{k-1},...,i_{0}\leq n$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como hemos visto las biyecciones dadas producen una 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

identificacion
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 entre numeros de 
\begin_inset Formula $\omega$
\end_inset

 y palabras del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Es decir, en algun sentido identificamos palabras y numeros ya que se correspon
den biunivocamente.
 Supongamos que 
\begin_inset Formula $\alpha$
\end_inset

 es una palabra de 
\begin_inset Formula $\Sigma^{\ast}-\{\varepsilon\}$
\end_inset

 y queremos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

verla como un numero
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Entonces en ves de ver sus simbolos vemos los ordenes de aparicion en 
\begin_inset Formula $\Sigma$
\end_inset

 de los mismos y miramos la suma de potencias asociada.
\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $x$
\end_inset

 es un numero de 
\begin_inset Formula $\omega-\{0\}$
\end_inset

 y ademas supongamos que somos super inteligentes y que cuando vemos a 
\begin_inset Formula $x$
\end_inset

 vemos la secuencia unica de numeros 
\begin_inset Formula $i_{k},i_{k-1},...,i_{0}$
\end_inset

 que nos permite expresarlo como suma de potencias segun el lema anterior.
 Entonces si queremos ver a 
\begin_inset Formula $x$
\end_inset

 como una palabra simplemente miramos la secuencia 
\begin_inset Formula $i_{k},i_{k-1},...,i_{0}$
\end_inset

 como palabra, reemplazando cada 
\begin_inset Formula $i_{j}$
\end_inset

 por el simbolo 
\begin_inset Formula $i_{j}$
\end_inset

-esimo de 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Caracter recursivo de las funciones 
\begin_inset Formula $s^{\leq}$
\end_inset

, 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 y 
\begin_inset Formula $\#^{\leq}$
\end_inset


\end_layout

\begin_layout Standard
Es un ejercicio (dejado al lector) probar que cualquiera sea 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, se tiene que
\begin_inset Formula 
\begin{align*}
s^{\leq}(\varepsilon) & =a_{1}\\
s^{\leq}(\alpha a_{i}) & =\alpha a_{i+1}\text{, }i<n\\
s^{\leq}(\alpha a_{n}) & =s^{\leq}(\alpha)a_{1}
\end{align*}

\end_inset

Notese que esto nos permite calcular recursivamente el valor de 
\begin_inset Formula $s^{\leq}$
\end_inset

 ya que las ecuaciones anteriores nos muestran como obtener rapidamente
 
\begin_inset Formula $s^{\leq}(\alpha a)$
\end_inset

 en terminos de 
\begin_inset Formula $s^{\leq}(\alpha)$
\end_inset

 y 
\begin_inset Formula $a$
\end_inset

, donde 
\begin_inset Formula $a$
\end_inset

 es un elemento cualquiera de 
\begin_inset Formula $\Sigma$
\end_inset

.
 Por supuesto, en algun momento deberemos usar el dato inicial 
\begin_inset Formula $s^{\leq}(\varepsilon)=a_{1}$
\end_inset

.
 En un lenguaje de programacion funcional, las tres ecuaciones anteriores
 son directamente un programa para computar 
\begin_inset Formula $s^{\leq}$
\end_inset

 o si se quiere una definicion de dicha funcion.
 Dejamos al lector que intente usar las ecuaciones anteriores para dar un
 programa imperativo que compute 
\begin_inset Formula $s^{\leq}$
\end_inset

 (esto esta hecho mas adelante en la primera lista de funciones 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables).
\end_layout

\begin_layout Standard
Lo mismo sucede con la funcion 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 la cual fue directamente definida en forma recursiva por las ecuaciones
\begin_inset Formula 
\begin{align*}
\ast^{\leq}(0) & =\varepsilon\\
\ast^{\leq}(i+1) & =s^{\leq}(\ast^{\leq}(i))
\end{align*}

\end_inset

Dejamos al lector corroborar que la funcion 
\begin_inset Formula $\#^{\leq}$
\end_inset

 verifica las siguientes ecuaciones, las cuales obviamente pueden ser usadas
 para calcular recursivamente sus valores
\begin_inset Formula 
\begin{align*}
\#^{\leq}(\varepsilon) & =0\\
\#^{\leq}(\alpha a_{i}) & =\#^{\leq}(\alpha).n+i
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Extension del orden total de 
\begin_inset Formula $\Sigma$
\end_inset

 a 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset


\end_layout

\begin_layout Standard
Podemos extender el orden de 
\begin_inset Formula $\Sigma$
\end_inset

 a 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\alpha\leq\beta$
\end_inset

 sii 
\begin_inset Formula $\#^{\leq}(\alpha)\leq\#^{\leq}(\beta)$
\end_inset

 
\end_layout

\begin_layout Standard
Es decir 
\begin_inset Formula $\alpha\leq\beta$
\end_inset

 sii 
\begin_inset Formula $\alpha=\beta$
\end_inset

 o 
\begin_inset Formula $\alpha$
\end_inset

 ocurre antes que 
\begin_inset Formula $\beta$
\end_inset

 en la lista.
 Dejamos como ejercicio para el lector probar que 
\begin_inset Formula $\leq$
\end_inset

 es un orden total sobre 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Deberia ser intuitivamente claro que el orden recien definido sobre 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 posee las mismas propiedades matematicas que el orden usual de 
\begin_inset Formula $\omega$
\end_inset

.
 Esto se entendera en forma mas profunda cuando veamos el concepto de isomorfism
o de posets en los capitulos de logica.
 Veamos un ejemplo:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $S\subseteq\Sigma^{\ast}$
\end_inset

 es no vacio, entonces existe 
\begin_inset Formula $\alpha\in S$
\end_inset

 tal que 
\begin_inset Formula $\alpha\leq\beta$
\end_inset

, para cada 
\begin_inset Formula $\beta\in S$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Codificacion de infinituplas de numeros
\end_layout

\begin_layout Standard
Usaremos 
\begin_inset Formula $\omega^{\mathbf{N}}$
\end_inset

 para denotar el conjunto de todas las infinituplas con coordenadas en 
\begin_inset Formula $\omega$
\end_inset

.
 Es decir
\begin_inset Formula 
\[
\omega^{\mathbf{N}}=\left\{ (s_{1},s_{2},...):s_{i}\in\omega\text{, para cada }i\geq1\right\} \text{.}
\]

\end_inset

Definamos el siguiente subconjunto de 
\begin_inset Formula $\omega^{\mathbf{N}}$
\end_inset


\begin_inset Formula 
\[
\omega^{\left[\mathbf{N}\right]}=\left\{ (s_{1},s_{2},...)\in\omega^{\mathbf{N}}:\text{ hay un }n\in\mathbf{N}\text{ tal que }s_{i}=0,\text{para }i\geq n\right\} \text{.}
\]

\end_inset

Notese que 
\begin_inset Formula $\omega^{\mathbf{N}}\neq\omega^{\left[\mathbf{N}\right]}$
\end_inset

, por ejemplo las infinituplas
\begin_inset Formula 
\begin{align*}
 & (10,20,30,40,50,...)\\
 & (1,0,1,0,1,0,1,0,...)
\end{align*}

\end_inset

no pertenecen a 
\begin_inset Formula $\omega^{\left[\mathbf{N}\right]}$
\end_inset

.
 Notese que 
\begin_inset Formula $(s_{1},s_{2},...)\in\omega^{\left[\mathbf{N}\right]}$
\end_inset

 si y solo si solo una cantidad finita de coordenadas de 
\begin_inset Formula $(s_{1},s_{2},...)$
\end_inset

 son no nulas (i.e.
 
\begin_inset Formula $\{i:s_{i}\neq0\}$
\end_inset

 es finito).
\end_layout

\begin_layout Standard
Definamos
\begin_inset Formula 
\[
\begin{array}{rll}
pr:\mathbf{N} & \rightarrow & \omega\\
n & \rightarrow & n\text{-esimo numero primo}
\end{array}
\]

\end_inset

Ntese que 
\begin_inset Formula $pr(1)=2$
\end_inset

, 
\begin_inset Formula $pr(2)=3$
\end_inset

, 
\begin_inset Formula $pr(3)=5$
\end_inset

, etc.
\end_layout

\begin_layout Standard
Es bien conocido que todo numero natural es expresable como producto de
 primos.
 Por ejemplo si tomamos 
\begin_inset Formula $x=57596$
\end_inset

 tenemos que 
\begin_inset Formula $x=2.2.7.11.11.17$
\end_inset

.
 Tambien es un hecho conocido que dicha representacion en producto de primos
 es unica, si escribimos a los factores primos de menor a mayor, tal como
 lo hicimos recien con el numero 
\begin_inset Formula $57596$
\end_inset

.
 El Teorema Fundamental de la Aritmetica justamente acevera esta propiedad
 de factorisacion unica de todo numero natural.
 Trataremos de escribir este teorema de una forma un poco mas 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

cheta
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $57596=2.2.7.11.11.17$
\end_inset

, podemos escribir
\begin_inset Formula 
\[
57596=pr(1)^{2}.pr(4)^{1}.pr(5)^{2}.pr(7)^{1}
\]

\end_inset

Notese que ahora cada primo que interviene en la factorizacion de 
\begin_inset Formula $57596$
\end_inset

 figura con un exponente que nos dice cuantas veces ocurre en dicha factorizacio
n.
 Hay muchos primos que no ocurren en esta factorizacion, es decir ocurren
 
\begin_inset Formula $0$
\end_inset

 veces en la misma.
 Pero podemos escribir
\begin_inset Formula 
\[
57596=pr(1)^{2}.pr(2)^{0}.pr(3)^{0}.pr(4)^{1}.pr(5)^{2}.pr(6)^{0}.pr(7)^{1}.pr(8)^{0}.pr(9)^{0}.pr(10)^{0}....
\]

\end_inset

y la igualdad no se altera ya que agregamos factores iguales a 
\begin_inset Formula $1$
\end_inset

 (una cantidad infinita!).
 De esta manera cada primo interviene en la factorizacion.
 Ademas si vemos la infinitupla de exponentes de dicha factorizacion, es
 decir
\begin_inset Formula 
\[
(2,0,0,1,2,0,1,0,0,0,...)
\]

\end_inset

obtenemos un elemento de 
\begin_inset Formula $\omega^{[\mathbf{N}]}$
\end_inset

.
\end_layout

\begin_layout Standard
Por supuesto esto lo podemos hacer con cualquier numero natural y siempre
 la infinitupla de exponentes sera un elemento de 
\begin_inset Formula $\omega^{[\mathbf{N}]}$
\end_inset

.
 Ademas es facil notar que estas representaciones 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

chetas
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 tambien resultan unicas.
\end_layout

\begin_layout Standard
Para probar nuestra version del Teorema Fundamental de la Aritmetica necesitarem
os el siguiente lema el cual aceptaremos sin demostracion.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "primos"

\end_inset

Si 
\begin_inset Formula $p,p_{1},...,p_{n}$
\end_inset

 son numeros primos y 
\begin_inset Formula $p$
\end_inset

 divide a 
\begin_inset Formula $p_{1}.p_{2}.\ldots.p_{n}$
\end_inset

, entonces 
\begin_inset Formula $p=p_{i}$
\end_inset

, para algun 
\begin_inset Formula $i$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Para cada 
\begin_inset Formula $x\in\mathbf{N}$
\end_inset

, hay una unica infinitupla 
\begin_inset Formula $(s_{1},s_{2},...)\in\omega^{\left[\mathbf{N}\right]}$
\end_inset

 tal que
\begin_inset Formula 
\[
x=\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{s_{i}}
\]

\end_inset

(Tiene sentido escribir 
\begin_inset Formula $\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{s_{i}}$
\end_inset

, ya que en esta productoria solo una cantidad finita de factores son no
 iguales a 
\begin_inset Formula $1$
\end_inset

.) 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Primero probaremos la existencia por induccion en 
\begin_inset Formula $x$
\end_inset

.
 Claramente 
\begin_inset Formula $1=\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{0}$
\end_inset

, con lo cual tomando 
\begin_inset Formula $(s_{1},s_{2},...)=(0,0,0,...)$
\end_inset

 el caso 
\begin_inset Formula $x=1$
\end_inset

 esta probado.
 Fijemos ahora un 
\begin_inset Formula $x>1$
\end_inset

 y supongamos la existencia vale para cada 
\begin_inset Formula $y$
\end_inset

 menor que 
\begin_inset Formula $x$
\end_inset

.
 Veremos que entonces vale para 
\begin_inset Formula $x$
\end_inset

.
 Si 
\begin_inset Formula $x$
\end_inset

 es primo, entonces 
\begin_inset Formula $x=pr(i_{0})$
\end_inset

 para algun 
\begin_inset Formula $i_{0}$
\end_inset

 por lo cual tenemos que 
\begin_inset Formula $x=\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{s_{i}}$
\end_inset

, tomando 
\begin_inset Formula $s_{i}=0$
\end_inset

 si 
\begin_inset Formula $i\neq i_{0}$
\end_inset

 y 
\begin_inset Formula $s_{i_{0}}=1$
\end_inset

.
 Si 
\begin_inset Formula $x$
\end_inset

 no es primo, entonces 
\begin_inset Formula $x=y_{1}.y_{2}$
\end_inset

, con 
\begin_inset Formula $y_{1},y_{2}<x$
\end_inset

.
 Por hipotesis inductiva tenemos que hay 
\begin_inset Formula $(s_{1},s_{2},...),(t_{1},t_{2},...)\in\omega^{\left[\mathbf{N}\right]}$
\end_inset

 tales que 
\begin_inset Formula $y_{1}=\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{s_{i}}$
\end_inset

 y 
\begin_inset Formula $y_{2}=\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{t_{i}}$
\end_inset

.
 Tenemos entonces que 
\begin_inset Formula $x=\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{s_{i}+t_{i}}$
\end_inset

 lo cual concluye la prueba de la existencia.
\end_layout

\begin_layout Standard
Veamos ahora la unicidad.
 Suponganos que las infinituplas 
\begin_inset Formula $(s_{1},s_{2},...),(t_{1},t_{2},...)\in\omega^{\left[\mathbf{N}\right]}$
\end_inset

 son tales que
\begin_inset Formula 
\[
\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{s_{i}}=\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{t_{i}}
\]

\end_inset

y ademas 
\begin_inset Formula $s_{i}\neq t_{i}$
\end_inset

 para algun 
\begin_inset Formula $i$
\end_inset

.
 Si 
\begin_inset Formula $s_{i}>t_{i}$
\end_inset

 entonces dividiendo ambos miembros por 
\begin_inset Formula $pr(i)^{t_{i}}$
\end_inset

 obtenemos que 
\begin_inset Formula $pr(i)$
\end_inset

 divide a un producto de primos todos distintos de el, lo cual es absurdo
 por el lema anterior.
 Analogamente llegamos a un absurdo si suponemos que 
\begin_inset Formula $t_{i}>s_{i}$
\end_inset

, lo cual nos dice que vale la unicidad.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como podra notarse la existencia en el teorema anterior es facil e intuitivament
e clara de probar.
 En realidad la potencia del Teorema Fundamental de la Aritmtica radica
 en el hecho de que dicha factorizacion es unica.
\end_layout

\begin_layout Standard
A continuacion un poco de notacion.
 Dada una infinitupla 
\begin_inset Formula $(s_{1},s_{2},...)\in\omega^{\left[\mathbf{N}\right]}$
\end_inset

 usaremos 
\begin_inset Formula $\left\langle s_{1},s_{2},...\right\rangle $
\end_inset

 para denotar al numero 
\begin_inset Formula $\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{s_{i}}$
\end_inset

.
 Dado 
\begin_inset Formula $x\in\mathbf{N}$
\end_inset

, usaremos 
\begin_inset Formula $(x)$
\end_inset

 para denotar a la unica infinitupla 
\begin_inset Formula $(s_{1},s_{2},...)\in\omega^{\left[\mathbf{N}\right]}$
\end_inset

 tal que
\begin_inset Formula 
\[
x=\left\langle s_{1},s_{2},...\right\rangle =\underset{i=1}{\overset{\infty}{\Pi}}pr(i)^{s_{i}}
\]

\end_inset

Ademas para 
\begin_inset Formula $i\in\mathbf{N}$
\end_inset

, usaremos 
\begin_inset Formula $(x)_{i}$
\end_inset

 para denotar a 
\begin_inset Formula $s_{i}$
\end_inset

 de dicha unica infinitupla.
 Es decir que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $(x)=((x)_{1},(x)_{2},...)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $(x)_{i}$
\end_inset

 es el exponente de 
\begin_inset Formula $pr(i)$
\end_inset

 en la (unica posible) factorizacion de 
\begin_inset Formula $x$
\end_inset

 como producto de primos 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Claramente entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $\left\langle (x)_{1},(x)_{2},...\right\rangle =x$
\end_inset

, para cada 
\begin_inset Formula $x\in\mathbf{N}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $(s_{1},s_{2},...)\in\omega^{\left[\mathbf{N}\right]}$
\end_inset

, se tiene que
\begin_inset Formula 
\[
(\left\langle s_{1},s_{2},...\right\rangle )_{i}=s_{i}\text{, para }i\in\mathbf{N}
\]

\end_inset

Es decir que
\begin_inset Formula 
\[
(\left\langle s_{1},s_{2},...\right\rangle )=(s_{1},s_{2},...)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
(Justifique con palabras las propiedades (3) y (4)).
 Tenemos entonces el siguiente resultado fundamental
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Las funciones
\begin_inset Formula 
\[
\begin{array}{lll}
\mathbf{N} & \rightarrow & \omega^{\left[\mathbf{N}\right]}\\
x & \rightarrow & (x)=((x)_{1},(x)_{2},...)
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll}
\omega^{\left[\mathbf{N}\right]} & \rightarrow & \mathbf{N}\\
(s_{1},s_{2},...) & \rightarrow & \left\langle s_{1},s_{2},...\right\rangle 
\end{array}
\]

\end_inset

son biyecciones una inversa de la otra.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Llamemos 
\begin_inset Formula $f$
\end_inset

 a la funcion de la izquierda y 
\begin_inset Formula $g$
\end_inset

 a la de la derecha.
 Notese que el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "mutuamente inversas"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que basta con probar que 
\begin_inset Formula $f\circ g=Id_{\omega^{\left[\mathbf{N}\right]}}$
\end_inset

 y 
\begin_inset Formula $g\circ f=Id_{\mathbf{N}}$
\end_inset

.
 Pero (3) justamente nos dice que 
\begin_inset Formula $g\circ f=Id_{\mathbf{N}}$
\end_inset

 y (4) nos dice que 
\begin_inset Formula $f\circ g=Id_{\omega^{\left[\mathbf{N}\right]}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tal como se hace en la escuela primaria, el siguiente lema nos permite calcular
 
\begin_inset Formula $(x)_{i}$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Dados 
\begin_inset Formula $x,i\in\mathbf{N}$
\end_inset

, se tiene que
\begin_inset Formula 
\[
(x)_{i}=\max_{t}\left(pr(i)^{t}\text{ divide a }x\right)
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ejercicio (aplique el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "primos"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Definamos la funcion 
\begin_inset Formula $Lt:\mathbf{N}\rightarrow\omega$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\[
Lt(x)=\left\{ \begin{array}{lll}
\max_{i}\;(x)_{i}\neq0 &  & \text{si }x\neq1\\
0 &  & \text{si }x=1
\end{array}\right.
\]

\end_inset

Se tienen las siguientes propiedades basicas
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Para cada 
\begin_inset Formula $x\in\mathbf{N}$
\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Lt(x)=0$
\end_inset

 sii 
\begin_inset Formula $x=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $x=\prod\nolimits _{i=1}^{Lt(x)}pr(i)^{(x)_{i}}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "ParadigmaFilosofico"

\end_inset

Procedimientos efectivos
\end_layout

\begin_layout Standard
UUn concepto importante en ciencias de la computacion es el de 
\shape italic
procedimiento
\shape default
 o 
\shape italic
metodo
\shape default
 para realizar alguna tarea determinada.
 Nos interesan los procedimientos que estan definidos en forma precisa e
 inambigua, es decir aquellos en los cuales en cada paso a seguir, la tarea
 a realizar esta objetivamente descripta.
 Tambien deben ser repetibles, en el sentido de que si realizamos un procedimien
to dos veces con el mismo dato de entrada, entonces ambas ejecuciones deben
 ser identicas, es decir se realizaran las mismas tareas y en el mismo orden.
\end_layout

\begin_layout Standard
Nos interesan los procedimientos 
\begin_inset Formula $\mathbb{P}$
\end_inset

 que posean las siguientes caracteristicas:
\end_layout

\begin_layout Enumerate
Siempre supondremos que el interprete o ejecutante de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es una persona que trabajara con papel y lapiz (ambos recursos disponibles
 en forma ilimitada).
\end_layout

\begin_layout Enumerate
Cada paso o tarea que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 encomiende a realizar debe ser simple y facil de realizar en forma 
\shape italic
efectiva
\shape default
 por cualquier persona.
\end_layout

\begin_layout Enumerate
El procedimiento 
\begin_inset Formula $\mathbb{P}$
\end_inset

 comienza a funcionar siempre a partir de cierto dato de entrada y una ves
 que haya comensado, siempre sucedera una de las dos siguientes posibilidades
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathbb{P}$
\end_inset

 se detiene y da cierto dato de salida
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbb{P}$
\end_inset

 nunca se detiene, es decir a medida que se van realizando las instrucciones
 o tareas, 
\begin_inset Formula $\mathbb{P}$
\end_inset

 siempre direcciona a realizar nuevas tareas y lo hace sucesiva e indefinidament
e.
 
\end_layout

\begin_layout Standard
En el caso a.
 diremos que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 se detiene partiendo del dato de entrada en cuestion y en el caso b.
 diremos que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 no se detiene partiendo de dicho dato
\end_layout

\end_deeper
\begin_layout Enumerate
Hay 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y un alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

 tales que el conjunto de datos de entrada de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Cabe aclarar que para ciertas 
\begin_inset Formula $(n+m)$
\end_inset

-uplas de 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 el procedimiento 
\begin_inset Formula $\mathbb{P}$
\end_inset

 se detendra y para ciertas otras no lo hara.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Llamaremos 
\shape italic
procedimientos efectivos
\shape default
 a aquellos procedimientos que posean las caracteristicas arriba mencionadas.
\end_layout

\begin_layout Standard
El 
\shape italic
conjunto de datos de salida de 
\shape default

\begin_inset Formula $\mathbb{P}$
\end_inset

 es el conjunto de todos los datos que el procedimiento 
\begin_inset Formula $\mathbb{P}$
\end_inset

 dara como salida en alguna de las posibles ejecuciones al variar todos
 los datos de entrada posibles.
 Si bien siempre el conjunto de datos de entrada sera de la forma 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

, puede ser muy dificil o imposible, en general, conocer con precision el
 conjunto de datos de salida de un procedimiento (esto lo justificaremos
 mas adelante).
\end_layout

\begin_layout Standard
Ya que el interprete de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es una persona dotada de lapiz y papel, supondremos que los elementos de
 
\begin_inset Formula $\omega$
\end_inset

 que intervienen en los datos de entrada y de salida estaran representados
 por palabras de 
\begin_inset Formula $Num$
\end_inset

 usando la notacion decimal.
\end_layout

\begin_layout Standard
Quisas el procedimiento efectivo mas famoso de la matematica es aquel que
 se ensea en los colegios para sumar dos numeros naturales expresados en
 notacion decimal.
 Notar que el conjunto de datos de entrada de dicho procedimiento es 
\begin_inset Formula $\omega^{2}$
\end_inset

 y el conjunto de datos de salida es el conjunto formado por todas las sumas
 posibles de pares de elementos de 
\begin_inset Formula $\omega$
\end_inset

, es decir 
\begin_inset Formula $\omega$
\end_inset

.
 Por supuesto este procedimiento solo usa lapiz, papel y pasos extremadamente
 simples a seguir en cada momento de la computacion, es decir, en algun
 sentido, no es necesario 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

entender que es lo que se esta haciendo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 para llegar al final y obtener la palabra que representa en notacion decimal
 a la suma de los numeros iniciales.
 Dejamos al lector repasar este procedimiento asi como el que calcula dado
 un numero 
\begin_inset Formula $x$
\end_inset

 no nulo de 
\begin_inset Formula $\omega$
\end_inset

, al numero 
\begin_inset Formula $x-1$
\end_inset

, los cuales nos haran falta mas adelante en los ejemplos.
\end_layout

\begin_layout Section
Funciones 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables
\end_layout

\begin_layout Standard
Una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 sera llamada 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-efectivamente computable
\shape default
 si hay un procedimiento efectivo 
\begin_inset Formula $\mathbb{P}$
\end_inset

 tal que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

El conjunto de datos de entrada de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

El conjunto de datos de salida esta contenido en 
\begin_inset Formula $\omega$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in D_{f}$
\end_inset

, entonces 
\begin_inset Formula $\mathbb{P}$
\end_inset

 se detiene partiendo de 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

, dando como dato de salida 
\begin_inset Formula $f(\vec{x},\vec{\alpha})$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in(\omega^{n}\times\Sigma^{\ast m})-D_{f}$
\end_inset

, entonces 
\begin_inset Formula $\mathbb{P}$
\end_inset

 no se detiene partiendo desde 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

 
\end_layout

\begin_layout Standard
Analogamente una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\Sigma^{\ast}$
\end_inset

 sera llamada 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-efectivamente computable
\shape default
 si hay un procedimiento efectivo 
\begin_inset Formula $\mathbb{P}$
\end_inset

 tal que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

El conjunto de datos de entrada de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

El conjunto de datos de salida esta contenido en 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in D_{f}$
\end_inset

, entonces 
\begin_inset Formula $\mathbb{P}$
\end_inset

 se detiene partiendo de 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

, dando como dato de salida 
\begin_inset Formula $f(\vec{x},\vec{\alpha})$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in(\omega^{n}\times\Sigma^{\ast m})-D_{f}$
\end_inset

, entonces 
\begin_inset Formula $\mathbb{P}$
\end_inset

 no se detiene partiendo desde 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

 
\end_layout

\begin_layout Standard
En ambos casos diremos que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 
\shape italic
computa
\shape default
 a la funcion 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
Notese que esta definicion para el caso 
\begin_inset Formula $f=\emptyset$
\end_inset

 tiene a priori cierta ambiguedad ya que cualesquiera sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

 tenemos que 
\begin_inset Formula $\emptyset:\emptyset\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 ya que 
\begin_inset Formula $D_{\emptyset}=\emptyset$
\end_inset

 y 
\begin_inset Formula $I_{\emptyset}=\emptyset$
\end_inset

.
 De todas maneras, cualesquiera sean los 
\begin_inset Formula $n,m$
\end_inset

 y 
\begin_inset Formula $O$
\end_inset

 elejidos, siempre hay un procedimiento efectivo que computa a 
\begin_inset Formula $f=\emptyset$
\end_inset

, i.e.
 un procedimiento que nunca se detiene, cualesquiera sea el dato de entrada
 de 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Es decir que la funcion 
\begin_inset Formula $\emptyset$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable cualesquiera sea el alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Cabe destacar que para el caso de una funcion 
\begin_inset Formula $f\neq\emptyset$
\end_inset

, nuestra definicion es inambigua ya que hay unicos 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

 tales que 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

.
\end_layout

\begin_layout Standard
Veamos algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $($
\end_inset

E
\begin_inset Formula $1)$
\end_inset


\end_layout

\end_inset

La funcion 
\begin_inset Formula $\lambda xy\left[x+y\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, cualquiera sea el alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

 ya que el procedimiento enseado en la escuela primaria para sumar numeros
 en notacion decimal es efectivo y computa esta funcion.
 Tambien las funciones 
\begin_inset Formula $\lambda xy\left[x.y\right]$
\end_inset

 y 
\begin_inset Formula $\lambda xy\left[x^{y}\right]$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables via los procedimientos clasicos enseados en
 la escuela primaria.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $($
\end_inset

E
\begin_inset Formula $2)$
\end_inset


\end_layout

\end_inset

La funcion 
\begin_inset Formula $C_{3}^{1,2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable ya que el siguiente procedimiento 
\begin_inset Formula $\mathbb{P}$
\end_inset

 con conjunto de datos de entrada 
\begin_inset Formula $\omega\times\Sigma^{\ast2}$
\end_inset

 la computa:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Independientemente de quien sea el dato de entrada 
\begin_inset Formula $(x_{1},\alpha_{1},\alpha_{2})$
\end_inset

, terminar y dar como salida el numero 
\begin_inset Formula $3$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $($
\end_inset

E
\begin_inset Formula $3)$
\end_inset


\end_layout

\end_inset

La funcion 
\begin_inset Formula $p_{3}^{2,3}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable ya que el siguiente procedimiento con conjunto
 de datos de entrada 
\begin_inset Formula $\omega^{2}\times\Sigma^{\ast3}$
\end_inset

 la computa:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Dado el dato de entrada 
\begin_inset Formula $(x_{1},x_{2},\alpha_{1},\alpha_{2},\alpha_{3})$
\end_inset

, terminar y dar como salida la palabra 
\begin_inset Formula $\alpha_{1}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $($
\end_inset

E
\begin_inset Formula $4)$
\end_inset


\end_layout

\end_inset


\begin_inset Formula $Pred$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Para realizar el procedimiento efectivo que compute a 
\begin_inset Formula $Pred$
\end_inset

 necesitaremos el procedimiento de la escuela primaria que dado un numero
 no nulo 
\begin_inset Formula $x$
\end_inset

, expresado en notacion decimal, calcula el numero 
\begin_inset Formula $x-1$
\end_inset

, en notacion decimal.
 Llamemos 
\begin_inset Formula $\mathbb{P}_{-1}$
\end_inset

 a dicho procedimiento.
 El siguiente procedimiento (con conjunto de datos de entrada igual a 
\begin_inset Formula $\omega$
\end_inset

) computa a 
\begin_inset Formula $Pred$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
Dado como dato de entrada un elemento 
\begin_inset Formula $x\in\omega$
\end_inset

, realizar lo siguiente:
\end_layout

\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $x=0$
\end_inset

, entonces ir a Etapa 3, en caso contrario ir a Etapa 2.
\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Correr 
\begin_inset Formula $\mathbb{P}_{-1}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x$
\end_inset

 obteniendo 
\begin_inset Formula $y$
\end_inset

 como dato de salida.
 Detenerse y dar 
\begin_inset Formula $y$
\end_inset

 como dato de salida.
\end_layout

\begin_layout Standard
Etapa 3
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $x=0$
\end_inset

, entonces ir a Etapa 1.
\end_layout

\begin_layout Standard
Como puede notarse el procedimiento anterior es efectivo ya que debemos
 entender que en la Etapa 2, los sucesivos pasos efectuados al correr 
\begin_inset Formula $\mathbb{P}_{-1}$
\end_inset

 son todos simples y efectivamente realizables ya que 
\begin_inset Formula $\mathbb{P}_{-1}$
\end_inset

 es efectivo.
 Por supuesto si uno quisiera ser mas prolijo, deberia reemplazar la Etapa
 2 por las distintas instrucciones de 
\begin_inset Formula $\mathbb{P}_{-1}$
\end_inset

, referidas a 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $($
\end_inset

E
\begin_inset Formula $5)$
\end_inset


\end_layout

\end_inset

El predicado 
\begin_inset Formula $\lambda xy[x<y]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable cualquiera sea el alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Describiremos con palabras un procedimiento que computa a 
\begin_inset Formula $\lambda xy[x<y]$
\end_inset

.
 Su conjunto de datos de entrada es 
\begin_inset Formula $\omega^{2}$
\end_inset

.
 Dado un par 
\begin_inset Formula $(x,y)\in\omega^{2}$
\end_inset

, el procedimiento primero compara las longitudes de las palabras que en
 notacion decimal representan a 
\begin_inset Formula $x$
\end_inset

 y 
\begin_inset Formula $y$
\end_inset

.
 Por supuesto esto lo hace borrando de a un simbolo y viendo si alguna se
 termina primero.
 Si resultan de distinta longitud, es facil darse cuenta como sigue.
 En caso de que las palabras resulten de igual longitud, entonces se hace
 el procedimiento clasico de ir comparando digitos de izquierda a derecha.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E
\begin_inset Formula $6$
\end_inset

)
\end_layout

\end_inset

Veamos que la funcion 
\begin_inset Formula $\lambda\alpha[\left\vert \alpha\right\vert ]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Como en los lenguajes de programacion, usaremos variables y asignaciones
 para disear el procedimiento.
 Ademas llamemos 
\begin_inset Formula $\mathbb{P}_{+1}$
\end_inset

 a el procedimiento de la escuela primaria que dado un numero no nulo 
\begin_inset Formula $x$
\end_inset

, expresado en notacion decimal, calcula el numero 
\begin_inset Formula $x+1$
\end_inset

, en notacion decimal.
 Sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 el siguiente procedimiento.
\end_layout

\begin_deeper
\begin_layout Standard
Dado como dato de entrada un elemento 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, realizar lo siguiente:
\end_layout

\begin_layout Standard
Etapa 1: Hacer las siguientes asignaciones
\begin_inset Formula 
\begin{align*}
A & \leftarrow\alpha\\
B & \leftarrow0
\end{align*}

\end_inset

e ir a Etapa 2.
\end_layout

\begin_layout Standard
Etapa 2: Si 
\begin_inset Formula $A$
\end_inset

 no es 
\begin_inset Formula $\varepsilon$
\end_inset

, ir a Etapa 3.
 En caso contrario terminar y dar como salida 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
Etapa 3: Correr 
\begin_inset Formula $\mathbb{P}_{+1}$
\end_inset

 con dato de entrada igual al contenido de 
\begin_inset Formula $B$
\end_inset

, obteniendo 
\begin_inset Formula $y$
\end_inset

 como salida.
 Hacer la asignacion
\begin_inset Formula 
\begin{align*}
A & \leftarrow\text{resultado de remover el 1er simbolo de }A\\
B & \leftarrow y
\end{align*}

\end_inset

e ir a Etapa 2.
\end_layout

\begin_layout Standard
Dejamos como ejercicio convenserse que el uso de asignaciones puede realizarse
 usando solo lapiz y papel.
 Imagine como lo haria en este ejemplo y corrobore que dicho procedimiento
 es efectivo y ademas computa a 
\begin_inset Formula $\lambda\alpha[\left\vert \alpha\right\vert ]$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E
\begin_inset Formula $7$
\end_inset

)
\end_layout

\end_inset

Si 
\begin_inset Formula $\leq$
\end_inset

 es el orden total sobre 
\begin_inset Formula $\Sigma=\{\blacktriangle,\%\}$
\end_inset

 dado por 
\begin_inset Formula $\blacktriangle<\%$
\end_inset

, entonces veremos que la funcion 
\begin_inset Formula $s^{\leq}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursion para la sucesor de palabras"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que cualquiera sea 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, se cumple
\begin_inset Formula 
\begin{align*}
s^{\leq}(\varepsilon) & =\blacktriangle\\
s^{\leq}(\alpha\blacktriangle) & =\alpha\%\\
s^{\leq}(\alpha\%) & =s^{\leq}(\alpha)\blacktriangle
\end{align*}

\end_inset

Tal como lo explica dicho lema el valor de 
\begin_inset Formula $s^{\leq}$
\end_inset

 queda determinado por las tres ecuaciones anteriores.
 Usaremos esta idea para dar un procedimiento efectivo (con conjunto de
 datos de entrada igual a 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

) que compute a 
\begin_inset Formula $s^{\leq}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Etapa 1: Dado el dato de entrada 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, hacer las siguientes asignaciones
\begin_inset Formula 
\begin{align*}
A & \leftarrow\alpha\\
B & \leftarrow\varepsilon\\
F & \leftarrow\blacktriangle
\end{align*}

\end_inset

e ir a Etapa 2.
\end_layout

\begin_layout Standard
Etapa 2: Si 
\begin_inset Formula $A$
\end_inset

 comiensa con 
\begin_inset Formula $\blacktriangle$
\end_inset

, entonces hacer las siguientes asignaciones
\begin_inset Formula 
\begin{align*}
A & \leftarrow\text{resultado de remover el 1er simbolo de }A\\
F & \leftarrow B\%\\
B & \leftarrow B\blacktriangle
\end{align*}

\end_inset

e ir a la Etapa 2.
 En caso contrario ir a la Etapa 3.
\end_layout

\begin_layout Standard
Etapa 3: Si 
\begin_inset Formula $A$
\end_inset

 comiensa con 
\begin_inset Formula $\%$
\end_inset

, entonces hacer las siguientes asignaciones
\begin_inset Formula 
\begin{align*}
A & \leftarrow\text{resultado de remover el 1er simbolo de }A\\
F & \leftarrow F\blacktriangle\\
B & \leftarrow B\%
\end{align*}

\end_inset

e ir a la Etapa 2.
 En caso contrario ir a la Etapa 4.
\end_layout

\begin_layout Standard
Etapa 4: Dar como salida 
\begin_inset Formula $F$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $($
\end_inset

E
\begin_inset Formula $8)$
\end_inset


\end_layout

\end_inset

Usando que 
\begin_inset Formula $s^{\leq}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable podemos ver que 
\begin_inset Formula $\ast^{\leq}:\omega\rightarrow\Sigma^{\ast}$
\end_inset

 tambien lo es ya que 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 es definida con las ecuaciones
\begin_inset Formula 
\begin{align*}
\ast^{\leq}(0) & =\varepsilon\\
\ast^{\leq}(x+1) & =s^{\leq}(\ast^{\leq}(x))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Dejamos como ejercico para el lector disear procedimientos efectivos que
 computen las funciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\lambda xy[x$
\end_inset

 divide a 
\begin_inset Formula $y]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\lambda x[pr(x)]$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\lambda ix[(x)_{i}]$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
(Utilice en el diseo de los respectivos procedimientos a los procedimientos
 que computan las funciones 
\begin_inset Formula $\lambda xy\left[x+y\right]$
\end_inset

, 
\begin_inset Formula $\lambda xy\left[x.y\right]$
\end_inset

 y 
\begin_inset Formula $\lambda xy\left[x^{y}\right]$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Nota Importante:
\series default
 en lo que sigue muchas veces daremos procedimientos que son efectivos en
 terminos de otros que ya se han dado, es decir daremos un procedimiento
 que en principio no es claro que sea efectivo pero el cual se volveria
 efectivo si reemplazaramos ciertas instrucciones por la manera efectiva
 de simularlas.
 Para hacer mas dinamico el discurso no distinguiremos entre este tipo de
 procedimientos (efectivisables) y los efectivos propiamente dichos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Constructores que preservan computabilidad efectiva
\end_layout

\begin_layout Standard
Hay muchos procesos constructivos que nos sirven para definir o construir
 una funcion en terminos de otras funciones dadas.
 Un ejemplo de esto es la composicion de funciones, la cual dadas dos funciones
 
\begin_inset Formula $f,g$
\end_inset

 nos permite construir su composicion, a saber 
\begin_inset Formula $f\circ g$
\end_inset

.
 Otro ejemplo es el contructor de predicados que dados dos predicados 
\begin_inset Formula $\Sigma$
\end_inset

-mixtos 
\begin_inset Formula $P:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\{0,1\}$
\end_inset

 y 
\begin_inset Formula $Q:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\{0,1\}$
\end_inset

, con el mismo dominio, nos define el predicado
\begin_inset Formula 
\[
\begin{array}{rll}
(P\vee Q):S & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
1 &  & \text{si }P(\vec{x},\vec{\alpha})=1\text{ o }Q(\vec{x},\vec{\alpha})=1\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset

Otro constructor muy importante que utilizaremos mucho es aquel que a partir
 de funciones 
\begin_inset Formula $f_{i}:D_{f_{i}}\rightarrow O$
\end_inset

, 
\begin_inset Formula $i=1,...,k$
\end_inset

, tales que 
\begin_inset Formula $D_{f_{i}}\cap D_{f_{j}}=\emptyset$
\end_inset

 para 
\begin_inset Formula $i\neq j$
\end_inset

, nos da la nueva funcion 
\begin_inset Formula $f_{1}\cup...\cup f_{k}$
\end_inset

, la cual cumple
\begin_inset Formula 
\[
\begin{array}{rll}
D_{f_{1}}\cup...\cup D_{f_{k}} & \rightarrow & O\\
e & \rightarrow & \left\{ \begin{array}{clc}
f_{1}(e) &  & \text{si }e\in D_{f_{1}}\\
\vdots &  & \vdots\\
f_{k}(e) &  & \text{si }e\in D_{f_{k}}
\end{array}\right.
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "boolean op de predicados e.c."

\end_inset

Si 
\begin_inset Formula $P:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 y 
\begin_inset Formula $Q:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 son predicados 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables, entonces 
\begin_inset Formula $(P\vee Q)$
\end_inset

, 
\begin_inset Formula $(P\wedge Q)$
\end_inset

 y 
\begin_inset Formula $\lnot P$
\end_inset

 lo son tambien.
 
\end_layout

\begin_layout Subsection
Composicion
\end_layout

\begin_layout Standard
Dadas funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas 
\begin_inset Formula $f,f_{1},...,f_{r}$
\end_inset

, con 
\begin_inset Formula $r\geq1$
\end_inset

, diremos que la funcion 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]$
\end_inset

 es 
\shape italic
obtenida por composicion a partir de las funciones 
\shape default

\begin_inset Formula $f,f_{1},...,f_{r}$
\end_inset

.
 Para probar que la composicion preserva la computabilidad efectiva necesitaremo
s el siguiente lema.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos que 
\begin_inset Formula $f,f_{1},...,f_{r}$
\end_inset

 son funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas, con 
\begin_inset Formula $r\geq1$
\end_inset

.
 Supongamos ademas que 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

.
 Entonces hay 
\begin_inset Formula $n,m,k,l\in\omega$
\end_inset

 y 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

 tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r=n+m$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f$
\end_inset

 es de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\#)$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\ast)$
\end_inset

, para cada 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

 
\end_layout

\begin_layout Standard
Mas aun, en tal caso la funcion 
\begin_inset Formula $f\circ[f_{1},...,f_{n+m}]$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,s)$
\end_inset

 y:
\begin_inset Formula 
\begin{align*}
D_{f\circ[f_{1},...,f_{n+m}]} & =\left\{ (\vec{x},\vec{\alpha})\in\bigcap_{i=1}^{n+m}D_{f_{i}}:(f_{1}(\vec{x},\vec{\alpha}),...,f_{n+m}(\vec{x},\vec{\alpha}))\in D_{f}\right\} \\
f\circ[f_{1},...,f_{n+m}](\vec{x},\vec{\alpha}) & =f(f_{1}(\vec{x},\vec{\alpha}),...,f_{n+m}(\vec{x},\vec{\alpha})).
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que 
\begin_inset Formula $f\neq\emptyset$
\end_inset

 y 
\begin_inset Formula $[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

 (por que?).
 Ya que 
\begin_inset Formula $f\neq\emptyset$
\end_inset

 tenemos que hay unicos 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

 tales que 
\begin_inset Formula $f$
\end_inset

 es de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset

.
 Ya que 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

 y 
\begin_inset Formula $I_{[f_{1},...,f_{r}]}\subseteq I_{f_{1}}\times...\times I_{f_{r}}$
\end_inset

, tenemos que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r=n+m$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $I_{f_{i}}\subseteq\omega$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $I_{f_{i}}\subseteq\Sigma^{\ast}$
\end_inset

, para cada 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

 
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

 tenemos que 
\begin_inset Formula $D_{[f_{1},...,f_{r}]}=\bigcap_{i=1}^{r}D_{f_{i}}\neq\emptyset$
\end_inset

, por lo cual los conjuntos 
\begin_inset Formula $D_{f_{1}},...,D_{f_{n+m}}$
\end_inset

 deberan ser todos de un mismo tipo, digamos de tipo 
\begin_inset Formula $(k,l)$
\end_inset

.
 Es decir que 
\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\#)$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n$
\end_inset

 y 
\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\ast)$
\end_inset

, para cada 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

.
\end_layout

\begin_layout Standard
Las ultimas observaciones del lema son directas de las definiciones de 
\begin_inset Formula $[f_{1},...,f_{n+m}]$
\end_inset

 y de composicion de funciones 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora si podemos probar facilmente que se preserva la computabilidad efectiva
 cuando componemos
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $f,f_{1},...,f_{r}$
\end_inset

, con 
\begin_inset Formula $r\geq1$
\end_inset

, son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables, entonces 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]$
\end_inset

 lo es.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Si 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]=\emptyset$
\end_inset

, entonces claramente es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Supongamos entonces que 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

.
 Por el lema anterior hay 
\begin_inset Formula $n,m,k,l\in\omega$
\end_inset

 y 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

 tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r=n+m$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f$
\end_inset

 es de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\#)$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\ast)$
\end_inset

, para cada 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

 
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $\mathbb{P},\mathbb{P}_{1},...,\mathbb{P}_{n+m}$
\end_inset

 procedimientos efectivos los cuales computen las funciones 
\begin_inset Formula $f,f_{1},...,f_{n+m}$
\end_inset

, respectivamente.
 Usando estos procedimientos es facil definir un procedimiento efectivo
 el cual compute a 
\begin_inset Formula $f\circ[f_{1},...,f_{n+m}]$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Lema de division por casos para funciones 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables
\end_layout

\begin_layout Standard
Recordemos que si 
\begin_inset Formula $f_{i}:D_{f_{i}}\rightarrow O$
\end_inset

, 
\begin_inset Formula $i=1,...,k$
\end_inset

, son funciones tales que 
\begin_inset Formula $D_{f_{i}}\cap D_{f_{j}}=\emptyset$
\end_inset

 para 
\begin_inset Formula $i\neq j$
\end_inset

, entonces 
\begin_inset Formula $f_{1}\cup...\cup f_{k}$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
D_{f_{1}}\cup...\cup D_{f_{k}} & \rightarrow & O\\
e & \rightarrow & \left\{ \begin{array}{clc}
f_{1}(e) &  & \text{si }e\in D_{f_{1}}\\
\vdots &  & \vdots\\
f_{k}(e) &  & \text{si }e\in D_{f_{k}}
\end{array}\right.
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "dpc para efectivamente computables"

\end_inset

Sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

.
 Supongamos 
\begin_inset Formula $f_{i}:D_{f_{i}}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

, 
\begin_inset Formula $i=1,...,k$
\end_inset

, son funciones 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables tales que 
\begin_inset Formula $D_{f_{i}}\cap D_{f_{j}}=\emptyset$
\end_inset

 para 
\begin_inset Formula $i\neq j$
\end_inset

.
 Entonces 
\begin_inset Formula $f_{1}\cup...\cup f_{k}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Haremos el caso 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $k=2$
\end_inset

.
 Sean 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 y 
\begin_inset Formula $\mathbb{P}_{2}$
\end_inset

 procedimientos efectivos que computen a 
\begin_inset Formula $f_{1}$
\end_inset

 y 
\begin_inset Formula $f_{2}$
\end_inset

, respectivamente.
 Sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 el procedimiento efectivo siguiente:
\end_layout

\begin_layout Standard
- Conjunto de datos de entrada de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 igual a 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset


\end_layout

\begin_layout Standard
- Conjunto de datos de salida de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 contenido en 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset


\end_layout

\begin_layout Standard
- Funcionamiento:
\end_layout

\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Hacer 
\begin_inset Formula $T=1$
\end_inset


\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Correr el procedimiento 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 una cantidad 
\begin_inset Formula $T$
\end_inset

 de pasos.
 En caso de que termine guardar la salida en la variable 
\begin_inset Formula $X$
\end_inset

 e ir a Etapa 5.
 Si no termina ir a Etapa 3.
\end_layout

\begin_layout Standard
Etapa 3
\end_layout

\begin_layout Standard
\noindent
Correr el procedimiento 
\begin_inset Formula $\mathbb{P}_{2}$
\end_inset

 una cantidad 
\begin_inset Formula $T$
\end_inset

 de pasos.
 En caso de que termine guardar la salida en la variable 
\begin_inset Formula $X$
\end_inset

 e ir a Etapa 6.
 Si no termina ir a Etapa 4.
\end_layout

\begin_layout Standard
Etapa 4
\end_layout

\begin_layout Standard
\noindent
Hacer 
\begin_inset Formula $T=T+1$
\end_inset

 e ir a Etapa 2
\end_layout

\begin_layout Standard
Etapa 5
\end_layout

\begin_layout Standard
\noindent
Dar como salida el contenido de 
\begin_inset Formula $X$
\end_inset

 y terminar.
\end_layout

\begin_layout Standard
Dejamos al lector corroborar que el procedimiento 
\begin_inset Formula $\mathbb{P}$
\end_inset

 computa a la funcion 
\begin_inset Formula $f_{1}\cup f_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "conjuntos sigma-efectivamente computables"

\end_inset

Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables
\end_layout

\begin_layout Standard
\noindent
Un conjunto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 sera llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-efectivamente computable
\shape default
 cuando la funcion 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Notese que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable sii hay un procedimiento efectivo 
\begin_inset Formula $\mathbb{P}$
\end_inset

, el cual computa 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

, es decir:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

El conjunto de datos de entrada de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

, siempre termina y da como dato de salida un elemento de 
\begin_inset Formula $\{0,1\}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Dado 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}$
\end_inset

, 
\begin_inset Formula $\mathbb{P}$
\end_inset

 da como salida al numero 
\begin_inset Formula $1$
\end_inset

 si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S$
\end_inset

 y al numero 
\begin_inset Formula $0$
\end_inset

 si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\notin S$
\end_inset

.
 
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es un procedimiento efectivo el cual computa a 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

, diremos que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 
\shape italic
decide la pertenecia a 
\shape default

\begin_inset Formula $S$
\end_inset

, con respecto al conjunto 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
Notese que esta definicion para el caso 
\begin_inset Formula $S=\emptyset$
\end_inset

 tiene a priori cierta ambiguedad ya que cualesquiera sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 tenemos que 
\begin_inset Formula $\emptyset\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 De todas maneras, cualesquiera sean los 
\begin_inset Formula $n,m$
\end_inset

 elejidos, siempre hay un procedimiento efectivo que computa a 
\begin_inset Formula $\chi_{\emptyset}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

, i.e.
 un procedimiento que siempre da como salida 
\begin_inset Formula $0$
\end_inset

, cualesquiera sea el dato de entrada de 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Es decir que el conjunto 
\begin_inset Formula $\emptyset$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable cualesquiera sea el alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Cabe destacar que para el caso de un conjunto 
\begin_inset Formula $S\neq\emptyset$
\end_inset

, nuestra definicion es inambigua ya que hay unicos 
\begin_inset Formula $n,m\in\omega$
\end_inset

 tales que 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos al lector la facil prueba del siguiente resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sean 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables.
 Entonces 
\begin_inset Formula $S_{1}\cup S_{2},S_{1}\cap S_{2}$
\end_inset

 y 
\begin_inset Formula $(\omega^{n}\times\Sigma^{\ast m})-S_{1}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente lema caracteriza cuando un conjunto rectangular es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

, 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 son conjuntos no vacios.
 Entonces 
\begin_inset Formula $S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable sii 
\begin_inset Formula $S_{1},...,S_{n},L_{1},...,L_{m}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que si 
\begin_inset Formula $n=m=0$
\end_inset

, entonces 
\begin_inset Formula $S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}=\{\Diamond\}$
\end_inset

 el cual es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable por lo cual el lema se cumple.
 Vemos entonces el caso 
\begin_inset Formula $n+m\geq1$
\end_inset

.
 Para hacer mas lejible la prueba haremos el caso 
\begin_inset Formula $n=m=1$
\end_inset

.
 La prueba general es completamente analoga.
\end_layout

\begin_layout Standard
(
\begin_inset Formula $\Rightarrow$
\end_inset

) Ya que 
\begin_inset Formula $S_{1}$
\end_inset

 y 
\begin_inset Formula $L_{1}$
\end_inset

 son conjuntos no vacios, hay 
\begin_inset Formula $x_{0}\in S_{1}$
\end_inset

 y 
\begin_inset Formula $\alpha_{0}\in L_{1}$
\end_inset

.
 Ya que 
\begin_inset Formula $S_{1}\times L_{1}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, tenemos que 
\begin_inset Formula $\chi_{S_{1}\times L_{1}}^{\omega\times\Sigma^{\ast}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Notese que:
\begin_inset Formula 
\[
x\in S_{1}\text{ sii }(x,\alpha_{0})\in S_{1}\times L_{1}\text{ sii }\chi_{S_{1}\times L_{1}}^{\omega\times\Sigma^{\ast}}(x,\alpha_{0})=1\text{ }
\]

\end_inset

Por lo tanto, es facil usando un procedimiento efectivo que compute a 
\begin_inset Formula $\chi_{S_{1}\times L_{1}}^{\omega\times\Sigma^{\ast}}$
\end_inset

 disear un procedimiento efectivo que compute a 
\begin_inset Formula $\chi_{S_{1}}^{\omega}$
\end_inset

.
 En forma similar se prueba que 
\begin_inset Formula $L_{1}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
\end_layout

\begin_layout Standard
(
\begin_inset Formula $\Leftarrow$
\end_inset

) Es facil, usando procedimientos efectivos que computen a 
\begin_inset Formula $\chi_{S_{1}}^{\omega}$
\end_inset

 y 
\begin_inset Formula $\chi_{L_{1}}^{\Sigma^{\ast}}$
\end_inset

, armar un procedimiento efectivo que compute a 
\begin_inset Formula $\chi_{S_{1}\times L_{1}}^{\omega\times\Sigma^{\ast}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "conjuntos sigma-efectivamente enumerables"

\end_inset

Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables
\end_layout

\begin_layout Standard
\noindent
Un conjunto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 sera llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-efectivamente enumerable
\shape default
 cuando sea vacio o haya una funcion 
\begin_inset Formula $F:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que 
\begin_inset Formula $I_{F}=S$
\end_inset

 y 
\begin_inset Formula $F_{(i)}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, para cada 
\begin_inset Formula $i\in\{1,...,n+m\}$
\end_inset

.
 Notese que para el caso 
\begin_inset Formula $n=m=0$
\end_inset

, la condicion de que 
\begin_inset Formula $F_{(i)}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, para cada 
\begin_inset Formula $i\in\{1,...,n+m\}$
\end_inset

 se cumple vacuamente y por lo tanto la definicion anterior nos dice que
 un conjunto 
\begin_inset Formula $S\subseteq\omega^{0}\times\Sigma^{\ast0}=\{\Diamond\}$
\end_inset

 sera 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable sii es vacio o hay una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable 
\begin_inset Formula $F:\omega\rightarrow\{\Diamond\}$
\end_inset

, tal que 
\begin_inset Formula $I_{F}=S$
\end_inset

.
 Por supuesto, esto nos dice que 
\begin_inset Formula $\emptyset$
\end_inset

 y 
\begin_inset Formula $\{\Diamond\}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables.
\end_layout

\begin_layout Standard
El siguiente resultado nos permite entender mejor la idea subyacente a esta
 definicion.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Un conjunto no vacio 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable sii hay un procedimiento efectivo 
\begin_inset Formula $\mathbb{P}$
\end_inset

 tal que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

El conjunto de datos de entrada de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es 
\begin_inset Formula $\omega$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\mathbb{P}$
\end_inset

 se detiene para cada 
\begin_inset Formula $x\in\omega$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

El conjunto de datos de salida de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es igual a 
\begin_inset Formula $S$
\end_inset

.
 (Es decir, siempre que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 se detiene, da como salida un elemento de 
\begin_inset Formula $S$
\end_inset

, y para cada elemento 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S$
\end_inset

, hay un 
\begin_inset Formula $x\in\omega$
\end_inset

 tal que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 da como salida a 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

 cuando lo corremos con 
\begin_inset Formula $x$
\end_inset

 como dato de entrada) 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 El caso 
\begin_inset Formula $n=m=0$
\end_inset

 es facil y es dejado al lector.
 Supongamos entonces que 
\begin_inset Formula $n+m\geq1$
\end_inset

.
\end_layout

\begin_layout Standard
(
\begin_inset Formula $\Rightarrow$
\end_inset

) Supongamos que 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Ya que 
\begin_inset Formula $S$
\end_inset

 es no vacio, por definicion hay una funcion 
\begin_inset Formula $F:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que 
\begin_inset Formula $I_{F}=S$
\end_inset

 y cada 
\begin_inset Formula $F_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Para cada 
\begin_inset Formula $i\in\{1,...,n+m\}$
\end_inset

 sea 
\begin_inset Formula $\mathbb{P}_{i}$
\end_inset

 un procedimiento efectivo que compute a 
\begin_inset Formula $F_{(i)}$
\end_inset

.
 Notar que cada 
\begin_inset Formula $\mathbb{P}_{i}$
\end_inset

 tiene a 
\begin_inset Formula $\omega$
\end_inset

 como conjunto de datos de entrada y siempre termina.
 Sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 el siguiente procedimiento efectivo, con conjunto de datos de entrada igual
 a 
\begin_inset Formula $\omega$
\end_inset

 y conjunto de datos de salida contenido en 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
Etapa 1: Correr 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x$
\end_inset

 y alojar el dato de salida en la variable 
\begin_inset Formula $X_{1}$
\end_inset


\end_layout

\begin_layout Standard
Etapa 2: Correr 
\begin_inset Formula $\mathbb{P}_{2}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x$
\end_inset

 y alojar el dato de salida en la variable 
\begin_inset Formula $X_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\ \ \ \ \vdots$
\end_inset


\end_layout

\begin_layout Standard
Etapa 
\begin_inset Formula $n$
\end_inset

: Correr 
\begin_inset Formula $\mathbb{P}_{n}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x$
\end_inset

 y alojar el dato de salida en la variable 
\begin_inset Formula $X_{n}$
\end_inset


\end_layout

\begin_layout Standard
Etapa 
\begin_inset Formula $n+1$
\end_inset

: Correr 
\begin_inset Formula $\mathbb{P}_{n+1}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x$
\end_inset

 y alojar el dato de salida en la variable 
\begin_inset Formula $A_{1}$
\end_inset


\end_layout

\begin_layout Standard
Etapa 
\begin_inset Formula $n+2$
\end_inset

: Correr 
\begin_inset Formula $\mathbb{P}_{n+2}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x$
\end_inset

 y alojar el dato de salida en la variable 
\begin_inset Formula $A_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\ \ \ \ \vdots$
\end_inset


\end_layout

\begin_layout Standard
Etapa 
\begin_inset Formula $n+m$
\end_inset

: Correr 
\begin_inset Formula $\mathbb{P}_{n+m}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x$
\end_inset

 y alojar el dato de salida en la variable 
\begin_inset Formula $A_{m}$
\end_inset


\end_layout

\begin_layout Standard
Etapa 
\begin_inset Formula $n+m+1$
\end_inset

: Detenerse y dar 
\begin_inset Formula $(X_{1},...,X_{n},A_{1},...,A_{m})$
\end_inset

 como dato de salida
\end_layout

\begin_layout Standard
\noindent
Dejamos al lector la verificacion de que el procedimiento 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es efectivo y cumple las propiedades (1), (2) y (3).
\end_layout

\begin_layout Standard
(
\begin_inset Formula $\Leftarrow$
\end_inset

) Supongamos 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es un procedimiento efectivo el cual cumple las propiedades (1), (2) y
 (3).
 Definamos 
\begin_inset Formula $F:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

, de la siguiente manera:
\begin_inset Formula 
\[
F(x)=\text{ dato de salida de }\mathbb{P}\text{ cuando lo corremos desde }x
\]

\end_inset

Notar que para cada 
\begin_inset Formula $i\in\{1,...,n+m\}$
\end_inset

 la funcion 
\begin_inset Formula $F_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable ya que el siguiente procedimiento efectivo la
 computa:
\end_layout

\begin_layout Standard
Etapa 1: Correr 
\begin_inset Formula $\mathbb{P}$
\end_inset

 desde 
\begin_inset Formula $x$
\end_inset

 y guardar la salida en la variable 
\begin_inset Formula $V$
\end_inset


\end_layout

\begin_layout Standard
Etapa 2: Dar como salida la coordenada 
\begin_inset Formula $i$
\end_inset

-esima de 
\begin_inset Formula $V$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Cuando un procedimiento 
\begin_inset Formula $\mathbb{P}$
\end_inset

 cumpla (1), (2) y (3) del lema anterior, diremos que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 
\shape italic
enumera
\shape default
 a 
\begin_inset Formula $S$
\end_inset

.
 O sea que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable sii es vacio o hay un procedimiento efectivo el
 cual enumera a 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard
Dicho de otra forma un conjunto no vacio 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable sii hay un procedimiento efectivo 
\begin_inset Formula $\mathbb{P}$
\end_inset

 el cual tiene conjunto de datos de entrada 
\begin_inset Formula $\omega$
\end_inset

 y ademas para los sucesivos datos de entrada 
\begin_inset Formula $0,1,2,3,...$
\end_inset

, el procedimiento 
\begin_inset Formula $\mathbb{P}$
\end_inset

 produce respectivamente los datos de salida 
\begin_inset Formula $e_{0},e_{1},e_{2},e_{3},...$
\end_inset

 de manera que 
\begin_inset Formula $S=\{e_{0},e_{1},e_{2},...\}$
\end_inset

.
 Cabe destacar aqui que puede suceder que 
\begin_inset Formula $e_{i}=e_{j}$
\end_inset

, para ciertos 
\begin_inset Formula $i,j$
\end_inset

, con 
\begin_inset Formula $i\neq j$
\end_inset

.
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset

El conjunto 
\begin_inset Formula $S=\{x\in\omega:x$
\end_inset

 es par
\begin_inset Formula $\}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable, cualesquiera sea 
\begin_inset Formula $\Sigma$
\end_inset

.
 El siguiente procedimiento enumera a 
\begin_inset Formula $S$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Calcular 
\begin_inset Formula $2x$
\end_inset

, darlo como dato de salida y terminar.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset

Un procedimiento que enumera 
\begin_inset Formula $\omega\times\omega$
\end_inset

 es el siguiente:
\end_layout

\begin_deeper
\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $x=0$
\end_inset

, dar como salida el par 
\begin_inset Formula $(0,0)$
\end_inset

 y terminar.
 Si 
\begin_inset Formula $x\neq0$
\end_inset

, calcular 
\begin_inset Formula $x_{1}=(x)_{1}$
\end_inset

 y 
\begin_inset Formula $x_{2}=(x)_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Dar como dato de salida el par 
\begin_inset Formula $(x_{1},x_{2})$
\end_inset

 y terminar
\end_layout

\begin_layout Standard
Como puede notarse el procedimiento es efectivo y ademas el conjunto de
 datos de salida es 
\begin_inset Formula $\omega\times\omega$
\end_inset

 ya que si tomamos un par cualquiera 
\begin_inset Formula $(a,b)\in\omega\times\omega$
\end_inset

, el procedimiento lo dara como dato de salida para la entrada 
\begin_inset Formula $x=2^{a}3^{b}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{3}$
\end_inset


\end_layout

\end_inset

Veamos que 
\begin_inset Formula $\omega^{2}\times\Sigma^{\ast3}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable cualquiera sea el alfabeto no vacio 
\begin_inset Formula $\Sigma$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total para el alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Utilisando el orden 
\begin_inset Formula $<$
\end_inset

 podemos disear el siguiente procedimiento para enumerar 
\begin_inset Formula $\omega^{2}\times\Sigma^{\ast3}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $x=0$
\end_inset

, dar como salida 
\begin_inset Formula $(0,0,\varepsilon,\varepsilon,\varepsilon)$
\end_inset

 y terminar.
 Si 
\begin_inset Formula $x\neq0$
\end_inset

, calcular
\end_layout

\begin_layout Standard
\begin_inset Formula $x_{1}=(x)_{1}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $x_{2}=(x)_{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\alpha_{1}=\ast^{\leq}((x)_{3})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\alpha_{2}=\ast^{\leq}((x)_{4})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\alpha_{3}=\ast^{\leq}((x)_{5})$
\end_inset


\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Dar como dato de salida la 5-upla 
\begin_inset Formula $(x_{1},x_{2},\alpha_{1},\alpha_{2},\alpha_{3})$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sean 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables.
 Entonces 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 y 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 El caso en el que alguno de los conjuntos es vacio es trivial.
 Supongamos que ambos conjuntos son no vacios y sean 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 y 
\begin_inset Formula $\mathbb{P}_{2}$
\end_inset

 procedimientos que enumeran a 
\begin_inset Formula $S_{1}$
\end_inset

 y 
\begin_inset Formula $S_{2}$
\end_inset

.
 El siguiente procedimiento enumera al conjunto 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $x$
\end_inset

 es par realizar 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 partiendo de 
\begin_inset Formula $x/2$
\end_inset

 y dar el elemento de 
\begin_inset Formula $S_{1}$
\end_inset

 obtenido como salida.
 Si 
\begin_inset Formula $x$
\end_inset

 es impar realizar 
\begin_inset Formula $\mathbb{P}_{2}$
\end_inset

 partiendo de 
\begin_inset Formula $(x-1)/2$
\end_inset

 y dar el elemento de 
\begin_inset Formula $S_{2}$
\end_inset

 obtenido como salida.
 
\end_layout

\begin_layout Standard
Veamos ahora que 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Si 
\begin_inset Formula $S_{1}\cap S_{2}=\emptyset$
\end_inset

 entonces no hay nada que probar.
 Supongamos entonces que 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 es no vacio.
 Sea 
\begin_inset Formula $e_{0}$
\end_inset

 un elemento fijo de 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 un procedimiento efectivo el cual enumere a 
\begin_inset Formula $\omega\times\omega$
\end_inset

 (ver el ejemplo de mas arriba).
 Un procedimiento que enumera a 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 es el siguiente
\end_layout

\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Realizar 
\begin_inset Formula $\mathbb{P}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x$
\end_inset

, para obtener un par 
\begin_inset Formula $(x_{1},x_{2})\in\omega\times\omega$
\end_inset

.
\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Realizar 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x_{1}$
\end_inset

 para obtener un elemento 
\begin_inset Formula $e_{1}\in S_{1}$
\end_inset


\end_layout

\begin_layout Standard
Etapa 3
\end_layout

\begin_layout Standard
\noindent
Realizar 
\begin_inset Formula $\mathbb{P}_{2}$
\end_inset

 con dato de entrada 
\begin_inset Formula $x_{2}$
\end_inset

 para obtener un elemento 
\begin_inset Formula $e_{2}\in S_{2}$
\end_inset


\end_layout

\begin_layout Standard
Etapa 4
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $e_{1}=e_{2}$
\end_inset

, entonces dar como dato de salida 
\begin_inset Formula $e_{1}.$
\end_inset

 En caso contrario dar como dato de salida 
\begin_inset Formula $e_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Dejamos al lector la prueba de que este procedimiento enumera a 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos al lector la prueba del siguiente resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

, 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 son conjuntos no vacios.
 Entonces 
\begin_inset Formula $S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable sii 
\begin_inset Formula $S_{1},...,S_{n},L_{1},...,L_{m}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable entonces 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $S\neq\emptyset$
\end_inset

.
 Sea 
\begin_inset Formula $(\vec{z},\gamma)\in S$
\end_inset

, fijo.
 Sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 un procedimiento efectivo que compute a 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

.
 Ya vimos en el ejemplo anterior que 
\begin_inset Formula $\omega^{2}\times\Sigma^{\ast3}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 En forma similar se puede ver que 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 lo es.
 Sea 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 un procedimiento efectivo que enumere a 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Entonces el siguiente procedimiento enumera a 
\begin_inset Formula $S$
\end_inset

:
\end_layout

\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Realizar 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 con 
\begin_inset Formula $x$
\end_inset

 de entrada para obtener 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Realizar 
\begin_inset Formula $\mathbb{P}$
\end_inset

 con 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

 de entrada para obtener el valor Booleano 
\begin_inset Formula $e$
\end_inset

 de salida.
\end_layout

\begin_layout Standard
Etapa 3
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $e=1$
\end_inset

 dar como dato de salida 
\begin_inset Formula $(\vec{x},\vec{\alpha}).$
\end_inset

 Si 
\begin_inset Formula $e=0$
\end_inset

 dar como dato de salida 
\begin_inset Formula $(\vec{z},\gamma)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como veremos mas adelante en la materia (Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "A es EE y no EC"
plural "false"
caps "false"
noprefix "false"

\end_inset

), hay conjuntos que son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables y no 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables.
 Sin envargo tenemos el siguiente interesante resultado:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 y 
\begin_inset Formula $(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a)
\begin_inset Formula $\Rightarrow$
\end_inset

(b).
 Por el lema anterior tenemos que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Notese ademas que, dado que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, 
\begin_inset Formula $(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

 tambien lo es (por que?).
 Es decir que aplicando nuevamente el lema anterior tenemos que 
\begin_inset Formula $(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
\end_layout

\begin_layout Standard
(b)
\begin_inset Formula $\Rightarrow$
\end_inset

(a).
 Si 
\begin_inset Formula $S=\emptyset$
\end_inset

 o 
\begin_inset Formula $S=\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es claro que se cumple (a).
 O sea que podemos suponer que ni 
\begin_inset Formula $S$
\end_inset

 ni 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 son igual al conjunto vacio.
 Sea 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 un procedimiento efectivo que enumere a 
\begin_inset Formula $S$
\end_inset

 y sea 
\begin_inset Formula $\mathbb{P}_{2}$
\end_inset

 un procedimiento efectivo que enumere a 
\begin_inset Formula $(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

.
 Es facil ver que el siguiente procedimiento computa el predicado 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

:
\end_layout

\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Darle a la variable 
\begin_inset Formula $T$
\end_inset

 el valor 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Realizar 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 con el valor de 
\begin_inset Formula $T$
\end_inset

 como entrada para obtener de salida la upla 
\begin_inset Formula $(\vec{y},\vec{\beta})$
\end_inset

.
\end_layout

\begin_layout Standard
Etapa 3
\end_layout

\begin_layout Standard
\noindent
Realizar 
\begin_inset Formula $\mathbb{P}_{2}$
\end_inset

 con el valor de 
\begin_inset Formula $T$
\end_inset

 como entrada para obtener de salida la upla 
\begin_inset Formula $(\vec{z},\vec{\gamma})$
\end_inset

.
\end_layout

\begin_layout Standard
Etapa 4
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $(\vec{y},\vec{\beta})=(\vec{x},\vec{\alpha})$
\end_inset

, entonces detenerse y dar como dato de salida el valor 
\begin_inset Formula $1$
\end_inset

.
 Si 
\begin_inset Formula $(\vec{z},\vec{\gamma})=(\vec{x},\vec{\alpha})$
\end_inset

, entonces detenerse y dar como dato de salida el valor 
\begin_inset Formula $0.$
\end_inset

 Si no suceden ninguna de las dos posibilidades antes mensionadas, aumentar
 en 
\begin_inset Formula $1$
\end_inset

 el valor de la variable 
\begin_inset Formula $T$
\end_inset

 y dirijirse a la Etapa 2.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Supongamos que 
\begin_inset Formula $k,l,n,m\in\omega$
\end_inset

 y que 
\begin_inset Formula $F:D_{F}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Supongamos ademas que 
\begin_inset Formula $n+m\geq1$
\end_inset

.
 Entonces denotaremos con 
\begin_inset Formula $F_{(i)}$
\end_inset

 a la funcion 
\begin_inset Formula $p_{i}^{n,m}\circ F$
\end_inset

.
 Notar que
\begin_inset Formula 
\begin{align*}
F_{(i)} & :D_{F}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\omega\text{, para cada }i=1,...,n\\
F_{(i)} & :D_{F}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\Sigma^{\ast}\text{, para cada }i=n+1,...,n+m
\end{align*}

\end_inset

Por lo cual cada una de las funciones 
\begin_inset Formula $F_{(i)}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas.
 Ademas notese que
\begin_inset Formula 
\[
F=[F_{(1)},...,F_{(n+m)}]
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "equivalencias de efectivamente enumerable"

\end_inset

Dado 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

, son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $S=I_{F}$
\end_inset

, para alguna 
\begin_inset Formula $F:D_{F}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que cada 
\begin_inset Formula $F_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $S=D_{f}$
\end_inset

, para alguna funcion 
\begin_inset Formula $f$
\end_inset

 la cual es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 El caso 
\begin_inset Formula $n=m=0$
\end_inset

 es facil y es dejado al lector.
 Supongamos entonces que 
\begin_inset Formula $n+m\geq1$
\end_inset

.
\end_layout

\begin_layout Standard
(1)
\begin_inset Formula $\Rightarrow$
\end_inset

(2) es trivial.
\end_layout

\begin_layout Standard
(2)
\begin_inset Formula $\Rightarrow$
\end_inset

(3).
 Para 
\begin_inset Formula $i=1,...,n+m$
\end_inset

, sea 
\begin_inset Formula $\mathbb{P}_{i}$
\end_inset

 un procedimiento el cual computa a 
\begin_inset Formula $F_{(i)}$
\end_inset

 y sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 un procedimiento el cual enumere a 
\begin_inset Formula $\omega\times\omega^{k}\times\Sigma^{\ast l}.$
\end_inset

 El siguiente procedimiento computa la funcion 
\begin_inset Formula $f:I_{F}\rightarrow\{1\}$
\end_inset

:
\end_layout

\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Darle a la variable 
\begin_inset Formula $T$
\end_inset

 el valor 0.
\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Hacer correr 
\begin_inset Formula $\mathbb{P}$
\end_inset

 con dato de entrada 
\begin_inset Formula $T$
\end_inset

 y obtener 
\begin_inset Formula $(t,z_{1},...,z_{k},\gamma_{1},...,\gamma_{l})$
\end_inset

 como dato de salida.
\end_layout

\begin_layout Standard
Etapa 3
\end_layout

\begin_layout Standard
\noindent
Para cada 
\begin_inset Formula $i=1,...,n+m$
\end_inset

, hacer correr 
\begin_inset Formula $\mathbb{P}_{i}$
\end_inset

 durante 
\begin_inset Formula $t$
\end_inset

 pasos, con dato de entrada 
\begin_inset Formula $(z_{1},...,z_{k},\gamma_{1},...,\gamma_{l}).$
\end_inset

 Si cada procedimiento 
\begin_inset Formula $\mathbb{P}_{i}$
\end_inset

 al cabo de los 
\begin_inset Formula $t$
\end_inset

 pasos termino y dio como resultado el valor 
\begin_inset Formula $o_{i}$
\end_inset

, entonces comparar 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

 con 
\begin_inset Formula $(o_{1},...,o_{n+m})$
\end_inset

 y en caso de que sean iguales detenerse y dar como dato de salida el valor
 
\begin_inset Formula $1$
\end_inset

.
 En el caso en que no son iguales, aumentar en 
\begin_inset Formula $1$
\end_inset

 el valor de la variable 
\begin_inset Formula $T$
\end_inset

 y dirijirse a la Etapa 2.
 Si algun procedimiento 
\begin_inset Formula $\mathbb{P}_{i}$
\end_inset

 al cabo de los 
\begin_inset Formula $t$
\end_inset

 pasos no termino, entonces aumentar en 
\begin_inset Formula $1$
\end_inset

 el valor de la variable 
\begin_inset Formula $T$
\end_inset

 y dirijirse a la Etapa 2.
\end_layout

\begin_layout Standard
(3)
\begin_inset Formula $\Rightarrow$
\end_inset

(1).
 Supongamos 
\begin_inset Formula $S\neq\emptyset$
\end_inset

.
 Sea 
\begin_inset Formula $(\vec{z},\vec{\gamma})$
\end_inset

 un elemento fijo de 
\begin_inset Formula $S$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 un procedimiento el cual compute a 
\begin_inset Formula $f$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbb{P}_{1}$
\end_inset

 un procedimiento el cual enumere a 
\begin_inset Formula $\omega\times\omega^{n}\times\Sigma^{\ast m}.$
\end_inset

 Dejamos al lector el diseo de un procedimiento efectivo el cual enumere
 
\begin_inset Formula $D_{f}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos como ejercicio la prueba de los dos siguientes lemas.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

.
 Supongamos 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable y 
\begin_inset Formula $S\subseteq I_{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable, entonces 
\begin_inset Formula $f^{-1}(S)=\{(\vec{x},\vec{\alpha}):f(\vec{x},\vec{\alpha})\in S\}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

.
 Supongamos 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable y 
\begin_inset Formula $S\subseteq D_{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable, entonces 
\begin_inset Formula $f|_{S}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Independencia del alfabeto
\end_layout

\begin_layout Standard
Una observacion importante es que los conceptos de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectvamente computable y de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable, no dependen del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Esto lo establecemos formalmente en los dos siguientes lemas.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "independencia alfabeto funciones efectivamente computables"

\end_inset

Sean 
\begin_inset Formula $\Sigma$
\end_inset

 y 
\begin_inset Formula $\Gamma$
\end_inset

 alfabetos cualesquiera.
 Supongamos una funcion 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta y 
\begin_inset Formula $\Gamma$
\end_inset

-mixta, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable sii 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "independencia alfabeto para conjuntos e.e. y e.c."

\end_inset

Sean 
\begin_inset Formula $\Sigma$
\end_inset

 y 
\begin_inset Formula $\Gamma$
\end_inset

 alfabetos cualesquiera.
 Supongamos un conjunto 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixto y 
\begin_inset Formula $\Gamma$
\end_inset

-mixto, entonces 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable) sii 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-efectivamente computable (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-efectivamente enumerable).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos al lector los detalles de las rutinarias pruebas de estos dos lemas.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Chapter
Tres modelos matematicos de la computabilidad efectiva
\end_layout

\begin_layout Standard
Ya que el concepto de procedimiento efectivo es un concepto intuitivo, impresiso
 y a priori no expresado en el formalismo matematico, los conceptos de
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable 
\end_layout

\begin_layout Standard
\noindent
tambien son impresisos y estan fuera del formalismo matematico, debido a
 que los tres se definen en terminos de la existencia de procedimientos
 efectivos.
 Por supuesto, los tres conceptos son fundamentales en el estudio teorico
 de la computabilidad por lo que es muy importante poder dar un modelo o
 formalizacion matematica de estos conceptos.
 Pero notese que los dos ultimos se definen en funcion del primero por lo
 que una formalizacion matematica precisa del concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, resuelve el problema de modelizar en forma matematica
 estos a tres conceptos.
\end_layout

\begin_layout Standard
En esta seccion daremos las tres formalizaciones matematicas mas clasicas
 del concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 La primera y la mas apegada a la idea intuitiva de procedimiento efectivo
 es la dada por Alan Turing via la matematizacion del concepto de maquina.
 La segunda, es la dada por Godel en su estudio de sistemas formales de
 la logica de primer orden.
 Por ultimo veremos una formalizacion via un lenguaje de programacion imperativo.
 En honor a la influencia que tuvo Von Neumann en el diseo de la primer
 computadora de caracter universal (i.e.
 programable de proposito general), llamaremos a este paradigma el paradigma
 imperativo de Von Neumann.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "BasicosMaquinasDeTuring"

\end_inset

El paradigma de Turing
\end_layout

\begin_layout Standard
Estudiaremos el concepto de maquina de Turing, el cual fue introducido por
 Alam Turing para formalizar o modelizar matematicamente la idea de procedimient
o efectivo.
 Una vez definidas las maquinas podremos dar una modelizacion matematica
 precisa del concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Llamaremos a estas funciones 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computables y seran aquellas que (en algun sentido que sera bien
 precisado matematicamente) pueden ser computadas por una maquina de Turing.
 Por supuesto, la fidedignidad de este concepto, es decir cuan buena es
 la modelizacion matematica dada por Turing, puede no ser clara al comienzo
 pero a medida que vayamos avanzando en nuestro estudio y conozcamos ademas
 los otros paradigmas y su relacion, quedara claro que el modelo de Turing
 es acertado.
\end_layout

\begin_layout Standard
Vivimos en un mundo plagado de maquinas (ascensores, celulares, relojes,
 taladros, etc).
 Una caracteristica comun a todas las maquinas es que tienen distintos estados
 posibles.
 Un estado es el conjunto de caracteristicas que determinan un momento concreto
 posible de la maquina cuando esta funcionando.
 Por ejemplo un estado posible de un ascensor seria:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

esta en el tercer piso, con la primer puerta abierta y la otra cerrada,
 esta apretado el boton de ir al sexto piso, etc 
\end_layout

\begin_layout Standard
\noindent
donde ponemos etc porque dependiendo del tipo de ascensor (si es con memoria,
 a que pisos puede ir, etc) habra mas datos que especificar para determinar
 un estado concreto.
\end_layout

\begin_layout Standard
Otra caracteristica comun de las maquinas es que interactuan de distintas
 formas con el usuario o mas generalmente su entorno.
 Dependiendo de que accion se ejecute sobre la maquina y en que estado este,
 la maquina realizara alguna tarea y ademas cambiara de estado.
 En general las maquinas son 
\shape italic
deterministicas
\shape default
 en el sentido que siempre que esten en determinado estado y se les aplique
 determinada accion, realizaran la misma tarea y pasaran al mismo estado.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Descripcion informal de las maquinas de Turing
\end_layout

\begin_layout Standard
Son un modelo abstracto de maquina con una cantidad finita de estados la
 cual trabaja sobre una cinta de papel dividida en cuadros e interactua
 o recibe acciones externas por medio de una cabeza lectora que lee de a
 un cuadro de la cinta a la ves y ademas puede borrar el contenido del cuadro
 leido y escribir en el un simbolo.
 Tambien la cabeza lectora puede moverse un cuadro hacia la izquierda o
 hacia la derecha.
 La cinta tiene un primer cuadro hacia su izquierda pero hacia la derecha
 puede extenderse todo lo necesario.
 En un cuadro de la cinta podra haber un simbolo o un cuadro puede simplemente
 estar en blanco.
 Es decir que habra un alfabeto 
\begin_inset Formula $\Gamma$
\end_inset

 el cual consiste de todos los simbolos que pueden figurar en la cinta.
 Esto sera parte de los datos o caracteristicas de cada maquina, es decir,
 
\begin_inset Formula $\Gamma$
\end_inset

 puede cambiar dependiendo de la maquina.
 La maquina, en funcion del estado en que se encuentre y de lo que vea su
 cabeza lectora en el cuadro escaneado, podra moverse a lo sumo un cuadro
 (izquierda, derecha o quedarse quieta), modificar lo que encuentre en dicho
 cuadro (borrando y escribiendo algun nuevo simbolo) y cambiar de estado
 (posiblemente al mismo que tenia).
 Para simplificar supondremos que hay en 
\begin_inset Formula $\Gamma$
\end_inset

 un simbolo el cual si aparece en un cuadro de la cinta, significara que
 dicho cuadro esta sin escribir o en blanco.
 Esto nos permitira describir mas facilmente el funcionamiento de la maquina.
 En gral llamaremos 
\begin_inset Formula $B$
\end_inset

 a tal simbolo.
 Tambien por lo general llamaremos 
\begin_inset Formula $Q$
\end_inset

 al conjunto de estados de la maquina.
\end_layout

\begin_layout Standard
Tambien cada maquina tendra un estado especial el cual sera llamado su estado
 inicial, generalmente denotado con 
\begin_inset Formula $q_{0}$
\end_inset

, el cual sera el estado en el que estara la maquina al comenzar a trabajar
 sobre la cinta.
 Hay otras caracteristicas que tendran las maquinas de Turing pero para
 dar un primer ejemplo ya nos basta.
 Describiremos una maquina de Turing 
\begin_inset Formula $M$
\end_inset

 que tendra 
\begin_inset Formula $\Gamma=\{@,a,b,B\}$
\end_inset

 y tendra dos estados, es decir 
\begin_inset Formula $Q=\{q_{0},q_{1}\}$
\end_inset

.
 Obviamente 
\begin_inset Formula $q_{0}$
\end_inset

 sera su estado inicial y ademas el 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

comportamiento o personalidad
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 de 
\begin_inset Formula $M$
\end_inset

 estara dado por las siguientes clausulas:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Estando en estado 
\begin_inset Formula $q_{0}$
\end_inset

 si ve ya sea 
\begin_inset Formula $b$
\end_inset

 o 
\begin_inset Formula $B$
\end_inset

 o 
\begin_inset Formula $@$
\end_inset

, entonces se queda en estado 
\begin_inset Formula $q_{0}$
\end_inset

 y se mueve a la derecha
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Estando en estado 
\begin_inset Formula $q_{0}$
\end_inset

 si ve 
\begin_inset Formula $a$
\end_inset

 entonces reescribe 
\begin_inset Formula $@$
\end_inset

, se mueve a la izquierda y cambia al estado 
\begin_inset Formula $q_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Estando en estado 
\begin_inset Formula $q_{1}$
\end_inset

 si ve 
\begin_inset Formula $a$
\end_inset

 o 
\begin_inset Formula $b$
\end_inset

 o 
\begin_inset Formula $B$
\end_inset

 o 
\begin_inset Formula $@$
\end_inset

 entonces lo deja como esta, se mueve a la izquierda y queda en estado 
\begin_inset Formula $q_{1}$
\end_inset

 
\end_layout

\begin_layout Standard
Supongamos ahora que tomamos una palabra 
\begin_inset Formula $\alpha\in\Gamma^{\ast}$
\end_inset

 y la distribuimos en la cinta dejando el primer cuadro en blanco y luego
 poniendo los simbolos de 
\begin_inset Formula $\alpha$
\end_inset

 en los siguientes cuadros.
 Supongamos ademas que ponemos la maquina en estado 
\begin_inset Formula $q_{0}$
\end_inset

 y con su cabeza lectora escaneando el primer cuadro de la cinta.
 Esto lo podemos representar graficamente de la siguiente manera
\begin_inset Formula 
\[
\begin{array}{cccccccc}
B & \alpha_{1} & ... & \alpha_{n} & B & B & B & ...\\
\uparrow\\
q_{0}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $\alpha_{1},...,\alpha_{n}$
\end_inset

 son los sucesivos simbolos de 
\begin_inset Formula $\alpha$
\end_inset

.
 Supongamos ademas que 
\begin_inset Formula $a$
\end_inset

 ocurre an 
\begin_inset Formula $\alpha$
\end_inset

.
 Dejamos al lector ir aplicando las clausulas de 
\begin_inset Formula $M$
\end_inset

 para convencerse que luego de un rato de funcionar 
\begin_inset Formula $M$
\end_inset

, la situacion sera
\begin_inset Formula 
\[
\begin{array}{cccccccc}
B & \beta_{1} & ... & \beta_{n} & B & B & B & ...\\
\uparrow\\
q_{1}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $\beta_{1}...\beta_{n}$
\end_inset

 es el resultado de reemplazar en 
\begin_inset Formula $\alpha$
\end_inset

 la primer ocurrencia de 
\begin_inset Formula $a$
\end_inset

 por 
\begin_inset Formula $@$
\end_inset

.
 Dejamos como ejercicio para el lector averiguar que sucede cuando 
\begin_inset Formula $a$
\end_inset

 no ocurre en 
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Una cosa que puede pasar es que para un determinado estado 
\begin_inset Formula $p$
\end_inset

 y un 
\begin_inset Formula $\sigma\in\Gamma$
\end_inset

, la maquina no tenga contemplada ninguna accion posible.
 Por ejemplo sea 
\begin_inset Formula $M$
\end_inset

 la maquina de Turing dada por 
\begin_inset Formula $Q=\{q_{0}\}$
\end_inset

, 
\begin_inset Formula $\Gamma=\{@,\$,B\}$
\end_inset

 y por la siguiente clausula:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Estando en estado 
\begin_inset Formula $q_{0}$
\end_inset

 si ve ya sea 
\begin_inset Formula $@$
\end_inset

 o 
\begin_inset Formula $B$
\end_inset

, entonces se queda en estado 
\begin_inset Formula $q_{0}$
\end_inset

 y se mueve a la derecha 
\end_layout

\begin_layout Standard
Es facil ver que si partimos de una situacion
\begin_inset Formula 
\[
\begin{array}{cccccccc}
B & \alpha_{1} & ... & \alpha_{n} & B & B & B & ...\\
\uparrow\\
q_{0}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $\alpha_{1},...,\alpha_{n}\in\Gamma$
\end_inset

, entonces si ningun 
\begin_inset Formula $\alpha_{i}$
\end_inset

 es igual a 
\begin_inset Formula $\$$
\end_inset

, la maquina se movera indefinidamente hacia la derecha y en caso contrario
 se movera 
\begin_inset Formula $i$
\end_inset

 pasos a la derecha y se detendra, donde 
\begin_inset Formula $i$
\end_inset

 es el menor 
\begin_inset Formula $l$
\end_inset

 tal que 
\begin_inset Formula $\alpha_{l}=\$$
\end_inset

.
\end_layout

\begin_layout Standard
Otro caso posible de detencion de una maquina de Turing es cuando esta escaneand
o el primer cuadro de la cinta y su unica accion posible implica moverse
 un cuadro a la izquierda.
 Tambien en estos casos diremos que la maquina se detiene ya que la cinta
 no es extensible hacia la izquierda.
\end_layout

\begin_layout Standard
Otra caracteristica de las maquinas de Turing es que poseen un 
\shape italic
alfabeto de entrada
\shape default
 el cual esta contenido en el alfabeto 
\begin_inset Formula $\Gamma$
\end_inset

 y en el cual estan los simbolos que se usaran para formar la configuracion
 inicial de la cinta (exepto 
\begin_inset Formula $B$
\end_inset

).
 En general lo denotaremos con 
\begin_inset Formula $\Sigma$
\end_inset

 al alfabeto de entrada y los simbolos de 
\begin_inset Formula $\Gamma-\Sigma$
\end_inset

 son considerados auxiliares.
 Tambien habra un conjunto 
\begin_inset Formula $F$
\end_inset

 contenido en el conjunto 
\begin_inset Formula $Q$
\end_inset

 de los estados de la maquina, cuyos elementos seran llamados 
\shape italic
estados finales
\shape default
.
\end_layout

\begin_layout Standard
Diremos que una palabra 
\begin_inset Formula $\alpha=\alpha_{1}...\alpha_{n}\in\Sigma^{\ast}$
\end_inset

 es 
\shape italic
aceptada por 
\shape default

\begin_inset Formula $M$
\end_inset

 
\shape italic
por alcance de estado final
\shape default
 si partiendo de
\begin_inset Formula 
\[
\begin{array}{cccccccc}
B & \alpha_{1} & ... & \alpha_{n} & B & B & B & ...\\
\uparrow\\
q_{0}
\end{array}
\]

\end_inset

en algun momento de la computacion 
\begin_inset Formula $M$
\end_inset

 esta en un estado de 
\begin_inset Formula $F$
\end_inset

.
 Llamaremos 
\begin_inset Formula $L(M)$
\end_inset

 al conjunto formado por todas las palabras que son aceptadas por alcance
 de estado final
\end_layout

\begin_layout Standard
Diremos que una palabra 
\begin_inset Formula $\alpha=\alpha_{1}...\alpha_{n}\in\Sigma^{\ast}$
\end_inset

 es 
\shape italic
aceptada por 
\shape default

\begin_inset Formula $M$
\end_inset

 
\shape italic
por detencion
\shape default
 si partiendo de
\begin_inset Formula 
\[
\begin{array}{cccccccc}
B & \alpha_{1} & ... & \alpha_{n} & B & B & B & ...\\
\uparrow\\
q_{0}
\end{array}
\]

\end_inset

en algun momento 
\begin_inset Formula $M$
\end_inset

 se detiene.
 Llamaremos 
\begin_inset Formula $H(M)$
\end_inset

 al conjunto formado por todas las palabras que son aceptadas por detencion
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Definicion matematica de maquina de Turing
\end_layout

\begin_layout Standard
Una 
\shape italic
maquina de Turing 
\shape default
es una 7-upla 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,F\right)$
\end_inset

 donde
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $Q$
\end_inset

 es un conjunto finito cuyos elementos son llamados 
\shape italic
estados
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\Gamma$
\end_inset

 es un alfabeto que contiene a 
\begin_inset Formula $\Sigma$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\Sigma$
\end_inset

 es un alfabeto llamado el 
\shape italic
alfabeto de entrada
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $B\in\Gamma-\Sigma$
\end_inset

 es un simbolo de 
\begin_inset Formula $\Gamma$
\end_inset

 llamado el 
\shape italic
blank symbol
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\delta:D_{\delta}\subseteq Q\times\Gamma\rightarrow Q\times\Gamma\times\{L,R,K\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $q_{0}$
\end_inset

 es un estado llamado el 
\shape italic
estado inicial
\shape default
 de 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $F\subseteq Q$
\end_inset

 es un conjunto de estados llamados 
\shape italic
finales
\shape default
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que la funcion 
\begin_inset Formula $\delta$
\end_inset

 da la 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

personalidad
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 de la maquina.
 Aqui los simbolos 
\begin_inset Formula $L,R,K$
\end_inset

 serviran para especificar que hace el cabezal.
 O sea:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\delta(p,\sigma)=(q,\gamma,L)$
\end_inset

 significara que la maquina estando en estado 
\begin_inset Formula $p$
\end_inset

 y leyendo el simbolo 
\begin_inset Formula $\sigma$
\end_inset

 borrara 
\begin_inset Formula $\sigma$
\end_inset

 y escribira 
\begin_inset Formula $\gamma$
\end_inset

 en su lugar y luego se movera un cuadro a la izquierda (esto en caso que
 el cabezal no este en el cuadro de mas a la izquierda, en cuyo caso no
 podra realizar dicha tarea y se detendra).
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\delta(p,\sigma)=(q,\gamma,K)$
\end_inset

 significara que la maquina estando en estado 
\begin_inset Formula $p$
\end_inset

 y leyendo el simbolo 
\begin_inset Formula $\sigma$
\end_inset

 borrara 
\begin_inset Formula $\sigma$
\end_inset

 y escribira 
\begin_inset Formula $\gamma$
\end_inset

 en su lugar y luego el cabezal se quedara kieto
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\delta(p,\sigma)=(q,\gamma,R)$
\end_inset

 significara que la maquina estando en estado 
\begin_inset Formula $p$
\end_inset

 y leyendo el simbolo 
\begin_inset Formula $\sigma$
\end_inset

 borrara 
\begin_inset Formula $\sigma$
\end_inset

 y escribira 
\begin_inset Formula $\gamma$
\end_inset

 en su lugar y luego el cabezal se movera un cuadro a la derecha 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Si bien en nuestra definicion de maquina de Turing no hay ninguna restriccion
 acerca de la naturaleza de los elementos de 
\begin_inset Formula $Q$
\end_inset

, para continuar nuestro analisis asumiremos siempre que 
\begin_inset Formula $Q$
\end_inset

 es un alfabeto disjunto con 
\begin_inset Formula $\Gamma$
\end_inset

.
 Esto nos permitira dar definiciones matematicas precisas que formalizaran
 el funcionamiento de las maquinas de Turing en el contexto de las funciones
 mixtas.
 Deberia quedar claro que el hecho que solo analicemos maquinas en las cuales
 
\begin_inset Formula $Q$
\end_inset

 es un alfabeto disjunto con 
\begin_inset Formula $\Gamma$
\end_inset

, no afectara la profundidad y generalidad de nuestros resultados.
\end_layout

\begin_layout Subsubsection
Descripciones instantaneas
\end_layout

\begin_layout Standard
Una 
\shape italic
descripcion instantanea
\shape default
 sera una palabra de la forma 
\begin_inset Formula $\alpha q\beta$
\end_inset

, donde 
\begin_inset Formula $\alpha,\beta\in\Gamma^{\ast}$
\end_inset

, 
\begin_inset Formula $\left[\beta\right]_{\left\vert \beta\right\vert }\neq B$
\end_inset

 y 
\begin_inset Formula $q\in Q$
\end_inset

.
 Notese que la condicion 
\begin_inset Formula $\left[\beta\right]_{\left\vert \beta\right\vert }\neq B$
\end_inset

 nos dice que 
\begin_inset Formula $\beta=\varepsilon$
\end_inset

 o el ultimo simbolo de 
\begin_inset Formula $\beta$
\end_inset

 es distinto de 
\begin_inset Formula $B$
\end_inset

.
 La descripcion instantanea 
\begin_inset Formula $\alpha_{1}...\alpha_{n}q\beta_{1}...\beta_{m}$
\end_inset

, con 
\begin_inset Formula $\alpha_{1},...,\alpha_{n}$
\end_inset

, 
\begin_inset Formula $\beta_{1},...,\beta_{m}\in\Gamma$
\end_inset

, 
\begin_inset Formula $n,m\geq0$
\end_inset

 representara la siguiente situacion
\begin_inset Formula 
\[
\begin{array}{cccccccccccc}
\alpha_{1} & \alpha_{2} & ... & \alpha_{n} & \beta_{1} & \beta_{2} & ... & \beta_{m} & B & B & B & ...\\
 &  &  &  & \uparrow\\
 &  &  &  & q
\end{array}
\]

\end_inset

Notese que aqui 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $m$
\end_inset

 pueden ser 
\begin_inset Formula $0$
\end_inset

.
 Por ejemplo si 
\begin_inset Formula $n=0$
\end_inset

 tenemos que 
\begin_inset Formula $\alpha_{1}...\alpha_{n}q\beta_{1}...\beta_{m}=q\beta_{1}...\beta_{m}$
\end_inset

 y representa la siguiente situacion
\begin_inset Formula 
\[
\begin{array}{cccccccccccc}
\beta_{1} & \beta_{2} & ... & \beta_{m} & B & B & B & ...\\
\uparrow\\
q
\end{array}
\]

\end_inset

Si 
\begin_inset Formula $m=0$
\end_inset

 tenemos que 
\begin_inset Formula $\alpha_{1}...\alpha_{n}q\beta_{1}...\beta_{m}=\alpha_{1}...\alpha_{n}q$
\end_inset

 y representa la siguiente situacion
\begin_inset Formula 
\[
\begin{array}{cccccccccccc}
\alpha_{1} & \alpha_{2} & ... & \alpha_{n} & B & B & ... &  &  &  & ...\\
 &  &  &  & \uparrow\\
 &  &  &  & q
\end{array}
\]

\end_inset

Si ambos 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $m$
\end_inset

 son 
\begin_inset Formula $0$
\end_inset

 entonces tenemos que 
\begin_inset Formula $\alpha_{1}...\alpha_{n}q\beta_{1}...\beta_{m}=q$
\end_inset

 y representa la siguiente situacion
\begin_inset Formula 
\[
\begin{array}{cccccccccccc}
B & B & B & ...\\
\uparrow\\
q
\end{array}
\]

\end_inset

La condicion de que en una descripcion instantanea 
\begin_inset Formula $\alpha q\beta$
\end_inset

 deba suceder que 
\begin_inset Formula $\left[\beta\right]_{\left\vert \beta\right\vert }\neq B$
\end_inset

 es para que haya una correspondencia biuniboca entre descripciones instantaneas
 y situaciones de funcionamiento de la maquina.
 Dejamos al lector meditar sobre esto hasta convenserse de su veracidad.
\end_layout

\begin_layout Standard
Usaremos 
\begin_inset Formula $Des$
\end_inset

 para denotar el conjunto de las descripciones instantaneas.
 Definamos la funcion 
\begin_inset Formula $St:Des\rightarrow Q$
\end_inset

, de la siguiente manera
\begin_inset Formula 
\[
St(d)=\text{unico simbolo de }Q\text{ que ocurre en }d
\]

\end_inset


\end_layout

\begin_layout Subsubsection
La relacion 
\begin_inset Formula $\vdash$
\end_inset


\end_layout

\begin_layout Standard
Dado 
\begin_inset Formula $\alpha\in(Q\cup\Gamma)^{\ast}$
\end_inset

, definamos 
\begin_inset Formula $\left\lfloor \alpha\right\rfloor $
\end_inset

 de la siguiente manera
\begin_inset Formula 
\begin{align*}
\left\lfloor \varepsilon\right\rfloor  & =\varepsilon\\
\left\lfloor \alpha\sigma\right\rfloor  & =\alpha\sigma\text{, si }\sigma\neq B\\
\left\lfloor \alpha B\right\rfloor  & =\left\lfloor \alpha\right\rfloor 
\end{align*}

\end_inset

Es decir 
\begin_inset Formula $\left\lfloor \alpha\right\rfloor $
\end_inset

 es el resultado de remover de 
\begin_inset Formula $\alpha$
\end_inset

 el tramo final mas grande de la forma 
\begin_inset Formula $B^{n}$
\end_inset

.
 Dada cualquier palabra 
\begin_inset Formula $\alpha$
\end_inset

 definimos
\begin_inset Formula 
\[
^{\curvearrowright}\alpha=\left\{ \begin{array}{lll}
\left[\alpha\right]_{2}...\left[\alpha\right]_{\left\vert \alpha\right\vert } & \text{si} & \left\vert \alpha\right\vert \geq2\\
\varepsilon & \text{si} & \left\vert \alpha\right\vert \leq1
\end{array}\right.\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \alpha^{\curvearrowleft}=\left\{ \begin{array}{lll}
\left[\alpha\right]_{1}...\left[\alpha\right]_{\left\vert \alpha\right\vert -1} & \text{si} & \left\vert \alpha\right\vert \geq2\\
\varepsilon & \text{si} & \left\vert \alpha\right\vert \leq1
\end{array}\right.
\]

\end_inset

Dadas 
\begin_inset Formula $d_{1},d_{2}\in Des$
\end_inset

, escribiremos 
\begin_inset Formula $d_{1}\vdash d_{2}$
\end_inset

 cuando existan 
\begin_inset Formula $\sigma\in\Gamma$
\end_inset

, 
\begin_inset Formula $\alpha,\beta\in\Gamma^{\ast}$
\end_inset

 y 
\begin_inset Formula $p,q\in Q$
\end_inset

 tales que se cumple alguno de los siguientes casos
\end_layout

\begin_layout Standard
Caso 1.
\begin_inset Formula 
\begin{align*}
d_{1} & =\alpha p\beta\\
\delta\left(p,\left[\beta B\right]_{1}\right) & =(q,\sigma,R)\\
d_{2} & =\alpha\sigma q^{\curvearrowright}\beta
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Caso 2.
\begin_inset Formula 
\begin{align*}
d_{1} & =\alpha p\beta\\
\delta\left(p,\left[\beta B\right]_{1}\right) & =(q,\sigma,L)\text{ y }\alpha\neq\varepsilon\\
d_{2} & =\left\lfloor \alpha^{\curvearrowleft}q\left[\alpha\right]_{\left\vert \alpha\right\vert }\sigma^{\curvearrowright}\beta\right\rfloor 
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Caso 3.
\begin_inset Formula 
\begin{align*}
d_{1} & =\alpha p\beta\\
\delta(p,\left[\beta B\right]_{1}) & =(q,\sigma,K)\\
d_{2} & =\left\lfloor \alpha q\sigma^{\curvearrowright}\beta\right\rfloor 
\end{align*}

\end_inset

Escribiremos 
\begin_inset Formula $d\nvdash d^{\prime}$
\end_inset

 para expresar que no se da 
\begin_inset Formula $d\vdash d^{\prime}$
\end_inset

.
 Para 
\begin_inset Formula $d,d^{\prime}\in Des$
\end_inset

 y 
\begin_inset Formula $n\geq0$
\end_inset

, escribiremos 
\begin_inset Formula $d\overset{n}{\vdash}d^{\prime}$
\end_inset

 si existen 
\begin_inset Formula $d_{1},...,d_{n+1}\in Des$
\end_inset

 tales que
\begin_inset Formula 
\begin{align*}
d & =d_{1}\\
d^{\prime} & =d_{n+1}\\
d_{i} & \vdash d_{i+1}\text{, para }i=1,...,n.
\end{align*}

\end_inset

Notese que 
\begin_inset Formula $d\overset{0}{\vdash}d^{\prime}$
\end_inset

 sii 
\begin_inset Formula $d=d^{\prime}$
\end_inset

.
 Finalmente definamos
\begin_inset Formula 
\[
d\overset{\ast}{\vdash}d^{\prime}\text{ sii }(\exists n\in\omega)\;d\overset{n}{\vdash}d^{\prime}\text{.}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Detencion
\end_layout

\begin_layout Standard
Dada 
\begin_inset Formula $d\in Des$
\end_inset

, diremos que 
\begin_inset Formula $M$
\end_inset

 
\shape italic
se detiene partiendo de 
\shape default

\begin_inset Formula $d$
\end_inset

 si existe 
\begin_inset Formula $d^{\prime}\in Des$
\end_inset

 tal que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $d\overset{\ast}{\vdash}d^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $d^{\prime}\nvdash d^{\prime\prime}$
\end_inset

, para cada 
\begin_inset Formula $d^{\prime\prime}\in Des$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Deberia quedar claro que es posible que 
\begin_inset Formula $\alpha p\beta\nvdash d$
\end_inset

, para cada descripcion instantanea 
\begin_inset Formula $d$
\end_inset

, y que 
\begin_inset Formula $\delta(p,[\beta B]_{1})$
\end_inset

 sea no vacio.
\end_layout

\begin_layout Subsubsection
El lenguaje 
\begin_inset Formula $L(M)$
\end_inset


\end_layout

\begin_layout Standard
Diremos que una palabra 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 es 
\shape italic
aceptada por 
\shape default

\begin_inset Formula $M$
\end_inset

 
\shape italic
por alcance de estado final
\shape default
 cuando
\begin_inset Formula 
\[
\left\lfloor q_{0}B\alpha\right\rfloor \overset{\ast}{\vdash}d\text{, con }d\text{ tal que }St(d)\in F.
\]

\end_inset

El 
\shape italic
lenguage aceptado por 
\shape default

\begin_inset Formula $M$
\end_inset

 
\shape italic
por alcance de estado final
\shape default
 se define de la siguiente manera
\begin_inset Formula 
\[
L(M)=\{\alpha\in\Sigma^{\ast}:\alpha\text{ es aceptada por }M\text{ por alcance de estado final}\}\text{.}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
El lenguaje 
\begin_inset Formula $H(M)$
\end_inset


\end_layout

\begin_layout Standard
Diremos que una palabra 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 es 
\shape italic
aceptada por 
\shape default

\begin_inset Formula $M$
\end_inset

 
\shape italic
por detencion
\shape default
 cuando 
\begin_inset Formula $M$
\end_inset

 se detiene partiendo de 
\begin_inset Formula $\left\lfloor q_{0}B\alpha\right\rfloor $
\end_inset

.
 El 
\shape italic
lenguage aceptado por 
\shape default

\begin_inset Formula $M$
\end_inset

 
\shape italic
por detencion
\shape default
 se define de la siguiente manera
\begin_inset Formula 
\[
H(M)=\{\alpha\in\Sigma^{\ast}:\alpha\text{ es aceptada por }M\text{ por detencion}\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Funciones 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computables
\end_layout

\begin_layout Standard
Para poder computar funciones mixtas con una maquina de Turing necesitaremos
 un simbolo para representar numeros sobre la cinta.
 Llamaremos a este simbolo 
\shape italic
unit
\shape default
 y lo denotaremos con 
\begin_inset Formula $\shortmid$
\end_inset

.
 Mas formalmente una 
\shape italic
maquina de Turing con unit
\shape default
 es una 8-upla 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,\shortmid,F\right)$
\end_inset

 tal que 
\begin_inset Formula $\left(Q,\Sigma,\Gamma,\delta,q_{0},B,F\right)$
\end_inset

 es una maquina de Turing y 
\begin_inset Formula $\shortmid$
\end_inset

 es un simbolo distingido perteneciente a 
\begin_inset Formula $\Gamma-(\{B\}\cup\Sigma)$
\end_inset

.
\end_layout

\begin_layout Standard
Diremos que una funcion 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\Sigma^{\ast}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
Turing computable
\shape default
 si existe una maquina de Turing con unit, 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,\shortmid,F\right)$
\end_inset

 tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in D_{f}$
\end_inset

, entonces hay un 
\begin_inset Formula $p\in Q$
\end_inset

 tal que
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor \overset{\ast}{\vdash}\left\lfloor pBf(\vec{x},\vec{\alpha})\right\rfloor 
\]

\end_inset

y 
\begin_inset Formula $\left\lfloor pBf(\vec{x},\vec{\alpha})\right\rfloor \nvdash d$
\end_inset

, para cada 
\begin_inset Formula $d\in Des$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}-D_{f}$
\end_inset

, entonces 
\begin_inset Formula $M$
\end_inset

 no se detiene partiendo de
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor .
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
En forma similar, una funcion 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast}{}^{m}\rightarrow\omega$
\end_inset

, es llamada 
\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
Turing computable
\shape default
 si existe una maquina de Turing con unit, 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,\shortmid,F\right)$
\end_inset

, tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in D_{f}$
\end_inset

, entonces hay un 
\begin_inset Formula $p\in Q$
\end_inset

 tal que
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor \overset{\ast}{\vdash}\left\lfloor pB\shortmid^{f(\vec{x},\vec{\alpha})}\right\rfloor 
\]

\end_inset

y 
\begin_inset Formula $\left\lfloor pB\shortmid^{f(\vec{x},\vec{\alpha})}\right\rfloor \nvdash d$
\end_inset

, para cada 
\begin_inset Formula $d\in Des$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}-D_{f}$
\end_inset

, entonces 
\begin_inset Formula $M$
\end_inset

 no se detiene partiendo de
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor 
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
Cuando 
\begin_inset Formula $M$
\end_inset

 y 
\begin_inset Formula $f$
\end_inset

 cumplan los items (1) y (2) de la definicion anterior, diremos que la funcion
 
\begin_inset Formula $f$
\end_inset

 es 
\shape italic
computada
\shape default
 por 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
Por supuesto esta definicion no tendria sentido como modelo matematico del
 concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable si no sucediera que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable fuera 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Este hecho es intuitivamente claro y lo expresamos en forma de proposicion.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 Sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

.
 Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast}{}^{m}\rightarrow O$
\end_inset

 es computada por una maquina de Turing con unit 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,\shortmid,F\right)$
\end_inset

, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Haremos el caso 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 el siguiente procedimiento efectivo.
\end_layout

\begin_layout Standard
- Conjunto de datos de entrada de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 igual a 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast}{}^{m}$
\end_inset


\end_layout

\begin_layout Standard
- Conjunto de datos de salida de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 contenido en 
\begin_inset Formula $O$
\end_inset


\end_layout

\begin_layout Standard
- Funcionamiento: Hacer funcionar paso a paso la maquina 
\begin_inset Formula $M$
\end_inset

 partiendo de la descripcion instantanea 
\begin_inset Formula $\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor $
\end_inset

.
 Si en alguna instancia 
\begin_inset Formula $M$
\end_inset

 termina, dar como salida el resultado de remover de la descripcion instantanea
 final los dos primeros simbolos.
\end_layout

\begin_layout Standard
Notese que este procedimiento termina solo en aquelos elementos 
\begin_inset Formula $(\vec{x},\vec{\sigma})\in\omega^{n}\times\Sigma^{\ast}{}^{m}$
\end_inset

 tales que la maquina 
\begin_inset Formula $M$
\end_inset

 termina partiendo desde
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor 
\]

\end_inset

por lo cual termina solo en los elementos de 
\begin_inset Formula $D_{f}$
\end_inset

 ya que 
\begin_inset Formula $M$
\end_inset

 computa a 
\begin_inset Formula $f$
\end_inset

.
 Ademas es claro que en caso de terminacion el procedimiento da como salida
 
\begin_inset Formula $f(\vec{x},\vec{\sigma})$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Sin envargo el modelo Turingniano podria a priori no ser del todo correcto
 ya que podria pasar que haya una funcion que sea computada por un procedimiento
 efectivo pero que no exista una maquina de Turing que la compute.
 En otras palabras el modelo podria ser incompleto.
 La completitud de este modelo puede no ser clara al comienzo pero a medida
 que vayamos avanzando en nuestro estudio y conozcamos ademas los otros
 paradigmas y su relacion, quedara claro que el modelo de Turing es acertado.
\end_layout

\begin_layout Subsection
Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-Turing enumerables
\end_layout

\begin_layout Standard
Ya que la nocion de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable es el modelo matematico de Turing del concepto de funcion
 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, nos podriamos preguntar entonces cual es el modelo
 matematico de Turing del concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Si prestamos atencion a la definicion de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable, notaremos que depende de la existencia de cierta
 funcion 
\begin_inset Formula $F$
\end_inset

 por lo cual la siguiente definicion cae de maduro:
\end_layout

\begin_layout Standard
Diremos que un conjunto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 sera llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-Turing enumerable
\shape default
 cuando sea vacio o haya una funcion 
\begin_inset Formula $F:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que 
\begin_inset Formula $I_{F}=S$
\end_inset

 y 
\begin_inset Formula $F_{(i)}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable, para cada 
\begin_inset Formula $i\in\{1,...,n+m\}$
\end_inset

.
\end_layout

\begin_layout Standard
Deberia quedar claro que si el concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable modeliza correctamente al concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, entonces el concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-Turing enumerable recien definido modeliza correctamente al concepto de
 conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Notese que segun la definicion que acabamos de escribir, un conjunto no
 vacio 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing enumerable si y solo si hay maquinas de Turing deterministicas con
 unit
\begin_inset Formula 
\begin{align*}
M_{1} & =\left(Q_{1},\Sigma,\Gamma_{1},\delta_{1},q_{01},B,\shortmid,F_{1}\right)\\
M_{2} & =\left(Q_{2},\Sigma,\Gamma_{2},\delta_{2},q_{02},B,\shortmid,F_{2}\right)\\
 & \vdots\\
M_{n+m} & =\left(Q_{n+m},\Sigma,\Gamma_{n+m},\delta_{n+m},q_{0n+m},B,\shortmid,F_{n+m}\right)
\end{align*}

\end_inset

tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada 
\begin_inset Formula $M_{i}$
\end_inset

, con 
\begin_inset Formula $i=1,...,n$
\end_inset

, computa una funcion 
\begin_inset Formula $F_{i}:\omega\rightarrow\omega$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada 
\begin_inset Formula $M_{i}$
\end_inset

, con 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

, computa una funcion 
\begin_inset Formula $F_{i}:\omega\rightarrow\Sigma^{\ast}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $S=\operatorname{Im}[F_{1},...,F_{n+m}]$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Como puede notarse las maquinas 
\begin_inset Formula $M_{1},...,M_{n+m}$
\end_inset

 puestas en paralelo a funcionar desde la descripciones instantaneas
\begin_inset Formula 
\begin{align*}
 & \left\lfloor q_{01}B\shortmid^{x}\right\rfloor \\
 & \left\lfloor q_{02}B\shortmid^{x}\right\rfloor \\
 & \ \ \ \ \ \ \ \ \ \vdots\\
 & \left\lfloor q_{0n+m}B\shortmid^{x}\right\rfloor 
\end{align*}

\end_inset

producen en forma natural un procedimiento efectivo (con dato de entrada
 
\begin_inset Formula $x\in\omega$
\end_inset

) que enumera a 
\begin_inset Formula $S$
\end_inset

.
 Por supuesto podemos decir que en tal caso las maquinas 
\begin_inset Formula $M_{1},...,M_{n+m}$
\end_inset

 enumeran a 
\begin_inset Formula $S$
\end_inset

.
 La siguiente proposicion muestra que tambien las cosas se pueden hacer
 con una sola maquina de Turing.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 Sea 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 un conjunto no vacio.
 Entonces 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing enumerable si y solo si hay una maquina de Turing deterministica
 con unit 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,\shortmid,F\right)$
\end_inset

, tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $x\in\omega$
\end_inset

, tenemos que 
\begin_inset Formula $M$
\end_inset

 se detiene partiendo de 
\begin_inset Formula $\left\lfloor q_{0}B\shortmid^{x}\right\rfloor $
\end_inset

 y llega a una descripcion instantanea de la forma 
\begin_inset Formula $\left\lfloor qB\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor $
\end_inset

, con 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S$
\end_inset

 hay un 
\begin_inset Formula $x\in\omega$
\end_inset

 tal que 
\begin_inset Formula $M$
\end_inset

 se detiene partiendo de 
\begin_inset Formula $\left\lfloor q_{0}B\shortmid^{x}\right\rfloor $
\end_inset

 y llega a una descripcion instantanea de la forma 
\begin_inset Formula $\left\lfloor qB\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor $
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Queda como ejercicio ver como construir la maquina 
\begin_inset Formula $M$
\end_inset

 utilizando las maquinas 
\begin_inset Formula $M_{1},...,M_{n+m}$
\end_inset

 y reciprocamente ver como a partir de una maquina 
\begin_inset Formula $M$
\end_inset

 con las propiedades (1) y (2) se pueden construir las maquinas 
\begin_inset Formula $M_{1},...,M_{n+m}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computables
\end_layout

\begin_layout Standard
La version Turingniana del concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable es facil de dar: un conjunto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 sera llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-Turing computable
\shape default
 cuando la funcion 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable.
 O sea que 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable sii hay una maquina de Turing deterministica con unit
 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,\shortmid,F\right)$
\end_inset

 la cual computa a 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

, es decir:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S$
\end_inset

, entonces hay un 
\begin_inset Formula $p\in Q$
\end_inset

 tal que
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor \overset{\ast}{\vdash}\left\lfloor pB\shortmid\right\rfloor 
\]

\end_inset

y 
\begin_inset Formula $\left\lfloor pB\shortmid\right\rfloor \nvdash d$
\end_inset

, para cada 
\begin_inset Formula $d\in Des$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

, entonces hay un 
\begin_inset Formula $p\in Q$
\end_inset

 tal que
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}\right\rfloor \overset{\ast}{\vdash}\left\lfloor pB\right\rfloor 
\]

\end_inset

y 
\begin_inset Formula $\left\lfloor pB\right\rfloor \nvdash d$
\end_inset

, para cada 
\begin_inset Formula $d\in Des$
\end_inset

 
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $M$
\end_inset

 es una maquina de Turing la cual computa a 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

, diremos que 
\begin_inset Formula $M$
\end_inset

 
\shape italic
decide la pertenecia a 
\shape default

\begin_inset Formula $S$
\end_inset

, con respecto al conjunto 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
El paradigma de Godel: Funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas
\end_layout

\begin_layout Standard
En esta seccion desarrollaremos el modelo matematico del concepto de funcion
 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, dado por Godel.
 Dichas funciones seran llamadas 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas.
 La idea es partir de un conjunto inicial de funciones muy simples y obviamente
 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables y luego obtener nuevas funciones 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables usando constructores que preservan la computabilidad
 efectiva.
 Las funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas seran las que se obtienen iterando el uso de estos constructores,
 partiendo del conjunto inicial de funciones antes mencionado.
 Nos referiremos a este paradigma como el paradigma Godeliano o recursivo.
 A veces tambien lo llamaremos el paradigma funcional.
\end_layout

\begin_layout Standard
La familia de funciones simples y obviamente 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables de la que partiremos es la siguiente
\begin_inset Formula 
\[
\left\{ Suc,Pred,C_{0}^{0,0},C_{\varepsilon}^{0,0}\right\} \cup\left\{ d_{a}:a\in\Sigma\right\} \cup\left\{ p_{j}^{n,m}:1\leq j\leq n+m\right\} 
\]

\end_inset

Los constructores que usaremos son:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Composicion
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Recursion primitiva
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Minimizacion de predicados totales 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Estos constructores nos permiten dadas ciertas funciones construir o definir
 una nueva funcion y tienen la propiedad de preservar la computabilidad
 efectiva en el sentido que si las funciones iniciales son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables, entonces la funcion obtenida tambien lo es.
 Un concepto fundamental es el de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva primitiva.
 Estas funciones seran aquellas que se obtienen a partir de las del conjunto
 inicial usando solo los dos primeros constructores: composicion y recursion
 primitiva.
 Nuestro primer objetivo es definir el concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva primitiva para lo cual en las proximas dos secciones definiremos
 y estudiaremos los constructores de composicion y recursion primitiva.
 Luego definiremos el concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva primitiva y nos abocaremos a desarrollar este concepto fundamental.
 Recien despues estudiaremos el constructor de minimizacion y definiremos
 el concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 La ultima parte de la seccion esta destinada a probar un teorema que nos
 dice que los conceptos de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva y 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva primitiva son independientes del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Composicion
\end_layout

\begin_layout Standard
Dadas funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas 
\begin_inset Formula $f,f_{1},...,f_{r}$
\end_inset

, con 
\begin_inset Formula $r\geq1$
\end_inset

, diremos que la funcion 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]$
\end_inset

 es 
\shape italic
obtenida por composicion a partir de las funciones 
\shape default

\begin_inset Formula $f,f_{1},...,f_{r}$
\end_inset

.
 Para probar que la composicion preserva la computabilidad efectiva necesitaremo
s el siguiente lema.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos que 
\begin_inset Formula $f,f_{1},...,f_{r}$
\end_inset

 son funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas, con 
\begin_inset Formula $r\geq1$
\end_inset

.
 Supongamos ademas que 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

.
 Entonces hay 
\begin_inset Formula $n,m,k,l\in\omega$
\end_inset

 y 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

 tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r=n+m$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f$
\end_inset

 es de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\#)$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\ast)$
\end_inset

, para cada 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

 
\end_layout

\begin_layout Standard
Mas aun, en tal caso la funcion 
\begin_inset Formula $f\circ[f_{1},...,f_{n+m}]$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,s)$
\end_inset

 y:
\begin_inset Formula 
\begin{align*}
D_{f\circ[f_{1},...,f_{n+m}]} & =\left\{ (\vec{x},\vec{\alpha})\in\bigcap_{i=1}^{n+m}D_{f_{i}}:(f_{1}(\vec{x},\vec{\alpha}),...,f_{n+m}(\vec{x},\vec{\alpha}))\in D_{f}\right\} \\
f\circ[f_{1},...,f_{n+m}](\vec{x},\vec{\alpha}) & =f(f_{1}(\vec{x},\vec{\alpha}),...,f_{n+m}(\vec{x},\vec{\alpha})).
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que 
\begin_inset Formula $f\neq\emptyset$
\end_inset

 y 
\begin_inset Formula $[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

 (por que?).
 Ya que 
\begin_inset Formula $f\neq\emptyset$
\end_inset

 tenemos que hay unicos 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

 tales que 
\begin_inset Formula $f$
\end_inset

 es de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset

.
 Ya que 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

 y 
\begin_inset Formula $I_{[f_{1},...,f_{r}]}\subseteq I_{f_{1}}\times...\times I_{f_{r}}$
\end_inset

, tenemos que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r=n+m$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $I_{f_{i}}\subseteq\omega$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $I_{f_{i}}\subseteq\Sigma^{\ast}$
\end_inset

, para cada 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

 
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

 tenemos que 
\begin_inset Formula $D_{[f_{1},...,f_{r}]}=\bigcap_{i=1}^{r}D_{f_{i}}\neq\emptyset$
\end_inset

, por lo cual los conjuntos 
\begin_inset Formula $D_{f_{1}},...,D_{f_{n+m}}$
\end_inset

 deberan ser todos de un mismo tipo, digamos de tipo 
\begin_inset Formula $(k,l)$
\end_inset

.
 Es decir que 
\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\#)$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n$
\end_inset

 y 
\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\ast)$
\end_inset

, para cada 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

.
\end_layout

\begin_layout Standard
Las ultimas observaciones del lema son directas de las definiciones de 
\begin_inset Formula $[f_{1},...,f_{n+m}]$
\end_inset

 y de composicion de funciones 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora si podemos probar facilmente que el contructor composicion preserva
 la computabilidad efectiva
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $f,f_{1},...,f_{r}$
\end_inset

, con 
\begin_inset Formula $r\geq1$
\end_inset

, son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables, entonces 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]$
\end_inset

 lo es.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Si 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]=\emptyset$
\end_inset

, entonces claramente es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Supongamos entonces que 
\begin_inset Formula $f\circ[f_{1},...,f_{r}]\neq\emptyset$
\end_inset

.
 Por el lema anterior hay 
\begin_inset Formula $n,m,k,l\in\omega$
\end_inset

 y 
\begin_inset Formula $s\in\{\#,\ast\}$
\end_inset

 tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r=n+m$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f$
\end_inset

 es de tipo 
\begin_inset Formula $(n,m,s)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\#)$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f_{i}$
\end_inset

 es de tipo 
\begin_inset Formula $(k,l,\ast)$
\end_inset

, para cada 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

 
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $\mathbb{P},\mathbb{P}_{1},...,\mathbb{P}_{n+m}$
\end_inset

 procedimientos efectivos los cuales computen las funciones 
\begin_inset Formula $f,f_{1},...,f_{n+m}$
\end_inset

, respectivamente.
 Usando estos procedimientos es facil definir un procedimiento efectivo
 el cual compute a 
\begin_inset Formula $f\circ[f_{1},...,f_{n+m}]$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Recursion primitiva
\end_layout

\begin_layout Standard
La recursion primitiva es un tipo muy particular de recursion.
 Consideremos por ejemplo las siguientes ecuaciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(0)=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(t+1)=1+R(t)+R(t)^{2}$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que hay una unica funcion 
\begin_inset Formula $R:\omega\rightarrow\omega$
\end_inset

 la cual cumple (1) y (2).
 Esto es ya que el valor de 
\begin_inset Formula $R$
\end_inset

 en 
\begin_inset Formula $t$
\end_inset

 esta determinado por sucesivas aplicaciones de las ecuaciones (1) y (2).
 Por ejemplo la ecuacion (1) nos dice que 
\begin_inset Formula $R(0)=1$
\end_inset

 pero entonces la ecuacion (2) nos dice que 
\begin_inset Formula $R(1)=1+1+1^{2}=3$
\end_inset

 por lo cual nuevamente la ecuacion (2) nos dice que 
\begin_inset Formula $R(2)=1+3+3^{2}=13$
\end_inset

 y asi podemos notar facilmente que 
\begin_inset Formula $R$
\end_inset

 esta determinada por dichas ecuaciones.
\end_layout

\begin_layout Standard
Se suele decir que las ecuaciones (1) y (2) definen recursivamente a la
 funcion 
\begin_inset Formula $R$
\end_inset

 pero hay que tener cuidado porque esto es una manera de hablar ya que la
 funcion 
\begin_inset Formula $R$
\end_inset

 podria en nuestro discurso ya haber sido definida de otra manera.
 Mas propio es pensar que dichas ecuaciones determinan a 
\begin_inset Formula $R$
\end_inset

 en el sentido que 
\begin_inset Formula $R$
\end_inset

 es la unica que las cumple.
 Por ejemplo las ecuaciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $R(0)=50$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $R(t+1)=R(t)$
\end_inset

 
\end_layout

\begin_layout Standard
definen recursivamente a la funcion 
\begin_inset Formula $C_{50}^{1,0}$
\end_inset

 pero esta claro que la definicion de 
\begin_inset Formula $C_{50}^{1,0}$
\end_inset

 en esta materia no fue dada de esta forma.
\end_layout

\begin_layout Standard
Hay casos de recursiones en las cuales el valor de 
\begin_inset Formula $R(t+1)$
\end_inset

 no solo depende de 
\begin_inset Formula $R(t)$
\end_inset

 sino que tambien depende de 
\begin_inset Formula $t$
\end_inset

.
 Por ejemplo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(i)
\end_layout

\end_inset


\begin_inset Formula $R(0)=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(ii)
\end_layout

\end_inset


\begin_inset Formula $R(t+1)=t.R(t)+1$
\end_inset

 
\end_layout

\begin_layout Standard
De todas maneras deberia quedar claro que las ecuaciones (i) y (ii) determinan
 una unica funcion 
\begin_inset Formula $R:\omega\rightarrow\omega$
\end_inset

 que las satisface.
\end_layout

\begin_layout Standard
Tambien podemos generalizar pensando que la funcion 
\begin_inset Formula $R$
\end_inset

 depende no solo de un parametro 
\begin_inset Formula $t$
\end_inset

 sino que su dominio es 
\begin_inset Formula $\omega^{4}$
\end_inset

, es decir depende de 
\begin_inset Formula $t$
\end_inset

 y 
\begin_inset Formula $x_{1},x_{2},x_{3}$
\end_inset

.
 Por ejemplo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(p)
\end_layout

\end_inset


\begin_inset Formula $R(0,x_{1},x_{2},x_{3})=x_{1}+2x_{3}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(q)
\end_layout

\end_inset


\begin_inset Formula $R(t+1,x_{1},x_{2},x_{3})=t+x_{1}+x_{2}+x_{3}+R(t,x_{1},x_{2},x_{3})$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos al lector convencerse de que (p) y (q) son cumplidas por una unica
 funcion 
\begin_inset Formula $R:\omega^{4}\rightarrow\omega$
\end_inset

.
 Tambien podriamos tener variables alfabeticas.
 Por ejemplo consideremos
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(r)
\end_layout

\end_inset


\begin_inset Formula $R(0,x_{1},x_{2},\alpha_{1},\alpha_{2})=x_{1}+\left\vert \alpha_{1}\right\vert ^{x_{2}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(s)
\end_layout

\end_inset


\begin_inset Formula $R(t+1,x_{1},x_{2},\alpha_{1},\alpha_{2})=t+x_{1}+x_{2}+\left\vert \alpha_{1}\right\vert +\left\vert \alpha_{2}\right\vert +R(t,x_{1},x_{2},\alpha_{1},\alpha_{2})$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Es claro aqui que las ecuaciones (r) y (s) determinan una unica funcion
 
\begin_inset Formula $R:\omega^{3}\times\Sigma^{\ast2}\rightarrow\omega$
\end_inset

 que las cumple.
 Esto se puede explicar de la siguiente manera:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

La ecuacion (r) determina los valores de 
\begin_inset Formula $R$
\end_inset

 sobre el conjunto 
\begin_inset Formula $\{0\}\times\omega\times\omega\times\Sigma^{\ast}\times\Sigma^{\ast}$
\end_inset

.
 Pero una ves determinados estos valores, la ecuacion (s) tomada con 
\begin_inset Formula $t=0$
\end_inset

, determina los valores de 
\begin_inset Formula $R$
\end_inset

 sobre el conjunto 
\begin_inset Formula $\{1\}\times\omega\times\omega\times\Sigma^{\ast}\times\Sigma^{\ast}$
\end_inset

.
 Pero una ves determinados estos valores, la ecuacion (s) tomada con 
\begin_inset Formula $t=1$
\end_inset

, determina los valores de 
\begin_inset Formula $R$
\end_inset

 sobre el conjunto 
\begin_inset Formula $\{2\}\times\omega\times\omega\times\Sigma^{\ast}\times\Sigma^{\ast}$
\end_inset

, etc 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El caso anterior podria generalizarse de la siguiente manera: Si tenemos
 dadas dos funciones
\begin_inset Formula 
\begin{align*}
f & :\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega\\
g & :\omega^{n+2}\times\Sigma^{\ast m}\rightarrow\omega
\end{align*}

\end_inset

entonces las ecuaciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $R(0,\vec{x},\vec{\alpha})=f(\vec{x},\vec{\alpha})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $R(t+1,\vec{x},\vec{\alpha})=g(R(t,\vec{x},\vec{\alpha}),t,\vec{x},\vec{\alpha})$
\end_inset

 
\end_layout

\begin_layout Standard
determinan una unica funcion 
\begin_inset Formula $R:\omega^{n+1}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 que las cumple.
 Notese que para el caso
\begin_inset Formula 
\begin{align*}
n & =m=2\\
f & =\lambda x_{1}x_{2}\alpha_{1}\alpha_{2}[x_{1}+\left\vert \alpha_{1}\right\vert ^{x_{2}}]\\
g & =\lambda xtx_{1}x_{2}\alpha_{1}\alpha_{2}[t+x_{1}+x_{2}+\left\vert \alpha_{1}\right\vert +\left\vert \alpha_{2}\right\vert +x]
\end{align*}

\end_inset

las ecuaciones (a) y (b) se transforman en las ecuaciones (r) y (s).
\end_layout

\begin_layout Standard
El primer caso de recursion primitiva que definiremos a continuacion engloba
 los ejemplos vistos recien dentro de un marco general.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Recursion primitiva sobre variable numerica con valores numericos
\end_layout

\begin_layout Standard
Supongamos tenemos dadas funciones
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega\\
g & :\omega\times\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega
\end{align*}

\end_inset

con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 conjuntos no vacios.
 Usando el razonamiento inductivo usado en los ejemplos anteriores, se puede
 probar que hay una unica funcion
\begin_inset Formula 
\[
R:\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega
\]

\end_inset

la cual cumple las ecuaciones
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $R(0,\vec{x},\vec{\alpha})=f(\vec{x},\vec{\alpha})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $R(t+1,\vec{x},\vec{\alpha})=g(R(t,\vec{x},\vec{\alpha}),t,\vec{x},\vec{\alpha})$
\end_inset

 
\end_layout

\begin_layout Standard
LLamaremos 
\begin_inset Formula $R(f,g)$
\end_inset

 a esta unica funcion que cumple las ecuaciones anteriores.
 Resumiendo, diremos que las ecuaciones
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(0,\vec{x},\vec{\alpha})=f(\vec{x},\vec{\alpha})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(t+1,\vec{x},\vec{\alpha})=g(R(f,g)(t,\vec{x},\vec{\alpha}),t,\vec{x},\vec{\alpha})$
\end_inset

 
\end_layout

\begin_layout Standard
definen recursivamente a la funcion 
\begin_inset Formula $R(f,g)$
\end_inset

.
 Tambien diremos que 
\begin_inset Formula $R(f,g)$
\end_inset

 es obtenida por 
\shape italic
recursion primitiva
\shape default
 a partir de 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
NOTA
\begin_inset space \space{}
\end_inset

IMPOTANTE: No confundirse y pensar que 
\begin_inset Formula $R(f,g)$
\end_inset

 es el resultado de aplicar una funcion 
\begin_inset Formula $R$
\end_inset

 al par 
\begin_inset Formula $(f,g)$
\end_inset

, de hecho hasta el momento no hemos definido ninguna funcion 
\begin_inset Formula $R$
\end_inset

 cuyo dominio sea cierto conjunto de pares ordenados de funciones!
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que cuando 
\begin_inset Formula $m=n=0$
\end_inset

, se tiene que 
\begin_inset Formula $D_{f}=\{\Diamond\}$
\end_inset

 y (1) y (2) se transforman en
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(0)=f(\Diamond)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(t+1)=g(R(f,g)(t),t)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Veamos algunos ejemplos
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset

Tomemos 
\begin_inset Formula $f=p_{1}^{1,0}$
\end_inset

 y 
\begin_inset Formula $g=Suc\circ p_{1}^{3,0}$
\end_inset

.
 De la definicion de 
\begin_inset Formula $R(f,g)$
\end_inset

, obtenemos que su dominio es 
\begin_inset Formula $\omega^{2}$
\end_inset

 y
\begin_inset Formula 
\begin{align*}
R(f,g)(0,x_{1}) & =p_{1}^{1,0}(x_{1})=x_{1}\\
R(f,g)(t+1,x_{1}) & =\left(Suc\circ p_{1}^{3,0}\right)(R(f,g)(t,x_{1}),t,x_{1})=R(f,g)(t,x_{1})+1
\end{align*}

\end_inset

Es facil notar que la unica funcion que cumple estas dos ecuaciones es 
\begin_inset Formula $\lambda tx_{1}\left[t+x_{1}\right]$
\end_inset

, lo cual implica que 
\begin_inset Formula $\lambda tx_{1}\left[t+x_{1}\right]=R\left(p_{1}^{1,0},Suc\circ p_{1}^{3,0}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset

Sean 
\begin_inset Formula $f=C_{0}^{0,0}$
\end_inset

 y 
\begin_inset Formula $g=p_{1}^{2,0}$
\end_inset

.
 De la definicion de 
\begin_inset Formula $R(f,g)$
\end_inset

, obtenemos que su dominio es 
\begin_inset Formula $\omega$
\end_inset

 y
\begin_inset Formula 
\begin{align*}
R(f,g)(0) & =C_{0}^{0,0}(\Diamond)=0\\
R(f,g)(t+1) & =p_{1}^{2,0}(R(f,g)(t),t)=R(f,g)(t)
\end{align*}

\end_inset

Es facil notar que la unica funcion que cumple estas dos ecuaciones es 
\begin_inset Formula $C_{0}^{1,0}$
\end_inset

 lo cual implica que 
\begin_inset Formula $C_{0}^{1,0}=R\left(C_{0}^{0,0},p_{1}^{2,0}\right)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como era de esperar, este caso del constructor de recursion primitiva preserva
 la computabilidad efectiva
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables, entonces 
\begin_inset Formula $R(f,g)$
\end_inset

 lo es.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es dejada al lector 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Nota importante:
\series default
 En los ejemplos anteriores y en todos los casos que manejaremos en esta
 primera etapa, en las aplicaciones del constructor de recursion primitiva
 (en sus cuatro formas) las funciones iniciales seran 
\begin_inset Formula $\Sigma$
\end_inset

-totales (es decir 
\begin_inset Formula $S_{1}=...=S_{n}=\omega$
\end_inset

 y 
\begin_inset Formula $L_{1}=...=L_{m}=\Sigma^{\ast}$
\end_inset

).
 Mas adelante veremos aplicaciones con funciones no 
\begin_inset Formula $\Sigma$
\end_inset

-totales.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Recursion primitiva sobre variable numerica con valores alfabeticos
\end_layout

\begin_layout Standard
Ahora haremos el caso en el que la funcion definida recursivamente tiene
 imagen contenida en 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
 Es claro que entonces 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 tambien deberan tener imagen contenida en 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
 El unico detalle a tener en cuenta en la definicion de este caso es que
 si solo hicieramos estos cambios y pusieramos las mismas ecuaciones la
 funcion 
\begin_inset Formula $g$
\end_inset

 no resultaria 
\begin_inset Formula $\Sigma$
\end_inset

-mixta en general.
 Para que la 
\begin_inset Formula $g$
\end_inset

 de la recursion siga siendo 
\begin_inset Formula $\Sigma$
\end_inset

-mixta deberemos modificar levemente su dominio en relacion al caso ya hecho
\end_layout

\begin_layout Standard
Supongamos 
\begin_inset Formula $\Sigma$
\end_inset

 es un alfabeto finito.
 Sean
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\Sigma^{\ast}\\
g & :\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Sigma^{\ast}\rightarrow\Sigma^{\ast}
\end{align*}

\end_inset

con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 conjuntos no vacios.
 Definamos
\begin_inset Formula 
\[
R(f,g):\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\Sigma^{\ast}
\]

\end_inset

de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(0,\vec{x},\vec{\alpha})=f(\vec{x},\vec{\alpha})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(t+1,\vec{x},\vec{\alpha})=g(t,\vec{x},\vec{\alpha},R(f,g)(t,\vec{x},\vec{\alpha}))$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Diremos que 
\begin_inset Formula $R(f,g)$
\end_inset

 es obtenida por 
\shape italic
recursion primitiva
\shape default
 a partir de 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

.
 Notese que cuando 
\begin_inset Formula $m=n=0$
\end_inset

, se tiene que 
\begin_inset Formula $D_{f}=\{\Diamond\}$
\end_inset

 y (1) y (2) se transforman en
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(0)=f(\Diamond)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(t+1)=g(t,R(f,g)(t))$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Veamos algunos ejemplos
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset

Tomemos 
\begin_inset Formula $f=C_{\varepsilon}^{0,1}$
\end_inset

 y 
\begin_inset Formula $g=\lambda\alpha\beta\left[\alpha\beta\right]\circ\left[p_{3}^{1,2},p_{2}^{1,2}\right]$
\end_inset

.
 De la definicion de 
\begin_inset Formula $R(f,g)$
\end_inset

, obtenemos que
\begin_inset Formula 
\begin{align*}
R(f,g)(0,\alpha_{1}) & =C_{\varepsilon}^{0,1}(\alpha_{1})=\varepsilon\\
R(f,g)(t+1,\alpha_{1}) & =\lambda\alpha\beta\left[\alpha\beta\right]\circ\left[p_{3}^{1,2},p_{2}^{1,2}\right](t,\alpha_{1},R(f,g)(t,\alpha_{1}))=R(f,g)(t,\alpha_{1})\alpha_{1}
\end{align*}

\end_inset

Es facil notar que la unica funcion que cumple estas dos ecuaciones es 
\begin_inset Formula $\lambda t\alpha_{1}\left[\alpha_{1}{}^{t}\right]$
\end_inset

, lo cual implica que 
\begin_inset Formula $\lambda t\alpha_{1}\left[\alpha_{1}{}^{t}\right]=R\left(C_{\varepsilon}^{0,1},\lambda\alpha\beta\left[\alpha\beta\right]\circ\left[p_{3}^{1,2},p_{2}^{1,2}\right]\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset

Sean 
\begin_inset Formula $f=C_{\varepsilon}^{0,0}$
\end_inset

 y 
\begin_inset Formula $g=p_{2}^{2,0}$
\end_inset

.
 De la definicion de 
\begin_inset Formula $R(f,g)$
\end_inset

, obtenemos que
\begin_inset Formula 
\begin{align*}
R(f,g)(0) & =C_{\varepsilon}^{0,0}(\Diamond)=\varepsilon\\
R(f,g)(t+1) & =p_{2}^{2,0}(t,R(f,g)(t))=R(f,g)(t)
\end{align*}

\end_inset

Es facil notar que la unica funcion que cumple estas dos ecuaciones es 
\begin_inset Formula $C_{\varepsilon}^{1,0}$
\end_inset

 lo cual implica que 
\begin_inset Formula $C_{\varepsilon}^{1,0}=R\left(C_{\varepsilon}^{0,0},p_{2}^{2,0}\right)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
La prueba del siguiente lema es completamente analoga a la del lema anterior
 que fue dejada como ejercicio.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables, entonces 
\begin_inset Formula $R(f,g)$
\end_inset

 lo es.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Recursion primitiva sobre variable alfabetica con valores numericos
\end_layout

\begin_layout Standard
Ya vimos dos casos de recursion donde el parametro que comanda la recursion
 es numerico.
 Daremos a continuacion un ejemplo de recursion en el cual el parametro
 principal es alfabetico.
 Sea 
\begin_inset Formula $\Sigma=\{\%,@,?\}$
\end_inset

 y consideremos las siguientes ecuaciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(\varepsilon)=15$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(\alpha\%)=R(\alpha)+1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $R(\alpha@)=R(\alpha).5$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $R(\alpha?)=R(\alpha)^{20}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que las ecuaciones anteriores determinan una funcion 
\begin_inset Formula $R:\Sigma^{\ast}\rightarrow\omega$
\end_inset

.
 Esto es ya que 
\begin_inset Formula $R$
\end_inset

 en 
\begin_inset Formula $\varepsilon$
\end_inset

 debe valer 
\begin_inset Formula $15$
\end_inset

 y sabiendo esto las ecuaciones (2), (3) y (4) (con 
\begin_inset Formula $\alpha=\varepsilon$
\end_inset

) nos dicen que
\begin_inset Formula 
\begin{align*}
R(\%) & =16\\
R(@) & =75\\
R(?) & =15^{20}
\end{align*}

\end_inset

por lo cual podemos aplicarlas nuevamente a dichas ecuaciones (con 
\begin_inset Formula $\alpha\in\{\%,@,?\}$
\end_inset

) para calcular 
\begin_inset Formula $R$
\end_inset

 en todas las palabras de longitud 
\begin_inset Formula $2$
\end_inset

; y asi sucesivamente.
\end_layout

\begin_layout Standard
Daremos otro ejemplo un poco mas complicado para seguir aproximandonos al
 caso general.
 Nuevamente supongamos que 
\begin_inset Formula $\Sigma=\{\%,@,?\}$
\end_inset

 y supongamos tenemos una funcion 
\begin_inset Formula 
\[
f:\omega\times\Sigma^{\ast}\rightarrow\omega
\]

\end_inset

y tres funciones
\begin_inset Formula 
\begin{align*}
\mathcal{G}_{\%} & :\omega\times\omega\times\Sigma^{\ast}\times\Sigma^{\ast}\rightarrow\omega\\
\mathcal{G}_{@} & :\omega\times\omega\times\Sigma^{\ast}\times\Sigma^{\ast}\rightarrow\omega\\
\mathcal{G}_{?} & :\omega\times\omega\times\Sigma^{\ast}\times\Sigma^{\ast}\rightarrow\omega
\end{align*}

\end_inset

Entonces hay una unica funcion 
\begin_inset Formula $R::\omega\times\Sigma^{\ast}\times\Sigma^{\ast}\rightarrow\omega$
\end_inset

 la cual cumple las siguientes ecuaciones
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(x_{1},\alpha_{1},\varepsilon)=f(x_{1},\alpha_{1})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(x_{1},\alpha_{1},\alpha\%)=\mathcal{G}_{\%}(R(x_{1},\alpha_{1},\alpha),x_{1},\alpha_{1},\alpha)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $R(x_{1},\alpha_{1},\alpha@)=\mathcal{G}_{@}(R(x_{1},\alpha_{1},\alpha),x_{1},\alpha_{1},\alpha)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $R(x_{1},\alpha_{1},\alpha?)=\mathcal{G}_{?}(R(x_{1},\alpha_{1},\alpha),x_{1},\alpha_{1},\alpha)$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
(Justifique que las ecuaciones anteriores determinan a la funcion 
\begin_inset Formula $R$
\end_inset

.)
\end_layout

\begin_layout Standard
El ejemplo anterior nos muestra que para hacer recursion sobre parametro
 alfabetico nos hace falta 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

una funcion 
\begin_inset Formula $g$
\end_inset

 por cada simbolo de 
\begin_inset Formula $\Sigma$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Esto motiva la siguiente definicion.
 Dado un alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

, una 
\shape italic
familia 
\shape default

\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
indexada de funciones
\shape default
 sera una funcion 
\begin_inset Formula $\mathcal{G}$
\end_inset

 tal que 
\begin_inset Formula $D_{\mathcal{G}}=\Sigma$
\end_inset

 y para cada 
\begin_inset Formula $a\in D_{\mathcal{G}}$
\end_inset

 se tiene que 
\begin_inset Formula $\mathcal{G}(a)$
\end_inset

 es una funcion.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset

Sea 
\begin_inset Formula $\mathcal{G}$
\end_inset

 dada por
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathcal{G}:\{\square,\%,\blacktriangle\} & \rightarrow & \{Suc,Pred\}\\
\square & \rightarrow & Suc\\
\% & \rightarrow & Suc\\
\blacktriangle & \rightarrow & Pred
\end{array}
\]

\end_inset

Claramente 
\begin_inset Formula $\mathcal{G}$
\end_inset

 es una familia 
\begin_inset Formula $\{\square,\%,\blacktriangle\}$
\end_inset

-indexada de funciones.
 Notar que
\begin_inset Formula 
\[
\mathcal{G}=\{(\square,Suc),(\%,Suc),(\blacktriangle,Pred)\}
\]

\end_inset

Se tiene tambien por ejemplo que 
\begin_inset Formula $\mathcal{G}(\%)=Suc$
\end_inset

 por lo cual tambien es cierto que 
\begin_inset Formula $\mathcal{G}(\%)(22)=23$
\end_inset

, etc.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset

Si 
\begin_inset Formula $\Sigma$
\end_inset

 es un alfabeto no vacio, la funcion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathcal{G}:\Sigma & \rightarrow & \{f:f\text{ es una funcion de }\Sigma^{\ast}\text{ en }\Sigma^{\ast}\}\\
a & \rightarrow & d_{a}
\end{array}
\]

\end_inset

es una familia 
\begin_inset Formula $\Sigma$
\end_inset

-indexada de funciones.
 Notar que
\begin_inset Formula 
\[
\mathcal{G}=\{(a,d_{a}):a\in\Sigma\}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{3}$
\end_inset


\end_layout

\end_inset


\begin_inset Formula $\emptyset$
\end_inset

 es una flia 
\begin_inset Formula $\emptyset$
\end_inset

-indexada de funciones 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\mathcal{G}$
\end_inset

 es una familia 
\begin_inset Formula $\Sigma$
\end_inset

-indexada de funciones, entonces para 
\begin_inset Formula $a\in\Sigma$
\end_inset

, escribiremos 
\begin_inset Formula $\mathcal{G}_{a}$
\end_inset

 en lugar de 
\begin_inset Formula $\mathcal{G}(a)$
\end_inset

.
 Ahora s, nuestro caso de recursion primitiva.
 Sea
\begin_inset Formula 
\[
f:S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega
\]

\end_inset

con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 conjuntos no vacios y sea 
\begin_inset Formula $\mathcal{G}$
\end_inset

 una familia 
\begin_inset Formula $\Sigma$
\end_inset

-indexada de funciones tal que
\begin_inset Formula 
\[
\mathcal{G}_{a}:\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Sigma^{\ast}\rightarrow\omega
\]

\end_inset

para cada 
\begin_inset Formula $a\in\Sigma.$
\end_inset

 Definamos
\begin_inset Formula 
\[
R(f,\mathcal{G}):S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Sigma^{\ast}\rightarrow\omega
\]

\end_inset

de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,\mathcal{G})(\vec{x},\vec{\alpha},\varepsilon)=f(\vec{x},\vec{\alpha})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(f,\mathcal{G})(\vec{x},\vec{\alpha},\alpha a)=\mathcal{G}_{a}(R(f,\mathcal{G})(\vec{x},\vec{\alpha},\alpha),\vec{x},\vec{\alpha},\alpha)$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Diremos que 
\begin_inset Formula $R(f,\mathcal{G})$
\end_inset

 es obtenida por 
\shape italic
recursion primitiva 
\shape default
a partir de 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $\mathcal{G}$
\end_inset

.
 Notese que cuando 
\begin_inset Formula $m=n=0$
\end_inset

, se tiene que 
\begin_inset Formula $D_{f}=\{\Diamond\}$
\end_inset

 y (1) y (2) se transforman en
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,\mathcal{G})(\varepsilon)=f(\Diamond)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(f,\mathcal{G})(\alpha a)=\mathcal{G}_{a}(R(f,\mathcal{G})(\alpha),\alpha)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $f$
\end_inset

 y cada 
\begin_inset Formula $\mathcal{G}_{a}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables, entonces 
\begin_inset Formula $R(f,\mathcal{G})$
\end_inset

 lo es.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es dejada al lector 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Recursion primitiva sobre variable alfabetica con valores alfabeticos
\end_layout

\begin_layout Standard
Supongamos 
\begin_inset Formula $\Sigma$
\end_inset

 es un alfabeto finito.
 Sea
\begin_inset Formula 
\[
f:S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\Sigma^{\ast}
\]

\end_inset

con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 conjuntos no vacios y sea 
\begin_inset Formula $\mathcal{G}$
\end_inset

 una familia 
\begin_inset Formula $\Sigma$
\end_inset

-indexada de funciones tal que
\begin_inset Formula 
\[
\mathcal{G}_{a}:S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Sigma^{\ast}\times\Sigma^{\ast}\rightarrow\Sigma^{\ast}
\]

\end_inset

para cada 
\begin_inset Formula $a\in\Sigma$
\end_inset

.
 Definamos
\begin_inset Formula 
\[
R(f,\mathcal{G}):S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Sigma^{\ast}\rightarrow\Sigma^{\ast}
\]

\end_inset

de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,\mathcal{G})(\vec{x},\vec{\alpha},\varepsilon)=f(\vec{x},\vec{\alpha})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(f,\mathcal{G})(\vec{x},\vec{\alpha},\alpha a)=\mathcal{G}_{a}(\vec{x},\vec{\alpha},\alpha,R(f,\mathcal{G})(\vec{x},\vec{\alpha},\alpha)).$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Diremos que 
\begin_inset Formula $R(f,\mathcal{G})$
\end_inset

 es obtenida por 
\shape italic
recursion primitiva 
\shape default
a partir de 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $\mathcal{G}$
\end_inset

.
 Notese que cuando 
\begin_inset Formula $m=n=0$
\end_inset

, se tiene que 
\begin_inset Formula $D_{f}=\{\Diamond\}$
\end_inset

 y (1) y (2) se transforman en
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,\mathcal{G})(\varepsilon)=f(\Diamond)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $R(f,\mathcal{G})(\alpha a)=\mathcal{G}_{a}(\alpha,R(f,\mathcal{G})(\alpha))$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
La prueba del siguiente lema es completamente analoga a la del lema anterior
 que fue dejada como ejercicio.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $f$
\end_inset

 y cada 
\begin_inset Formula $\mathcal{G}_{a}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables, entonces 
\begin_inset Formula $R(f,\mathcal{G})$
\end_inset

 lo es.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas primitivas
\end_layout

\begin_layout Standard
Intuitivamente hablando una funcion es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva primitiva si se puede obtener de las iniciales usando los constructor
es de composicion y recursion primitiva.
 Daremos ahora una definicion matematica de este concepto.
 Definamos los conjuntos 
\begin_inset Formula $\mathrm{PR}_{0}^{\Sigma}\subseteq\mathrm{PR}_{1}^{\Sigma}\subseteq\mathrm{PR}_{2}^{\Sigma}\subseteq...\subseteq\mathrm{PR}^{\Sigma}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
\begin{array}{lll}
\mathrm{PR}_{0}^{\Sigma} & = & \left\{ Suc,Pred,C_{0}^{0,0},C_{\varepsilon}^{0,0}\right\} \cup\left\{ d_{a}:a\in\Sigma\right\} \cup\left\{ p_{j}^{n,m}:1\leq j\leq n+m\right\} \\
\mathrm{PR}_{k+1}^{\Sigma} & = & \mathrm{PR}_{k}^{\Sigma}\cup\left\{ f\circ[f_{1},...,f_{r}]:f,f_{1},...,f_{r}\in\mathrm{PR}_{k}^{\Sigma}\text{, }r\geq1\right\} \cup\\
 &  & \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left\{ R(f,\mathcal{G}):f\text{ y cada }\mathcal{G}_{a}\text{ pertenecen a }\mathrm{PR}_{k}^{\Sigma}\right\} \cup\\
 &  & \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left\{ R(f,g):f,g\in\mathrm{PR}_{k}^{\Sigma}\right\} \medskip\\
\mathrm{PR}^{\Sigma} & = & \bigcup_{k\geq0}\mathrm{PR}_{k}^{\Sigma}
\end{array}
\]

\end_inset

Una funcion es llamada 
\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
recursiva primitiva
\shape default
 (
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-p.r.
\shape default
) si pertenece a 
\begin_inset Formula $\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 Si 
\begin_inset Formula $f\in\mathrm{PR}^{\Sigma}$
\end_inset

, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dejamos al lector la prueba por induccion en 
\begin_inset Formula $k$
\end_inset

 de que si 
\begin_inset Formula $f\in\mathrm{PR}_{k}^{\Sigma}$
\end_inset

, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, la cual sale en forma directa usando los lemas
 anteriores que garantizan que los constructores de composicion y recursion
 primitiva preservan la computabilidad efectiva 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Algunas funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas primitivas
\end_layout

\begin_layout Standard
En los siguientes cuatro lemas se prueba bien formalmente que varias funciones
 bien conocidas son 
\begin_inset Formula $\Sigma$
\end_inset

-primitivas recursivas.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\emptyset\in\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\lambda xy\left[x+y\right]\in\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $\lambda xy\left[x.y\right]\in\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $\lambda x\left[x!\right]\in\mathrm{PR}^{\Sigma}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Notese que 
\begin_inset Formula $\emptyset=Pred\circ C_{0}^{0,0}\in\mathrm{PR}_{1}^{\Sigma}$
\end_inset


\end_layout

\begin_layout Standard
(2) Notar que
\begin_inset Formula 
\begin{align*}
\lambda xy\left[x+y\right](0,x_{1}) & =x_{1}=p_{1}^{1,0}(x_{1})\\
\lambda xy\left[x+y\right](t+1,x_{1}) & =\lambda xy\left[x+y\right](t,x_{1})+1\\
 & =\left(Suc\circ p_{1}^{3,0}\right)\left(\lambda xy\left[x+y\right](t,x_{1}),t,x_{1}\right)
\end{align*}

\end_inset

lo cual implica que 
\begin_inset Formula $\lambda xy\left[x+y\right]=R\left(p_{1}^{1,0},Suc\circ p_{1}^{3,0}\right)\in\mathrm{PR}_{2}^{\Sigma}.$
\end_inset


\end_layout

\begin_layout Standard
(3) Primero note que
\begin_inset Formula 
\begin{align*}
C_{0}^{1,0}(0) & =C_{0}^{0,0}(\Diamond)\\
C_{0}^{1,0}(t+1) & =C_{0}^{1,0}(t)
\end{align*}

\end_inset

lo cual implica que 
\begin_inset Formula $C_{0}^{1,0}=R\left(C_{0}^{0,0},p_{1}^{2,0}\right)\in\mathrm{PR}_{1}^{\Sigma}.$
\end_inset

 Tambien note que
\begin_inset Formula 
\[
\lambda tx\left[t.x\right]=R\left(C_{0}^{1,0},\lambda xy\left[x+y\right]\circ\left[p_{1}^{3,0},p_{3}^{3,0}\right]\right),
\]

\end_inset

lo cual por (2) implica que 
\begin_inset Formula $\lambda tx\left[t.x\right]\in\mathrm{PR}_{4}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
(4) Note que
\begin_inset Formula 
\begin{align*}
\lambda x\left[x!\right](0) & =1=C_{1}^{0,0}(\Diamond)\\
\lambda x\left[x!\right](t+1) & =\lambda x\left[x!\right](t).(t+1),
\end{align*}

\end_inset

lo cual implica que
\begin_inset Formula 
\[
\lambda x\left[x!\right]=R\left(C_{1}^{0,0},\lambda xy\left[x.y\right]\circ\left[p_{1}^{2,0},Suc\circ p_{2}^{2,0}\right]\right).
\]

\end_inset

Ya que 
\begin_inset Formula $C_{1}^{0,0}=$
\end_inset

 
\begin_inset Formula $Suc\circ C_{0}^{0,0}$
\end_inset

, tenemos que 
\begin_inset Formula $C_{1}^{0,0}\in\mathrm{PR}_{1}^{\Sigma}$
\end_inset

.
 Por (3), tenemos que
\begin_inset Formula 
\[
\lambda xy\left[x.y\right]\circ\left[p_{1}^{2,0},Suc\circ p_{2}^{2,0}\right]\in\mathrm{PR}_{5}^{\Sigma},
\]

\end_inset

obteniendo que 
\begin_inset Formula $\lambda x\left[x!\right]\in\mathrm{PR}_{6}^{\Sigma}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora consideraremos dos funciones las cuales son obtenidas naturalmente
 por recursion primitiva sobre variable alfabetica.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $\Sigma$
\end_inset

 es un alfabeto finito.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $\lambda\alpha\beta\left[\alpha\beta\right]\in\mathrm{PR}^{\Sigma}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\lambda\alpha\left[\left\vert \alpha\right\vert \right]\in\mathrm{PR}^{\Sigma}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Ya que
\begin_inset Formula 
\begin{align*}
\lambda\alpha\beta\left[\alpha\beta\right](\alpha_{1},\varepsilon) & =\alpha_{1}=p_{1}^{0,1}(\alpha_{1})\\
\lambda\alpha\beta\left[\alpha\beta\right](\alpha_{1},\alpha a) & =d_{a}(\lambda\alpha\beta\left[\alpha\beta\right](\alpha_{1},\alpha)),\ a\in\Sigma
\end{align*}

\end_inset

tenemos que 
\begin_inset Formula $\lambda\alpha\beta\left[\alpha\beta\right]=R\left(p_{1}^{0,1},\mathcal{G}\right)$
\end_inset

, donde 
\begin_inset Formula $\mathcal{G}_{a}=d_{a}\circ p_{3}^{0,3}$
\end_inset

, para cada 
\begin_inset Formula $a\in\Sigma$
\end_inset

.
\end_layout

\begin_layout Standard
(b) Ya que
\begin_inset Formula 
\begin{align*}
\lambda\alpha\left[\left\vert \alpha\right\vert \right](\varepsilon) & =0=C_{0}^{0,0}(\Diamond)\\
\lambda\alpha\left[\left\vert \alpha\right\vert \right](\alpha a) & =\lambda\alpha\left[\left\vert \alpha\right\vert \right](\alpha)+1
\end{align*}

\end_inset

tenemos que 
\begin_inset Formula $\lambda\alpha\left[\left\vert \alpha\right\vert \right]=R\left(C_{0}^{0,0},\mathcal{G}\right)$
\end_inset

, donde 
\begin_inset Formula $\mathcal{G}_{a}=$
\end_inset

 
\begin_inset Formula $Suc\circ p_{1}^{1,1}$
\end_inset

, para cada 
\begin_inset Formula $a\in\Sigma.$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
 Entonces 
\begin_inset Formula $C_{k}^{n,m},C_{\alpha}^{n,m}\in\mathrm{PR}^{\Sigma}$
\end_inset

, para cada 
\begin_inset Formula $n,m,k\geq0$
\end_inset

 y 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Note que 
\begin_inset Formula $C_{k+1}^{0,0}=$
\end_inset

 
\begin_inset Formula $Suc\circ C_{k}^{0,0}$
\end_inset

, lo cual implica 
\begin_inset Formula $C_{k}^{0,0}\in\mathrm{PR}_{k}^{\Sigma}$
\end_inset

, para 
\begin_inset Formula $k\geq0$
\end_inset

.
 Tambien note que 
\begin_inset Formula $C_{\alpha a}^{0,0}=d_{a}\circ C_{\alpha}^{0,0}$
\end_inset

, lo cual dice que 
\begin_inset Formula $C_{\alpha}^{0,0}\in\mathrm{PR}^{\Sigma}$
\end_inset

, para 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

.
 Para ver que 
\begin_inset Formula $C_{k}^{0,1}\in\mathrm{PR}^{\Sigma}$
\end_inset

 notar que
\begin_inset Formula 
\begin{align*}
C_{k}^{0,1}(\varepsilon) & =k=C_{k}^{0,0}(\Diamond)\\
C_{k}^{0,1}(\alpha a) & =C_{k}^{0,1}(\alpha)=p_{1}^{1,1}\left(C_{k}^{0,1}(\alpha),\alpha\right)
\end{align*}

\end_inset

lo cual implica que 
\begin_inset Formula $C_{k}^{0,1}=R\left(C_{k}^{0,0},\mathcal{G}\right)$
\end_inset

, con 
\begin_inset Formula $\mathcal{G}_{a}=p_{1}^{1,1}$
\end_inset

, 
\begin_inset Formula $a\in\Sigma$
\end_inset

.
 En forma similar podemos ver que 
\begin_inset Formula $C_{k}^{1,0},C_{\alpha}^{1,0},C_{\alpha}^{0,1}\in\mathrm{PR}^{\Sigma}$
\end_inset

.
 Supongamos ahora que 
\begin_inset Formula $m>0$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
C_{k}^{n,m} & =C_{k}^{0,1}\circ p_{n+1}^{n,m}\\
C_{\alpha}^{n,m} & =C_{\alpha}^{0,1}\circ p_{n+1}^{n,m}
\end{align*}

\end_inset

de lo cual obtenemos que 
\begin_inset Formula $C_{k}^{n,m},C_{\alpha}^{n,m}\in\mathrm{PR}^{\Sigma}$
\end_inset

.
 El caso 
\begin_inset Formula $n>0$
\end_inset

 es similar.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $\lambda xy\left[x^{y}\right]\in\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\lambda t\alpha\left[\alpha^{t}\right]\in\mathrm{PR}^{\Sigma}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Note que
\begin_inset Formula 
\[
\lambda tx\left[x^{t}\right]=R\left(C_{1}^{1,0},\lambda xy\left[x.y\right]\circ\left[p_{1}^{3,0},p_{3}^{3,0}\right]\right)\in\mathrm{PR}^{\Sigma}.
\]

\end_inset

O sea que 
\begin_inset Formula $\lambda xy\left[x^{y}\right]=\lambda tx\left[x^{t}\right]\circ\left[p_{2}^{2,0},p_{1}^{2,0}\right]\in\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
(b) Note que
\begin_inset Formula 
\[
\lambda t\alpha\left[\alpha^{t}\right]=R\left(C_{\varepsilon}^{0,1},\lambda\alpha\beta\left[\alpha\beta\right]\circ\left[p_{3}^{1,2},p_{2}^{1,2}\right]\right)\in\mathrm{PR}^{\Sigma}.
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora probaremos que si 
\begin_inset Formula $\Sigma$
\end_inset

 es no vacio, entonces las biyeciones naturales entre 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $\omega$
\end_inset

, dadas en el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "biyeccion0"
plural "false"
caps "false"
noprefix "false"

\end_inset

, son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "sonpr"

\end_inset

Si 
\begin_inset Formula $\leq$
\end_inset

 es un orden total sobre un alfabeto no vacio 
\begin_inset Formula $\Sigma$
\end_inset

, entonces 
\begin_inset Formula $s^{\leq}$
\end_inset

, 
\begin_inset Formula $\#^{\leq}$
\end_inset

 y 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 pertenecen a 
\begin_inset Formula $\mathrm{PR}^{\Sigma}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $\Sigma=\{a_{1},...,a_{k}\}$
\end_inset

 y 
\begin_inset Formula $\leq$
\end_inset

 es dado por 
\begin_inset Formula $a_{1}<...<a_{k}$
\end_inset

.
 Ya que
\begin_inset Formula 
\begin{align*}
s^{\leq}(\varepsilon) & =a_{1}\\
s^{\leq}(\alpha a_{i}) & =\alpha a_{i+1}\text{, para }i<k\\
s^{\leq}(\alpha a_{k}) & =s^{\leq}(\alpha)a_{1}
\end{align*}

\end_inset

tenemos que 
\begin_inset Formula $s^{\leq}=R\left(C_{a_{1}}^{0,0},\mathcal{G}\right)$
\end_inset

, donde 
\begin_inset Formula $\mathcal{G}_{a_{i}}=d_{a_{i+1}}\circ p_{1}^{0,2}$
\end_inset

, para 
\begin_inset Formula $i=1,...,k-1$
\end_inset

 y 
\begin_inset Formula $\mathcal{G}_{a_{k}}=d_{a_{1}}\circ p_{2}^{0,2}.$
\end_inset

 O sea que 
\begin_inset Formula $s^{\leq}\in\mathrm{PR}^{\Sigma}.$
\end_inset

 Ya que
\begin_inset Formula 
\begin{align*}
\ast^{\leq}(0) & =\varepsilon\\
\ast^{\leq}(t+1) & =s^{\leq}(\ast^{\leq}(t))
\end{align*}

\end_inset

podemos ver que 
\begin_inset Formula $\ast^{\leq}\in\mathrm{PR}^{\Sigma}$
\end_inset

.
 Ya que
\begin_inset Formula 
\begin{align*}
\#^{\leq}(\varepsilon) & =0\\
\#^{\leq}(\alpha a_{i}) & =\#^{\leq}(\alpha).k+i\text{, para }i=1,...,k,
\end{align*}

\end_inset

tenemos que 
\begin_inset Formula $\#^{\leq}=R\left(C_{0}^{0,0},\mathcal{G}\right)$
\end_inset

, donde
\begin_inset Formula 
\[
\mathcal{G}_{a_{i}}=\lambda xy\left[x+y\right]\circ\left[\lambda xy\left[x.y\right]\circ\left[p_{1}^{1,1},C_{k}^{1,1}\right],C_{i}^{1,1}\right]\text{, para }i=1,...,k\text{.}
\]

\end_inset

O sea que 
\begin_inset Formula $\#^{\leq}\in\mathrm{PR}^{\Sigma}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dados 
\begin_inset Formula $x,y\in\omega$
\end_inset

, definamos
\begin_inset Formula 
\[
x\dot{-}y=\max(x-y,0).
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma

\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $\lambda xy\left[x\dot{-}y\right]\in\mathrm{PR}^{\Sigma}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\lambda xy\left[\max(x,y)\right]\in\mathrm{PR}^{\Sigma}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset


\begin_inset Formula $\lambda xy\left[x=y\right]\in\mathrm{PR}^{\Sigma}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(d)
\end_layout

\end_inset


\begin_inset Formula $\lambda xy\left[x\leq y\right]\in\mathrm{PR}^{\Sigma}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(e)
\end_layout

\end_inset


\begin_inset Formula $\lambda\alpha\beta\left[\alpha=\beta\right]\in\mathrm{PR}^{\Sigma}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Primero notar que 
\begin_inset Formula $\lambda x\left[x\dot{-}1\right]=R\left(C_{0}^{0,0},p_{2}^{2,0}\right)\in\mathrm{PR}^{\Sigma}.$
\end_inset

 Tambien note que
\begin_inset Formula 
\[
\lambda tx\left[x\dot{-}t\right]=R\left(p_{1}^{1,0},\lambda x\left[x\dot{-}1\right]\circ p_{1}^{3,0}\right)\in\mathrm{PR}^{\Sigma}.
\]

\end_inset

O sea que 
\begin_inset Formula $\lambda xy\left[x\dot{-}y\right]=\lambda tx\left[x\dot{-}t\right]\circ\left[p_{2}^{2,0},p_{1}^{2,0}\right]\in\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
(b) Note que 
\begin_inset Formula $\lambda xy\left[\max(x,y)\right]=\lambda xy\left[x+(y\dot{-}x)\right]$
\end_inset

.
\end_layout

\begin_layout Standard
(c) Note que 
\begin_inset Formula $\lambda xy\left[x=y\right]=\lambda xy\left[1\dot{-}((x\dot{-}y)+(y\dot{-}x))\right]$
\end_inset

.
\end_layout

\begin_layout Standard
(d) Note que 
\begin_inset Formula $\lambda xy\left[x\leq y\right]=\lambda xy\left[1\dot{-}(x\dot{-}y)\right]$
\end_inset

.
\end_layout

\begin_layout Standard
(e) Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma.$
\end_inset

 Ya que
\begin_inset Formula 
\[
\alpha=\beta\text{ sii }\#^{\leq}(\alpha)=\#^{\leq}(\beta)
\]

\end_inset

tenemos que
\begin_inset Formula 
\[
\lambda\alpha\beta\left[\alpha=\beta\right]=\lambda xy\left[x=y\right]\circ\left[\#^{\leq}\circ p_{1}^{0,2},\#^{\leq}\circ p_{2}^{0,2}\right]
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $\lambda\alpha\beta\left[\alpha=\beta\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Operaciones logicas entre predicados
\end_layout

\begin_layout Standard
Dados predicados 
\begin_inset Formula $P:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 y 
\begin_inset Formula $Q:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

, con el mismo dominio, definamos nuevos predicados 
\begin_inset Formula $(P\vee Q)$
\end_inset

, 
\begin_inset Formula $(P\wedge Q)$
\end_inset

 y 
\begin_inset Formula $\lnot P$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\begin{align*}
 & \begin{array}{rll}
(P\vee Q):S & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
1 &  & \text{si }P(\vec{x},\vec{\alpha})=1\text{ o }Q(\vec{x},\vec{\alpha})=1\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}\\
 & \begin{array}{rll}
(P\wedge Q):S & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
1 &  & \text{si }P(\vec{x},\vec{\alpha})=1\text{ y }Q(\vec{x},\vec{\alpha})=1\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}\\
 & \begin{array}{rll}
\lnot P:S & \rightarrow & \omega\\
(\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
1 &  & \text{si }P(\vec{x},\vec{\alpha})=0\\
0 &  & \text{si }P(\vec{x},\vec{\alpha})=1
\end{array}\right.
\end{array}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "boolean op"

\end_inset

Si 
\begin_inset Formula $P:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 y 
\begin_inset Formula $Q:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 son predicados 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., entonces 
\begin_inset Formula $(P\vee Q)$
\end_inset

, 
\begin_inset Formula $(P\wedge Q)$
\end_inset

 y 
\begin_inset Formula $\lnot P$
\end_inset

 lo son tambien.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Note que
\begin_inset Formula 
\begin{align*}
\lnot P & =\lambda xy\left[x\dot{-}y\right]\circ\left[C_{1}^{n,m},P\right]\\
(P\wedge Q) & =\lambda xy\left[x.y\right]\circ[P,Q]\\
(P\vee Q) & =\lnot(\lnot P\wedge\lnot Q).
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-recursivos primitivos
\end_layout

\begin_layout Standard
Un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-mixto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-recursivo primitivo
\shape default
 si su funcion caracteristica 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 (Notese que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es el predicado 
\begin_inset Formula $\lambda\vec{x}\vec{\alpha}\left[(\vec{x},\vec{\alpha})\in S\right]$
\end_inset

.)
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "union"

\end_inset

Si 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., entonces 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

, 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 y 
\begin_inset Formula $S_{1}-S_{2}$
\end_inset

 lo son.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Note que
\begin_inset Formula 
\begin{align*}
\chi_{S_{1}\cup S_{2}}^{\omega^{n}\times\Sigma^{\ast m}} & =(\chi_{S_{1}}^{\omega^{n}\times\Sigma^{\ast m}}\vee\chi_{S_{2}}^{\omega^{n}\times\Sigma^{\ast m}})\\
\chi_{S_{1}\cap S_{2}}^{\omega^{n}\times\Sigma^{\ast m}} & =(\chi_{S_{1}}^{\omega^{n}\times\Sigma^{\ast m}}\wedge\chi_{S_{2}}^{\omega^{n}\times\Sigma^{\ast m}})\\
\chi_{S_{1}-S_{2}}^{\omega^{n}\times\Sigma^{\ast m}} & =\lambda xy\left[x\dot{-}y\right]\circ\left[\chi_{S_{1}}^{\omega^{n}\times\Sigma^{\ast m}},\chi_{S_{2}}^{\omega^{n}\times\Sigma^{\ast m}}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 
\begin_inset CommandInset label
LatexCommand label
name "finito"

\end_inset

Si 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es finito, entonces 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Si 
\begin_inset Formula $S=\emptyset$
\end_inset

, entonces es claro que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Probaremos ahora el lema para el caso en que 
\begin_inset Formula $S$
\end_inset

 tiene un solo elemento.
 Supongamos entonces
\begin_inset Formula 
\[
S=\{(z_{1},...,z_{n},\gamma_{1},...,\gamma_{m})\}.
\]

\end_inset

Note que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es el siguiente predicado
\begin_inset Formula 
\[
\left(\chi_{\{z_{1}\}}^{\omega}\circ p_{1}^{n,m}\wedge...\wedge\chi_{\{z_{n}\}}^{\omega}\circ p_{n}^{n,m}\wedge\chi_{\{\gamma_{1}\}}^{\Sigma^{\ast}}\circ p_{n+1}^{n,m}\wedge...\wedge\chi_{\{\gamma_{m}\}}^{\Sigma^{\ast}}\circ p_{n+m}^{n,m}\right).
\]

\end_inset

Ya que los predicados
\begin_inset Formula 
\begin{align*}
\chi_{\{z_{i}\}}^{\omega} & =\lambda xy\left[x=y\right]\circ\left[p_{1}^{1,0},C_{z_{i}}^{1,0}\right]\\
\chi_{\{\gamma_{i}\}}^{\Sigma^{\ast}} & =\lambda\alpha\beta\left[\alpha=\beta\right]\circ\left[p_{1}^{0,1},C_{\gamma_{i}}^{0,1}\right]
\end{align*}

\end_inset

son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "boolean op"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (aplicado 
\begin_inset Formula $(n+m)-1$
\end_inset

 veces), implica que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Cuando 
\begin_inset Formula $S$
\end_inset

 tiene mas de un elemento, ya que entonces es la union de una cantidad finita
 de conjuntos de un solo elemento, se puede aplicar el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "union"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (
\begin_inset Formula $\left\vert S\right\vert -1$
\end_inset

 veces) para obtener que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente lema caracteriza cuando un conjunto rectangular es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "rectangulos pr"

\end_inset

Supongamos 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

, 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 son conjuntos no vacios.
 Entonces 
\begin_inset Formula $S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 sii 
\begin_inset Formula $S_{1},...,S_{n},L_{1},...,L_{m}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (
\begin_inset Formula $\Rightarrow$
\end_inset

) Veremos por ejemplo que 
\begin_inset Formula $L_{1}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $(z_{1},...,z_{n},\zeta_{1},...,\zeta_{m})$
\end_inset

 un elemento fijo de 
\begin_inset Formula $S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}.$
\end_inset

 Note que
\begin_inset Formula 
\[
\alpha\in L_{1}\text{ sii }(z_{1},...,z_{n},\alpha,\zeta_{2},...,\zeta_{m})\in S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m},
\]

\end_inset

lo cual implica que
\begin_inset Formula 
\[
\chi_{L_{1}}^{\Sigma^{\ast}}=\chi_{S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}}^{\omega^{n}\times\Sigma^{\ast m}}\circ\left[C_{z_{1}}^{0,1},...,C_{z_{n}}^{0,1},p_{1}^{0,1},C_{\zeta_{2}}^{0,1},...,C_{\zeta_{m}}^{0,1}\right]
\]

\end_inset

(
\begin_inset Formula $\Leftarrow$
\end_inset

) Note que 
\begin_inset Formula $\chi_{S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es el predicado
\begin_inset Formula 
\[
\left(\chi_{S_{1}}^{\omega}\circ p_{1}^{n,m}\wedge...\wedge\chi_{S_{n}}^{\omega}\circ p_{n}^{n,m}\wedge\chi_{L_{1}}^{\Sigma^{\ast}}\circ p_{n+1}^{n,m}\wedge...\wedge\chi_{L_{m}}^{\Sigma^{\ast}}\circ p_{n+m}^{n,m}\right).
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dada una funcion 
\begin_inset Formula $f$
\end_inset

 y un conjunto 
\begin_inset Formula $S\subseteq D_{f}$
\end_inset

, usaremos 
\begin_inset Formula $f|_{S}$
\end_inset

 para denotar la 
\shape italic
restriccion
\shape default
 de 
\begin_inset Formula $f$
\end_inset

 al conjunto 
\begin_inset Formula $S$
\end_inset

, i.e.
 
\begin_inset Formula $f|_{S}=f\cap(S\times I_{f})$
\end_inset

.
 Notese que 
\begin_inset Formula $f|_{S}$
\end_inset

 es la funcion dada por
\begin_inset Formula 
\[
D_{f|_{S}}=S\text{ \ \ \ y \ \ }f|_{S}(e)=f(e)\text{, para cada }e\in S
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "restriccion"

\end_inset

Sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

.
 Supongamos 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Si 
\begin_inset Formula $S\subseteq D_{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., entonces 
\begin_inset Formula $f|_{S}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
f|_{S}=\lambda x\alpha\left[\alpha^{x}\right]\circ\left[Suc\circ Pred\circ\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}},f\right]
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $f|_{S}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 El caso 
\begin_inset Formula $O=\omega$
\end_inset

 es similar usando 
\begin_inset Formula $\lambda xy\left[x^{y}\right]$
\end_inset

 en lugar de 
\begin_inset Formula $\lambda x\alpha\left[\alpha^{x}\right]$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Usando el lema anterior en combinacion con el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "boolean op"
plural "false"
caps "false"
noprefix "false"

\end_inset

 podemos ver que muchos predicados usuales son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Por ejemplo sea
\begin_inset Formula 
\[
P=\lambda x\alpha\beta\gamma\left[x=\left\vert \gamma\right\vert \wedge\alpha=\gamma^{Pred(\left\vert \beta\right\vert )}\right].
\]

\end_inset

Notese que
\begin_inset Formula 
\[
D_{P}=\omega\times\Sigma^{\ast}\times(\Sigma^{\ast}-\{\varepsilon\})\times\Sigma^{\ast}
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 ya que
\begin_inset Formula 
\[
\chi_{D_{P}}^{\omega\times\Sigma^{\ast3}}=\lnot\lambda\alpha\beta\left[\alpha=\beta\right]\circ\left[p_{3}^{1,3},C_{\varepsilon}^{1,3}\right]
\]

\end_inset

Tambien note que los predicados
\begin_inset Formula 
\begin{align*}
 & \lambda x\alpha\beta\gamma\left[x=\left\vert \gamma\right\vert \right]\\
 & \lambda x\alpha\beta\gamma\left[\alpha=\gamma^{Pred(\left\vert \beta\right\vert )}\right]
\end{align*}

\end_inset

son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 ya que pueden obtenerse componiendo funciones 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 O sea que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 ya que
\begin_inset Formula 
\[
P=\left(\lambda x\alpha\beta\gamma\left[x=\left\vert \gamma\right\vert \right]|_{D_{P}}\wedge\lambda x\alpha\beta\gamma\left[\alpha=\gamma^{Pred(\left\vert \beta\right\vert )}\right]\right).
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "extension"

\end_inset

Sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

.
 Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., entonces existe una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $\bar{f}:\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

, tal que 
\begin_inset Formula $f=\bar{f}|_{D_{f}}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es facil ver por induccion en 
\begin_inset Formula $k$
\end_inset

 que el enunciado se cumple para cada 
\begin_inset Formula $f\in\mathrm{PR}_{k}^{\Sigma}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora podemos probar el siguiente importante resultado
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "caract-dominios"

\end_inset

Un conjunto 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 sii 
\begin_inset Formula $S$
\end_inset

 es el dominio de alguna funcion 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\begin_inset Formula $.$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos que 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
(
\begin_inset Formula $\Rightarrow$
\end_inset

) Note que 
\begin_inset Formula $S=D_{Pred\circ\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}}$
\end_inset

.
\end_layout

\begin_layout Standard
(
\begin_inset Formula $\Leftarrow$
\end_inset

) Probaremos por induccion en 
\begin_inset Formula $k$
\end_inset

 que 
\begin_inset Formula $D_{F}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., para cada 
\begin_inset Formula $F\in\mathrm{PR}_{k}^{\Sigma}.$
\end_inset

 El caso 
\begin_inset Formula $k=0$
\end_inset

 es facil
\begin_inset Formula $.$
\end_inset

 Supongamos el resultado vale para un 
\begin_inset Formula $k$
\end_inset

 fijo y supongamos 
\begin_inset Formula $F\in\mathrm{PR}_{k+1}^{\Sigma}.$
\end_inset

 Veremos entonces que 
\begin_inset Formula $D_{F}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Hay varios casos.
 Consideremos primero el caso en que 
\begin_inset Formula $F=R(f,g)$
\end_inset

, donde
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\Sigma^{\ast}\\
g & :\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Sigma^{\ast}\rightarrow\Sigma^{\ast},
\end{align*}

\end_inset

con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 conjuntos no vacios y 
\begin_inset Formula $f,g\in\mathrm{PR}_{k}^{\Sigma}$
\end_inset

.
 Notese que por definicion de 
\begin_inset Formula $R(f,g)$
\end_inset

, tenemos que
\begin_inset Formula 
\[
D_{F}=\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}.
\]

\end_inset

Por hipotesis inductiva tenemos que 
\begin_inset Formula $D_{f}=S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., lo cual por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "rectangulos pr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que los conjuntos 
\begin_inset Formula $S_{1},...,S_{n}$
\end_inset

, 
\begin_inset Formula $L_{1},...,L_{m}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Ya que 
\begin_inset Formula $\omega$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "rectangulos pr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $D_{F}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard
Los otros casos de recursion primitiva son dejados al lector.
\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $F=g\circ[g_{1},...,g_{r}]$
\end_inset

 con 
\begin_inset Formula $g,g_{1},...,g_{r}\in\mathrm{PR}_{k}^{\Sigma}$
\end_inset

.
 Si 
\begin_inset Formula $F=\emptyset$
\end_inset

, entonces es claro que 
\begin_inset Formula $D_{F}=\emptyset$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Supongamos entonces que 
\begin_inset Formula $F$
\end_inset

 no es la funcion 
\begin_inset Formula $\emptyset$
\end_inset

.
 Tenemos entonces que 
\begin_inset Formula $r$
\end_inset

 es de la forma 
\begin_inset Formula $n+m$
\end_inset

 y
\begin_inset Formula 
\begin{align*}
g & :D_{g}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O\\
g_{i} & :D_{g_{i}}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\omega\text{, }i=1,...,n\\
g_{i} & :D_{g_{i}}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\Sigma^{\ast},i=n+1,...,n+m
\end{align*}

\end_inset

con 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

 y 
\begin_inset Formula $k,l\in\omega$
\end_inset

.
 Por Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "extension"
plural "false"
caps "false"
noprefix "false"

\end_inset

, hay funciones 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $\bar{g}_{1},...,\bar{g}_{n+m}$
\end_inset

 las cuales son 
\begin_inset Formula $\Sigma$
\end_inset

-totales y cumplen
\begin_inset Formula 
\[
g_{i}=\bar{g}_{i}|_{D_{g_{i}}}\text{, para }i=1,...,n+m.
\]

\end_inset

Por hipotesis inductiva los conjuntos 
\begin_inset Formula $D_{g}$
\end_inset

, 
\begin_inset Formula $D_{g_{i}}$
\end_inset

, 
\begin_inset Formula $i=1,...,n+m$
\end_inset

, son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 y por lo tanto
\begin_inset Formula 
\[
S=\bigcap_{i=1}^{n+m}D_{g_{i}}
\]

\end_inset

lo es.
 Notese que
\begin_inset Formula 
\[
\chi_{D_{F}}^{\omega^{k}\times\Sigma^{\ast l}}=(\chi_{D_{g}}^{\omega^{n}\times\Sigma^{\ast m}}\circ\left[\bar{g}_{1},...,\bar{g}_{n+m}\right]\wedge\chi_{S}^{\omega^{k}\times\Sigma^{\ast l}})
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $D_{F}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Lema de division por casos para funciones 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
Una observacion interesante es que si 
\begin_inset Formula $f_{i}:D_{f_{i}}\rightarrow O$
\end_inset

, 
\begin_inset Formula $i=1,...,k$
\end_inset

, son funciones tales que 
\begin_inset Formula $D_{f_{i}}\cap D_{f_{j}}=\emptyset$
\end_inset

 para 
\begin_inset Formula $i\neq j$
\end_inset

, entonces 
\begin_inset Formula $f_{1}\cup...\cup f_{k}$
\end_inset

 es la funcion
\begin_inset Formula 
\[
\begin{array}{rll}
D_{f_{1}}\cup...\cup D_{f_{k}} & \rightarrow & O\\
e & \rightarrow & \left\{ \begin{array}{clc}
f_{1}(e) &  & \text{si }e\in D_{f_{1}}\\
\vdots &  & \vdots\\
f_{k}(e) &  & \text{si }e\in D_{f_{k}}
\end{array}\right.
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "dpc"

\end_inset

Sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

.
 Supongamos 
\begin_inset Formula $f_{i}:D_{f_{i}}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

, 
\begin_inset Formula $i=1,...,k$
\end_inset

, son funciones 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 tales que 
\begin_inset Formula $D_{f_{i}}\cap D_{f_{j}}=\emptyset$
\end_inset

 para 
\begin_inset Formula $i\neq j.$
\end_inset

 Entonces 
\begin_inset Formula $f_{1}\cup...\cup f_{k}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $k=2.$
\end_inset

 Sean
\begin_inset Formula 
\[
\bar{f}_{i}:\omega^{n}\times\Sigma^{\ast m}\rightarrow\Sigma^{\ast},i=1,2,
\]

\end_inset

funciones 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 tales que 
\begin_inset Formula $\bar{f}_{i}|_{D_{f_{i}}}=f_{i}$
\end_inset

, 
\begin_inset Formula $i=1,2$
\end_inset

 (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "extension"
plural "false"
caps "false"
noprefix "false"

\end_inset

)
\begin_inset Formula $.$
\end_inset

 Por Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "caract-dominios"
plural "false"
caps "false"
noprefix "false"

\end_inset

 los conjuntos 
\begin_inset Formula $D_{f_{1}}$
\end_inset

 y 
\begin_inset Formula $D_{f_{2}}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 y por lo tanto lo es 
\begin_inset Formula $D_{f_{1}}\cup D_{f_{2}}$
\end_inset

.
 Ya que
\begin_inset Formula 
\[
f_{1}\cup f_{2}=\left(\lambda\alpha\beta\left[\alpha\beta\right]\circ\left[\lambda x\alpha\left[\alpha^{x}\right]\circ\left[\chi_{D_{f_{1}}}^{\omega^{n}\times\Sigma^{\ast m}},\bar{f}_{1}\right],\lambda x\alpha\left[\alpha^{x}\right]\circ\left[\chi_{D_{f_{2}}}^{\omega^{n}\times\Sigma^{\ast m}},\bar{f}_{2}\right]\right]\right)|_{D_{f_{1}}\cup D_{f_{2}}}
\]

\end_inset

tenemos que 
\begin_inset Formula $f_{1}\cup f_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard
El caso 
\begin_inset Formula $k>2$
\end_inset

 puede probarse por induccion ya que
\begin_inset Formula 
\[
f_{1}\cup...\cup f_{k}=(f_{1}\cup...\cup f_{k-1})\cup f_{k}.
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 
\begin_inset CommandInset label
LatexCommand label
name "dom-finito"

\end_inset

Supongamos 
\begin_inset Formula $f$
\end_inset

 es una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta cuyo dominio es finito.
 Entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

, con 
\begin_inset Formula $D_{f}=\{e_{1},...,e_{k}\}$
\end_inset

.
 Por el Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "finito"
plural "false"
caps "false"
noprefix "false"

\end_inset

, cada 
\begin_inset Formula $\{e_{i}\}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 por lo cual el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "restriccion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $C_{f(e_{i})}^{n,m}|_{\{e_{i}\}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 O sea que
\begin_inset Formula 
\[
f=C_{f(e_{1})}^{n,m}|_{\{e_{1}\}}\cup...\cup C_{f(e_{k})}^{n,m}|_{\{e_{k}\}}
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que dados 
\begin_inset Formula $i\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, definimos
\begin_inset Formula 
\[
\left[\alpha\right]_{i}=\left\{ \begin{array}{lll}
i\text{-esimo elemento de }\alpha &  & \text{si }1\leq i\leq\left\vert \alpha\right\vert \\
\varepsilon &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $\lambda i\alpha\left[[\alpha]_{i}\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Note que
\begin_inset Formula 
\begin{align*}
[\varepsilon]_{i} & =\varepsilon\\{}
[\alpha a]_{i} & =\left\{ \begin{array}{lll}
[\alpha]_{i} &  & \text{si }i\neq\left\vert \alpha\right\vert +1\\
a &  & \text{si }i=\left\vert \alpha\right\vert +1
\end{array}\right.
\end{align*}

\end_inset

lo cual dice que 
\begin_inset Formula $\lambda i\alpha\left[[\alpha]_{i}\right]=R\left(C_{\varepsilon}^{1,0},\mathcal{G}\right)$
\end_inset

, donde 
\begin_inset Formula $\mathcal{G}_{a}:\omega\times\Sigma^{\ast}\times\Sigma^{\ast}\rightarrow\Sigma^{\ast}$
\end_inset

 es dada por
\begin_inset Formula 
\[
\mathcal{G}_{a}(i,\alpha,\zeta)=\left\{ \begin{array}{lll}
\zeta &  & \text{si }i\neq\left\vert \alpha\right\vert +1\\
a &  & \text{si }i=\left\vert \alpha\right\vert +1
\end{array}\right.
\]

\end_inset

O sea que solo resta probar que cada 
\begin_inset Formula $\mathcal{G}_{a}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Primero note que los conjuntos
\begin_inset Formula 
\begin{align*}
S_{1} & =\left\{ (i,\alpha,\zeta)\in\omega\times\Sigma^{\ast}\times\Sigma^{\ast}:i\neq\left\vert \alpha\right\vert +1\right\} \\
S_{2} & =\left\{ (i,\alpha,\zeta)\in\omega\times\Sigma^{\ast}\times\Sigma^{\ast}:i=\left\vert \alpha\right\vert +1\right\} 
\end{align*}

\end_inset

son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 ya que
\begin_inset Formula 
\begin{align*}
\chi_{S_{1}}^{\omega\times\Sigma^{\ast}\times\Sigma^{\ast}} & =\lambda xy\left[x\neq y\right]\circ\left[p_{1}^{1,2},Suc\circ\lambda\alpha\left[\left\vert \alpha\right\vert \right]\circ p_{2}^{1,2}\right]\\
\chi_{S_{2}}^{\omega\times\Sigma^{\ast}\times\Sigma^{\ast}} & =\lambda xy\left[x=y\right]\circ\left[p_{1}^{1,2},Suc\circ\lambda\alpha\left[\left\vert \alpha\right\vert \right]\circ p_{2}^{1,2}\right]
\end{align*}

\end_inset

Ya que
\begin_inset Formula 
\[
\mathcal{G}_{a}=p_{3}^{1,2}|_{S_{1}}\cup C_{a}^{1,2}|_{S_{2}}
\]

\end_inset

el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "dpc"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $\mathcal{G}_{a}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., para cada 
\begin_inset Formula $a\in\Sigma$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Sumatoria, productoria y concatenatoria de funciones 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
 Sea 
\begin_inset Formula $f:\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega$
\end_inset

, con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 no vacios.
 Para 
\begin_inset Formula $x,y\in\omega$
\end_inset

 y 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

, definamos
\begin_inset Formula 
\begin{align*}
\sum\limits _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha}) & =\left\{ \begin{array}{lll}
0 &  & \text{si }x>y\\
f(x,\vec{x},\vec{\alpha})+f(x+1,\vec{x},\vec{\alpha})+...+f(y,\vec{x},\vec{\alpha}) &  & \text{si }x\leq y
\end{array}\right.\\
\prod\limits _{t=x}^{t=y}f(t,\vec{x},\vec{\alpha}) & =\left\{ \begin{array}{lll}
1 &  & \text{si }x>y\\
f(x,\vec{x},\vec{\alpha}).f(x+1,\vec{x},\vec{\alpha})....f(y,\vec{x},\vec{\alpha}) &  & \text{si }x\leq y
\end{array}\right.
\end{align*}

\end_inset

En forma similar, cuando 
\begin_inset Formula $I_{f}\subseteq\Sigma^{\ast}$
\end_inset

, definamos
\begin_inset Formula 
\[
\overset{t=y}{\underset{t=x}{\subset}}f(t,\vec{x},\vec{\alpha})=\left\{ \begin{array}{lll}
\varepsilon &  & \text{si }x>y\\
f(x,\vec{x},\vec{\alpha})f(x+1,\vec{x},\vec{\alpha})....f(y,\vec{x},\vec{\alpha}) &  & \text{si }x\leq y
\end{array}\right.
\]

\end_inset

Note que, en virtud de la definicion anterior, el dominio de las funciones
\begin_inset Formula 
\[
\lambda xy\vec{x}\vec{\alpha}\left[\sum_{t=x}^{t=y}f(t,\vec{x},\vec{\alpha})\right]\ \ \ \ \ \ \ \ \ \ \ \ \lambda xy\vec{x}\vec{\alpha}\left[\prod_{t=x}^{t=y}f(t,\vec{x},\vec{\alpha})\right]\ \ \ \ \ \ \ \ \ \ \ \ \lambda xy\vec{x}\vec{\alpha}\left[\subset_{t=x}^{t=y}f(t,\vec{x},\vec{\alpha})\right]
\]

\end_inset

es 
\begin_inset Formula $\omega\times\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "iteracion"

\end_inset

Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Si 
\begin_inset Formula $f:\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 no vacios, entonces las funciones 
\begin_inset Formula $\lambda xy\vec{x}\vec{\alpha}\left[\sum_{t=x}^{t=y}f(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 y 
\begin_inset Formula $\lambda xy\vec{x}\vec{\alpha}\left[\prod_{t=x}^{t=y}f(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si 
\begin_inset Formula $f:\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\Sigma^{\ast}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 no vacios, entonces la funcion 
\begin_inset Formula $\lambda xy\vec{x}\vec{\alpha}\left[\subset_{t=x}^{t=y}f(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Sea 
\begin_inset Formula $G=\lambda tx\vec{x}\vec{\alpha}\left[\sum_{i=x}^{i=t}f(i,\vec{x},\vec{\alpha})\right]$
\end_inset

.
 Ya que
\begin_inset Formula 
\[
\lambda xy\vec{x}\vec{\alpha}\left[\sum_{i=x}^{i=y}f(i,\vec{x},\vec{\alpha})\right]=G\circ\left[p_{2}^{n+2,m},p_{1}^{n+2,m},p_{3}^{n+2,m},...,p_{n+m+2}^{n+2,m}\right]
\]

\end_inset

solo tenemos que probar que 
\begin_inset Formula $G$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Primero note que
\begin_inset Formula 
\begin{align*}
G(0,x,\vec{x},\vec{\alpha}) & =\left\{ \begin{array}{lll}
0 &  & \text{si }x>0\\
f(0,\vec{x},\vec{\alpha}) &  & \text{si }x=0
\end{array}\right.\\
G(t+1,x,\vec{x},\vec{\alpha}) & =\left\{ \begin{array}{lll}
0 &  & \text{si }x>t+1\\
G(t,x,\vec{x},\vec{\alpha})+f(t+1,\vec{x},\vec{\alpha}) &  & \text{si }x\leq t+1
\end{array}\right.
\end{align*}

\end_inset

O sea que si definimos
\begin_inset Formula 
\[
\begin{array}{rll}
h:\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m} & \rightarrow & \omega\\
(x,\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
0 &  & \text{si }x>0\\
f(0,\vec{x},\vec{\alpha}) &  & \text{si }x=0
\end{array}\right.
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{rll}
g:\omega^{3}\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m} & \rightarrow & \omega\\
(A,t,x,\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
0 &  & \text{si }x>t+1\\
A+f(t+1,\vec{x},\vec{\alpha}) &  & \text{si }x\leq t+1
\end{array}\right.
\end{array}
\]

\end_inset

tenemos que 
\begin_inset Formula $G=R(h,g)$
\end_inset

.
 Es decir que solo nos falta probar que 
\begin_inset Formula $h$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Sean
\begin_inset Formula 
\begin{align*}
D_{1} & =\left\{ (x,\vec{x},\vec{\alpha})\in\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}:x>0\right\} \\
D_{2} & =\left\{ (x,\vec{x},\vec{\alpha})\in\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}:x=0\right\} \\
H_{1} & =\left\{ (z,t,x,\vec{x},\vec{\alpha})\in\omega^{3}\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}:x>t+1\right\} \\
H_{2} & =\left\{ (z,t,x,\vec{x},\vec{\alpha})\in\omega^{3}\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}:x\leq t+1\right\} .
\end{align*}

\end_inset

Notese que
\begin_inset Formula 
\begin{align*}
h & =C_{0}^{n+1,m}|_{D_{1}}\cup\lambda x\vec{x}\vec{\alpha}\left[f(0,\vec{x},\vec{\alpha})\right]|_{D_{2}}\\
g & =C_{0}^{n+3,m}|_{H_{1}}\cup\lambda Atx\vec{x}\vec{\alpha}\left[A+f(t+1,\vec{x},\vec{\alpha})\right])|_{H_{2}}
\end{align*}

\end_inset

Ya que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 y
\begin_inset Formula 
\begin{align*}
\lambda x\vec{x}\vec{\alpha}\left[f(0,\vec{x},\vec{\alpha})\right] & =f\circ\left[C_{0}^{n+1,m},p_{2}^{n+1,m},p_{3}^{n+1,m},...,p_{n+1+m}^{n+1,m}\right]\\
\lambda Atx\vec{x}\vec{\alpha}\left[A+f(t+1,\vec{x},\vec{\alpha})\right]) & =\lambda xy[x+y]\circ\left[p_{1}^{n+3,m},f\circ\left[Suc\circ p_{2}^{n+3,m},p_{4}^{n+3,m},...,p_{n+3+m}^{n+3,m}\right]\right]
\end{align*}

\end_inset

tenemos que 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[f(0,\vec{x},\vec{\alpha})\right]$
\end_inset

 y 
\begin_inset Formula $\lambda Atx\vec{x}\vec{\alpha}\left[A+f(t+1,\vec{x},\vec{\alpha})\right])$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..O sea que para probar que 
\begin_inset Formula $h$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.solo nos falta ver que los conjuntos 
\begin_inset Formula $D_{1},D_{2},H_{1},H_{2}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 y aplicar luego el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "restriccion"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Veamos que por ejemplo 
\begin_inset Formula $H_{1}$
\end_inset

 lo es.
 Es decir debemos ver que 
\begin_inset Formula $\chi_{H_{1}}^{\omega^{3+n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Ya que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 tenemos que 
\begin_inset Formula $D_{f}=\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., lo cual por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "rectangulos pr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que los conjuntos 
\begin_inset Formula $S_{1},...,S_{n}$
\end_inset

, 
\begin_inset Formula $L_{1},...,L_{m}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Ya que 
\begin_inset Formula $\omega$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "rectangulos pr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $R=\omega^{3}\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Notese que 
\begin_inset Formula $\chi_{H_{1}}^{\omega^{3+n}\times\Sigma^{\ast m}}=(\chi_{R}^{\omega^{3+n}\times\Sigma^{\ast m}}\wedge\lambda ztx\vec{x}\vec{\alpha}\left[x>t+1\right])$
\end_inset

 por lo cual 
\begin_inset Formula $\chi_{H_{1}}^{\omega^{3+n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 ya que es la conjuncion de dos predicados 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Veamos un ejemplo de como se puede aplicar el lema anterior.
 Sea 
\begin_inset Formula $F=\lambda yx_{1}\left[\sum_{t=0}^{t=y}(x_{1})^{t}\right]$
\end_inset

.
 Es claro que 
\begin_inset Formula $D_{F}=\omega^{2}$
\end_inset

.
 Para ver que 
\begin_inset Formula $F$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 aplicaremos el lema anterior por lo cual es importante encontrar la 
\begin_inset Formula $f$
\end_inset

 adecuada a la cual se le aplicara el lema.
 Tomemos 
\begin_inset Formula $f=\lambda tx_{1}[(x_{1})^{t}]$
\end_inset

.
 Claramente 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 por lo cual el lema anterior nos dice que
\begin_inset Formula 
\[
G=\lambda xyx_{1}\left[\sum_{t=x}^{t=y}f(t,x_{1})\right]=\lambda xyx_{1}\left[\sum_{t=x}^{t=y}(x_{1})^{t}\right]
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Claramente 
\begin_inset Formula $G$
\end_inset

 no es la funcion 
\begin_inset Formula $F$
\end_inset

 pero es en algun sentido 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

mas amplia
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 que 
\begin_inset Formula $F$
\end_inset

 ya que tiene una variable mas y se tiene que 
\begin_inset Formula $F(y,x_{1})=G(0,y,x_{1})$
\end_inset

, para cada 
\begin_inset Formula $y,x_{1}\in\omega$
\end_inset

.
 Es facil ver que
\begin_inset Formula 
\[
F=G\circ\left[C_{0}^{2,0},p_{1}^{2,0},p_{2}^{2,0}\right]
\]

\end_inset

por lo cual 
\begin_inset Formula $F$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Cuantificacion acotada de predicados 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 con dominio rectangular
\end_layout

\begin_layout Standard
Ses 
\begin_inset Formula $P:S\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega$
\end_inset

 un predicado, con 
\begin_inset Formula $S,S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 no vacios.
 Supongamos 
\begin_inset Formula $\bar{S}\subseteq S$
\end_inset

.
 Entonces la expresion Booleana
\begin_inset Formula 
\[
(\forall t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})
\]

\end_inset

depende de las variables 
\begin_inset Formula $x,\vec{x},\vec{\alpha}$
\end_inset

 y valdra 
\begin_inset Formula $1$
\end_inset

 en una 
\begin_inset Formula $(1+n+m)$
\end_inset

-upla 
\begin_inset Formula $(x,\vec{x},\vec{\alpha})$
\end_inset

 cuando 
\begin_inset Formula $P(t,\vec{x},\vec{\alpha})$
\end_inset

 sea igual a 
\begin_inset Formula $1$
\end_inset

 para cada 
\begin_inset Formula $t\in\{u\in\bar{S}:u\leq x\}$
\end_inset

; y 
\begin_inset Formula $0$
\end_inset

 en caso contrario.
 Tenemos entonces que el dominio del predicado
\begin_inset Formula 
\[
\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})\right]
\]

\end_inset

es 
\begin_inset Formula $\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

.
 En forma analoga se define la forma de interpretar la expresion Booleana
\begin_inset Formula 
\[
(\exists t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})
\]

\end_inset

Cabe destacar que
\begin_inset Formula 
\[
\lambda x\vec{x}\vec{\alpha}\left[(\exists t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})\right]=\lnot\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\bar{S})_{t\leq x}\;\lnot P(t,\vec{x},\vec{\alpha})\right]
\]

\end_inset


\end_layout

\begin_layout Standard
Tambien podemos cuantificar sobre variable alfabetica.
 Sea 
\begin_inset Formula $P:S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times L\rightarrow\omega$
\end_inset

 un predicado, con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L,L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 no vacios.
 Supongamos 
\begin_inset Formula $\bar{L}\subseteq L$
\end_inset

.
 Entonces la expresion Booleana
\begin_inset Formula 
\[
(\forall\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\;P(\vec{x},\vec{\alpha},\alpha)
\]

\end_inset

depende de las variables 
\begin_inset Formula $x,\vec{x},\vec{\alpha}$
\end_inset

 y valdra 
\begin_inset Formula $1$
\end_inset

 en una 
\begin_inset Formula $(1+n+m)$
\end_inset

-upla 
\begin_inset Formula $(x,\vec{x},\vec{\alpha})$
\end_inset

 cuando 
\begin_inset Formula $P(\vec{x},\vec{\alpha},\alpha)$
\end_inset

 sea igual a 
\begin_inset Formula $1$
\end_inset

 para cada 
\begin_inset Formula $\alpha\in\{\beta\in\bar{L}:\left\vert \beta\right\vert \leq x\}$
\end_inset

; y 
\begin_inset Formula $0$
\end_inset

 en caso contrario.
 Tenemos entonces que el dominio del predicado
\begin_inset Formula 
\[
\lambda x\vec{x}\vec{\alpha}\left[(\forall\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\;P(\vec{x},\vec{\alpha},\alpha)\right]
\]

\end_inset

es 
\begin_inset Formula $\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

.
 En forma analoga se define la forma de interpretar la expresion Booleana
\begin_inset Formula 
\[
(\exists\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\;P(\vec{x},\vec{\alpha},\alpha)
\]

\end_inset

Cabe destacar que
\begin_inset Formula 
\[
\lambda x\vec{x}\vec{\alpha}\left[(\exists\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}P(\vec{x},\vec{\alpha},\alpha)\right]=\lnot\lambda x\vec{x}\vec{\alpha}\left[(\forall\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\lnot P(\vec{x},\vec{\alpha},\alpha)\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "cuantificacion"

\end_inset

Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Sea 
\begin_inset Formula $P:S\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega$
\end_inset

 un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., con 
\begin_inset Formula $S,S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 no vacios.
 Supongamos 
\begin_inset Formula $\bar{S}\subseteq S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Entonces 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 y 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\exists t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 son predicados 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Sea 
\begin_inset Formula $P:S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times L\rightarrow\omega$
\end_inset

 un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L,L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 no vacios.
 Supongamos 
\begin_inset Formula $\bar{L}\subseteq L$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Entonces 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\forall\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\;P(\vec{x},\vec{\alpha},\alpha)\right]$
\end_inset

 y 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\exists\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\;P(\vec{x},\vec{\alpha},\alpha)\right]$
\end_inset

 son predicados 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
(a) Sea
\begin_inset Formula 
\[
\bar{P}=P|_{\bar{S}\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}}\cup C_{1}^{1+n,m}|_{(\omega-\bar{S})\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}}
\]

\end_inset

Notese que 
\begin_inset Formula $\bar{P}$
\end_inset

 tiene dominio 
\begin_inset Formula $\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 y es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Ya que
\begin_inset Formula 
\begin{align*}
\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\bar{S})_{t\leq x}P(t,\vec{x},\vec{\alpha})\right] & =\lambda x\vec{x}\vec{\alpha}\left[\prod\limits _{t=0}^{t=x}\bar{P}(t,\vec{x},\vec{\alpha})\right]\\
 & =\lambda xy\vec{x}\vec{\alpha}\left[\prod\limits _{t=x}^{t=y}\bar{P}(t,\vec{x},\vec{\alpha})\right]\circ\left[C_{0}^{1+n,m},p_{1}^{1+n,m},...,p_{1+n+m}^{1+n,m}\right]
\end{align*}

\end_inset

el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "iteracion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 implica que 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard
Ya que
\begin_inset Formula 
\[
\lambda x\vec{x}\vec{\alpha}\left[(\exists t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})\right]=\lnot\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\bar{S})_{t\leq x}\;\lnot P(t,\vec{x},\vec{\alpha})\right]
\]

\end_inset

tenemos que 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\exists t\in\bar{S})_{t\leq x}\;P(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
(b) Haremos solo el caso del cuantificador 
\begin_inset Formula $\forall$
\end_inset

.
 Primero supongamos que 
\begin_inset Formula $\Sigma=\emptyset$
\end_inset

.
 Ya que 
\begin_inset Formula $L,L_{1},...,L_{m}$
\end_inset

 son no vacios, debera suceder que 
\begin_inset Formula $L=L_{1}=...=L_{m}=\{\varepsilon\}$
\end_inset

.
 Ya que 
\begin_inset Formula $\bar{L}\subseteq L$
\end_inset

, tenemos que 
\begin_inset Formula $\bar{L}=\emptyset$
\end_inset

 o 
\begin_inset Formula $\bar{L}=\{\varepsilon\}$
\end_inset

.
 Si 
\begin_inset Formula $\bar{L}=\emptyset$
\end_inset

, entonces
\begin_inset Formula 
\begin{align*}
\lambda x\vec{x}\vec{\alpha}\left[(\forall\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\;P(\vec{x},\vec{\alpha},\alpha)\right] & =\lambda x\vec{x}\vec{\alpha}\left[1\right]\\
 & =C_{1}^{1+n,m}
\end{align*}

\end_inset

por lo cual es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\bar{L}=\{\varepsilon\}$
\end_inset

, entonces
\begin_inset Formula 
\begin{align*}
\lambda x\vec{x}\vec{\alpha}\left[(\forall\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\;P(\vec{x},\vec{\alpha},\alpha)\right] & =\lambda x\vec{x}\vec{\alpha}\left[(P(\vec{x},\vec{\alpha},\varepsilon)\right]\\
 & =P\circ\left[p_{2}^{1+n,m},...,p_{1+n+m}^{1+n,m},C_{\varepsilon}^{1+n,m},\right]
\end{align*}

\end_inset

por lo cual es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
Ahora supongamos 
\begin_inset Formula $\Sigma$
\end_inset

 es no vacio.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma.$
\end_inset

 Sea 
\begin_inset Formula $k$
\end_inset

 el cardinal de 
\begin_inset Formula $\Sigma$
\end_inset

.
 Primero notese que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset


\begin_inset Formula $\left\vert \alpha\right\vert \leq x$
\end_inset

 sii 
\begin_inset Formula $\#^{\leq}(\alpha)\leq\sum_{\iota=1}^{i=x}k^{i}$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 
\end_layout

\begin_layout Standard
(queda como ejercicio probar (*).
 Sean
\begin_inset Formula 
\begin{align*}
\#^{\leq}(L) & =\{\#^{\leq}(\alpha):\alpha\in L\}\\
\#^{\leq}(\bar{L}) & =\{\#^{\leq}(\alpha):\alpha\in\bar{L}\}
\end{align*}

\end_inset

Notese que
\begin_inset Formula 
\begin{align*}
\chi_{\#^{\leq}(L)}^{\omega} & =\chi_{L}^{\Sigma^{\ast}}\circ\ast^{\leq}\\
\chi_{\#^{\leq}(\bar{L})}^{\omega} & =\chi_{\bar{L}}^{\Sigma^{\ast}}\circ\ast^{\leq}
\end{align*}

\end_inset

por lo cual 
\begin_inset Formula $\#^{\leq}(L)$
\end_inset

 y 
\begin_inset Formula $\#^{\leq}(\bar{L})$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $H=\lambda t\vec{x}\vec{\alpha}\left[P(\vec{x},\vec{\alpha},\ast^{\leq}(t))\right].$
\end_inset

 Notese que
\begin_inset Formula 
\[
D_{H}=\#^{\leq}(L)\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}
\]

\end_inset

y 
\begin_inset Formula $H$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 O sea que por (a) tenemos que
\begin_inset Formula 
\[
\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\#^{\leq}(\bar{L}))_{t\leq x}H(t,\vec{x},\vec{\alpha})\right]=\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\#^{\leq}(\bar{L}))_{t\leq x}P(\vec{x},\vec{\alpha},\ast^{\leq}(t))\right]
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Llamemos 
\begin_inset Formula $Q$
\end_inset

 al predicado 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\#^{\leq}(\bar{L}))_{t\leq x}P(\vec{x},\vec{\alpha},\ast^{\leq}(t))\right]$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\begin{align*}
\lambda x\vec{x}\vec{\alpha}\left[(\forall\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}P(\vec{x},\vec{\alpha},\alpha)\right] & =\lambda x\vec{x}\vec{\alpha}\left[(\forall t\in\#^{\leq}(\bar{L}))_{t\leq\sum_{\iota=1}^{i=x}k^{i}}P(\vec{x},\vec{\alpha},\ast^{\leq}(t))\right]\text{ (por (*))}\\
 & =Q\circ\left[\lambda x\vec{x}\vec{\alpha}\left[\sum\limits _{\iota=1}^{i=x}k^{i}\right],p_{1}^{1+n,m},...,p_{1+n+m}^{1+n,m}\right]
\end{align*}

\end_inset

Pero 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[\sum\limits _{\iota=1}^{i=x}k^{i}\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 (ejercicio), lo cual nos dice que 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\forall\alpha\in\bar{L})_{\left\vert \alpha\right\vert \leq x}\;P(\vec{x},\vec{\alpha},\alpha)\right]$
\end_inset

 lo es 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
OBSERVACION: La cuantificacion no acotada no preserva la propiedad de ser
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Como veremos mas adelante si elejimos bien al predicado 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $P$
\end_inset

, obtenemos que el predicado 
\begin_inset Formula $\lambda\vec{x}\vec{\alpha}\left[(\exists t\in\bar{S})\;P(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 no solo no es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 sino que tampoco es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable (Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "autohalt es no EC"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Algunos ejemplos en los cuales cuantificacion acotada se aplica naturalmente
 son dados a continuacion.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

El predicado 
\begin_inset Formula $\lambda xy\left[x\text{ divide }y\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

El predicado 
\begin_inset Formula $\lambda x\left[x\text{ es primo}\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset

El predicado 
\begin_inset Formula $\lambda\alpha\beta\left[\alpha\text{\ }\mathrm{inicial}\ \beta\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Sea 
\begin_inset Formula $P=\lambda tx_{1}x_{2}\left[x_{2}=t.x_{1}\right]$
\end_inset

.
 Es claro que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 El lema anterior nos dice que 
\begin_inset Formula $\lambda xx_{1}x_{2}\left[(\exists t\in\omega)_{t\leq x}\;P(t,x_{1},x_{2})\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Notese que 
\begin_inset Formula $x_{1}$
\end_inset

 divide 
\begin_inset Formula $x_{2}$
\end_inset

 si y solo si hay un 
\begin_inset Formula $t\leq x_{2}$
\end_inset

 tal que 
\begin_inset Formula $x_{2}=t.x_{1}$
\end_inset

.
 Esto nos dice que
\begin_inset Formula 
\[
\lambda x_{1}x_{2}\left[x_{1}\text{ divide }x_{2}\right]=\lambda x_{1}x_{2}\left[(\exists t\in\omega)_{t\leq x_{2}}\;P(t,x_{1},x_{2})\right]
\]

\end_inset

Pero
\begin_inset Formula 
\[
\lambda x_{1}x_{2}\left[(\exists t\in\omega)_{t\leq x_{2}}\;P(t,x_{1},x_{2})\right]=\lambda xx_{1}x_{2}\left[(\exists t\in\omega)_{t\leq x}\;P(t,x_{1},x_{2})\right]\circ\left[p_{2}^{2,0},p_{1}^{2,0},p_{2}^{2,0}\right]
\]

\end_inset

por lo cual 
\begin_inset Formula $\lambda x_{1}x_{2}\left[x_{1}\text{ divide }x_{2}\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
(b) Ya que
\begin_inset Formula 
\[
x\text{ es primo sii }x>1\wedge\left((\forall t\in\omega)_{t\leq x}\;t=1\vee t=x\vee\lnot(t\text{ divide }x)\right)
\]

\end_inset

podemos usar un argumento similar al de la prueba de (a).
\end_layout

\begin_layout Standard
(c) es dejado al lector.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
La idea fundamental subyacente en las aplicaciones anteriores es que en
 muchos casos de predicados obtenidos por cuantificacion a partir de otros
 predicados, la variable cuantificada tiene una cota natural en terminos
 de las otras variables y ntonces componiendo adecuadamente se lo puede
 presentar como un caso de cuantificacion acotada
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Minimizacion y funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas
\end_layout

\begin_layout Standard
Tal como fue explicado anteriormente, para obtener la clase de las funciones
 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas debemos agregar un nuevo constructor a los ya definidos de composici
on y recursion primitiva, a saber el constructor de 
\shape italic
minimizacion
\shape default
.
 Tiene dos casos.
\end_layout

\begin_layout Subsubsection
Minimizacion de variable numerica
\end_layout

\begin_layout Standard
\noindent
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito y sea 
\begin_inset Formula $P:D_{P}\subseteq\omega\times\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 un predicado.
 Dado 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}$
\end_inset

, cuando exista al menos un 
\begin_inset Formula $t\in\omega$
\end_inset

 tal que 
\begin_inset Formula $P(t,\vec{x},\vec{\alpha})=1$
\end_inset

, usaremos 
\begin_inset Formula $\min_{t}P(t,\vec{x},\vec{\alpha})$
\end_inset

 para denotar al menor de tales 
\begin_inset Formula $t^{\prime}s$
\end_inset

.
 Notese que la expresion 
\begin_inset Formula $\min_{t}P(t,\vec{x},\vec{\alpha})$
\end_inset

 esta definida solo para aquellas 
\begin_inset Formula $(n+m)$
\end_inset

-uplas 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

 para las cuales hay al menos un 
\begin_inset Formula $t$
\end_inset

 tal que se da 
\begin_inset Formula $P(t,\vec{x},\vec{\alpha})=1$
\end_inset

.
 Dicho de otra forma, 
\begin_inset Formula $\min_{t}P(t,\vec{x},\vec{\alpha})$
\end_inset

 no estara definida cuando para cada 
\begin_inset Formula $t\in\omega$
\end_inset

 se de que 
\begin_inset Formula $(t,\vec{x},\vec{\alpha})$
\end_inset

 no pertenece a 
\begin_inset Formula $D_{P}$
\end_inset

 o 
\begin_inset Formula $P(t,\vec{x},\vec{\alpha})=0$
\end_inset

.
 Otro detalle importante a tener en cuenta es que la expresion 
\begin_inset Formula $\min_{t}P(t,\vec{x},\vec{\alpha})$
\end_inset

 no depende de la variable 
\begin_inset Formula $t$
\end_inset

.
 Por ejemplo, las expresiones 
\begin_inset Formula $\min_{t}P(t,\vec{x},\vec{\alpha})$
\end_inset

 y 
\begin_inset Formula $\min_{i}P(i,\vec{x},\vec{\alpha})$
\end_inset

 son equivalentes en el sentido que estan definidas en las mismas 
\begin_inset Formula $(n+m)$
\end_inset

-uplas y cuando estan definidas asumen el mismo valor.
\end_layout

\begin_layout Standard
Definamos
\begin_inset Formula 
\[
M(P)=\lambda\vec{x}\vec{\alpha}\left[\min\nolimits _{t}P(t,\vec{x},\vec{\alpha})\right]
\]

\end_inset

Notese que
\begin_inset Formula 
\begin{align*}
D_{M(P)} & =\left\{ (\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}:(\exists t\in\omega)\ P(t,\vec{x},\vec{\alpha})\right\} \\
M(P)(\vec{x},\vec{\alpha}) & =\min\nolimits _{t}P(t,\vec{x},\vec{\alpha})\text{, para cada }(\vec{x},\vec{\alpha})\in D_{M(P)}
\end{align*}

\end_inset

Diremos que 
\begin_inset Formula $M(P)$
\end_inset

 se obtiene por 
\shape italic
minimizacion de variable numerica 
\shape default
a partir de 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Veamos un par de ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Tomemos 
\begin_inset Formula $P=\lambda tx_{1}[t^{2}=x_{1}]$
\end_inset

.
 Tenemos que:
\begin_inset Formula 
\begin{align*}
D_{M(P)} & =\left\{ x_{1}\in\omega:(\exists t\in\omega)\ P(t,x_{1})\right\} \\
 & =\left\{ x_{1}\in\omega:(\exists t\in\omega)\ t^{2}=x_{1}\right\} 
\end{align*}

\end_inset

Es decir el dominio de 
\begin_inset Formula $M(P)$
\end_inset

 es el conjunto de los cuadrados.
 Ademas para cada 
\begin_inset Formula $x_{1}\in D_{M(P)}$
\end_inset

 tenemos que
\begin_inset Formula 
\[
M(P)(x_{1})=\min\nolimits _{t}P(t,x_{1})=\min\nolimits _{t}(t^{2}=x_{1})
\]

\end_inset

por lo cual 
\begin_inset Formula $M(P)(x)=\sqrt{x}$
\end_inset

, para cada 
\begin_inset Formula $x\in D_{M(P)}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Recordemos que dados 
\begin_inset Formula $x_{1},x_{2}\in\omega$
\end_inset

, con 
\begin_inset Formula $x_{2}$
\end_inset

 no nulo, el 
\shape italic
cociente de dividir 
\shape default

\begin_inset Formula $x_{1}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

por 
\shape default

\begin_inset Formula $x_{2}$
\end_inset

 se define como el maximo elemento del conjunto 
\begin_inset Formula $\{t\in\omega:t.x_{2}\leq x_{1}\}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\begin{array}[t]{rll}
Q:\omega\times\mathbf{N} & \rightarrow & \omega\\
(x_{1},x_{2}) & \rightarrow & \text{cociente de dividir }x_{1}\text{ por }x_{2}
\end{array}
\]

\end_inset

Sea 
\begin_inset Formula $P=\lambda tx_{1}x_{2}\left[x_{1}<t.x_{2}\right]$
\end_inset

.
 Notar que
\begin_inset Formula 
\begin{align*}
D_{M(P)} & =\{(x_{1},x_{2})\in\omega^{2}:(\exists t\in\omega)\;P(t,x_{1},x_{2})=1\}\\
 & =\{(x_{1},x_{2}):(\exists t\in\omega)\;x_{1}<t.x_{2}\}\\
 & =\omega\times\mathbf{N}
\end{align*}

\end_inset

Ademas si 
\begin_inset Formula $(x_{1},x_{2})\in\omega\times\mathbf{N}$
\end_inset

, es facil de probar que
\begin_inset Formula 
\[
\min\nolimits _{t}\ x_{1}<t.x_{2}=Q(x_{1},x_{2})+1
\]

\end_inset

por lo que 
\begin_inset Formula $M(P)=Suc\circ Q$
\end_inset

.
 Si quisieramos encontrar un predicado 
\begin_inset Formula $P^{\prime}$
\end_inset

 tal que 
\begin_inset Formula $M(P^{\prime})=Q$
\end_inset

, entonces podemos tomar 
\begin_inset Formula $P^{\prime}=\lambda tx_{1}x_{2}\left[x_{1}<(t+1).x_{2}\right]$
\end_inset

 y con un poco de concentracion nos daremos cuenta que 
\begin_inset Formula $M(P^{\prime})=Q$
\end_inset

.
 De todas maneras hay una forma mas facil de hacerlo y es tomando 
\begin_inset Formula $P^{\prime}$
\end_inset

 de tal forma que para cada 
\begin_inset Formula $(x_{1},x_{2})\in D_{Q}$
\end_inset

 se de que
\begin_inset Formula 
\[
Q(x_{1},x_{2})=\mathrm{\ unico\ }t\in\omega\mathrm{\ tal\ que\ }P^{\prime}(t,x_{1},x_{2})
\]

\end_inset

Por ejemplo se puede tomar 
\begin_inset Formula $P^{\prime}=\lambda tx_{1}x_{2}\left[x_{1}\geq t.x_{2}\text{ y }x_{1}<(t+1).x_{2}\right]$
\end_inset

 que dicho sea de paso es justo la definicion de cociente dada en la escuela
 primaria.
 Dejamos al lector corroborar que 
\begin_inset Formula $M(P^{\prime})=Q$
\end_inset

, para este ultimo 
\begin_inset Formula $P^{\prime}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tal como lo vimos recien muchas veces que querramos encontrar un predicado
 
\begin_inset Formula $P$
\end_inset

 tal que 
\begin_inset Formula $M(P)$
\end_inset

 sea igual a una funcion dada 
\begin_inset Formula $f$
\end_inset

, sera mas facil encontrar un 
\begin_inset Formula $P$
\end_inset

 el cual cumpla
\begin_inset Formula 
\[
f(\vec{x},\vec{\alpha})=\mathrm{\ unico\ }t\in\omega\mathrm{\ tal\ que\ }P(t,\vec{x},\vec{\alpha})
\]

\end_inset

es decir un predicado 
\begin_inset Formula $P$
\end_inset

 que caracterice al valor que toma 
\begin_inset Formula $f$
\end_inset

.
 Enunciamos esto en forma de regla.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
REGLA U:
\series default
 Si tenemos una funcion 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 y buscamos un predicado 
\begin_inset Formula $P$
\end_inset

 tal que 
\begin_inset Formula $f=M(P)$
\end_inset

 muchas veces es util tratar de disear 
\begin_inset Formula $P$
\end_inset

 de manera que para cada 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in D_{f}$
\end_inset

 se de que
\begin_inset Formula 
\[
f(\vec{x},\vec{\alpha})=\mathrm{\ unico\ }t\in\omega\mathrm{\ tal\ que\ }P(t,\vec{x},\vec{\alpha})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $P:D_{P}\subseteq\omega\times\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 es un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable y 
\begin_inset Formula $D_{P}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, entonces la funcion 
\begin_inset Formula $M(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ejercicio 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Lamentablemente si quitamos la hipotesis en el lema anterior de que 
\begin_inset Formula $D_{P}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, el lema resulta falso.
 Mas adelante veremos un contraejemplo basado en la tesis de Church (Proposicion
 
\begin_inset CommandInset ref
LatexCommand ref
reference "P recursivo no implica M(P) recursiva"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Por el momento el lector puede ejercitar su comprencion del tema convenciendose
 de que aun teniendo un procedimiento efectivo que compute a un predicado
 
\begin_inset Formula $P:D_{P}\subseteq\omega\times\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

, no es claro como construir un procedimiento efectivo que compute a 
\begin_inset Formula $M(P)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Definicion de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva
\end_layout

\begin_layout Standard
Con este nuevo constructor de funciones estamos en condiciones de definir
 la clase de las funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas.
 Definamos los conjuntos 
\begin_inset Formula $\mathrm{R}_{0}^{\Sigma}\subseteq\mathrm{R}_{1}^{\Sigma}\subseteq\mathrm{R}_{2}^{\Sigma}\subseteq...\subseteq\mathrm{R}^{\Sigma}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
\begin{array}{lll}
\mathrm{R}_{0}^{\Sigma} & = & \mathrm{PR}_{0}^{\Sigma}\\
\mathrm{R}_{k+1}^{\Sigma} & = & \mathrm{R}_{k}^{\Sigma}\cup\left\{ f\circ[f_{1},...,f_{n}]:f,f_{1},...,f_{r}\in\mathrm{R}_{k}^{\Sigma}\text{, }r\geq1\right\} \cup\\
 &  & \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left\{ R(f,\mathcal{G}):f\text{ y cada }\mathcal{G}_{a}\text{ pertenecen a }\mathrm{R}_{k}^{\Sigma}\right\} \cup\\
 &  & \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left\{ R(f,g):f,g\in\mathrm{R}_{k}^{\Sigma}\right\} \cup\\
 &  & \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\left\{ M(P):P\text{ es }\Sigma\text{-total y }P\in\mathrm{R}_{k}^{\Sigma}\right\} \\
\mathrm{R}^{\Sigma} & = & \bigcup_{k\geq0}\mathrm{R}_{k}^{\Sigma}
\end{array}
\]

\end_inset

Una funcion 
\begin_inset Formula $f$
\end_inset

 es llamada 
\begin_inset Formula $\Sigma$
\end_inset

-
\shape italic
recursiva
\shape default
 si pertenece a 
\begin_inset Formula $\mathrm{R}^{\Sigma}$
\end_inset

.
 Cabe destacar que aunque 
\begin_inset Formula $M(P)$
\end_inset

 fue definido para predicados no necesariamente 
\begin_inset Formula $\Sigma$
\end_inset

-totales, en la definicion de los conjuntos 
\begin_inset Formula $\mathrm{R}_{k}^{\Sigma}$
\end_inset

, nos restringimos al caso en que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-total.
\end_layout

\begin_layout Standard
Notese que 
\begin_inset Formula $\mathrm{PR}_{k}^{\Sigma}\subseteq\mathrm{R}_{k}^{\Sigma}$
\end_inset

, para cada 
\begin_inset Formula $k\in\omega$
\end_inset

, por lo cual 
\begin_inset Formula $\mathrm{PR}^{\Sigma}\subseteq\mathrm{R}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "f recursiva implica f efectivamente computable"

\end_inset

Si 
\begin_inset Formula $f\in\mathrm{R}^{\Sigma}$
\end_inset

, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dejamos al lector la prueba por induccion en 
\begin_inset Formula $k$
\end_inset

 de que si 
\begin_inset Formula $f\in\mathrm{R}_{k}^{\Sigma}$
\end_inset

, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Daremos sin prueba el siguiente conceptualmente importante resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "recursivo no implica PR"

\end_inset

Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
 Entonces no toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Este resultado no es facil de probar.
 Mas adelante (Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "T y FI no son PR"
plural "false"
caps "false"
noprefix "false"

\end_inset

) veremos ejemplos naturales de funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas que no son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Otro ejemplo natural es la famosa funcion de Ackermann.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Lema de minimizacion acotada de variable numerica de predicados 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
Aunque no siempre que 
\begin_inset Formula $P\in\mathrm{R}^{\Sigma}$
\end_inset

, tendremos que 
\begin_inset Formula $M(P)\in\mathrm{R}^{\Sigma}$
\end_inset

 (Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "P recursivo no implica M(P) recursiva"
plural "false"
caps "false"
noprefix "false"

\end_inset

), el siguiente lema nos garantiza que este es el caso cuando 
\begin_inset Formula $P\in\mathrm{PR}^{\Sigma}$
\end_inset

 y ademas da condiciones para que 
\begin_inset Formula $M(P)$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "minimizacion"

\end_inset

Sean 
\begin_inset Formula $n,m\geq0$
\end_inset

.
 Sea 
\begin_inset Formula $P:D_{P}\subseteq\omega\times\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $M(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si hay una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $f:\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 tal que
\begin_inset Formula 
\[
M(P)(\vec{x},\vec{\alpha})=\min\nolimits _{t}P(t,\vec{x},\vec{\alpha})\leq f(\vec{x},\vec{\alpha})\text{, para cada }(\vec{x},\vec{\alpha})\in D_{M(P)}\text{,}
\]

\end_inset

entonces 
\begin_inset Formula $M(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Sea 
\begin_inset Formula $\bar{P}=P\cup C_{0}^{n+1,m}|_{(\omega^{n+1}\times\Sigma^{\ast m})-D_{P}}$
\end_inset

.
 Note que 
\begin_inset Formula $\bar{P}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 (por que?).
 Veremos a continuacion que 
\begin_inset Formula $M(P)=M(\bar{P})$
\end_inset

.
 Notese que
\begin_inset Formula 
\[
\{t\in\omega:P(t,\vec{x},\vec{\alpha})=1\}=\{t\in\omega:\bar{P}(t,\vec{x},\vec{\alpha})=1\}
\]

\end_inset

Esto claramente dice que 
\begin_inset Formula $D_{M(P)}=D_{M(\bar{P})}$
\end_inset

 y que 
\begin_inset Formula $M(P)(\vec{x},\vec{\alpha})=M(\bar{P})(\vec{x},\vec{\alpha})$
\end_inset

, para cada 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in D_{M(P)}$
\end_inset

., por lo cual 
\begin_inset Formula $M(P)=M(\bar{P})$
\end_inset

.
\end_layout

\begin_layout Standard
Veremos entonces que 
\begin_inset Formula $M(\bar{P})$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Sea 
\begin_inset Formula $k$
\end_inset

 tal que 
\begin_inset Formula $\bar{P}\in\mathrm{PR}_{k}^{\Sigma}$
\end_inset

.
 Ya que 
\begin_inset Formula $\bar{P}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-total y 
\begin_inset Formula $\bar{P}\in\mathrm{PR}_{k}^{\Sigma}\subseteq\mathrm{R}_{k}^{\Sigma}$
\end_inset

, tenemos que 
\begin_inset Formula $M(\bar{P})\in\mathrm{R}_{k+1}^{\Sigma}$
\end_inset

 y por lo tanto 
\begin_inset Formula $M(\bar{P})\in\mathrm{R}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
(b) Ya que 
\begin_inset Formula $M(P)=M(\bar{P})$
\end_inset

, basta con probar que 
\begin_inset Formula $M(\bar{P})$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 Primero veremos que 
\begin_inset Formula $D_{M(\bar{P})}$
\end_inset

 es un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Notese que
\begin_inset Formula 
\[
\chi_{D_{M(\bar{P})}}^{\omega^{n}\times\Sigma^{\ast m}}=\lambda\vec{x}\vec{\alpha}\left[(\exists t\in\omega)_{t\leq f(\vec{x},\vec{\alpha})}\;\bar{P}(t,\vec{x},\vec{\alpha})\right]
\]

\end_inset

lo cual nos dice que
\begin_inset Formula 
\[
\chi_{D_{M(\bar{P})}}^{\omega^{n}\times\Sigma^{\ast m}}=\lambda x\vec{x}\vec{\alpha}\left[(\exists t\in\omega)_{t\leq x}\;\bar{P}(t,\vec{x},\vec{\alpha})\right]\circ\left[f,p_{1}^{n,m},...,p_{n+m}^{n,m}\right]
\]

\end_inset

Pero el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cuantificacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $\lambda x\vec{x}\vec{\alpha}\left[(\exists t\in\omega)_{t\leq x}\;\bar{P}(t,\vec{x},\vec{\alpha})\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 por lo cual tenemos que 
\begin_inset Formula $\chi_{D_{M(\bar{P})}}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 lo es.
\end_layout

\begin_layout Standard
Sea
\begin_inset Formula 
\[
P_{1}=\lambda t\vec{x}\vec{\alpha}\left[\bar{P}(t,\vec{x},\vec{\alpha})\wedge(\forall j\in\omega)_{j\leq t}\;j=t\vee\lnot\bar{P}(j,\vec{x},\vec{\alpha})\right]
\]

\end_inset

Note que 
\begin_inset Formula $P_{1}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-total.
 Dejamos al lector usando lemas anteriores probar que 
\begin_inset Formula $P_{1}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 Ademas notese que para 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 se tiene que
\begin_inset Formula 
\[
P_{1}(t,\vec{x},\vec{\alpha})=1\text{ si y solo si }(\vec{x},\vec{\alpha})\in D_{M(\bar{P})}\text{ y }t=M(\bar{P})(\vec{x},\vec{\alpha})
\]

\end_inset

Esto nos dice que
\begin_inset Formula 
\[
M(\bar{P})=\left(\lambda\vec{x}\vec{\alpha}\left[\prod_{t=0}^{f(\vec{x},\vec{\alpha})}t^{P_{1}(t,\vec{x},\vec{\alpha})}\right]\right)|_{D_{M(\bar{P})}}
\]

\end_inset

por lo cual para probar que 
\begin_inset Formula $M(\bar{P})$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 solo nos resta probar que
\begin_inset Formula 
\[
F=\lambda\vec{x}\vec{\alpha}\left[\prod_{t=0}^{f(\vec{x},\vec{\alpha})}t^{P_{1}(t,\vec{x},\vec{\alpha})}\right]
\]

\end_inset

lo es.
 Pero
\begin_inset Formula 
\[
F=\lambda xy\vec{x}\vec{\alpha}\left[\prod_{t=x}^{y}t^{P_{1}(t,\vec{x},\vec{\alpha})}\right]\circ\left[C_{0}^{n,m},f,p_{1}^{n,m},...,p_{n+m}^{n,m}\right]
\]

\end_inset

y por lo tanto el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "iteracion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $F$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
OBSERVACION: No siempre que 
\begin_inset Formula $P$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 tendremos que 
\begin_inset Formula $M(P)$
\end_inset

 lo sera.
 Notese que si 
\begin_inset Formula $M(P)$
\end_inset

 fuera 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., cada ves que 
\begin_inset Formula $P$
\end_inset

 lo sea, entonces tendriamos que 
\begin_inset Formula $\mathrm{PR}^{\Sigma}=\mathrm{R}^{\Sigma}$
\end_inset

 (justifique) lo cual contradiria la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo no implica PR"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Mas adelante (Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion de PR que no es PR"
plural "false"
caps "false"
noprefix "false"

\end_inset

) veremos un ejemplo de un predicado 
\begin_inset Formula $P$
\end_inset

 el cual es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 pero 
\begin_inset Formula $M(P)$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El lema de minimizacion recien probado es muy util como veremos en los siguiente
s dos lemas.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "cociente y resto"

\end_inset

Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
 Las siguientes funciones son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $\begin{array}[t]{rll}
Q:\omega\times\mathbf{N} & \rightarrow & \omega\\
(x,y) & \rightarrow & \text{cociente de la division de }x\text{ por }y
\end{array}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\begin{array}[t]{rll}
R:\omega\times\mathbf{N} & \rightarrow & \omega\\
(x,y) & \rightarrow & \text{resto de la division de }x\text{ por }y
\end{array}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset


\begin_inset Formula $\begin{array}[t]{rll}
pr:\mathbf{N} & \rightarrow & \omega\\
n & \rightarrow & n\text{-esimo numero primo}
\end{array}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Ya vimos anteriormente que 
\begin_inset Formula $Q=M(P^{\prime})$
\end_inset

, donde 
\begin_inset Formula $P^{\prime}=\lambda tx_{1}x_{2}\left[x_{1}\geq t.x_{2}\text{ y }x_{1}<(t+1).x_{2}\right]$
\end_inset

.
 Ya que 
\begin_inset Formula $P^{\prime}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 y
\begin_inset Formula 
\[
Q(x_{1},x_{2})\leq p_{1}^{2,0}(x_{1},x_{2}),\text{ para cada }(x_{1},x_{2})\in\omega\times\mathbf{N}
\]

\end_inset

(b) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 implica que 
\begin_inset Formula $Q\in\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
(b) Notese que
\begin_inset Formula 
\[
R=\lambda xy\left[x\dot{-}Q(x,y).y\right]
\]

\end_inset

y por lo tanto 
\begin_inset Formula $R\in\mathrm{PR}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
(c) Para ver que 
\begin_inset Formula $pr$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., veremos que la extension 
\begin_inset Formula $h:\omega\rightarrow\omega$
\end_inset

, dada por 
\begin_inset Formula $h(0)=0$
\end_inset

 y 
\begin_inset Formula $h(n)=pr(n)$
\end_inset

, 
\begin_inset Formula $n\geq1$
\end_inset

, es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Luego 
\begin_inset Formula $pr=h|_{\mathbf{N}}$
\end_inset

 resultara 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 por ser la restriccion de una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 a un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Primero note que
\begin_inset Formula 
\begin{align*}
h(0) & =0\\
h(t+1) & =\min\nolimits _{i}\left(i\text{ es primo}\wedge i>h(t)\right)
\end{align*}

\end_inset

O sea que 
\begin_inset Formula $h=R\left(C_{0}^{0,0},g\right)$
\end_inset

, donde
\begin_inset Formula 
\[
\begin{array}[t]{rll}
g:\omega\times\omega & \rightarrow & \omega\\
(A,t) & \rightarrow & \min\nolimits _{i}\left(i\text{ es primo}\wedge i>A\right)
\end{array}
\]

\end_inset

Es decir que solo nos resta ver que 
\begin_inset Formula $g$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Pero notese que 
\begin_inset Formula $g=M(P)$
\end_inset

, donde 
\begin_inset Formula $P=\lambda iAt\left[i\text{ es primo}\wedge i>A\right]$
\end_inset

.
 Claramente 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 por lo cual para poder aplicar (b) del lema anterior debemos encontrar
 una funcion 
\begin_inset Formula $f:\omega\times\omega\rightarrow\omega$
\end_inset

 tal que
\begin_inset Formula 
\[
M(P)(A,t)\leq f(A,t)\text{, para cada }(A,t)\in\omega^{2}
\]

\end_inset

Es decir 
\begin_inset Formula $f$
\end_inset

 debera cumplir
\begin_inset Formula 
\[
\min\nolimits _{i}\left(i\text{ es primo}\wedge i>A\right)\leq f(A,t)\text{, para cada }(A,t)\in\omega^{2}
\]

\end_inset

Definamos 
\begin_inset Formula $f=\lambda At[A!+1]$
\end_inset

.
 Debemos probar entonces que
\begin_inset Formula 
\[
\min\nolimits _{i}\left(i\text{ es primo}\wedge i>A\right)\leq A!+1\text{, para cada }A\in\omega
\]

\end_inset

Sea 
\begin_inset Formula $p$
\end_inset

 un primo tal que 
\begin_inset Formula $p$
\end_inset

 divide a 
\begin_inset Formula $A!+1$
\end_inset

.
 Es facil ver que entonces 
\begin_inset Formula $p>A$
\end_inset

 ya que de lo contrario 
\begin_inset Formula $p$
\end_inset

 dividiria a 
\begin_inset Formula $A!$
\end_inset

 lo cual nos diria que 
\begin_inset Formula $p$
\end_inset

 divide a 
\begin_inset Formula $1=A!+1-A!$
\end_inset

, lo cual es absurdo.
 Pero esto claramente nos dice que
\begin_inset Formula 
\[
\min\nolimits _{i}\left(i\text{ es primo}\wedge i>A\right)\leq p\leq A!+1
\]

\end_inset

O sea que (b) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 implica que 
\begin_inset Formula $g=M(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Las funciones 
\begin_inset Formula $\lambda xi\left[(x)_{i}\right]$
\end_inset

 y 
\begin_inset Formula $\lambda x\left[Lt(x)\right]$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Note que 
\begin_inset Formula $D_{\lambda xi\left[(x)_{i}\right]}=\mathbf{N}\times\mathbf{N}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
P=\lambda txi\left[\lnot(pr(i)^{t+1}\ \text{divide }x)\right]
\]

\end_inset

Note que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 y que 
\begin_inset Formula $D_{P}=\omega\times\omega\times\mathbf{N}$
\end_inset

.
 Dejamos al lector la prueba de que 
\begin_inset Formula $\lambda xi\left[(x)_{i}\right]=M(P)$
\end_inset

.
 Ya que 
\begin_inset Formula $(x)_{i}\leq x$
\end_inset

, para todo 
\begin_inset Formula $(x,i)\in\mathbf{N}\times\mathbf{N}$
\end_inset

, (b) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 implica que 
\begin_inset Formula $\lambda xi\left[(x)_{i}\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard
Veamos que 
\begin_inset Formula $\lambda x\left[Lt(x)\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Sea
\begin_inset Formula 
\[
Q=\lambda tx\left[(\forall i\in\mathbf{N})_{i\leq x}\;(i\leq t\vee(x)_{i}=0)\right]
\]

\end_inset

Notese que 
\begin_inset Formula $D_{Q}=\omega\times\mathbf{N}$
\end_inset

 y que ademas por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cuantificacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $Q$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 (dejamos al lector explicar como se aplica tal lema en este caso).
 Ademas notese que 
\begin_inset Formula $\lambda x\left[Lt(x)\right]=M(Q)$
\end_inset

 y que
\begin_inset Formula 
\[
Lt(x)\leq x,\text{para todo }x\in\mathbf{N}
\]

\end_inset

lo cual por (b) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $\lambda x\left[Lt(x)\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $x_{1},...,x_{n}\in\omega$
\end_inset

, con 
\begin_inset Formula $n\geq1$
\end_inset

, escribiremos 
\begin_inset Formula $\left\langle x_{1},...,x_{n}\right\rangle $
\end_inset

 en lugar de 
\begin_inset Formula $\left\langle x_{1},...,x_{n},0,...\right\rangle $
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "CodificadorasSonPR"

\end_inset

Sea 
\begin_inset Formula $n\geq1$
\end_inset

.
 La funcion 
\begin_inset Formula $\lambda x_{1}...x_{n}\left[\left\langle x_{1},...,x_{n}\right\rangle \right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $f_{n}=\lambda x_{1}...x_{n}\left[\left\langle x_{1},...,x_{n}\right\rangle \right]$
\end_inset

.
 Claramente 
\begin_inset Formula $f_{1}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Ademas note que para cada 
\begin_inset Formula $n\geq1$
\end_inset

, tenemos
\begin_inset Formula 
\[
f_{n+1}=\lambda x_{1}...x_{n+1}\left[\left(f_{n}(x_{1},...,x_{n})pr(n+1)^{x_{n+1}}\right)\right]\text{.}
\]

\end_inset

O sea que podemos aplicar un argumento inductivo.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Minimizacion de variable alfabetica
\end_layout

\begin_layout Standard
Supongamos que 
\begin_inset Formula $\Sigma\neq\emptyset$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Recordemos que 
\begin_inset Formula $\leq$
\end_inset

 puede ser naturalmente extendido a un orden total sobre 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
 Sea 
\begin_inset Formula $P:D_{P}\subseteq\omega^{n}\times\Sigma^{\ast m}\times\Sigma^{\ast}\rightarrow\omega$
\end_inset

 un predicado.
 Cuando 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es tal que existe al menos un 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 tal que 
\begin_inset Formula $P(\vec{x},\vec{\alpha},\alpha)=1$
\end_inset

, usaremos 
\begin_inset Formula $\min_{\alpha}^{\leq}P(\vec{x},\vec{\alpha},\alpha)$
\end_inset

 para denotar al menor 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 tal que 
\begin_inset Formula $P(\vec{x},\vec{\alpha},\alpha)=1$
\end_inset

.
 Notese que la expresion 
\begin_inset Formula $\min_{\alpha}^{\leq}P(\vec{x},\vec{\alpha},\alpha)$
\end_inset

 esta definida solo para aquellas 
\begin_inset Formula $(n+m)$
\end_inset

-uplas 
\begin_inset Formula $(\vec{x},\vec{\alpha})$
\end_inset

 para las cuales hay al menos un 
\begin_inset Formula $\alpha$
\end_inset

 tal que se da 
\begin_inset Formula $P(\vec{x},\vec{\alpha},\alpha)=1$
\end_inset

.
 Dicho de otra forma, 
\begin_inset Formula $\min_{\alpha}^{\leq}P(\vec{x},\vec{\alpha},\alpha)$
\end_inset

 no estara definida cuando para cada 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

 se de que 
\begin_inset Formula $(\vec{x},\vec{\alpha},\alpha)$
\end_inset

 no pertenece a 
\begin_inset Formula $D_{P}$
\end_inset

 o 
\begin_inset Formula $P(\vec{x},\vec{\alpha},\alpha)=0$
\end_inset

.
 Otro detalle importante a tener en cuenta es que la expresion 
\begin_inset Formula $\min_{\alpha}^{\leq}P(\vec{x},\vec{\alpha},\alpha)$
\end_inset

 no depende de la variable 
\begin_inset Formula $\alpha$
\end_inset

.
 Por ejemplo, las expresiones 
\begin_inset Formula $\min_{\alpha}^{\leq}P(\vec{x},\vec{\alpha},\alpha)$
\end_inset

 y 
\begin_inset Formula $\min_{\beta}^{\leq}P(\vec{x},\vec{\alpha},\beta)$
\end_inset

 son equivalentes en el sentido que estan definidas en las mismas 
\begin_inset Formula $(n+m)$
\end_inset

-uplas y cuando estan definidas asumen el mismo valor.
\end_layout

\begin_layout Standard
Definamos
\begin_inset Formula 
\[
\begin{array}{c}
M^{\leq}(P)=\lambda\vec{x}\vec{\alpha}\left[\min_{\alpha}^{\leq}P(\vec{x},\vec{\alpha},\alpha)\right]\end{array}
\]

\end_inset

Notese que
\begin_inset Formula 
\begin{align*}
D_{M^{\leq}(P)} & =\left\{ (\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}:(\exists\alpha\in\Sigma^{\ast})\ P(\vec{x},\vec{\alpha},\alpha)\right\} \\
M^{\leq}(P)(\vec{x},\vec{\alpha}) & =\min\nolimits _{\alpha}^{\leq}P(\vec{x},\vec{\alpha},\alpha)\text{, para cada }(\vec{x},\vec{\alpha})\in D_{M^{\leq}(P)}
\end{align*}

\end_inset

Diremos que 
\begin_inset Formula $M^{\leq}(P)$
\end_inset

 es obtenida por 
\shape italic
minimizacion de variable alfabetica 
\shape default
a partir de 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
Vemos un ejemplo.
 Sea 
\begin_inset Formula $\Sigma=\{@,a,b,c,d,e\}$
\end_inset

 y sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Sea 
\begin_inset Formula $Dir=\{\alpha_{1}\in\Sigma^{\ast}:\left\vert \alpha_{1}\right\vert _{@}=1\}$
\end_inset

 y definamos 
\begin_inset Formula $U:Dir\rightarrow\Sigma^{\ast}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
U(\alpha_{1})=\text{unico }\alpha\text{ tal que }\alpha@\text{ es tramo inicial de }\alpha_{1}
\]

\end_inset

Sea
\begin_inset Formula 
\[
P=\lambda\alpha_{1}\alpha[\alpha_{1}\in Dir\text{ y }\alpha@\text{ es tramo inicial de }\alpha_{1}]
\]

\end_inset

Tenemos que
\begin_inset Formula 
\begin{align*}
D_{M^{\leq}(P)} & =\left\{ \alpha_{1}\in\Sigma^{\ast}:(\exists\alpha\in\Sigma^{\ast})\ P(\alpha_{1},\alpha)\right\} \\
 & =\left\{ \alpha_{1}\in\Sigma^{\ast}:\alpha_{1}\in Dir\text{ y }(\exists\alpha\in\Sigma^{\ast})\ \alpha@\text{ es tramo inicial de }\alpha_{1}\right\} \\
 & =Dir
\end{align*}

\end_inset

y ademas es claro que 
\begin_inset Formula $M^{\leq}(P)(\alpha_{1})=U(\alpha_{1})$
\end_inset

, para cada 
\begin_inset Formula $\alpha_{1}\in Dir$
\end_inset

, por lo cual 
\begin_inset Formula $M^{\leq}(P)=U$
\end_inset

.
 Intente explicar por que se utiizaron los nombres 
\begin_inset Formula $Dir$
\end_inset

 y 
\begin_inset Formula $U$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Lema de minimizacion acotada de variable alfabetica de predicados 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "minimizacion1"

\end_inset

Supongamos que 
\begin_inset Formula $\Sigma\neq\emptyset$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

, sean 
\begin_inset Formula $n,m\geq0$
\end_inset

 y sea 
\begin_inset Formula $P:D_{P}\subseteq\omega^{n}\times\Sigma^{\ast m}\times\Sigma^{\ast}\rightarrow\omega$
\end_inset

 un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $M^{\leq}(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si existe una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $f:\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 tal que
\begin_inset Formula 
\[
\left\vert M^{\leq}(P)(\vec{x},\vec{\alpha})\right\vert =\left\vert \min\nolimits _{\alpha}^{\leq}P(\vec{x},\vec{\alpha},\alpha)\right\vert \leq f(\vec{x},\vec{\alpha})\text{, para cada }(\vec{x},\vec{\alpha})\in D_{M^{\leq}(P)}\text{,}
\]

\end_inset

entonces 
\begin_inset Formula $M^{\leq}(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $Q=P\circ\left[p_{2}^{1+n,m},...,p_{1+n+m}^{1+n,m},\ast^{\leq}\circ p_{1}^{1+n,m}\right]$
\end_inset

.
 Note que
\begin_inset Formula 
\[
M^{\leq}(P)=\ast^{\leq}\circ M(Q)
\]

\end_inset

lo cual por (a) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 implica que 
\begin_inset Formula $M^{\leq}(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $k$
\end_inset

 el cardinal de 
\begin_inset Formula $\Sigma$
\end_inset

.
 Ya que
\begin_inset Formula 
\[
\left\vert \ast^{\leq}(M(Q)(\vec{x},\vec{\alpha}))\right\vert =\left\vert M^{\leq}(P)(\vec{x},\vec{\alpha})\right\vert \leq f(\vec{x},\vec{\alpha})\text{,}
\]

\end_inset

para todo 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in D_{M^{\leq}(P)}=D_{M(Q)}$
\end_inset

, tenemos que
\begin_inset Formula 
\[
M(Q)(\vec{x},\vec{\alpha})\leq\sum_{\iota=1}^{i=f(\vec{x},\vec{\alpha})}k^{i}\text{, para cada }(\vec{x},\vec{\alpha})\in D_{M(Q)}\text{.}
\]

\end_inset

O sea que por (b) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $M(Q)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 y por lo tanto 
\begin_inset Formula $M^{\leq}(P)$
\end_inset

 lo es.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
En el ejemplo de recien vimos que 
\begin_inset Formula $U=M(P)$
\end_inset

, con 
\begin_inset Formula $P=\lambda\alpha_{1}\alpha[\alpha@$
\end_inset

 es tramo inicial de 
\begin_inset Formula $\alpha_{1}]$
\end_inset

 por lo cual, dado que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 y ademas
\begin_inset Formula 
\[
\left\vert U(\alpha_{1})\right\vert \leq\left\vert \alpha_{1}\right\vert \text{, para cada }\alpha_{1}\in Dir
\]

\end_inset

el lema anterior nos dice que 
\begin_inset Formula $U$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerables
\end_layout

\begin_layout Standard
Ya que la nocion de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva es el modelo matematico Godeliano del concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, nos podriamos preguntar entonces cual es el modelo
 matematico Godeliano del concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Si prestamos atencion a la definicion de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable, notaremos que depende de la existencia de ciertas
 funciones 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables por lo cual la siguiente definicion cae de maduro:
\end_layout

\begin_layout Standard
Diremos que un conjunto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 sera llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-recursivamente enumerable
\shape default
 cuando sea vacio o haya una funcion 
\begin_inset Formula $F:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que 
\begin_inset Formula $I_{F}=S$
\end_inset

 y 
\begin_inset Formula $F_{(i)}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva, para cada 
\begin_inset Formula $i\in\{1,...,n+m\}$
\end_inset

.
\end_layout

\begin_layout Standard
Deberia entonces quedar claro que si el concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva modeliza correctamente al concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, entonces el concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerable recien definido modeliza correctamente al concepto
 de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-recursivos
\end_layout

\begin_layout Standard
La version Godeliana del concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable es facil de dar: un conjunto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 sera llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-recursivo
\shape default
 cuando la funcion 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Algunos resultados basicos
\end_layout

\begin_layout Standard
Muchos resultados ya probados para el caso primitivo recursivo pueden ser
 probados usando basicamente las mismas pruebas e ideas para el caso recursivo.
 Por ejemplo las pruebas de los siguientes cuatro lemas son identicas a
 las del caso primitivo recursivo
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "boolean op para recursivos"

\end_inset

Si 
\begin_inset Formula $P:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 y 
\begin_inset Formula $Q:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 son predicados 
\begin_inset Formula $\Sigma$
\end_inset

-r., entonces 
\begin_inset Formula $(P\vee Q)$
\end_inset

, 
\begin_inset Formula $(P\wedge Q)$
\end_inset

 y 
\begin_inset Formula $\lnot P$
\end_inset

 lo son tambien.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "union recursivos"

\end_inset

Si 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-r., entonces 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

, 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 y 
\begin_inset Formula $S_{1}-S_{2}$
\end_inset

 lo son.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "rectangulos recursivos"

\end_inset

Supongamos 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

, 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

 son conjuntos no vacios.
 Entonces 
\begin_inset Formula $S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 sii 
\begin_inset Formula $S_{1},...,S_{n},L_{1},...,L_{m}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "restriccion de recursivas a conj recursivos"

\end_inset

Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 y 
\begin_inset Formula $S\subseteq D_{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r., entonces 
\begin_inset Formula $f|_{S}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tambien se puede probar una version del lema de division por casos para
 funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas con dominio 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo, la cual generaliza el caso 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 La prueba es la misma que la del caso primitivo recursivo aunque al lema
 previo de existencia de extensiones lo probaremos en forma mas directa
 que para el caso primitivo recursivo.
 A saber:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "extension para recursivas con dominio recursivo"

\end_inset

Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 y 
\begin_inset Formula $D_{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r., entonces existe una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 
\begin_inset Formula $\bar{f}:\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

, tal que 
\begin_inset Formula $f=\bar{f}|_{D_{f}}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Si 
\begin_inset Formula $f=\emptyset$
\end_inset

, es facil de probar y dejado al lector.
 Supongamos entonces 
\begin_inset Formula $f$
\end_inset

 es no vacia.
 Sin perdida de generalidad podemos suponer que 
\begin_inset Formula $(0,...,0,\varepsilon,...,\varepsilon)\in D_{f}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\begin{array}[t]{rll}
F:\omega^{n}\times\Sigma^{\ast m} & \rightarrow & \omega^{n}\times\Sigma^{\ast m}\\
(\vec{x},\vec{\alpha}) & \rightarrow & \left\{ \begin{array}{lll}
(\vec{x},\vec{\alpha}) &  & \text{si }(\vec{x},\vec{\alpha})\in D_{f}\\
(0,...,0,\varepsilon,...,\varepsilon) &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset

Ya que
\begin_inset Formula 
\begin{align*}
F_{(i)} & =\lambda\vec{x}\vec{\alpha}\left[x_{i}.\chi_{D_{f}}^{\omega^{n}\times\Sigma^{\ast m}}(\vec{x},\vec{\alpha})\right]\text{, para }i=1,...,n\\
F_{(i)} & =\lambda\vec{x}\vec{\alpha}\left[\alpha_{i}^{\chi_{D_{f}}^{\omega^{n}\times\Sigma^{\ast m}}(\vec{x},\vec{\alpha})}\right]\text{, para }i=n+1,...,n+m
\end{align*}

\end_inset

tenemos que cada 
\begin_inset Formula $F_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Es claro que 
\begin_inset Formula $\bar{f}=f\circ F$
\end_inset

 cumple que 
\begin_inset Formula $f=\bar{f}|_{D_{f}}$
\end_inset

 por lo cual solo falta ver que 
\begin_inset Formula $\bar{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Pero esto es obvio ya que 
\begin_inset Formula $F=\left[F_{(1)},...,F_{(n+m)}\right]$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "dpc para recursivas con dominio recursivo"

\end_inset

Supongamos 
\begin_inset Formula $f_{i}:D_{f_{i}}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

, 
\begin_inset Formula $i=1,...,k$
\end_inset

, son funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas tales que cada 
\begin_inset Formula $D_{f_{i}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo y 
\begin_inset Formula $D_{f_{i}}\cap D_{f_{j}}=\emptyset$
\end_inset

 para 
\begin_inset Formula $i\neq j$
\end_inset

.
 Entonces la funcion 
\begin_inset Formula $f_{1}\cup...\cup f_{k}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Completamente analoga a la del caso primitivo recursivo.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo, entonces 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $\emptyset\neq S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Sea 
\begin_inset Formula $(z_{1},...,z_{n},\gamma_{1},...,\gamma_{m})\in S$
\end_inset

 fijo.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Sea 
\begin_inset Formula $G:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 dada por
\begin_inset Formula 
\[
G(x)=\left((x+1)_{1},...,(x+1)_{n},\ast^{\leq}((x+1)_{n+1}),...,\ast^{\leq}((x+1)_{n+m})\right)
\]

\end_inset

Es claro que cada 
\begin_inset Formula $G_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva y que 
\begin_inset Formula $\operatorname{Im}G=\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $i=1,...,n$
\end_inset

, definamos 
\begin_inset Formula $F_{i}:\omega\rightarrow\omega$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
F_{i}(x)=\left\{ \begin{array}{ccl}
G_{(i)}(x) &  & \text{si }G(x)\in S\\
z_{i} &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

Para 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

, definamos 
\begin_inset Formula $F_{i}:\omega\rightarrow\Sigma^{\ast}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
F_{i}(x)=\left\{ \begin{array}{ccl}
G_{(i)}(x) &  & \text{si }G(x)\in S\\
\gamma_{i} &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

Usando que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo podemos aplicar el lema anterior y ver que cada 
\begin_inset Formula $F_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Sea 
\begin_inset Formula $F=[F_{1},...,F_{n+m}]$
\end_inset

.
 Notese que 
\begin_inset Formula $F_{(i)}=F_{i}$
\end_inset

 para cada 
\begin_inset Formula $i=1,...,n+m$
\end_inset

.
 Esto nos dice que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 ya que 
\begin_inset Formula $\operatorname{Im}F=S$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Mas adelante (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "A es RE y no R"
plural "false"
caps "false"
noprefix "false"

\end_inset

) daremos un ejemplo natural de un conjunto que es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 pero el cual no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
\end_layout

\begin_layout Standard
Deberia quedar claro que si el modelo de Godel es correcto, entonces todos
 los resultados probados dentro del paradigma filosofico de la computabilidad
 efectiva son ciertos una ves reenunciados de acuerdo al paradigma Godeliano.
 Tal como vimos arriba muchos de estos resultados se prueban en forma facil
 en su version recursiva.
 Sin envargo muchos otros requieren mas trabajo y es necesario utilizar
 algun paradigma mas constructivo (como el imperativo o el de Turing) para
 poder probarlos en su version recursiva.
 Por ejemplo consideremos el teorema siguiente dado en el contexto del paradigma
 filosofico:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 y 
\begin_inset Formula $(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
Se tiene que la version recursiva de (a)
\begin_inset Formula $\Rightarrow$
\end_inset

(b) es probada sin problemas en el lema anterior pero para probar la version
 recursiva de (b)
\begin_inset Formula $\Rightarrow$
\end_inset

(a), nos sera necesario utilizar el paradigma imperativo (Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "carac recursivos"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Lo mismo sucede con el lema de division por casos en su forma mas general
 (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "dpc para efectivamente computables"
plural "false"
caps "false"
noprefix "false"

\end_inset

) y con el teorema de caracterizacion de conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables (Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "equivalencias de efectivamente enumerable"
plural "false"
caps "false"
noprefix "false"

\end_inset

), ambos cuando son enunciados en su version recursiva no son faciles de
 probar con las herramientas desarrolladas hasta ahora y nos sera necesario
 usar el paradigma imperativo para representar a los objetos recursivos
 involucrados.
 Estas pruebas estan en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "survey recursivo"
plural "false"
caps "false"
noprefix "false"

\end_inset

 donde se compilan todos los resultados basicos (expresados en paradigma
 recursivo) y se obtienen algunos resultados los cuales en esta instancia
 todavia no se pueden probar ya que para obtenerlos es necesario hacer uso
 de la formalizacion matematica de ambos paradigmas el funcional y el imperativo
 (por ejemplo la existencia de un conjunto que es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 pero el cual no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Recursion primitiva sobre valores anteriores
\end_layout

\begin_layout Standard
Dada una funcion 
\begin_inset Formula $h:\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega$
\end_inset

, con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

, no vacios, definamos 
\begin_inset Formula $h^{\downarrow}:\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\begin{align*}
h^{\downarrow}(x,\vec{x},\vec{\alpha}) & =\left\langle h(0,\vec{x},\vec{\alpha}),h(1,\vec{x},\vec{\alpha}),...,h(x,\vec{x},\vec{\alpha})\right\rangle \\
 & =\Pi_{i=0}^{x}pr(i+1)^{h(i,\vec{x},\vec{\alpha})}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "f-flecha"

\end_inset

Supongamos
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega\\
g & :\omega\times\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega\\
h & :\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega
\end{align*}

\end_inset

son funciones tales que
\begin_inset Formula 
\begin{align*}
h(0,\vec{x},\vec{\alpha}) & =f(\vec{x},\vec{\alpha})\\
h(x+1,\vec{x},\vec{\alpha}) & =g(h^{\downarrow}(x,\vec{x},\vec{\alpha}),x,\vec{x},\vec{\alpha})\text{,}
\end{align*}

\end_inset

para cada 
\begin_inset Formula $x\in\omega$
\end_inset

 y 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

.
 Entonces 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.) si 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

 lo son.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $f,g$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Primero veremos que 
\begin_inset Formula $h^{\downarrow}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.).
 Notese que para cada 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

 tenemos que
\begin_inset Formula 
\begin{align*}
h^{\downarrow}(0,\vec{x},\vec{\alpha}) & =\left\langle h(0,\vec{x},\vec{\alpha})\right\rangle \\
 & =\left\langle f(\vec{x},\vec{\alpha})\right\rangle \\
 & =2^{f(\vec{x},\vec{\alpha})}\\
h^{\downarrow}(x+1,\vec{x},\vec{\alpha}) & =h^{\downarrow}(x,\vec{x},\vec{\alpha})pr(x+2)^{h(x+1,\vec{x},\vec{\alpha})}\\
 & =h^{\downarrow}(x,\vec{x},\vec{\alpha})pr(x+2)^{g(h^{\downarrow}(x,\vec{x},\vec{\alpha}),x,\vec{x},\vec{\alpha})}
\end{align*}

\end_inset

lo cual nos dice que 
\begin_inset Formula $h^{\downarrow}=R(f_{1},g_{1})$
\end_inset

 donde
\begin_inset Formula 
\begin{align*}
f_{1} & =\lambda\vec{x}\vec{\alpha}\left[2^{f(\vec{x},\vec{\alpha})}\right]\\
g_{1} & =\lambda Ax\vec{x}\vec{\alpha}\left[Apr(x+2)^{g(A,x,\vec{x},\vec{\alpha})}\right]
\end{align*}

\end_inset

O sea que 
\begin_inset Formula $h^{\downarrow}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.) ya que 
\begin_inset Formula $f_{1}$
\end_inset

 y 
\begin_inset Formula $g_{1}$
\end_inset

 lo son.
 Finalmente notese que
\begin_inset Formula 
\[
h=\lambda ix[(x)_{i}]\circ\left[Suc\circ p_{1}^{1+n,m},h^{\downarrow}\right]
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Independencia del alfabeto
\end_layout

\begin_layout Standard
Probaremos que los conceptos de 
\begin_inset Formula $\Sigma$
\end_inset

-recursividad y 
\begin_inset Formula $\Sigma$
\end_inset

-recursividad primitiva son en realidad independientes del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

, es decir que si 
\begin_inset Formula $f$
\end_inset

 es una funcion la cual es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta y 
\begin_inset Formula $\Gamma$
\end_inset

-mixta, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.) sii 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
\end_layout

\begin_layout Standard
Ya definimos para el caso de un alfabeto 
\begin_inset Formula $\Sigma\neq\emptyset$
\end_inset

 y 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

, las funciones 
\begin_inset Formula $\#^{\leq}$
\end_inset

 y 
\begin_inset Formula $\ast^{\leq}$
\end_inset

.
 Sea 
\begin_inset Formula $\Sigma=\emptyset$
\end_inset

.
 Notese que el conjunto 
\begin_inset Formula $\emptyset$
\end_inset

 es un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

 (de hecho es el unico orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

).
 Definamos
\begin_inset Formula 
\[
\begin{array}{rll}
\#^{\emptyset}:\{0\} & \rightarrow & \{\varepsilon\}\\
0 & \rightarrow & \varepsilon
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll}
\ast^{\emptyset}:\{\varepsilon\} & \rightarrow & \{0\}\\
\varepsilon & \rightarrow & 0
\end{array}
\]

\end_inset

Ya que 
\begin_inset Formula $\Sigma^{\ast}=\{\varepsilon\}$
\end_inset

, las funciones 
\begin_inset Formula $\#^{\emptyset}$
\end_inset

 y 
\begin_inset Formula $\ast^{\emptyset}$
\end_inset

 son biyecciones mutuamente inversas entre 
\begin_inset Formula $\{0\}$
\end_inset

 y 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
 Ademas notese que estas funciones son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "aux"

\end_inset

Supongamos 
\begin_inset Formula $\Sigma\subseteq\Gamma$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Si 
\begin_inset Formula $\leq$
\end_inset

 es un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

, entonces las funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 y 
\begin_inset Formula $\#^{\leq}$
\end_inset

 son 
\begin_inset Formula $\Gamma$
\end_inset

-p.r..
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si 
\begin_inset Formula $\leq^{\prime}$
\end_inset

 es un orden total sobre 
\begin_inset Formula $\Gamma$
\end_inset

, entonces las funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas 
\begin_inset Formula $\#^{\leq^{\prime}}|_{\Sigma^{\ast}}$
\end_inset

 y 
\begin_inset Formula $\ast^{\leq^{\prime}}|_{\#^{\leq^{\prime}}(\Sigma^{\ast})}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Si 
\begin_inset Formula $\Sigma=\emptyset$
\end_inset

, entonces es facil ver que 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 y 
\begin_inset Formula $\#^{\leq}$
\end_inset

 son 
\begin_inset Formula $\Gamma$
\end_inset

-p.r., y es dejado como ejercicio.
 Supongamos 
\begin_inset Formula $\Sigma=\{a_{1},...,a_{k}\}$
\end_inset

 con 
\begin_inset Formula $k\geq1$
\end_inset

 y 
\begin_inset Formula $\leq$
\end_inset

 es dado por 
\begin_inset Formula $a_{1}<...<a_{k}$
\end_inset

.
 Sea 
\begin_inset Formula $s_{e}^{\leq}:\Gamma^{\ast}\rightarrow\Gamma^{\ast}$
\end_inset

 dada por
\begin_inset Formula 
\begin{align*}
s_{e}^{\leq}(\varepsilon) & =a_{1}\\
s_{e}^{\leq}(\alpha a_{i}) & =\alpha a_{i+1}\text{, si }i<k\\
s_{e}^{\leq}(\alpha a_{k}) & =s_{e}^{\leq}(\alpha)a_{1}\\
s_{e}^{\leq}(\alpha a) & =\varepsilon\text{, si }a\in\Gamma-\Sigma.
\end{align*}

\end_inset

Note que 
\begin_inset Formula $s_{e}^{\leq}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.
 y que 
\begin_inset Formula $s_{e}^{\leq}|_{\Sigma^{\ast}}=s^{\leq}$
\end_inset

.
 Ya que
\begin_inset Formula 
\begin{align*}
\ast^{\leq}(0) & =\varepsilon\\
\ast^{\leq}(x+1) & =s^{\leq}(\ast^{\leq}(x))
\end{align*}

\end_inset

para cada 
\begin_inset Formula $x\in\omega$
\end_inset

, tenemos que
\begin_inset Formula 
\begin{align*}
\ast^{\leq}(0) & =\varepsilon\\
\ast^{\leq}(x+1) & =s_{e}^{\leq}(\ast^{\leq}(x))
\end{align*}

\end_inset

Pero esto nos dice que 
\begin_inset Formula $\ast^{\leq}=R(C_{\varepsilon}^{0,0},g)$
\end_inset

 donde
\begin_inset Formula 
\[
\begin{array}{lll}
g:\omega\times\Gamma^{\ast} & \rightarrow & \Gamma^{\ast}\\
\;\;\;\;\;(x,\alpha) & \rightarrow & s_{e}^{\leq}(\alpha)
\end{array}
\]

\end_inset

Pero es claro que 
\begin_inset Formula $g$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.
 por lo cual 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-p.r..
\end_layout

\begin_layout Standard
Para ver que 
\begin_inset Formula $\#^{\leq}:\Sigma^{\ast}\rightarrow\omega$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-p.r., sea 
\begin_inset Formula $\#_{e}^{\leq}:\Gamma^{\ast}\rightarrow\omega$
\end_inset

 dada por
\begin_inset Formula 
\begin{align*}
\#_{e}^{\leq}(\varepsilon) & =0\\
\#_{e}^{\leq}(\alpha a_{i}) & =\#_{e}^{\leq}(\alpha).k+i\\
\#_{e}^{\leq}(\alpha a) & =0\text{, si }a\in\Gamma-\Sigma.
\end{align*}

\end_inset

Ya que 
\begin_inset Formula $\#_{e}^{\leq}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-p.r., eso es 
\begin_inset Formula $\#^{\leq}=\#_{e}^{\leq}|_{\Sigma^{\ast}}$
\end_inset

.
\end_layout

\begin_layout Standard
(b) El caso 
\begin_inset Formula $\Sigma=\emptyset$
\end_inset

 es facil y queda como ejercicio.
 Supongamos entonces 
\begin_inset Formula $\Sigma$
\end_inset

 es no vacio.
 Sea 
\begin_inset Formula $n$
\end_inset

 el cardinal de 
\begin_inset Formula $\Gamma.$
\end_inset

 Ya que
\begin_inset Formula 
\begin{align*}
\#^{\leq^{\prime}}|_{\Sigma^{\ast}}(\varepsilon) & =0\\
\#^{\leq^{\prime}}|_{\Sigma^{\ast}}(\alpha a) & =\#^{\leq^{\prime}}|_{\Sigma^{\ast}}(\alpha).n+\#^{\leq^{\prime}}(a)\text{, para cada }a\in\Sigma
\end{align*}

\end_inset

la funcion 
\begin_inset Formula $\#^{\leq^{\prime}}|_{\Sigma^{\ast}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 O sea que el predicado 
\begin_inset Formula $P=\lambda x\alpha\left[\#^{\leq^{\prime}}|_{\Sigma^{\ast}}(\alpha)=x\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Note que 
\begin_inset Formula $\ast^{\leq^{\prime}}|_{\#^{\leq^{\prime}}(\Sigma^{\ast})}=M^{\leq}(P)$
\end_inset

, lo cual ya que
\begin_inset Formula 
\[
\left\vert \ast^{\leq^{\prime}}|_{\#^{\leq^{\prime}}(\Sigma^{\ast})}(x)\right\vert \leq x
\]

\end_inset

nos dice que 
\begin_inset Formula $\ast^{\leq^{\prime}}|_{\#^{\leq^{\prime}}(\Sigma^{\ast})}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $\mathrm{PR}^{\emptyset}\subseteq\mathrm{PR}^{\Sigma}$
\end_inset

 y 
\begin_inset Formula $\mathrm{R}^{\emptyset}\subseteq\mathrm{R}^{\Sigma}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Veamos que 
\begin_inset Formula $\mathrm{R}^{\emptyset}\subseteq\mathrm{R}^{\Sigma}$
\end_inset

.
 Probaremos por induccion en 
\begin_inset Formula $k$
\end_inset

 que 
\begin_inset Formula $\mathrm{R}_{k}^{\emptyset}\subseteq\mathrm{R}^{\Sigma}$
\end_inset

.
 El caso 
\begin_inset Formula $k=0$
\end_inset

 es trivial.
 Supongamos entonces que vale la hipotesis inductiva 
\begin_inset Formula $\mathrm{R}_{k}^{\emptyset}\subseteq\mathrm{R}^{\Sigma}$
\end_inset

 y veamos que 
\begin_inset Formula $\mathrm{R}_{k+1}^{\emptyset}\subseteq\mathrm{R}^{\Sigma}$
\end_inset

.
 Sea 
\begin_inset Formula $F\in\mathrm{R}_{k+1}^{\emptyset}-\mathrm{R}_{k}^{\emptyset}$
\end_inset

 veremos que 
\begin_inset Formula $F\in\mathrm{R}^{\Sigma}$
\end_inset

.
 Hay varios casos:
\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $F=R(f,\mathcal{G})$
\end_inset

, con
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times\emptyset^{\ast m}\rightarrow\emptyset^{\ast}\\
\mathcal{G}_{a} & :S_{1}\times...\times S_{n}\times\emptyset^{\ast m}\times\emptyset^{\ast}\times\emptyset^{\ast}\rightarrow\emptyset^{\ast}\text{, para cada }a\in\emptyset
\end{align*}

\end_inset

funciones en 
\begin_inset Formula $\mathrm{R}_{k}^{\emptyset}$
\end_inset

 y cada 
\begin_inset Formula $S_{i}$
\end_inset

 no vacio.
 Por hipotesis inductiva tenemos que 
\begin_inset Formula $f\in\mathrm{R}^{\Sigma}$
\end_inset

.
 Notese que 
\begin_inset Formula $\mathcal{G}=\emptyset$
\end_inset

, lo cual nos dice que por definicion
\begin_inset Formula 
\[
\begin{array}{rll}
R(f,\mathcal{G}):S_{1}\times...\times S_{n}\times\emptyset^{\ast m}\times\emptyset^{\ast} & \rightarrow & \emptyset^{\ast}\\
(\vec{x},\varepsilon,...,\varepsilon,\varepsilon) & \rightarrow & f(\vec{x},\varepsilon,...,\varepsilon)
\end{array}
\]

\end_inset

Es claro que 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}\times\emptyset^{\ast}$
\end_inset

 es un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 por lo cual las funciones 
\begin_inset Formula $p_{i}^{n,m+1}|_{\omega^{n}\times\Sigma^{\ast m}\times\emptyset^{\ast}}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 (aqui las 
\begin_inset Formula $p_{i}^{n,m+1}$
\end_inset

 son respecto de 
\begin_inset Formula $\Sigma$
\end_inset

).
 Ya que
\begin_inset Formula 
\[
R(f,\mathcal{G})=f\circ\left[p_{1}^{n,m+1}|_{\omega^{n}\times\Sigma^{\ast m}\times\emptyset^{\ast}},...,p_{n+m}^{n,m+1}|_{\omega^{n}\times\Sigma^{\ast m}\times\emptyset^{\ast}}\right]
\]

\end_inset

tenemos que 
\begin_inset Formula $F$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva
\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $F=R(f,g)$
\end_inset

, con
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times\emptyset^{\ast m}\rightarrow\emptyset^{\ast}\\
g & :\omega\times S_{1}\times...\times S_{n}\times\emptyset^{\ast m}\times\emptyset^{\ast}\rightarrow\emptyset^{\ast}
\end{align*}

\end_inset

funciones en 
\begin_inset Formula $\mathrm{R}_{k}^{\emptyset}$
\end_inset

 y cada 
\begin_inset Formula $S_{i}$
\end_inset

 no vacio.
 Por hipotesis inductiva tenemos que 
\begin_inset Formula $f,g\in\mathrm{R}^{\Sigma}$
\end_inset

.
 Notese que respecto de 
\begin_inset Formula $\Sigma$
\end_inset

, la funcion 
\begin_inset Formula $R(f,g)$
\end_inset

 no esta definida ya que por la forma de 
\begin_inset Formula $f$
\end_inset

, el dominio de 
\begin_inset Formula $g$
\end_inset

 deberia ser 
\begin_inset Formula $\omega\times S_{1}\times...\times S_{n}\times\emptyset^{\ast m}\times\Sigma^{\ast}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\tilde{g}=g\circ\left[p_{1}^{1+n,m+1},...,p_{1+n+m}^{1+n,m+1},C_{\varepsilon}^{1+n,m+1}\right]
\]

\end_inset

(aqui las 
\begin_inset Formula $p_{i}^{1+n,m+1}$
\end_inset

 y 
\begin_inset Formula $C_{\varepsilon}^{1+n,m+1}$
\end_inset

 son respecto de 
\begin_inset Formula $\Sigma$
\end_inset

).
 Notese que 
\begin_inset Formula $D_{\tilde{g}}=\omega\times S_{1}\times...\times S_{n}\times\emptyset^{\ast m}\times\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $\tilde{g}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Ademas es facil ver que 
\begin_inset Formula $F=Rf,\tilde{g})$
\end_inset

 (respecto del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

) por lo cual 
\begin_inset Formula $F$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva
\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $F=M(P)$
\end_inset

, con 
\begin_inset Formula $P:\omega\times\omega^{n}\times\emptyset^{\ast m}\rightarrow\omega$
\end_inset

, un predicado en 
\begin_inset Formula $\mathrm{R}_{k}^{\emptyset}$
\end_inset

.
 Por hipotesis inductiva tenemos que 
\begin_inset Formula $P\in\mathrm{R}^{\Sigma}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\bar{P}=P\circ\left[p_{1}^{1+n,m},...,p_{1+n}^{1+n,m},C_{\varepsilon}^{1+n,m},...,C_{\varepsilon}^{1+n,m}\right]
\]

\end_inset

Notese que 
\begin_inset Formula $\bar{P}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-total y 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo y ademas extiende a 
\begin_inset Formula $P$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\tilde{P}=\lambda xy[x.y]\circ\left[\bar{P},\chi_{\omega\times\omega^{n}\times\emptyset^{\ast m}}^{\omega\times\omega^{n}\times\Sigma^{\ast m}}\right]
\]

\end_inset

Tambien 
\begin_inset Formula $\tilde{P}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-total y 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo y extiende a 
\begin_inset Formula $P$
\end_inset

 pero ademas fuera del dominio de 
\begin_inset Formula $P$
\end_inset

 vale 
\begin_inset Formula $0$
\end_inset

.
 Esto nos dice que 
\begin_inset Formula $M(\tilde{P})=M(P)$
\end_inset

 por lo cual 
\begin_inset Formula $F$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva ya que 
\begin_inset Formula $M(\tilde{P})$
\end_inset

 lo es
\end_layout

\begin_layout Standard
Los otros casos de recursion primitiva son parecidos a los hechos y el caso
 de la composicion es trivial.
\end_layout

\begin_layout Standard
La prueba de que 
\begin_inset Formula $\mathrm{PR}^{\emptyset}\subseteq\mathrm{PR}^{\Sigma}$
\end_inset

 es muy similar.
 Se dejan los detalles como ejercicio para el lector 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito (puede ser vacio) y sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Para 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

, definamos
\begin_inset Formula 
\[
f^{\#^{\leq}}=f\circ\left[p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast^{\leq}\circ p_{n+1}^{n+m,0},...,\ast^{\leq}\circ p_{n+m}^{n+m,0}\right]
\]

\end_inset

Similarmente, para 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\Sigma^{\ast}$
\end_inset

, definamos
\begin_inset Formula 
\[
f^{\#^{\leq}}=\#^{\leq}\circ f\circ\left[p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast^{\leq}\circ p_{n+1}^{n+m,0},...,\ast^{\leq}\circ p_{n+m}^{n+m,0}\right]
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\Gamma$
\end_inset

 un alfabeto finito y sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Gamma$
\end_inset

.
 Dada 
\begin_inset Formula $h$
\end_inset

 una funcion 
\begin_inset Formula $\Gamma$
\end_inset

-mixta, son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.)
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $h^{\#^{\leq}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.) 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (2)
\begin_inset Formula $\Rightarrow$
\end_inset

(1).
 Supongamos 
\begin_inset Formula $h:D_{h}\subseteq\omega^{n}\times\Gamma^{\ast m}\rightarrow\Gamma^{\ast}$
\end_inset

 es tal que 
\begin_inset Formula $h^{\#^{\leq}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
 Dejamos al lector chequear que
\begin_inset Formula 
\[
h=\ast^{\leq}\circ h^{\#^{\leq}}\circ\left[p_{1}^{n,m},...,p_{n}^{n,m},\#^{\leq}\circ p_{n+1}^{n,m},...,\#^{\leq}\circ p_{n+m}^{n,m}\right]
\]

\end_inset

(aqui las 
\begin_inset Formula $p_{i}^{n,m}$
\end_inset

 son respecto de 
\begin_inset Formula $\Gamma$
\end_inset

).
 Por el lema anterior tenemos que 
\begin_inset Formula $h^{\#^{\leq}}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
 Ya que (aun cuando 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

) tenemos que las funciones 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 y 
\begin_inset Formula $\#^{\leq}$
\end_inset

 son 
\begin_inset Formula $\Gamma$
\end_inset

-p.r., tenemos que 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.) ya que es composicion de funciones 
\begin_inset Formula $\Gamma$
\end_inset

-recursivas (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
\end_layout

\begin_layout Standard
(1)
\begin_inset Formula $\Rightarrow$
\end_inset

(2).
 El caso 
\begin_inset Formula $\Gamma=\emptyset$
\end_inset

 es trivial ya que 
\begin_inset Formula $h^{\#^{\leq}}$
\end_inset

 se define como composicion de funciones 
\begin_inset Formula $\emptyset$
\end_inset

-recursivas (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
 Supongamos entonces que 
\begin_inset Formula $\Gamma=\{a_{1},...,a_{r}\}$
\end_inset

, con 
\begin_inset Formula $a_{1}<a_{2}<...<a_{r}$
\end_inset

 y 
\begin_inset Formula $r>0$
\end_inset

.
 Probaremos por induccion en 
\begin_inset Formula $k$
\end_inset

 que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset

Si 
\begin_inset Formula $h\in\mathrm{R}_{k}^{\Gamma}$
\end_inset

 (resp.
 
\begin_inset Formula $h\in\mathrm{PR}_{k}^{\Gamma}$
\end_inset

), entonces 
\begin_inset Formula $h^{\#^{\leq}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
 
\end_layout

\begin_layout Standard
\noindent
El caso 
\begin_inset Formula $k=0$
\end_inset

 es facil y dejado al lector.
 Supongamos (*) vale para un 
\begin_inset Formula $k$
\end_inset

 fijo.
 Veremos que vale para 
\begin_inset Formula $k+1$
\end_inset

.
 Sea 
\begin_inset Formula $h\in\mathrm{R}_{k+1}^{\Gamma}$
\end_inset

 (resp.
 
\begin_inset Formula $h\in\mathrm{PR}_{k+1}^{\Gamma}$
\end_inset

).
 Hay varios casos
\end_layout

\begin_layout Standard
Caso 1.
 Supongamos 
\begin_inset Formula $h=f\circ[f_{1},...,f_{n}]$
\end_inset

, con 
\begin_inset Formula $f,f_{1},...,f_{n}\in\mathrm{R}_{k}^{\Gamma}$
\end_inset

 (resp.
 
\begin_inset Formula $f,f_{1},...,f_{n}\in\mathrm{PR}_{k}^{\Gamma}$
\end_inset

).
 Por hipotesis inductiva tenemos que 
\begin_inset Formula $f^{\#^{\leq}},f_{1}^{\#^{\leq}},...,f_{n}^{\#^{\leq}}$
\end_inset

 son 
\begin_inset Formula $\emptyset$
\end_inset

-recursivas (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
 Ya que 
\begin_inset Formula $h^{\#^{\leq}}=f^{\#^{\leq}}\circ\left[f_{1}^{\#^{\leq}},...,f_{n}^{\#^{\leq}}\right]$
\end_inset

, tenemos que 
\begin_inset Formula $h^{\#^{\leq}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
\end_layout

\begin_layout Standard
Caso 2.
 Supongamos 
\begin_inset Formula $h=M(P)$
\end_inset

, con 
\begin_inset Formula $P:\omega\times\omega^{n}\times\Gamma^{\ast m}\rightarrow\omega$
\end_inset

, un predicado en 
\begin_inset Formula $\mathrm{R}_{k}^{\Gamma}$
\end_inset

.
 Ya que 
\begin_inset Formula $h^{\#^{\leq}}=M(P^{\#^{\leq}})$
\end_inset

, tenemos que 
\begin_inset Formula $h^{\#^{\leq}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva.
\end_layout

\begin_layout Standard
Caso 3.
 Supongamos 
\begin_inset Formula $h=R(f,\mathcal{G})$
\end_inset

, con
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\Gamma^{\ast}\\
\mathcal{G}_{a} & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Gamma^{\ast}\times\Gamma^{\ast}\rightarrow\Gamma^{\ast}\text{, }a\in\Gamma
\end{align*}

\end_inset

funciones en 
\begin_inset Formula $\mathrm{R}_{k}^{\Gamma}$
\end_inset

 (resp.
 
\begin_inset Formula $\mathrm{PR}_{k}^{\Gamma}$
\end_inset

) y 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $L_{1},...,L_{m}\subseteq\Sigma^{\ast}$
\end_inset

, no vacios.
 Notese que
\begin_inset Formula 
\begin{align*}
f^{\#^{\leq}} & :S_{1}\times...\times S_{n}\times\#^{\leq}(L_{1})\times...\times\#^{\leq}(L_{m})\rightarrow\omega\\
\mathcal{G}_{a}^{\#^{\leq}} & :S_{1}\times...\times S_{n}\times\#^{\leq}(L_{1})\times...\times\#^{\leq}(L_{m})\times\omega\times\omega\rightarrow\omega\text{, }a\in\Gamma\\
h^{\#^{\leq}} & :S_{1}\times...\times S_{n}\times\#^{\leq}(L_{1})\times...\times\#^{\leq}(L_{m})\times\omega\rightarrow\omega
\end{align*}

\end_inset

Por hipotesis inductiva tenemos que 
\begin_inset Formula $f^{\#^{\leq}}$
\end_inset

 y cada 
\begin_inset Formula $\mathcal{G}_{a}^{\#^{\leq}}$
\end_inset

 son 
\begin_inset Formula $\emptyset$
\end_inset

-recursivas (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
 Sea
\begin_inset Formula 
\[
\begin{array}{rll}
i_{0}:\omega & \rightarrow & \omega\\
x & \rightarrow & \left\{ \begin{array}{lll}
r &  & \text{si }r\text{ divide }x\\
R(x,r) &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset

y sea
\begin_inset Formula 
\[
B=\lambda x\left[Q(x\dot{-}i_{0}(x),r)\right]
\]

\end_inset

(
\begin_inset Formula $R$
\end_inset

 y 
\begin_inset Formula $Q$
\end_inset

 son definidas en el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cociente y resto"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Note que 
\begin_inset Formula $i_{0}$
\end_inset

 y 
\begin_inset Formula $B$
\end_inset

 son 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.
 y que
\begin_inset Formula 
\[
\ast^{\leq}(x)=\ast^{\leq}(B(x))a_{i_{0}(x)}\text{, para }x\geq1
\]

\end_inset

(ejercicio).
 Tambien tenemos para cada 
\begin_inset Formula $(\vec{x},\vec{y},t)\in S_{1}\times...\times S_{n}\times\#^{\leq}(L_{1})\times...\times\#^{\leq}(L_{m})\times\omega$
\end_inset

 se da
\begin_inset Formula 
\begin{align*}
h^{\#^{\leq}}(\vec{x},\vec{y},t+1) & =\#^{\leq}(h(\vec{x},\ast^{\leq}(\vec{y}),\ast^{\leq}(t+1)))\\
 & =\#^{\leq}(h(\vec{x},\ast^{\leq}(\vec{y}),\ast^{\leq}(B(t+1))a_{i_{0}(t+1)}))\\
 & =\#^{\leq}\left(\mathcal{G}_{a_{i_{0}(t+1)}}(\vec{x},\ast^{\leq}(\vec{y}),\ast^{\leq}(B(t+1)),h(\vec{x},\ast^{\leq}(\vec{y}),\ast^{\leq}(B(t+1)))\right)\\
 & =\#^{\leq}\left(\mathcal{G}_{a_{i_{0}(t+1)}}(\vec{x},\ast^{\leq}(\vec{y}),\ast^{\leq}(B(t+1)),\ast^{\leq}(h^{\#^{\leq}}(\vec{x},\vec{y},B(t+1))))\right)\\
 & =\mathcal{G}_{a_{i_{0}(t+1)}}^{\#^{\leq}}(\vec{x},\vec{y},B(t+1),h^{\#^{\leq}}(\vec{x},\vec{y},B(t+1)))
\end{align*}

\end_inset

y ya que 
\begin_inset Formula $B(t+1)<t+1$
\end_inset

, tenemos que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(**)
\end_layout

\end_inset


\begin_inset Formula $h^{\#^{\leq}}(\vec{x},\vec{y},t+1)=\mathcal{G}_{a_{i_{0}(t+1)}}^{\#^{\leq}}(\vec{x},\vec{y},B(t+1),\left(\left\langle h^{\#^{\leq}}(\vec{x},\vec{y},0),...,h^{\#^{\leq}}(\vec{x},\vec{y},t)\right\rangle \right)_{B(t+1)+1})$
\end_inset

, para cada 
\begin_inset Formula $(\vec{x},\vec{y},t)\in S_{1}\times...\times S_{n}\times\#^{\leq}(L_{1})\times...\times\#^{\leq}(L_{m})\times\omega$
\end_inset

 
\end_layout

\begin_layout Standard
A continuacion aplicaremos la idea del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "f-flecha"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Sera mas claro asi ya que para aplicarlo directamente deberiamos cambiar
 el orden de los parametros de las funciones 
\begin_inset Formula $h^{\#^{\leq}}$
\end_inset

, 
\begin_inset Formula $\mathcal{G}_{a_{i}}^{\#^{\leq}}$
\end_inset

 componiendolas adecuadamente y seria muy engorroso notacionalmente.
\end_layout

\begin_layout Standard
Definamos
\begin_inset Formula 
\[
H=\lambda t\vec{x}\vec{y}\left[\left\langle h^{\#^{\leq}}(\vec{x},\vec{y},0),...,h^{\#^{\leq}}(\vec{x},\vec{y},t)\right\rangle \right]
\]

\end_inset

Notar que
\begin_inset Formula 
\[
D_{H}=\omega\times S_{1}\times...\times S_{n}\times\#^{\leq}(L_{1})\times...\times\#^{\leq}(L_{m})
\]

\end_inset

Tenemos que
\begin_inset Formula 
\begin{align*}
H(0,\vec{x},\vec{y}) & =\left\langle h^{\#^{\leq}}(\vec{x},\vec{y},0)\right\rangle =\left\langle f^{\#^{\leq}}(\vec{x},\vec{y})\right\rangle =2^{f^{\#^{\leq}}(\vec{x},\vec{y})}\\
H(t+1,\vec{x},\vec{y}) & =\left(H(t,\vec{x},\vec{y}).pr(t+2)^{h^{\#^{\leq}}(\vec{x},\vec{y},t+1)}\right)\\
 & =\left(H(t,\vec{x},\vec{y}).pr(t+2)^{\mathcal{G}_{a_{i_{0}(t+1)}}^{\#^{\leq}}(\vec{x},\vec{y},B(t+1),(H(t,\vec{x},\vec{y}))_{B(t+1)+1})}\right)\text{ (por (**))}
\end{align*}

\end_inset

para cada 
\begin_inset Formula $(t,\vec{x},\vec{y})\in\omega\times S_{1}\times...\times S_{n}\times\#^{\leq}(L_{1})\times...\times\#^{\leq}(L_{m})$
\end_inset

.
 O sea que si definimos
\begin_inset Formula 
\[
g:\omega\times\omega\times S_{1}\times...\times S_{n}\times\#^{\leq}(L_{1})\times...\times\#^{\leq}(L_{m})\rightarrow\omega
\]

\end_inset

por
\begin_inset Formula 
\[
g(A,t,\vec{x},\vec{y})=\left\{ \begin{array}{clc}
\left(A.pr(t+2)^{\mathcal{G}_{a_{1}}^{\#^{\leq}}(\vec{x},\vec{y},B(t+1),(A)_{B(t+1)+1})}\right) & \text{si} & i_{0}(t+1)=1\\
\vdots &  & \vdots\\
\left(A.pr(t+2)^{\mathcal{G}_{a_{r}}^{\#^{\leq}}(\vec{x},\vec{y},B(t+1),(A)_{B(t+1)+1})}\right) & \text{si} & i_{0}(t+1)=r
\end{array}\right.
\]

\end_inset

tenemos que 
\begin_inset Formula $H=R(\lambda x\left[2^{x}\right]\circ f^{\#^{\leq}},g)$
\end_inset

.
 Note que 
\begin_inset Formula $g$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.), ya que
\begin_inset Formula 
\[
g=\lambda At\vec{x}\vec{y}\left[f_{1}(A,t,\vec{x},\vec{y})P_{1}(A,t,\vec{x},\vec{y})+...+f_{r}(A,t,\vec{x},\vec{y})P_{r}(A,t,\vec{x},\vec{y})\right]\text{,}
\]

\end_inset

con
\begin_inset Formula 
\begin{align*}
f_{i} & =\lambda At\vec{x}\vec{y}\left[\left(A.pr(t+2)^{\mathcal{G}_{a_{i}}^{\#^{\leq}}(\vec{x},\vec{y},B(t+1),(A)_{B(t+1)})}\right)\right]\\
P_{i} & =\lambda At\vec{x}\vec{y}\left[i_{0}(t+1)=i\right]
\end{align*}

\end_inset

O sea que 
\begin_inset Formula $H$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.) y por lo tanto lo es
\begin_inset Formula 
\[
h^{\#^{\leq}}=\lambda\vec{x}\vec{y}t\left[(H(t,\vec{x},\vec{y}))_{t+1}\right]
\]

\end_inset

Los otros casos en los cuales 
\begin_inset Formula $h$
\end_inset

 es obtenida por recursion primitiva son similares.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora podemos probar el anunciado resultado de independencia.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "independencia"

\end_inset

Sean 
\begin_inset Formula $\Sigma$
\end_inset

 y 
\begin_inset Formula $\Gamma$
\end_inset

 alfabetos cualesquiera.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Supongamos una funcion 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta y 
\begin_inset Formula $\Gamma$
\end_inset

-mixta, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.) sii 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Supongamos un conjunto 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixto y 
\begin_inset Formula $\Gamma$
\end_inset

-mixto, entonces 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-r.e., 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.) sii 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursivo (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-r.e., 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Ya que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cap\Gamma)$
\end_inset

-mixta, podemos suponer sin perdida de generalidad que 
\begin_inset Formula $\Sigma\subseteq\Gamma$
\end_inset

 (por que?).
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

 y sea 
\begin_inset Formula $\leq^{\prime}$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Gamma$
\end_inset

.
 Primero supongamos que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.).
 Probaremos que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
 Ya que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

 mixta, tenemos que 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

, con 
\begin_inset Formula $O\in\{\omega,\Sigma^{\ast}\}$
\end_inset

.
 Haremos el caso 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Ya que las funciones 
\begin_inset Formula $\#^{\leq^{\prime}}|_{\Sigma^{\ast}}$
\end_inset

 y 
\begin_inset Formula $\ast^{\leq^{\prime}}|_{\#^{\leq^{\prime}}(\Sigma^{\ast})}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "aux"
plural "false"
caps "false"
noprefix "false"

\end_inset

) y ademas
\begin_inset Formula 
\begin{align*}
f^{\#^{\leq^{\prime}}} & =\#^{\leq^{\prime}}\circ f\circ\left[p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast^{\leq^{\prime}}\circ p_{n+1}^{n+m,0},...,\ast^{\leq^{\prime}}\circ p_{n+m}^{n+m,0}\right]\\
 & =\#^{\leq^{\prime}}|_{\Sigma^{\ast}}\circ f\circ\left[p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast^{\leq^{\prime}}|_{\#^{\leq^{\prime}}(\Sigma^{\ast})}\circ p_{n+1}^{n+m,0},...,\ast^{\leq^{\prime}}|_{\#^{\leq^{\prime}}(\Sigma^{\ast})}\circ p_{n+m}^{n+m,0}\right]
\end{align*}

\end_inset

(justifique) tenemos que 
\begin_inset Formula $f^{\#^{\leq^{\prime}}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.).
 Por el lema anterior tenemos que 
\begin_inset Formula $\left(f^{\#^{\leq^{\prime}}}\right)^{\#^{\leq}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.), pero notese que 
\begin_inset Formula $\left(f^{\#^{\leq^{\prime}}}\right)^{\#^{\leq}}=f^{\#^{\leq^{\prime}}}$
\end_inset

 ya que 
\begin_inset Formula $f^{\#^{\leq^{\prime}}}$
\end_inset

 es de tipo 
\begin_inset Formula $(n+m,0,\#)$
\end_inset

, por lo cual tenemos que 
\begin_inset Formula $f^{\#^{\leq^{\prime}}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
 Pero esto por el lema anterior nos dice que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
 Probaremos que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.).
 Ya que 
\begin_inset Formula $\#^{\leq}$
\end_inset

 y 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 son 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.
 (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "aux"
plural "false"
caps "false"
noprefix "false"

\end_inset

), la funcion
\begin_inset Formula 
\[
f^{\#^{\leq}}=\#^{\leq}\circ f\circ\left[p_{1}^{n+m,0},...,p_{n}^{n+m,0},\ast^{\leq}\circ p_{n+1}^{n+m,0},...,\ast^{\leq}\circ p_{n+m}^{n+m,0}\right]
\]

\end_inset

es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Gamma$
\end_inset

-p.r.).
 Por el lema anterior 
\begin_inset Formula $\left(f^{\#^{\leq}}\right)^{\#^{\leq^{\prime}}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
 Pero notese que 
\begin_inset Formula $\left(f^{\#^{\leq}}\right)^{\#^{\leq^{\prime}}}=f^{\#^{\leq}}$
\end_inset

 ya que 
\begin_inset Formula $f^{\#^{\leq}}$
\end_inset

 es de tipo 
\begin_inset Formula $(n+m,0,\#)$
\end_inset

, por lo cual 
\begin_inset Formula $f^{\#^{\leq}}$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.).
 Esto por el lema anterior nos dice que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva (resp.
 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.).
\end_layout

\begin_layout Standard
(b) Supongamos 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixto y 
\begin_inset Formula $\Gamma$
\end_inset

-mixto.
 Ya que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cap\Gamma)$
\end_inset

-mixto, podemos suponer sin perdida de generalidad que 
\begin_inset Formula $\Sigma\subseteq\Gamma$
\end_inset

.
 Que
\begin_inset Formula 
\[
S\text{ es }\Sigma\text{-r.e. sii }S\text{ es }\Gamma\text{-r.e.}
\]

\end_inset

sigue directo de (a).
 Supongamos ahora que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
 Veremos que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursivo.
 Supongamos 
\begin_inset Formula $S$
\end_inset

 es de tipo 
\begin_inset Formula $(n,m)$
\end_inset

 es decir 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Por definicion tenemos que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Pero 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es tambien 
\begin_inset Formula $\Gamma$
\end_inset

-mixta, por lo cual (a) nos dice que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva.
 Ademas es claro que el conjunto 
\begin_inset Formula $(\omega^{n}\times\Gamma^{\ast m})-(\omega^{n}\times\Sigma^{\ast m})$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursivo.
 Ya que
\begin_inset Formula 
\[
\chi_{S}^{\omega^{n}\times\Gamma^{\ast m}}=\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}\cup C_{0}^{n,m}|_{(\omega^{n}\times\Gamma^{\ast m})-(\omega^{n}\times\Sigma^{\ast m})}
\]

\end_inset

los Lemas 
\begin_inset CommandInset ref
LatexCommand ref
reference "restriccion de recursivas a conj recursivos"
plural "false"
caps "false"
noprefix "false"

\end_inset

 y 
\begin_inset CommandInset ref
LatexCommand ref
reference "dpc para recursivas con dominio recursivo"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dicen que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Gamma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva (aqui 
\begin_inset Formula $C_{0}^{n,m}$
\end_inset

 es respecto del alfabeto 
\begin_inset Formula $\Gamma$
\end_inset

).
\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursivo.
 Veremos que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
 Por definicion tenemos que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Gamma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva.
 Ya que 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursivo, tenemos que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Gamma^{\ast m}}|_{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Gamma$
\end_inset

-recursiva.
 Por (a) tenemos que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Gamma^{\ast m}}|_{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Pero 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}=\chi_{S}^{\omega^{n}\times\Gamma^{\ast m}}|_{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 por lo cual 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva, obteniendo que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
\end_layout

\begin_layout Standard
El caso primitivo recursivo es analogo y dejado al lector.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
@@finpagina@@
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
El paradigma imperativo de Neumann: El lenguaje 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset


\end_layout

\begin_layout Standard
En esta seccion daremos una modelizacion matematica del concepto de funcion
 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable utilizando un lenguaje de programacion teorico
 el cual depende del alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

.
 Lo llamaremos 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 a dicho lenguaje.
 Dado que fue el matematico Von Neumann quien contribuyo al desarrollo de
 la primera computadora de proposito general (es decir a la cual se le pueden
 hacer correr programas tal como a las computadoras actuales), nos referiremos
 a este paradigma de computabilidad efectiva como el paradigma de Von Neumann.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "SintaxisDeSsigma"

\end_inset

Sintaxis de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset


\end_layout

\begin_layout Standard
Necesitaremos algunas funciones basicas para poder describir la sintaxis
 de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 en forma precisa.
 Llamaremos 
\shape italic
numerales
\shape default
 a los siguientes simbolos
\begin_inset Formula 
\[
0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9
\]

\end_inset

Usaremos 
\begin_inset Formula $Num$
\end_inset

 para denotar el conjunto de numerales.
 Notese que 
\begin_inset Formula $Num\cap\omega=\emptyset$
\end_inset

.
 Sea 
\begin_inset Formula $Sig:Num^{\ast}\rightarrow Num^{\ast}$
\end_inset

 definida de la siguiente manera
\begin_inset Formula 
\begin{align*}
Sig(\varepsilon) & =1\\
Sig(\alpha0) & =\alpha1\\
Sig(\alpha1) & =\alpha2\\
Sig(\alpha2) & =\alpha3\\
Sig(\alpha3) & =\alpha4\\
Sig(\alpha4) & =\alpha5\\
Sig(\alpha5) & =\alpha6\\
Sig(\alpha6) & =\alpha7\\
Sig(\alpha7) & =\alpha8\\
Sig(\alpha8) & =\alpha9\\
Sig(\alpha9) & =Sig(\alpha)0
\end{align*}

\end_inset

Definamos 
\begin_inset Formula $Dec:\omega\rightarrow Num^{\ast}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\begin{align*}
Dec(0) & =\varepsilon\\
Dec(n+1) & =Sig(Dec(n))
\end{align*}

\end_inset

Notese que para 
\begin_inset Formula $n\in\mathbf{N}$
\end_inset

, la palabra 
\begin_inset Formula $Dec(n)$
\end_inset

 es la notacion usual decimal de 
\begin_inset Formula $n$
\end_inset

.
 Para hacer mas agil la notacion escribiremos 
\begin_inset Formula $\bar{n}$
\end_inset

 en lugar de 
\begin_inset Formula $Dec(n)$
\end_inset

.
 Notese que, en virtud de esta convencion notacional se tiene que 
\begin_inset Formula $Dec=\lambda n[\bar{n}]$
\end_inset

.
 Recordemos que para 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, definiamos
\begin_inset Formula 
\[
^{\curvearrowright}\alpha=\left\{ \begin{array}{lll}
\left[\alpha\right]_{2}...\left[\alpha\right]_{\left\vert \alpha\right\vert } & \text{si} & \left\vert \alpha\right\vert \geq2\\
\varepsilon & \text{si} & \left\vert \alpha\right\vert \leq1
\end{array}\right.
\]

\end_inset

La sintaxis de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 sera dada utilizando solo simbolos del alfabeto 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

, donde
\begin_inset Formula 
\[
\Sigma_{p}=Num\cup\left\{ \leftarrow,+,\dot{-},.,\neq,^{\curvearrowright},\varepsilon,\mathrm{N},\mathrm{K},\mathrm{P},\mathrm{L},\mathrm{I},\mathrm{F},\mathrm{G},\mathrm{O},\mathrm{T},\mathrm{B},\mathrm{E},\mathrm{S}\right\} .
\]

\end_inset


\end_layout

\begin_layout Standard
Cabe aclarar que la palabra de longitud 
\begin_inset Formula $0$
\end_inset

 no es un elemento de 
\begin_inset Formula $\Sigma_{p}$
\end_inset

 sino que la letra griega 
\begin_inset Formula $\varepsilon$
\end_inset

 que usualmente denota esta palabra, lo es.
 Tambien notese que en 
\begin_inset Formula $\Sigma_{p}$
\end_inset

 hay simbolos que a veces representan operaciones como por ejemplo 
\begin_inset Formula $+$
\end_inset

 y 
\begin_inset Formula $\dot{-}$
\end_inset

, pero deberia quedar claro que en 
\begin_inset Formula $\Sigma_{p}$
\end_inset

 estan los simbolos 
\begin_inset Formula $+$
\end_inset

 y 
\begin_inset Formula $\dot{-}$
\end_inset

 y no las operaciones que ellos denotan.
\end_layout

\begin_layout Standard
Las palabras de la forma 
\begin_inset Formula $\mathrm{N}\bar{k}$
\end_inset

 con 
\begin_inset Formula $k\in\mathbf{N}$
\end_inset

, son llamadas 
\shape italic
variables numericas de 
\shape default

\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
 Las palabras de la forma 
\begin_inset Formula $\mathrm{P}\bar{k}$
\end_inset

 con 
\begin_inset Formula $k\in\mathbf{N}$
\end_inset

, son llamadas 
\shape italic
variables alfabeticas de 
\shape default

\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
 Las palabras de la forma 
\begin_inset Formula $\mathrm{L}\bar{k}$
\end_inset

 con 
\begin_inset Formula $k\in\mathbf{N}$
\end_inset

, son llamadas 
\shape italic
labels de 
\shape default

\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
Una 
\shape italic
instruccion basica de 
\shape default

\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 es una palabra de 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

 la cual es de alguna de las siguientes formas
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{k}+1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{k}\dot{-}1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{n}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{N}\bar{k}\leftarrow0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{k}.a$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{P}\bar{k}\leftarrow$
\end_inset

 
\begin_inset Formula $^{\curvearrowright}\mathrm{P}\bar{k}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{n}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{P}\bar{k}\leftarrow\varepsilon$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{IF}\;\mathrm{N}\bar{k}\neq0\;\mathrm{GOTO}\;\mathrm{L}\bar{n}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{n}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{GOTO}\;\mathrm{L}\bar{n}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{SKIP}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
donde 
\begin_inset Formula $a\in\Sigma$
\end_inset

 y 
\begin_inset Formula $k,n\in\mathbf{N}$
\end_inset

.
 Como puede observarse para que las instrucciones basicas sean mas lejibles
 usamos espacios entre ciertos simbolos.
 Por ejemplo, hemos escrito 
\begin_inset Formula $\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{k}+1$
\end_inset

 pero en realidad nos referimos a la palabra
\begin_inset Formula 
\[
\mathrm{N}\bar{k}\mathrm{\leftarrow}\text{\textrm{N}}\bar{k}\mathrm{+1}
\]

\end_inset

cuya longitud es 
\begin_inset Formula $2\left\vert \bar{k}\right\vert +5$
\end_inset

.
 Otro ejemplo, hemos escrito 
\begin_inset Formula $\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{n}$
\end_inset

 pero en realidad nos referiamos a la palabra 
\begin_inset Formula $\mathrm{IFP}\bar{k}\mathrm{BEGINS}a\mathrm{GOTOL}\bar{n}$
\end_inset

 cuya longitud es 
\begin_inset Formula $\left\vert \bar{k}\right\vert +\left\vert \bar{n}\right\vert +15$
\end_inset

.
\end_layout

\begin_layout Standard
Una 
\shape italic
instruccion de 
\shape default

\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 es ya sea una instruccion basica de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 o una palabra de la forma 
\begin_inset Formula $\alpha I$
\end_inset

, donde 
\begin_inset Formula $\alpha\in\{\mathrm{L}\bar{n}:n\in\mathbf{N}\}$
\end_inset

 y 
\begin_inset Formula $I$
\end_inset

 es una instruccion basica de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
 Usaremos 
\begin_inset Formula $\mathrm{Ins}^{\Sigma}$
\end_inset

 para denotar el conjunto de todas las instrucciones de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
 Cuando la instruccion 
\begin_inset Formula $I$
\end_inset

 es de la forma 
\begin_inset Formula $\mathrm{L}\bar{n}J$
\end_inset

 con 
\begin_inset Formula $J$
\end_inset

 una instruccion basica, diremos que 
\begin_inset Formula $\mathrm{L}\bar{n}$
\end_inset

 es el 
\shape italic
label
\shape default
 de 
\begin_inset Formula $I$
\end_inset

.
 Damos a continuacion, a modo de ejemplo, la interpretacion intuitiva asociada
 a ciertas instrucciones basicas de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\text{INSTRUCCION} & :\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{k}\dot{-}1\\
\text{INTERPRETACION} & :\begin{array}[t]{c}
\text{Si el contenido de }\mathrm{N}\bar{k}\text{ es }0\text{ dejarlo sin modificar; en}\\
\text{caso contrario disminuya en 1 el contenido de }\mathrm{N}\bar{k}\;
\end{array}\\
\text{INSTRUCCION} & :\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{n}\\
\text{INTERPRETACION} & :\begin{array}[t]{l}
\text{Copiar en }\mathrm{N}\bar{k}\text{ el contenido de }\mathrm{N}\bar{n}\text{ (sin modificar el}\\
\text{contenido de }\mathrm{N}\bar{n}\text{)}
\end{array}\\
\text{INSTRUCCION} & :\mathrm{P}\bar{k}\leftarrow^{\curvearrowright}\mathrm{P}\bar{k}\\
\text{INTERPRETACION} & :\begin{array}[t]{l}
\text{Si el contenido de }\mathrm{P}\bar{k}\text{ es }\varepsilon\text{ dejarlo sin modificar;}\\
\text{en caso contrario remueva el 1er simbolo del}\\
\text{contenido de }\mathrm{P}\bar{k}
\end{array}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\text{INSTRUCCION} & :\mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{k}.a\\
\text{INTERPRETACION} & :\begin{array}[t]{l}
\text{Modificar el contenido de }\mathrm{P}\bar{k}\text{ agregandole}\\
\text{el simbolo }a\text{ a la derecha}
\end{array}\\
\text{INSTRUCCION} & :\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\\
\text{INTERPRETACION} & :\begin{array}[t]{l}
\text{Si el contenido de }\mathrm{P}\bar{k}\text{ comiensa con }a,\text{ejecute}\\
\text{la primer instruccion con label }\mathrm{L}\bar{m}\text{; en caso}\\
\text{contrario ejecute la siguiente instruccion}
\end{array}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Un 
\shape italic
programa de 
\shape default

\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 es una palabra de la forma
\begin_inset Formula 
\[
I_{1}I_{2}...I_{n}
\]

\end_inset

donde 
\begin_inset Formula $n\geq1$
\end_inset

, 
\begin_inset Formula $I_{1},...,I_{n}\in\mathrm{Ins}^{\Sigma}$
\end_inset

 y ademas se cumple la siguiente propiedad, llamada 
\shape italic
la ley de los GOTO
\shape default
,
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(G)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $i\in\{1,...,n\}$
\end_inset

, si 
\begin_inset Formula $\mathrm{GOTOL}\bar{m}$
\end_inset

 es un tramo final de 
\begin_inset Formula $I_{i}$
\end_inset

, entonces existe 
\begin_inset Formula $j\in\{1,...,n\}$
\end_inset

 tal que 
\begin_inset Formula $I_{j}$
\end_inset

 tiene label 
\begin_inset Formula $\mathrm{L}\bar{m}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Usaremos 
\begin_inset Formula $\mathrm{Pro}^{\Sigma}$
\end_inset

 para denotar el conjunto de todos los programas de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
 Como es usual cuando escribamos un programa lo haremos linea por linea,
 con la finalidad de que sea mas lejible.
 Por ejemplo, escribiremos
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}2 & \mathrm{N}12\leftarrow\mathrm{N}12\dot{-}1\\
 & \mathrm{P}1\leftarrow\text{ }^{\curvearrowright}\mathrm{P}1\\
 & \mathrm{IF\;N}12\neq0\;\mathrm{GOTO}\;\mathrm{L}2
\end{array}
\]

\end_inset

en lugar de
\begin_inset Formula 
\[
\mathrm{L}2\mathrm{N}12\mathrm{\leftarrow}\text{N}12\mathrm{\dot{-}}1\mathrm{P}1\mathrm{\leftarrow}^{\curvearrowright}\mathrm{P}1\mathrm{IFN}12\mathrm{\neq}0\mathrm{GOTOL}2
\]

\end_inset

Un importante resultado es el siguiente lema que garantiza que los programas
 pueden ser parseados en forma unica como concatenacion de instrucciones.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Si 
\begin_inset Formula $I_{1}...I_{n}=J_{1}...J_{m}$
\end_inset

, con 
\begin_inset Formula $I_{1},...,I_{n},J_{1},...,J_{m}\in\mathrm{Ins}^{\Sigma}$
\end_inset

, entonces 
\begin_inset Formula $n=m$
\end_inset

 y 
\begin_inset Formula $I_{j}=J_{j}$
\end_inset

 para cada 
\begin_inset Formula $j\geq1$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

, entonces existe una unica sucesion de instrucciones 
\begin_inset Formula $I_{1},...,I_{n}$
\end_inset

 tal que 
\begin_inset Formula $\mathcal{P}=I_{1}...I_{n}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Supongamos 
\begin_inset Formula $I_{n}$
\end_inset

 es un tramo final propio de 
\begin_inset Formula $J_{m}.$
\end_inset

 Notar que entonces 
\begin_inset Formula $n>1$
\end_inset

.
 Es facil ver que entonces ya sea 
\begin_inset Formula $J_{m}=\mathrm{L}\bar{u}I_{n}$
\end_inset

 para algun 
\begin_inset Formula $u\in\mathbf{N}$
\end_inset

, o 
\begin_inset Formula $I_{n}$
\end_inset

 es de la forma 
\begin_inset Formula $\mathrm{GOTO}\;\mathrm{L}\bar{n}$
\end_inset

 y 
\begin_inset Formula $J_{m}$
\end_inset

 es de la forma 
\begin_inset Formula $w\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{n}$
\end_inset

 donde 
\begin_inset Formula $w\in\{\mathrm{L}\bar{n}:n\in\mathbf{N}\}\cup\{\varepsilon\}$
\end_inset

.
 El segundo caso no puede darse porque entonces el anteultimo simbolo de
 
\begin_inset Formula $I_{n-1}$
\end_inset

 deberia ser 
\begin_inset Formula $\mathrm{S}$
\end_inset

 lo cual no sucede para ninguna instruccion.
 O sea que
\begin_inset Formula 
\[
I_{1}...I_{n}=J_{1}...J_{m-1}\mathrm{L}\bar{u}I_{n}
\]

\end_inset

lo cual dice que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset


\begin_inset Formula $I_{1}...I_{n-1}=J_{1}...J_{m-1}\mathrm{L}\bar{u}.$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Es decir que 
\begin_inset Formula $\mathrm{L}\bar{u}$
\end_inset

 es tramo final de 
\begin_inset Formula $I_{n-1}$
\end_inset

 y por lo tanto 
\begin_inset Formula $\mathrm{GOTO}\;\mathrm{L}\bar{u}$
\end_inset

 es tramo final de 
\begin_inset Formula $I_{n-1}.$
\end_inset

 Por (*), 
\begin_inset Formula $\mathrm{GOTO}$
\end_inset

 es tramo final de 
\begin_inset Formula $J_{1}...J_{m-1}$
\end_inset

, lo cual es impossible.
 Hemos llegado a una contradiccion lo cual nos dice que 
\begin_inset Formula $I_{n}$
\end_inset

 no es un tramo final propio de 
\begin_inset Formula $J_{m}.$
\end_inset

 Por simetria tenemos que 
\begin_inset Formula $I_{n}=J_{m}$
\end_inset

, lo cual usando un razonamiento inductivo nos dice que 
\begin_inset Formula $n=m$
\end_inset

 y 
\begin_inset Formula $I_{j}=J_{j}$
\end_inset

 para cada 
\begin_inset Formula $j\geq1$
\end_inset

.
\end_layout

\begin_layout Standard
(b) Es consecuencia directa de (a).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
(b) del lema anterior nos dice que dado un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

, tenemos univocamente determinados 
\begin_inset Formula $n(\mathcal{P})\in\mathbf{N}$
\end_inset

 y 
\begin_inset Formula $I_{1}^{\mathcal{P}},...,I_{n(\mathcal{P})}^{\mathcal{P}}\in\mathrm{Ins}^{\Sigma}$
\end_inset

 tales que 
\begin_inset Formula $\mathcal{P}=I_{1}^{\mathcal{P}}...I_{n(\mathcal{P})}^{\mathcal{P}}$
\end_inset

.
 Definamos tambien
\begin_inset Formula 
\[
I_{i}^{\mathcal{P}}=\varepsilon
\]

\end_inset

cuando 
\begin_inset Formula $i=0$
\end_inset

 o 
\begin_inset Formula $i>n(\mathcal{P})$
\end_inset

.
 Notese que las expresiones 
\begin_inset Formula $n(\alpha)$
\end_inset

 y 
\begin_inset Formula $I_{i}^{\alpha}$
\end_inset

 estan definidas solo cuando 
\begin_inset Formula $\alpha$
\end_inset

 es un programa (y 
\begin_inset Formula $i$
\end_inset

 es un elemento de 
\begin_inset Formula $\omega$
\end_inset

), es decir, cierta palabra del alfabeto 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

.
 O sea que cuando usemos notacion lambda que involucre dichas expresiones,
 el alfabeto respecto del cual usaremos dicha notacion sera 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

.
 Esto nos dice entonces que 
\begin_inset Formula $\lambda\alpha[n(\alpha)]$
\end_inset

 tiene dominio igual a 
\begin_inset Formula $\mathrm{Pro}^{\Sigma}\subseteq(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

 y 
\begin_inset Formula $\lambda i\alpha[I_{i}^{\alpha}]$
\end_inset

 tiene dominio igual a 
\begin_inset Formula $\omega\times\mathrm{Pro}^{\Sigma}$
\end_inset

.
 Para hacer mas sugestiva la notacion a veces escribiremos 
\begin_inset Formula $\lambda\mathcal{P}[n(\mathcal{P})]$
\end_inset

 y 
\begin_inset Formula $\lambda i\mathcal{P}[I_{i}^{\mathcal{P}}]$
\end_inset

 en lugar de 
\begin_inset Formula $\lambda\alpha[n(\alpha)]$
\end_inset

 y 
\begin_inset Formula $\lambda i\alpha[I_{i}^{\alpha}]$
\end_inset

.
\end_layout

\begin_layout Standard
Sera necesaria la funcion 
\begin_inset Formula $Bas:\mathrm{Ins}^{\Sigma}\rightarrow(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

, dada por
\begin_inset Formula 
\[
Bas(I)=\left\{ \begin{array}{ccl}
J &  & \text{si }I\text{ es de la forma }\mathrm{L}\bar{k}J\text{, con }k\in\mathbf{N}\text{ y }J\in\mathrm{Ins}^{\Sigma}\\
I &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Semantica de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset


\end_layout

\begin_layout Standard
Definamos
\begin_inset Formula 
\begin{align*}
\omega^{\left[\mathbf{N}\right]} & =\left\{ (s_{1},s_{2},...)\in\omega^{\mathbf{N}}:\text{ hay }n\in\mathbf{N}\text{ tal que }s_{i}=0,\text{para }i\geq n\right\} \\
\Sigma^{\ast\left[\mathbf{N}\right]} & =\left\{ (\sigma_{1},\sigma_{2},...)\in\Sigma^{\ast\mathbf{N}}:\text{ hay }n\in\mathbf{N}\text{ tal que }\sigma_{i}=\varepsilon,\text{para }i\geq n\right\} .
\end{align*}

\end_inset

Asumiremos siempre que en una computacion via un programa de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

, todas exepto una cantidad finita de las variables numericas tienen el
 valor 
\begin_inset Formula $0$
\end_inset

 y todas exepto una cantiad finita de las variables alfabeticas tienen el
 valor 
\begin_inset Formula $\varepsilon$
\end_inset

.
 Esto no quita generalidad a nuestra modelizacion del funcionamiento de
 los programas ya que todo programa envuelve una cantidad finita de variables.
\end_layout

\begin_layout Standard
Un 
\shape italic
estado
\shape default
 es un par
\begin_inset Formula 
\[
(\vec{s},\vec{\sigma})=((s_{1},s_{2},...),(\sigma_{1},\sigma_{2},...))\in\omega^{\left[\mathbf{N}\right]}\times\Sigma^{\ast\left[\mathbf{N}\right]}.
\]

\end_inset

Si 
\begin_inset Formula $i\geq1$
\end_inset

, entonces diremos que 
\begin_inset Formula $s_{i}$
\end_inset

 es el 
\shape italic
contenido 
\shape default
o
\shape italic

\begin_inset space \space{}
\end_inset

valor 
\shape default
de la variable 
\begin_inset Formula $\mathrm{N}\bar{\imath}$
\end_inset

 en el estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 y 
\begin_inset Formula $\sigma_{i}$
\end_inset

 es el 
\shape italic
contenido 
\shape default
o
\shape italic

\begin_inset space \space{}
\end_inset

valor 
\shape default
de la variable 
\begin_inset Formula $\mathrm{P}\bar{\imath}$
\end_inset

 en el estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
 Intuitivamente hablando, un estado es un par de infinituplas que contiene
 la informacion de que valores tienen alojados las distintas variables.
\end_layout

\begin_layout Standard
Imaginemos que corremos un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 partiendo de un estado inicial 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
 Por supuesto la primera instruccion a realizar sera 
\begin_inset Formula $I_{1}^{\mathcal{P}}$
\end_inset

 pero, dado que 
\begin_inset Formula $I_{1}^{\mathcal{P}}$
\end_inset

 puede ser de tipo GOTO, la segunda instruccion que realizaremos puede no
 ser 
\begin_inset Formula $I_{2}^{\mathcal{P}}$
\end_inset

.
 Es decir en cada paso iremos decidiendo en funcion de la instruccion ejecutada
 cual es la siguiente instruccion a realizar.
 O sea que mientras corremos 
\begin_inset Formula $\mathcal{P}$
\end_inset

, en cada paso la informacion importante a tener en cuenta es, por una parte,
 cuales son los valores que tienen cada una de las variables y, por otra
 parte, cual es la instruccion que nos tocara realizar a continuacion.
 Esto da lugar al concepto de descripcion instantanea, a saber, un objeto
 matematico que describe en un instante dado de la computacion cuales son
 los valores de las variables y cual es la instruccion que se debe realizar
 en el instante siguiente.
 Mas formalmente una 
\shape italic
descripcion instantanea
\shape default
 es una terna 
\begin_inset Formula $(i,\vec{s},\vec{\sigma})$
\end_inset

 tal que 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 es un estado e 
\begin_inset Formula $i\in\omega$
\end_inset

.
 Es decir que 
\begin_inset Formula $\omega\times\omega^{\left[\mathbf{N}\right]}\times\Sigma^{\ast\left[\mathbf{N}\right]}$
\end_inset

 es el conjunto formado por todas las descripciones instantaneas.
 Intuitivamente hablando, cuando 
\begin_inset Formula $i\in\{1,...,n(\mathcal{P})\}$
\end_inset

, la descripcion instantanea 
\begin_inset Formula $(i,\vec{s},\vec{\sigma})$
\end_inset

 nos dice que las variables estan en el estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 y que la instruccion que 
\shape italic
debemos realizar
\shape default
 es 
\begin_inset Formula $I_{i}^{\mathcal{P}}$
\end_inset

.
 Dado que sera conveniente para simplificar el tratamiento formal, nos abstraere
mos un poco y cuando 
\begin_inset Formula $i=0$
\end_inset

 o 
\begin_inset Formula $i>n(\mathcal{P})$
\end_inset

 pensaremos tambien que la descripcion instantanea 
\begin_inset Formula $(i,\vec{s},\vec{\sigma})$
\end_inset

 nos dice que las variables estan en el estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 y que debemos realizar 
\begin_inset Formula $I_{i}^{\mathcal{P}}=\varepsilon$
\end_inset

 (aunque por supuesto no podremos realizarla ya que no es una instruccion).
\end_layout

\begin_layout Standard
Dado un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 definiremos a continuacion una funcion
\begin_inset Formula 
\[
S_{\mathcal{P}}:\omega\times\omega^{\left[\mathbf{N}\right]}\times\Sigma^{\ast\left[\mathbf{N}\right]}\rightarrow\omega\times\omega^{\left[\mathbf{N}\right]}\times\Sigma^{\ast\left[\mathbf{N}\right]}
\]

\end_inset

la cual le asignara a una descripcion instantanea 
\begin_inset Formula $(i,\vec{s},\vec{\sigma})$
\end_inset

 la 
\shape italic
descripcion instantanea sucesora de 
\shape default

\begin_inset Formula $(i,\vec{s},\vec{\sigma})$
\end_inset

 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Cuando 
\begin_inset Formula $i\in\{1,...,n(\mathcal{P})\}$
\end_inset

, intuitivamente hablando, 
\begin_inset Formula $S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})$
\end_inset

 sera la descripcion instantanea que resulta luego de realizar 
\begin_inset Formula $I_{i}^{\mathcal{P}}$
\end_inset

 estando en el estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
 Cuando 
\begin_inset Formula $i=0$
\end_inset

 o 
\begin_inset Formula $i>n(\mathcal{P})$
\end_inset

 definiremos 
\begin_inset Formula $S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i,\vec{s},\vec{\sigma})$
\end_inset

, lo cual es bastante intuitivo ya que si estamos en estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 y debemos realizar 
\begin_inset Formula $I_{i}^{\mathcal{P}}=\varepsilon$
\end_inset

, dado que 
\begin_inset Formula $\varepsilon$
\end_inset

 no es una instruccion y por lo tanto no la podremos realizar, seguiremos
 en el mismo estado y teniendo que realizar 
\begin_inset Formula $I_{i}^{\mathcal{P}}$
\end_inset

.
\end_layout

\begin_layout Standard
Para darle una semantica mas unificada al concepto de descripcion instantanea
 sucesora debemos crear un nuevo verbo.
 El verbo 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

realizarp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Dada una actividad A, diremos que un individuo P 
\shape italic
realizap
\shape default
 la actividad A, si P realiza A, en caso de que pueda hacerlo.
 O sea realizarp una actividad es realizarla si se puede.
\end_layout

\begin_layout Standard
Para dar otro ejemplo de este tipo de verbos, consideremos el verbo 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

comprarp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, es decir 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

comprar si se puede
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Un hijo le pide a su padre que le compre un determinado juguete y el padre
 le dice 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

si, hijo mio, te lo voy a comprarp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Luego el padre es despedido de su empleo y su cituacion economica hace
 que no le sea posible comprar dicho juguete.
 Sin envargo el padre no mintio ya que si bien no compro dicho juguete,
 l si lo comprop.
\end_layout

\begin_layout Standard
Con este verbo podemos describir intuitivamente 
\begin_inset Formula $S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})$
\end_inset

:
\begin_inset Formula 
\begin{align*}
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma}) & =\mathrm{desc\ inst\ que\ resulta\ luego\ de}\\
 & \mathrm{rea}\text{l}\mathrm{izarp\ }I_{i}^{\mathcal{P}}\text{, estando en estado }(\vec{s},\vec{\sigma})
\end{align*}

\end_inset

Ahora si, daremos la definicion matematica de 
\begin_inset Formula $S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})$
\end_inset

, segun se den distintos casos posibles.
\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $i\notin\{1,...,n(\mathcal{P})\}$
\end_inset

.
 Entonces 
\begin_inset Formula $S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i,\vec{s},\vec{\sigma})$
\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{k}\dot{-}1.$
\end_inset

 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,(s_{1},...,s_{k-1},s_{k}\dot{-}1,s_{k+1},...),\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{k}+1.$
\end_inset

 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,(s_{1},...,s_{k-1},s_{k}+1,s_{k+1},...),\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{n}$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,(s_{1},...,s_{k-1},s_{n},s_{k+1},...),\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow0.$
\end_inset

 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,(s_{1},...,s_{k-1},0,s_{k+1},...),\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}$
\end_inset

 
\begin_inset Formula $\mathrm{N}\bar{k}$
\end_inset

 
\begin_inset Formula $\neq0$
\end_inset

 
\begin_inset Formula $\mathrm{GOTO}$
\end_inset

 
\begin_inset Formula $\mathrm{L}\bar{m}.$
\end_inset

 Entonces tenemos dos subcasos.
\end_layout

\begin_layout Standard
Subcaso a.
 El valor de 
\begin_inset Formula $\mathrm{N}\bar{k}$
\end_inset

 en 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 es 0.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,\vec{s},\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Subcaso b.
 El valor de 
\begin_inset Formula $\mathrm{N}\bar{k}$
\end_inset

 en 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 es no nulo.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(\min\{l:I_{l}^{\mathcal{P}}\ \mathrm{tiene\ label\ L}\bar{m}\},\vec{s},\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow$
\end_inset

 
\begin_inset Formula $^{\curvearrowright}\mathrm{P}\bar{k}.$
\end_inset

 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,\vec{s},(\sigma_{1},...,\sigma_{k-1},^{\curvearrowright}\sigma_{k},\sigma_{k+1},...))
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{k}.a$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,\vec{s},(\sigma_{1},...,\sigma_{k-1},\sigma_{k}a,\sigma_{k+1},...))
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{n}$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,\vec{s},(\sigma_{1},...,\sigma_{k-1},\sigma_{n},\sigma_{k+1},...))
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow\varepsilon.$
\end_inset

 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,\vec{s},(\sigma_{1},...,\sigma_{k-1},\varepsilon,\sigma_{k+1},...))
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}.$
\end_inset

 Entonces tenemos dos subcasos.
\end_layout

\begin_layout Standard
Subcaso a.
 El valor de 
\begin_inset Formula $\mathrm{P}\bar{k}$
\end_inset

 en 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 comiensa con 
\begin_inset Formula $a$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(\min\{l:I_{l}^{\mathcal{P}}\ \mathrm{tiene\ label\ L}\bar{m}\},\vec{s},\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Subcaso b.
 El valor de 
\begin_inset Formula $\mathrm{P}\bar{k}$
\end_inset

 en 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 no comiensa con 
\begin_inset Formula $a$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,\vec{s},\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{GOTO}\;\mathrm{L}\bar{m}$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(\min\{l:I_{l}^{\mathcal{P}}\ \mathrm{tiene\ label\ L}\bar{m}\},\vec{s},\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{SKIP}$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
S_{\mathcal{P}}(i,\vec{s},\vec{\sigma})=(i+1,\vec{s},\vec{\sigma})
\]

\end_inset


\end_layout

\begin_layout Subsubsection
La computacion partiendo de un estado
\end_layout

\begin_layout Standard
Dado un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 y un estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 a la infinitupla
\begin_inset Formula 
\[
((1,\vec{s},\vec{\sigma}),S_{\mathcal{P}}(1,\vec{s},\vec{\sigma}),S_{\mathcal{P}}(S_{\mathcal{P}}(1,\vec{s},\vec{\sigma})),S_{\mathcal{P}}(S_{\mathcal{P}}(S_{\mathcal{P}}(1,\vec{s},\vec{\sigma}))),...)
\]

\end_inset

la llamaremos la 
\shape italic
computacion de 
\shape default

\begin_inset Formula $\mathcal{P}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

partiendo del estado 
\shape default

\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
 Diremos que
\begin_inset Formula 
\[
\overset{t\text{ veces}}{\overbrace{S_{\mathcal{P}}(...S_{\mathcal{P}}(S_{\mathcal{P}}(}}1,\vec{s},\vec{\sigma}))...)
\]

\end_inset

es la 
\shape italic
descripcion instantanea obtenida luego de 
\shape default

\begin_inset Formula $t$
\end_inset

 
\shape italic
pasos, partiendo del estado 
\shape default

\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
 Si
\begin_inset Formula 
\[
\overset{t\text{ veces}}{\overbrace{S_{\mathcal{P}}(...S_{\mathcal{P}}(S_{\mathcal{P}}(}}1,\vec{s},\vec{\sigma}))...)=(j,\vec{u},\vec{\eta})
\]

\end_inset

diremos que 
\begin_inset Formula $(\vec{u},\vec{\eta})$
\end_inset

 es el 
\shape italic
estado obtenido luego de 
\shape default

\begin_inset Formula $t$
\end_inset

 
\shape italic
pasos, partiendo del estado 
\shape default

\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
\end_layout

\begin_layout Standard
Es claro que en la infinitupla de mas arriba esta toda la informacion de
 la 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

corrida
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 del programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 cuando partimos del estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
 Veamos un ejemplo.
 Sea 
\begin_inset Formula $\Sigma=\{\blacktriangle,\#\}$
\end_inset

 y sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}3 & \mathrm{N}4\leftarrow\mathrm{N}4+1\\
 & \mathrm{P}1\leftarrow\ ^{\curvearrowright}\mathrm{P}1\\
 & \mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3\\
 & \mathrm{P}3\leftarrow\mathrm{P}3.\#
\end{array}
\]

\end_inset

Supongamos que tomamos 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 igual al estado
\begin_inset Formula 
\[
\left((2,1,0,5,3,0,0,0,...),(\#\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...)\right)
\]

\end_inset

Tendremos entonces que la computacion de 
\begin_inset Formula $\mathcal{P}$
\end_inset


\begin_inset space \space{}
\end_inset

partiendo del estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 es la siguiente sucesion (de arriba hacia abajo) de descripciones instantaneas:
\begin_inset Formula 
\begin{gather*}
(1,(2,1,0,5,3,0,0,0,...),(\#\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{1}^{\mathcal{P}}=\mathrm{N}4\leftarrow\mathrm{N}4+1\text{ obtenemos}\\
(2,(2,1,0,6,3,0,0,0,...),(\#\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{2}^{\mathcal{P}}=\mathrm{P}1\leftarrow\ ^{\curvearrowright}\mathrm{P}1\text{ obtenemos}\\
(3,(2,1,0,6,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{3}^{\mathcal{P}}=\mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3\text{ obtenemos}\\
(1,(2,1,0,6,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{1}^{\mathcal{P}}=\mathrm{N}4\leftarrow\mathrm{N}4+1\text{ obtenemos}\\
(2,(2,1,0,7,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{2}^{\mathcal{P}}=\mathrm{P}1\leftarrow\ ^{\curvearrowright}\mathrm{P}1\text{ obtenemos}\\
(3,(2,1,0,7,3,0,0,0,...),(\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{3}^{\mathcal{P}}=\mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3\text{ obtenemos}\\
(4,(2,1,0,7,3,0,0,0,...),(\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{4}^{\mathcal{P}}=\mathrm{P}3\leftarrow\mathrm{P}3.\#\text{ obtenemos}\\
(5,(2,1,0,7,3,0,0,0,...),(\#\#,\varepsilon,\blacktriangle\blacktriangle\#,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{intentando realizar }I_{5}^{\mathcal{P}}=\varepsilon\text{ obtenemos}\\
(5,(2,1,0,7,3,0,0,0,...),(\#\#,\varepsilon,\blacktriangle\blacktriangle\#,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{intentando realizar }I_{5}^{\mathcal{P}}=\varepsilon\text{ obtenemos}\\
(5,(2,1,0,7,3,0,0,0,...),(\#\#,\varepsilon,\blacktriangle\blacktriangle\#,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{intentando realizar }I_{5}^{\mathcal{P}}=\varepsilon\text{ obtenemos}\\
(5,(2,1,0,7,3,0,0,0,...),(\#\#,\varepsilon,\blacktriangle\blacktriangle\#,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\vdots
\end{gather*}

\end_inset

Notese que en este caso es natural decir que el programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene, partiendo del estado inicial dado ya que llega a un punto en
 el que queda intentando realizar 
\begin_inset Formula $I_{n(\mathcal{P})+1}^{\mathcal{P}}$
\end_inset

 lo cual no es una instruccion.
 Veamos un ejemplo de no detencion.
 Sea 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 el siguiente programa
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}3 & \mathrm{N}4\leftarrow\mathrm{N}4+1\\
 & \mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3
\end{array}
\]

\end_inset

Supongamos que tomamos 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 igual al estado
\begin_inset Formula 
\[
\left((2,1,0,5,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...)\right)
\]

\end_inset

Tendremos entonces que la computacion de 
\begin_inset Formula $\mathcal{Q}$
\end_inset


\begin_inset space \space{}
\end_inset

partiendo del estado 
\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

 es la siguiente sucesion (de arriba hacia abajo) de descripciones instantaneas:
\begin_inset Formula 
\begin{gather*}
(1,(2,1,0,5,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{1}^{\mathcal{P}}=\mathrm{N}4\leftarrow\mathrm{N}4+1\text{ obtenemos}\\
(2,(2,1,0,6,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{2}^{\mathcal{P}}=\mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3\text{ obtenemos}\\
(1,(2,1,0,6,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{1}^{\mathcal{P}}=\mathrm{N}4\leftarrow\mathrm{N}4+1\text{ obtenemos}\\
(2,(2,1,0,7,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{2}^{\mathcal{P}}=\mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3\text{ obtenemos}\\
(1,(2,1,0,7,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{1}^{\mathcal{P}}=\mathrm{N}4\leftarrow\mathrm{N}4+1\text{ obtenemos}\\
(2,(2,1,0,8,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{2}^{\mathcal{P}}=\mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3\text{ obtenemos}\\
(1,(2,1,0,8,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{1}^{\mathcal{P}}=\mathrm{N}4\leftarrow\mathrm{N}4+1\text{ obtenemos}\\
(2,(2,1,0,9,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\text{realizando }I_{2}^{\mathcal{P}}=\mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3\text{ obtenemos}\\
(1,(2,1,0,9,3,0,0,0,...),(\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#,\varepsilon,\varepsilon,\varepsilon,...))\\
\vdots
\end{gather*}

\end_inset

Notese que en este caso, es claro que el programa 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 no se detiene partiendo del estado inicial dado ya que sigue indefinidamente
 realizando instrucciones.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
Definicion matematica de detencion
\end_layout

\begin_layout Standard
Ahora definiremos matematicamente el concepto de detencion.
 Cuando la primer coordenada de
\begin_inset Formula 
\[
\overset{t\text{ veces}}{\overbrace{S_{\mathcal{P}}(...S_{\mathcal{P}}(S_{\mathcal{P}}(}}1,\vec{s},\vec{\sigma}))...)
\]

\end_inset

sea igual a 
\begin_inset Formula $n(\mathcal{P})+1$
\end_inset

, diremos que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 
\shape italic
se detiene (luego de 
\shape default

\begin_inset Formula $t$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

pasos), partiendo desde el estado 
\shape default

\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
 Si ninguna de las primeras coordenadas en la computacion
\begin_inset Formula 
\[
((1,\vec{s},\vec{\sigma}),S_{\mathcal{P}}(1,\vec{s},\vec{\sigma}),S_{\mathcal{P}}(S_{\mathcal{P}}(1,\vec{s},\vec{\sigma})),S_{\mathcal{P}}(S_{\mathcal{P}}(S_{\mathcal{P}}(1,\vec{s},\vec{\sigma}))),...)
\]

\end_inset

es igual a 
\begin_inset Formula $n(\mathcal{P})+1$
\end_inset

, diremos que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 
\shape italic
no se detiene partiendo del estado 
\shape default

\begin_inset Formula $(\vec{s},\vec{\sigma})$
\end_inset

.
\end_layout

\begin_layout Standard
Cabe destacar que en los conceptos antes definidos por 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

1 paso
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 entendemos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

realizarp una instrucion
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, donde tal como se lo explico antes 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

realizarp
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 significa 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

realizar si se puede
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Otra observacion importante es que los programas de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 tienen una sola manera de detenerse, i.e.
 siempre que se detienen lo hacen habiendo realizado la ultima de sus instruccio
nes e intentando realizar la instruccion siguiente a su ultima instruccion.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Funciones 
\begin_inset Formula $\Sigma$
\end_inset

-computables
\end_layout

\begin_layout Standard
Ahora que hemos definido matematicamente la semantica de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 estamos en condiciones de definir el concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable, el cual sera una modelizacion matematica del concepto de funcion
 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Intuitivamente hablando una funcion sera 
\begin_inset Formula $\Sigma$
\end_inset

-computable cuando haya un programa que la compute.
 Para precisar este concepto nos sera util la siguiente notacion.
 Dados 
\begin_inset Formula $x_{1},...,x_{n}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{m}\in\Sigma^{\ast}$
\end_inset

, con 
\begin_inset Formula $n,m\in\omega$
\end_inset

, usaremos
\begin_inset Formula 
\[
\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert 
\]

\end_inset

para denotar el estado
\begin_inset Formula 
\[
\left((x_{1},...,x_{n},0,...),(\alpha_{1},...,\alpha_{m},\varepsilon,...)\right)
\]

\end_inset

Esta notacion requiere aclarar un poco como debe interpretarse en los casos
 limite, es decir cuando alguno de los numeros 
\begin_inset Formula $n,m$
\end_inset

 es igual a 
\begin_inset Formula $0$
\end_inset

.
 Notese que por ejemplo
\begin_inset Formula 
\[
\left\Vert x\right\Vert =\left((x,0,...),(\varepsilon,...)\right)
\]

\end_inset

(es el caso 
\begin_inset Formula $n=1$
\end_inset

 y 
\begin_inset Formula $m=0$
\end_inset

).
 Tambien
\begin_inset Formula 
\[
\left\Vert \alpha\right\Vert =\left((0,...),(\alpha,\varepsilon,...)\right)
\]

\end_inset

(es el caso 
\begin_inset Formula $n=0$
\end_inset

 y 
\begin_inset Formula $m=1$
\end_inset

).
 En el caso 
\begin_inset Formula $n=m=0$
\end_inset

 pensaremos que 
\begin_inset Formula $x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}$
\end_inset

 se transforma en 
\begin_inset Formula $\Diamond$
\end_inset

 por lo que se obtiene
\begin_inset Formula 
\[
\left\Vert \Diamond\right\Vert =\left((0,...),(\varepsilon,...)\right)
\]

\end_inset

Ademas es claro que
\begin_inset Formula 
\[
\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert =\left\Vert x_{1},...,x_{n},\overset{i}{\overbrace{0,...,0}},\alpha_{1},...,\alpha_{m},\overset{j}{\overbrace{\varepsilon,...,\varepsilon}}\right\Vert 
\]

\end_inset

cualesquiera sean 
\begin_inset Formula $i,j\in\omega$
\end_inset

.
\end_layout

\begin_layout Standard
Dado 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

, definamos para cada par 
\begin_inset Formula $n,m\geq0$
\end_inset

, la funcion 
\begin_inset Formula $\Psi_{\mathcal{P}}^{n,m,\#}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\[
\begin{array}{l}
D_{\Psi_{\mathcal{P}}^{n,m,\#}}=\{(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}:\mathcal{P}\text{ termina, partiendo del}\\
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{estado }\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert \}
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{l}
\Psi_{\mathcal{P}}^{n,m,\#}(\vec{x},\vec{\alpha})=\text{valor de }\mathrm{N}1\text{ en el estado obtenido cuando }\mathcal{P}\text{ termina,}\\
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{partiendo de }\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert 
\end{array}
\]

\end_inset

Analogamente definamos la funcion 
\begin_inset Formula $\Psi_{\mathcal{P}}^{n,m,\ast}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\[
\begin{array}{l}
D_{\Psi_{\mathcal{P}}^{n,m,\ast}}=\{(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}:\mathcal{P}\text{ termina, partiendo del}\\
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{estado }\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert \}
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{l}
\Psi_{\mathcal{P}}^{n,m,\ast}(\vec{x},\vec{\alpha})=\text{valor de }\mathrm{P}1\text{ en el estado obtenido cuando }\mathcal{P}\text{ termina,}\\
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{partiendo de }\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert 
\end{array}
\]

\end_inset

Ahora si daremos la definicion precisa de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 Una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta 
\begin_inset Formula $f:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 sera llamada 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-computable
\shape default
 si hay un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 tal que 
\begin_inset Formula $f=\Psi_{\mathcal{P}}^{n,m,\#}$
\end_inset

.
 En tal caso diremos que la funcion 
\begin_inset Formula $f$
\end_inset

 es 
\shape italic
computada
\shape default
 por 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Analogamente una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta 
\begin_inset Formula $f:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\Sigma^{\ast}$
\end_inset

 sera llamada 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-computable
\shape default
 si hay un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 tal que 
\begin_inset Formula $f=\Psi_{\mathcal{P}}^{n,m,\ast}$
\end_inset

.
 En tal caso diremos que la funcion 
\begin_inset Formula $f$
\end_inset

 es 
\shape italic
computada
\shape default
 por 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset

El programa
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}2 & \mathrm{IF}\;\mathrm{N}1\neq0\;\mathrm{GOTO}\;\mathrm{L}1\\
 & \mathrm{GOTO}\;\mathrm{L}2\\
\mathrm{L}1 & \mathrm{N}1\leftarrow\mathrm{N}1\dot{-}1
\end{array}
\]

\end_inset

computa la funcion 
\begin_inset Formula $Pred$
\end_inset

.
 Note que este programa tambien computa las funciones 
\begin_inset Formula $Pred\circ p_{1}^{n,m}$
\end_inset

, para 
\begin_inset Formula $n\geq1$
\end_inset

 y 
\begin_inset Formula $m\geq0$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset

Sea 
\begin_inset Formula $\Sigma=\{\clubsuit,\triangle\}.$
\end_inset

 El programa
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}3 & \mathrm{IF}\;\mathrm{P}2\;\mathrm{BEGINS}\;\clubsuit\;\mathrm{GOTO}\;\mathrm{L}1\\
 & \mathrm{IF}\;\mathrm{P}2\;\mathrm{BEGINS}\;\triangle\;\mathrm{GOTO}\;\mathrm{L}2\\
 & \mathrm{GOTO}\;\mathrm{L}4\\
\mathrm{L}1 & \mathrm{P}2\leftarrow\text{ }^{\curvearrowright}\mathrm{P}2\\
 & \mathrm{P}1\leftarrow\mathrm{P}1\clubsuit\\
 & \mathrm{GOTO}\;\mathrm{L}3\\
\mathrm{L}2 & \mathrm{P}2\leftarrow\text{ }^{\curvearrowright}\mathrm{P}2\\
 & \mathrm{P}1\leftarrow\mathrm{P}1\triangle\\
 & \mathrm{GOTO}\;\mathrm{L}3\\
\mathrm{L}4 & \mathrm{SKIP}
\end{array}
\]

\end_inset

computa la funcion 
\begin_inset Formula $\lambda\alpha\beta\left[\alpha\beta\right].$
\end_inset

 
\end_layout

\begin_layout Standard
Por supuesto para que el concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable tenga chance de ser una modelizacion adecuada del concepto de
 funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, tiene que ser cierto el siguiente resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 Si 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos por ejemplo que 
\begin_inset Formula $f:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 es computada por 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

.
 Un procedimiento efectivo que compute a 
\begin_inset Formula $f$
\end_inset

 puede consistir de realizar las sucesivas instrucciones de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 (partiendo de 
\begin_inset Formula $\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

) y eventualmente terminar en caso de que nos toque realizar la instruccion
 
\begin_inset Formula $n(\mathcal{P})+1$
\end_inset

, y dar como salida el contenido de la variable 
\begin_inset Formula $\mathrm{N}1$
\end_inset

.
 Daremos a continuacion una descripcion mas detallada de dicho procedimiento.
\end_layout

\begin_layout Standard
Fijemos primero un numero natural 
\begin_inset Formula $k$
\end_inset

 que sea mayor que 
\begin_inset Formula $\max\{n,m\}$
\end_inset

 y tal que toda variable que ocurre en 
\begin_inset Formula $\mathcal{P}$
\end_inset

 este en la lista 
\begin_inset Formula $\mathrm{N}1,...,\mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k}$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbb{P}$
\end_inset

 el siguiente procedimiento efectivo:
\end_layout

\begin_layout Standard
- Conjunto de datos de entrada de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 igual a 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast}{}^{m}$
\end_inset


\end_layout

\begin_layout Standard
- Conjunto de datos de salida de 
\begin_inset Formula $\mathbb{P}$
\end_inset

 contenido en 
\begin_inset Formula $\omega$
\end_inset


\end_layout

\begin_layout Standard
- Funcionamiento:
\end_layout

\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Asignar los siguientes valores a las variables 
\begin_inset Formula $I,X_{1},...,X_{k},A_{1},...,A_{k}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{ccc}
 & I\leftarrow1\\
X_{1}\leftarrow x_{1} &  & A_{1}\leftarrow\alpha_{1}\\
\vdots &  & \vdots\\
X_{n}\leftarrow x_{n} &  & A_{m}\leftarrow\alpha_{m}\\
X_{n+1}\leftarrow0 &  & A_{m+1}\leftarrow\varepsilon\\
\vdots &  & \vdots\\
X_{k}\leftarrow0 &  & A_{k}\leftarrow\varepsilon
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Etapa 2
\end_layout

\begin_layout Standard
\noindent
Asignar:
\end_layout

\begin_layout Standard
\begin_inset Formula $I\leftarrow$
\end_inset

 1er coordenada de 
\begin_inset Formula $S_{\mathcal{P}}(I,(X_{1},...,X_{k},0,...),(A_{1},...,A_{k},\varepsilon,...))$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Para 
\begin_inset Formula $i=1,...,k$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $X_{i}\leftarrow$
\end_inset

 
\begin_inset Formula $i$
\end_inset

-esima coordenada de la segunda coordenada de 
\begin_inset Formula $S_{\mathcal{P}}(I,(X_{1},...,X_{k},0,...),(A_{1},...,A_{k},\varepsilon,...))$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $A_{i}\leftarrow$
\end_inset

 
\begin_inset Formula $i$
\end_inset

-esima coordenada de la tercer coordenada de 
\begin_inset Formula $S_{\mathcal{P}}(I,(X_{1},...,X_{k},0,...),(A_{1},...,A_{k},\varepsilon,...))$
\end_inset


\end_layout

\begin_layout Standard
Etapa 3
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $I=n(\mathcal{P})+1$
\end_inset

, entonces dar 
\begin_inset Formula $X_{1}$
\end_inset

 como salida y detenerse.
 En caso contrario ir a Etapa 2.
\end_layout

\begin_layout Standard
Se deja al lector corroborar que 
\begin_inset Formula $\mathbb{P}$
\end_inset

 es efectivo.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Sin envargo nuestro modelo imperativo de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable todavia podria no ser correcto ya que podria pasar
 que haya una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-mixta que sea computada por un procedimiento efectivo pero que no exista
 un programa de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 que la compute.
 En otras palabras el modelo imperativo o Neumanniano podria ser incompleto.
 Por supuesto este no es el caso y los desarrollos que veremos mas adelante
 nos convenceran de que el paradigma imperativo es completo.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Macros
\end_layout

\begin_layout Standard
Supongamos que estamos escribiendo un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 con el objeto de que realice cierta tarea.
 Supongamos ademas que nos vendria muy bien para nuestros propositos poder
 usar una instruccion
\begin_inset Formula 
\[
\mathrm{N}5\leftarrow\mathrm{N}16+\mathrm{N}3
\]

\end_inset

la cual por supuesto al correr el programa, deberia producir el efecto de
 dejar en la variable 
\begin_inset Formula $\mathrm{N}5$
\end_inset

 la suma de los contenidos de las variables 
\begin_inset Formula $\mathrm{N}16$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}3$
\end_inset

, sin modificar el contenido de las variables distintas a 
\begin_inset Formula $\mathrm{N}5$
\end_inset

.
 Lamentablemente no tenemos en 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 este tipo de instruccion pero podriamos reemplazarla por el siguiente programa
\begin_inset Formula 
\[
\begin{array}{ll}
 & \mathrm{N}1111\leftarrow\mathrm{N}16\\
 & \mathrm{N}2222\leftarrow\mathrm{N}3\\
 & \mathrm{N}5\leftarrow\mathrm{N}1111\\
\mathrm{L}1000 & \mathrm{IF}\;\mathrm{N}2222\neq0\;\mathrm{GOTO}\;\mathrm{L}2000\\
 & \mathrm{GOTO}\;\mathrm{L}3000\\
\mathrm{L}2000 & \mathrm{N}2222\leftarrow\mathrm{N}2222\dot{-}1\\
 & \mathrm{N}5\leftarrow\mathrm{N}5+1\\
 & \mathrm{GOTO}\;\mathrm{L}1000\\
\mathrm{L}3000 & \mathrm{SKIP}
\end{array}
\]

\end_inset

donde las variables 
\begin_inset Formula $\mathrm{N}1111$
\end_inset

, 
\begin_inset Formula $\mathrm{N}2222$
\end_inset

 y los labels 
\begin_inset Formula $\mathrm{L}1000$
\end_inset

, 
\begin_inset Formula $\mathrm{L}2000$
\end_inset

, 
\begin_inset Formula $\mathrm{L}3000$
\end_inset

 solo seran usados aqui, es decir no apareceran en el resto de nuestro programa
 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Notese que este programa cuando es corrido termina dejando en la variable
 
\begin_inset Formula $\mathrm{N}5$
\end_inset

 la suma de los contenidos de las variables 
\begin_inset Formula $\mathrm{N}16$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}3$
\end_inset

 y modifica el contenido de las variables 
\begin_inset Formula $\mathrm{N}1111$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}2222$
\end_inset

, lo cual no traera problemas ya que 
\begin_inset Formula $\mathrm{N}1111$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}2222$
\end_inset

 no se usan en el resto de 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 La variables 
\begin_inset Formula $\mathrm{N}1111$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}2222$
\end_inset

 son auxiliares y se usan justamente para preservar el valor de las variables
 
\begin_inset Formula $\mathrm{N}16$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}3$
\end_inset

 ya que ellas son variables protagonistas de nuestro programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 y en esta instancia no queremos alterar su contenido sino solo realizar
 la asignacion 
\begin_inset Formula $\mathrm{N}5\leftarrow\mathrm{N}16+\mathrm{N}3$
\end_inset

.
 Dejamos al lector explicar por que es necesario para que la simulacion
 sea correcta que los labels 
\begin_inset Formula $\mathrm{L}1000$
\end_inset

, 
\begin_inset Formula $\mathrm{L}2000$
\end_inset

 y 
\begin_inset Formula $\mathrm{L}3000$
\end_inset

 no sean usados en el resto de 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Standard
Es decir el programa anterior simula la instruccion 
\begin_inset Formula $\mathrm{N}5\leftarrow\mathrm{N}16+\mathrm{N}3$
\end_inset

 que no podiamos usar por no ser una instruccion de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

, con un costo bastante bajo, es decir el costo de convenir en no usar en
 el resto de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 las variables 
\begin_inset Formula $\mathrm{N}1111$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}2222$
\end_inset

 ni los labels 
\begin_inset Formula $\mathrm{L}1000$
\end_inset

, 
\begin_inset Formula $\mathrm{L}2000$
\end_inset

 y 
\begin_inset Formula $\mathrm{L}3000$
\end_inset

.
\end_layout

\begin_layout Standard
Ahora supongamos que seguimos escribiendo el programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 y nos hace falta simular la instruccion 
\begin_inset Formula $\mathrm{N}20\leftarrow\mathrm{N}1+\mathrm{N}14$
\end_inset

.
 Entonces es claro que podriamos modificar el programa que simulaba 
\begin_inset Formula $\mathrm{N}5\leftarrow\mathrm{N}16+\mathrm{N}3$
\end_inset

 haciendole reemplazos adecuados a sus variables y labels.
 Por ejemplo podriamos escribir
\begin_inset Formula 
\[
\begin{array}{ll}
 & \mathrm{N}9999\leftarrow\mathrm{N}1\\
 & \mathrm{N}8888\leftarrow\mathrm{N}14\\
 & \mathrm{N}20\leftarrow\mathrm{N}9999\\
\mathrm{L}1001 & \mathrm{IF}\;\mathrm{N}8888\neq0\;\mathrm{GOTO}\;\mathrm{L}2002\\
 & \mathrm{GOTO}\;\mathrm{L}3003\\
\mathrm{L}2002 & \mathrm{N}8888\leftarrow\mathrm{N}8888\dot{-}1\\
 & \mathrm{N}20\leftarrow\mathrm{N}20+1\\
 & \mathrm{GOTO}\;\mathrm{L}1001\\
\mathrm{L}3003 & \mathrm{SKIP}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $\mathrm{N}9999$
\end_inset

, 
\begin_inset Formula $\mathrm{N}8888$
\end_inset

, 
\begin_inset Formula $\mathrm{L}1001$
\end_inset

, 
\begin_inset Formula $\mathrm{L}2002$
\end_inset

 y 
\begin_inset Formula $\mathrm{L}3003$
\end_inset

 solo seran usados aqui, es decir no apareceran en el resto de nuestro programa
 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Standard
Consideremos el siguiente 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

molde
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 que llamaremos 
\begin_inset Formula $M$
\end_inset


\begin_inset Formula 
\[
\begin{array}{ll}
 & \mathrm{V}4\leftarrow\mathrm{V}2\\
 & \mathrm{V}5\leftarrow\mathrm{V}3\\
 & \mathrm{V}1\leftarrow\mathrm{V}4\\
\mathrm{A}1 & \mathrm{IF}\;\mathrm{V}5\neq0\;\mathrm{GOTO}\;\mathrm{A}2\\
 & \mathrm{GOTO}\;\mathrm{A}3\\
\mathrm{A}2 & \mathrm{V}5\leftarrow\mathrm{V}5\dot{-}1\\
 & \mathrm{V}1\leftarrow\mathrm{V}1+1\\
 & \mathrm{GOTO}\;\mathrm{A}1\\
\mathrm{A}3 & \mathrm{SKIP}
\end{array}
\]

\end_inset

Como puede notarse, cuando reemplazamos en 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}5$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}16$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}3$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}3$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}4$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}1111$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}5$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}2222$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}1000$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}2000$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}3$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}3000$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
obtenemos el programa que simulaba la instruccion 
\begin_inset Formula $\mathrm{N}5\leftarrow\mathrm{N}16+\mathrm{N}3$
\end_inset

 dentro de 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Similarmente, cuando reemplazamos en 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}20$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}3$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}14$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}4$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}9999$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}5$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}8888$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}1001$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}2002$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}3$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}3003$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
obtenemos el programa que simulaba la instruccion 
\begin_inset Formula $\mathrm{N}20\leftarrow\mathrm{N}1+\mathrm{N}14$
\end_inset

 dentro de 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 La practicidad de tener el molde 
\begin_inset Formula $M$
\end_inset

 cae de maduro.
 Ahora en caso de necesitar una instruccion del tipo 
\begin_inset Formula $\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{n}+\mathrm{N}\bar{m}$
\end_inset

 solo tenemos que reemplazar en 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}\bar{k}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}\bar{n}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}3$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}\bar{m}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
y reemplazar las 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

variables
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 
\begin_inset Formula $\mathrm{V}4$
\end_inset

 y 
\begin_inset Formula $\mathrm{V}5$
\end_inset

 y los 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

labels
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 
\begin_inset Formula $\mathrm{A}1$
\end_inset

, 
\begin_inset Formula $\mathrm{A}2$
\end_inset

 y 
\begin_inset Formula $\mathrm{A}3$
\end_inset

, por dos variables concretas y tres labels concretos que no se usen en
 el programa que estamos realizando.
 El programa asi obtenido simulara a la instruccion 
\begin_inset Formula $\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{n}+\mathrm{N}\bar{m}$
\end_inset

.
\end_layout

\begin_layout Standard
En la gerga computacional el molde 
\begin_inset Formula $M$
\end_inset

 suele llamarse 
\shape italic
macro
\shape default
 y los programas obtenidos luego de realizar los reemplazos son llamados
 
\shape italic
expansiones de 
\shape default

\begin_inset Formula $M$
\end_inset

.
 Notese que 
\begin_inset Formula $Ti(M)=\mathrm{PALABRA}$
\end_inset

 ya que, como en el caso de los programas, escribimos a 
\begin_inset Formula $M$
\end_inset

 linea por linea para facilitar su manejo pero en realidad es una sola palabra,
 a saber:
\begin_inset Formula 
\[
\mathrm{V}1\mathrm{\leftarrow}\text{V}2\mathrm{V}4\mathrm{\leftarrow}\text{V}3\mathrm{A}1\mathrm{IFV}4\mathrm{\neq}0\mathrm{GOTOA}2\mathrm{GOTOA}3\mathrm{A}2\mathrm{V}4\mathrm{\leftarrow}\text{V}4\mathrm{\dot{-}}1\mathrm{V}1\mathrm{\leftarrow}\text{V}1\mathrm{+}1\mathrm{GOTOA}1\mathrm{A}3\mathrm{SKIP}
\]

\end_inset

Es decir, como objeto matematico, 
\begin_inset Formula $M$
\end_inset

 es simplemente una palabra.
 A las palabras de la forma 
\begin_inset Formula $\mathrm{V}\bar{n}$
\end_inset

, con 
\begin_inset Formula $n\in\mathbf{N}$
\end_inset

, las llamaremos 
\shape italic
variables numericas de macro
\shape default
.
 A las palabras de la forma 
\begin_inset Formula $\mathrm{W}\bar{n}$
\end_inset

, con 
\begin_inset Formula $n\in\mathbf{N}$
\end_inset

, las llamaremos 
\shape italic
variables alfabeticas de macro
\shape default
 y a las palabras de la forma 
\begin_inset Formula $\mathrm{A}\bar{n}$
\end_inset

, con 
\begin_inset Formula $n\in\mathbf{N}$
\end_inset

, las llamaremos 
\shape italic
labels de macro
\shape default
.
 Nuestro macro 
\begin_inset Formula $M$
\end_inset

 no tiene variables alfabeticas de macro pero otros macros por supuesto
 pueden tener este tipo de variables.
\end_layout

\begin_layout Standard
Las variables 
\begin_inset Formula $\mathrm{V}1$
\end_inset

, 
\begin_inset Formula $\mathrm{V}2$
\end_inset

 y 
\begin_inset Formula $\mathrm{V}3$
\end_inset

 son llamadas 
\shape italic
variables oficiales
\shape default
 de 
\begin_inset Formula $M$
\end_inset

 ya que son las variables que seran reemplazadas por variables que son protagoni
stas dentro del programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 que usara la expansion de 
\begin_inset Formula $M$
\end_inset

.
 Las palabras 
\begin_inset Formula $\mathrm{V}4$
\end_inset

 y 
\begin_inset Formula $\mathrm{V}5$
\end_inset

 son llamadas 
\shape italic
variables auxiliares
\shape default
 de 
\begin_inset Formula $M$
\end_inset

 ya que seran reemplazadas por variables que se usaran solo dentro de la
 expansion y no intervienen en la 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

trama
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 del programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Tambien 
\begin_inset Formula $\mathrm{A}1$
\end_inset

, 
\begin_inset Formula $\mathrm{A}2$
\end_inset

 y 
\begin_inset Formula $\mathrm{A}3$
\end_inset

 son llamados 
\shape italic
labels auxiliares
\shape default
 de 
\begin_inset Formula $M$
\end_inset

 ya que son usados solo para su funcionamiento interno y no tienen vinculacion
 con los labels del programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Standard
En el siguiente ejemplo veremos un macro que tiene un label que no es auxiliar
 sino oficial.
 Sea 
\begin_inset Formula $\Sigma=\{@,!\}$
\end_inset

.
 Supongamos que estamos escribiendo un programa 
\begin_inset Formula $\mathcal{P}^{\prime}$
\end_inset

 y nos hace falta simular instrucciones de la forma
\begin_inset Formula 
\[
\mathrm{IF}\;\left\vert \mathrm{P}\bar{n}\right\vert \leq\mathrm{N}\bar{m}\ \mathrm{GOTO}\;\mathrm{L}\bar{k}
\]

\end_inset

(por supuesto estas instrucciones no pertenecen al lenguaje 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 pero deberia quedar claro como funcionan).
 Entonces podemos tomar el macro 
\begin_inset Formula $M^{\prime}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{ll}
 & \mathrm{W}2\leftarrow\mathrm{W}1\\
 & \mathrm{V}2\leftarrow\mathrm{V}1\\
\mathrm{A}4 & \mathrm{IF}\;\mathrm{W}2\;\mathrm{BEGINS}\;@\;\mathrm{GOTO}\;\mathrm{A}2\\
 & \mathrm{IF}\;\mathrm{W}2\;\mathrm{BEGINS}\;!\;\mathrm{GOTO}\;\mathrm{A}2\\
 & \mathrm{GOTO}\;\mathrm{A}1\\
\mathrm{A}2 & \mathrm{IF}\;\mathrm{V}2\neq0\;\mathrm{GOTO}\;\mathrm{A}3\\
 & \mathrm{GOTO}\;\mathrm{A}5\\
\mathrm{A}3 & \mathrm{W}2\leftarrow^{\curvearrowright}\mathrm{W}2\\
 & \mathrm{V}2\leftarrow\mathrm{V}2\dot{-}1\\
 & \mathrm{GOTO}\;\mathrm{A}4\\
\mathrm{A}5 & \mathrm{SKIP}
\end{array}
\]

\end_inset

el cual tiene
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

variables oficiales 
\begin_inset Formula $\mathrm{W}1$
\end_inset

 y 
\begin_inset Formula $\mathrm{V}1$
\end_inset

 (correspondientes a 
\begin_inset Formula $\mathrm{P}\bar{n}$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}\bar{m}$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

variables auxiliares 
\begin_inset Formula $\mathrm{W}2$
\end_inset

 y 
\begin_inset Formula $\mathrm{V}2$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

labels auxiliares 
\begin_inset Formula $\mathrm{A}2$
\end_inset

, 
\begin_inset Formula $\mathrm{A}3$
\end_inset

, 
\begin_inset Formula $\mathrm{A}4$
\end_inset

 y 
\begin_inset Formula $\mathrm{A}5$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

un label oficial 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 (correspondiente a 
\begin_inset Formula $\mathrm{L}\bar{k}$
\end_inset

) 
\end_layout

\begin_layout Standard
\noindent
Una descripcion intuitiva del macro 
\begin_inset Formula $M^{\prime}$
\end_inset

 seria
\begin_inset Formula 
\[
\mathrm{IF}\;\left\vert \mathrm{W}1\right\vert \leq\mathrm{V}1\ \mathrm{GOTO}\;\mathrm{A}1
\]

\end_inset

Notese que en las primeras dos lineas el macro 
\begin_inset Formula $M^{\prime}$
\end_inset

 guarda los valores de las variables oficiales 
\begin_inset Formula $\mathrm{W}1$
\end_inset

 y 
\begin_inset Formula $\mathrm{V}1$
\end_inset

 en las variables auxiliares 
\begin_inset Formula $\mathrm{W}2$
\end_inset

 y 
\begin_inset Formula $\mathrm{V}2$
\end_inset

, y sigue trabajando con las auxiliares.
 Esto es para preservar el valor de las variables oficiales.
 Dado que 
\begin_inset Formula $\Sigma=\{@,!\}$
\end_inset

, las dos siguientes lineas sirven para decidir si el contenido de 
\begin_inset Formula $\mathrm{W}2$
\end_inset

 es 
\begin_inset Formula $\varepsilon$
\end_inset

 o no.
 Dejamos al lector entender el resto del funcionamiento de 
\begin_inset Formula $M^{\prime}$
\end_inset

.
\end_layout

\begin_layout Standard
Para dar un ejemplo de como usariamos a 
\begin_inset Formula $M^{\prime}$
\end_inset

, supongamos que para seguir escribiendo nuestro programa 
\begin_inset Formula $\mathcal{P}^{\prime}$
\end_inset

 nos hace falta simular la instruccion
\begin_inset Formula 
\[
\mathrm{IF}\;\left\vert \mathrm{P}5\right\vert \leq\mathrm{N}14\ \mathrm{GOTO}\;\mathrm{L}1
\]

\end_inset

y supongamos que las variables 
\begin_inset Formula $\mathrm{P}1000$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}1000$
\end_inset

 y los labels 
\begin_inset Formula $\mathrm{L}6666$
\end_inset

, 
\begin_inset Formula $\mathrm{L}7777$
\end_inset

, 
\begin_inset Formula $\mathrm{L}8888$
\end_inset

 y 
\begin_inset Formula $\mathrm{L}9999$
\end_inset

 no se usaron hasta el momento en 
\begin_inset Formula $\mathcal{P}^{\prime}$
\end_inset

.
 Entonces podemos reemplazar en 
\begin_inset Formula $M^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{W}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{P}5$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}14$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{W}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{P}1000$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}1000$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}6666$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}3$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}7777$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}4$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}8888$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}5$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}9999$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
y la expansion de 
\begin_inset Formula $M^{\prime}$
\end_inset

 asi obtenida simulara la instruccion 
\begin_inset Formula $\mathrm{IF}\;\left\vert \mathrm{P}5\right\vert \leq\mathrm{N}14\ \mathrm{GOTO}\;\mathrm{L}1$
\end_inset

.
 Cabe destacar que para asegurarnos que la simulacion funcione, tambien
 deberemos no usar en el resto de 
\begin_inset Formula $\mathcal{P}^{\prime}$
\end_inset

 las variables 
\begin_inset Formula $\mathrm{P}1000$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}1000$
\end_inset

 y los labels 
\begin_inset Formula $\mathrm{L}6666$
\end_inset

, 
\begin_inset Formula $\mathrm{L}7777$
\end_inset

, 
\begin_inset Formula $\mathrm{L}8888$
\end_inset

 y 
\begin_inset Formula $\mathrm{L}9999$
\end_inset

.
\end_layout

\begin_layout Standard
Es decir 
\begin_inset Formula $M^{\prime}$
\end_inset

 funciona como un molde con el cual haciendo reemplazos adecuados podemos
 simular cualquier instruccion del tipo 
\begin_inset Formula $\mathrm{IF}\;\left\vert \mathrm{P}\bar{n}\right\vert \leq\mathrm{N}\bar{m}\ \mathrm{GOTO}\;\mathrm{L}\bar{k}$
\end_inset

, con 
\begin_inset Formula $n,m,k\in\mathbf{N}$
\end_inset

.
\end_layout

\begin_layout Standard
Deberia quedar claro el caracter oficial del label 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 en 
\begin_inset Formula $M^{\prime}$
\end_inset

 ya que el label por el que se lo reemplaza para hacer la expansion es uno
 de los labels protagonistas del programa que se esta escribiendo.
\end_layout

\begin_layout Standard
Cabe destacar que las expansiones de 
\begin_inset Formula $M^{\prime}$
\end_inset

 no son programas ya que si bien son concatenaciones de instrucciones, no
 cumplen la ley de los GOTO (llamada (G) en la definicion de programa) respecto
 del label que reemplazo a 
\begin_inset Formula $\mathrm{A}1$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Nota:
\series default
 Siempre supondremos que la primera instruccion de los macros no es labelada.
 Esto es porque muchas veces cuando expandamos un macro nos interesara labelar
 la primera instruccion de dicha expansion.
 Por supuesto, esto es facil de conseguir ya que si 
\begin_inset Formula $M$
\end_inset

 es un macro, entonces 
\begin_inset Formula $\mathrm{SKIP}M$
\end_inset

 es tambien un macro que posee las mismas propiedades.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como hemos visto recien hay dos tipos de macros:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

los de asignacion que cuando son expandidos nos dan un programa que simula
 la asignacion a una variable dada del resultado de aplicar una funcion
 a los contenidos de ciertas otras variables; y
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

los de tipo IF que cuando son expandidos nos dan un programa salvo por la
 ley (G), el cual direcciona al label que fue a reemplazar a 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 cuando se cumple cierta propiedad (predicado) relativa a los contenidos
 de las variables que fueron a reemplazar a las variables oficiales.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Ejemplo concreto de uso de macros
\end_layout

\begin_layout Standard
Ya vimos recien que la palabra
\begin_inset Formula 
\[
\begin{array}{ll}
 & \mathrm{V}4\leftarrow\mathrm{V}2\\
 & \mathrm{V}5\leftarrow\mathrm{V}3\\
 & \mathrm{V}1\leftarrow\mathrm{V}4\\
\mathrm{A}1 & \mathrm{IF}\;\mathrm{V}5\neq0\;\mathrm{GOTO}\;\mathrm{A}2\\
 & \mathrm{GOTO}\;\mathrm{A}3\\
\mathrm{A}2 & \mathrm{V}5\leftarrow\mathrm{V}5\dot{-}1\\
 & \mathrm{V}1\leftarrow\mathrm{V}1+1\\
 & \mathrm{GOTO}\;\mathrm{A}1\\
\mathrm{A}3 & \mathrm{SKIP}
\end{array}
\]

\end_inset

es un macro que sirve para simular instrucciones de la forma 
\begin_inset Formula $\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{n}+\mathrm{N}\bar{m}$
\end_inset

.
 Notemos que este macro es de asignacion ya que cuando es expandido nos
 da un programa que simula la asignacion a una variable dada del resultado
 de aplicar una funcion a los contenidos de ciertas otras variables.
 En este caso la funcion es 
\begin_inset Formula $SUMA=\lambda xy[x+y]$
\end_inset

 por lo cual usaremos 
\begin_inset Formula $\left[\mathrm{V}1\leftarrow SUMA(\mathrm{V}2,\mathrm{V}3)\right]$
\end_inset

 para denotar a dicho macro.
 Usaremos este macro para dar un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 que compute a la funcion 
\begin_inset Formula $\lambda xy[x.y]$
\end_inset

.
 Notese que podemos tomar 
\begin_inset Formula $\mathcal{P}$
\end_inset

 igual al siguiente programa
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}1 & \mathrm{IF}\;\mathrm{N}2\neq0\;\mathrm{GOTO}\;\mathrm{L}2\\
 & \mathrm{GOTO}\;\mathrm{L}3\\
\mathrm{L}2 & \left[\mathrm{N}3\leftarrow SUMA(\mathrm{N}3,\mathrm{N}1)\right]\\
 & \mathrm{N}2\leftarrow\mathrm{N}2\dot{-}1\\
 & \mathrm{GOTO}\;\mathrm{L}1\\
\mathrm{L}3 & \mathrm{N}1\leftarrow\mathrm{N}3
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $\left[\mathrm{N}3\leftarrow SUMA(\mathrm{N}3,\mathrm{N}1)\right]$
\end_inset

 es una expansion del macro 
\begin_inset Formula $\left[\mathrm{V}1\leftarrow SUMA(\mathrm{V}2,\mathrm{V}3)\right]$
\end_inset

 hecha haciendo el reemplazo de las variables oficiales 
\begin_inset Formula $\mathrm{V}1,\mathrm{V}2$
\end_inset

 y 
\begin_inset Formula $\mathrm{V}3$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}3,\mathrm{N}3$
\end_inset

 y 
\begin_inset Formula $\mathrm{N}1$
\end_inset

, respectivamente, y haciendo reemplazos adecuados de sus variables y labels
 auxiliares.
 Hay muchas formas de hacer los reemplazos de variables y labels auxiliares
 pero en general no lo especificaremos explicitamente cuando expandamos
 un macro ya que es facil imaginar como hacerlo en funcion del programa
 que estemos realizando.
 Por ejemplo en el caso de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 podriamos hacer los siguientes reemplazos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}4$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}1111$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{V}5$
\end_inset

 por 
\begin_inset Formula $\mathrm{N}2222$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}1000$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}2$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}2000$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada ocurrencia de 
\begin_inset Formula $\mathrm{A}3$
\end_inset

 por 
\begin_inset Formula $\mathrm{L}3000$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
y claramente esto no afectara la 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

logica
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 o 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

idea
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 de nuestro programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 De esta forma la expansion 
\begin_inset Formula $\left[\mathrm{N}3\leftarrow SUMA(\mathrm{N}3,\mathrm{N}1)\right]$
\end_inset

 es el siguiente programa:
\begin_inset Formula 
\[
\begin{array}{ll}
 & \mathrm{N}1111\leftarrow\mathrm{N}3\\
 & \mathrm{N}2222\leftarrow\mathrm{N}1\\
 & \mathrm{N}3\leftarrow\mathrm{N}1111\\
\mathrm{L}1000 & \mathrm{IF}\;\mathrm{N}2222\neq0\;\mathrm{GOTO}\;\mathrm{L}2000\\
 & \mathrm{GOTO}\;\mathrm{L}3000\\
\mathrm{L}2000 & \mathrm{N}2222\leftarrow\mathrm{N}2222\dot{-}1\\
 & \mathrm{N}3\leftarrow\mathrm{N}3+1\\
 & \mathrm{GOTO}\;\mathrm{L}1000\\
\mathrm{L}3000 & \mathrm{SKIP}
\end{array}
\]

\end_inset

el cual por supuesto esta escrito con espacios y en forma vertical pero
 es una mera palabra.
 Tenemos entonces que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 es el programa:
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}1 & \mathrm{IF}\;\mathrm{N}2\neq0\;\mathrm{GOTO}\;\mathrm{L}2\\
 & \mathrm{GOTO}\;\mathrm{L}3\\
\mathrm{L}2 & \mathrm{N}1111\leftarrow\mathrm{N}1\\
 & \mathrm{N}2222\leftarrow\mathrm{N}3\\
 & \mathrm{N}3\leftarrow\mathrm{N}1111\\
\mathrm{L}1000 & \mathrm{IF}\;\mathrm{N}2222\neq0\;\mathrm{GOTO}\;\mathrm{L}2000\\
 & \mathrm{GOTO}\;\mathrm{L}3000\\
\mathrm{L}2000 & \mathrm{N}2222\leftarrow\mathrm{N}2222\dot{-}1\\
 & \mathrm{N}3\leftarrow\mathrm{N}3+1\\
 & \mathrm{GOTO}\;\mathrm{L}1000\\
\mathrm{L}3000 & \mathrm{SKIP}\\
 & \mathrm{N}2\leftarrow\mathrm{N}2\dot{-}1\\
 & \mathrm{GOTO}\;\mathrm{L}1\\
\mathrm{L}3 & \mathrm{N}1\leftarrow\mathrm{N}3
\end{array}
\]

\end_inset

el cual por supuesto esta escrito con espacios y en forma vertical pero
 es una mera palabra.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Macros asociados a funciones 
\begin_inset Formula $\Sigma$
\end_inset

-computables
\end_layout

\begin_layout Standard
Dada una funcion 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

, usaremos
\begin_inset Formula 
\[
\left[\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]
\]

\end_inset

para denotar un macro 
\begin_inset Formula $M$
\end_inset

 el cual cumpla las siguientes propiedades.
 Cabe destacar que no siempre existira dicho macro, es decir solo para ciertas
 funciones 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 habra un tal macro.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Las variables oficiales de 
\begin_inset Formula $M$
\end_inset

 son 
\begin_inset Formula $\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{V}\overline{n+1},\mathrm{W}1,...,\mathrm{W}\bar{m}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $M$
\end_inset

 no tiene labels oficiales
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si reemplazamos:
\end_layout

\begin_deeper
\begin_layout Enumerate
las variables oficiales de 
\begin_inset Formula $M$
\end_inset

 (i.e.
 
\begin_inset Formula $\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{V}\overline{n+1},\mathrm{W}1,...,\mathrm{W}\bar{m}$
\end_inset

) por variables concretas
\begin_inset Formula 
\[
\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{N}\overline{k_{n+1}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}
\]

\end_inset

(elejidas libremente, es decir los numeros 
\begin_inset Formula $k_{1},...,k_{n+1},j_{1},...,j_{m}$
\end_inset

 son cualesquiera)
\end_layout

\begin_layout Enumerate
las variables auxiliares de 
\begin_inset Formula $M$
\end_inset

 por variables concretas (distintas de a dos) y NO pertenecientes a la lista
 
\begin_inset Formula $\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{N}\overline{k_{n+1}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}$
\end_inset


\end_layout

\begin_layout Enumerate
los labels auxiliares de 
\begin_inset Formula $M$
\end_inset

 por labels concretos (distintos de a dos) 
\end_layout

\begin_layout Standard
\noindent
Entonces la palabra asi obtenida es un programa de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 que denotaremos con
\begin_inset Formula 
\[
\left[\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right]
\]

\end_inset

el cual debe tener la siguiente propiedad:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si hacemos correr 
\begin_inset Formula $\left[\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right]$
\end_inset

 partiendo de un estado 
\begin_inset Formula $e$
\end_inset

 que le asigne a las variables 
\begin_inset Formula $\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}$
\end_inset

 valores 
\begin_inset Formula $x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}$
\end_inset

, entonces independientemente de los valores que les asigne 
\begin_inset Formula $e$
\end_inset

 al resto de las variables (incluidas las que fueron a reemplazar a las
 variables auxiliares de 
\begin_inset Formula $M$
\end_inset

) se dara que
\end_layout

\begin_deeper
\begin_layout Enumerate
si 
\begin_inset Formula $(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})\notin D_{f}$
\end_inset

, entonces 
\begin_inset Formula $\left[\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right]$
\end_inset

 no se detiene
\end_layout

\begin_layout Enumerate
si 
\begin_inset Formula $(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})\in D_{f}$
\end_inset

, entonces 
\begin_inset Formula $\left[\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right]$
\end_inset

 se detiene (i.e.
 intenta realizar la siguiente a su ultima instrucion) y llega a un estado
 
\begin_inset Formula $e^{\prime}$
\end_inset

 el cual cumple:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $e^{\prime}$
\end_inset

 le asigna a 
\begin_inset Formula $\mathrm{N}\overline{k_{n+1}}$
\end_inset

 el valor 
\begin_inset Formula $f(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $e^{\prime}$
\end_inset

 solo puede diferir de 
\begin_inset Formula $e$
\end_inset

 en los valores que le asigna a 
\begin_inset Formula $\mathrm{N}\overline{k_{n+1}}$
\end_inset

 o a las variables que fueron a reemplazar a las variables auxiliares de
 
\begin_inset Formula $M$
\end_inset

.
 Al resto de las variables, incluidas 
\begin_inset Formula $\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}$
\end_inset

 no las modifica (salvo en el caso de que alguna 
\begin_inset Formula $\mathrm{N}\overline{k_{i}}$
\end_inset

 sea la variable 
\begin_inset Formula $\mathrm{N}\overline{k_{n+1}}$
\end_inset

, situacion en la cual el valor final de la variable 
\begin_inset Formula $\mathrm{N}\overline{k_{i}}$
\end_inset

 sera 
\begin_inset Formula $f(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})$
\end_inset

) 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\noindent
El programa 
\begin_inset Formula $\left[\mathrm{N}\overline{k_{n+1}}\leftarrow f(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\right]$
\end_inset

 es comunmente llamado la expansion del macro 
\begin_inset Formula $\left[\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]$
\end_inset

 con respecto a la eleccion de variables y labels realizada.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tambien, dada una funcion 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\Sigma^{\ast}$
\end_inset

, con
\begin_inset Formula 
\[
\left[\mathrm{W}\overline{m+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]
\]

\end_inset

denotaremos un macro el cual cumpla condiciones analogas a las descriptas
 recien.
 Dejamos al lector escribirlas en detalle para este caso.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "macro funciones"

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Sea 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 una funcion 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computable.
 Entonces en 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 hay un macro
\begin_inset Formula 
\[
\left[\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Sea 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\Sigma^{\ast}$
\end_inset

 una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 Entonces en 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 hay un macro
\begin_inset Formula 
\[
\left[\mathrm{W}\overline{m+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Probaremos (b) La prueba de (a) es similar.
 Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 un programa que compute a 
\begin_inset Formula $f$
\end_inset

.
 Tomemos un 
\begin_inset Formula $k$
\end_inset

 tal que 
\begin_inset Formula $k\geq n,m$
\end_inset

 y tal que todas las variables y labels de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 estan en el conjunto
\begin_inset Formula 
\[
\{\mathrm{N}1,...,\mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k},\mathrm{L}1,...,\mathrm{L}\bar{k}\}\text{.}
\]

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}^{\prime}$
\end_inset

 la palabra que resulta de reemplazar en 
\begin_inset Formula $\mathcal{P}$
\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

la variable 
\begin_inset Formula $\mathrm{N}\overline{j}$
\end_inset

 por 
\begin_inset Formula $\mathrm{V}\overline{n+j}$
\end_inset

, para cada 
\begin_inset Formula $j=1,...,k$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

la variable 
\begin_inset Formula $\mathrm{P}\overline{j}$
\end_inset

 por 
\begin_inset Formula $\mathrm{W}\overline{m+j}$
\end_inset

, para cada 
\begin_inset Formula $j=1,...,k$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

el label 
\begin_inset Formula $\mathrm{L}\overline{j}$
\end_inset

 por 
\begin_inset Formula $\mathrm{A}\overline{j}$
\end_inset

, para cada 
\begin_inset Formula $j=1,...,k$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que
\begin_inset Formula 
\[
\begin{array}{l}
\mathrm{V}\overline{n+1}\leftarrow\mathrm{V}1\\
\ \ \ \ \ \ \ \ \ \vdots\\
\mathrm{V}\overline{n+n}\leftarrow\mathrm{V}\overline{n}\\
\mathrm{V}\overline{n+n+1}\leftarrow0\\
\ \ \ \ \ \ \ \ \ \vdots\\
\mathrm{V}\overline{n+k}\leftarrow0\\
\mathrm{W}\overline{m+1}\leftarrow\mathrm{W}1\\
\ \ \ \ \ \ \ \ \ \vdots\\
\mathrm{W}\overline{m+m}\leftarrow\mathrm{W}\overline{m}\\
\mathrm{W}\overline{m+m+1}\leftarrow\varepsilon\\
\ \ \ \ \ \ \ \ \ \vdots\\
\mathrm{W}\overline{m+k}\leftarrow\varepsilon\\
\mathcal{P}^{\prime}
\end{array}
\]

\end_inset

es el macro buscado, el cual tendra sus variables auxiliares y labels en
 la lista
\begin_inset Formula 
\[
\mathrm{V}\overline{n+1},...,\mathrm{V}\overline{n+k},\mathrm{W}\overline{m+2},...,\mathrm{W}\overline{m+k},\mathrm{A}1,...,\mathrm{A}\overline{k}.
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos al lector probar la resiproca de la proposicion anterior, es decir
 que si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 es tal que en 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 hay un macro
\begin_inset Formula 
\[
\left[\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]
\]

\end_inset

entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Macros asociados a predicados 
\begin_inset Formula $\Sigma$
\end_inset

-computables
\end_layout

\begin_layout Standard
Dado un predicado 
\begin_inset Formula $P:D_{P}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

, usaremos
\begin_inset Formula 
\[
\left[\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

para denotar un macro 
\begin_inset Formula $M$
\end_inset

 el cual cumpla las siguientes propiedades.
 Cabe destacar que no siempre existira dicho macro, es decir solo para ciertos
 predicados 
\begin_inset Formula $P:D_{P}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 habra un tal macro.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Las variables oficiales de 
\begin_inset Formula $M$
\end_inset

 son 
\begin_inset Formula $\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\mathrm{A}1$
\end_inset

 es el unico label oficial de 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si reemplazamos:
\end_layout

\begin_deeper
\begin_layout Enumerate
las variables oficiales de 
\begin_inset Formula $M$
\end_inset

 (i.e.
 
\begin_inset Formula $\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m}$
\end_inset

) por variables concretas
\begin_inset Formula 
\[
\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}
\]

\end_inset

(elejidas libremente, es decir los numeros 
\begin_inset Formula $k_{1},...,k_{n},j_{1},...,j_{m}$
\end_inset

 son cualesquiera)
\end_layout

\begin_layout Enumerate
el label oficial 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 por el label concreto 
\begin_inset Formula $\mathrm{L}\bar{k}$
\end_inset

 (elejido libremente, es decir 
\begin_inset Formula $k$
\end_inset

 es cualquier elemento de 
\begin_inset Formula $\mathbf{N}$
\end_inset

)
\end_layout

\begin_layout Enumerate
las variables auxiliares de 
\begin_inset Formula $M$
\end_inset

 por variables concretas (distintas de a dos) y NO pertenecientes a la lista
 
\begin_inset Formula $\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}$
\end_inset


\end_layout

\begin_layout Enumerate
los labels auxiliares de 
\begin_inset Formula $M$
\end_inset

 por labels concretos (distintos de a dos) y ninguno igual a 
\begin_inset Formula $\mathrm{L}\bar{k}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Entonces la palabra asi obtenida es un programa de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 (salvo por la ley de los GOTO respecto de 
\begin_inset Formula $\mathrm{L}\bar{k}$
\end_inset

) que denotaremos con
\begin_inset Formula 
\[
\left[\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right]
\]

\end_inset

el cual debe tener la siguiente propiedad:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si hacemos correr 
\begin_inset Formula $\left[\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right]$
\end_inset

 partiendo de un estado 
\begin_inset Formula $e$
\end_inset

 que le asigne a las variables 
\begin_inset Formula $\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}$
\end_inset

 valores 
\begin_inset Formula $x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}$
\end_inset

, entonces independientemente de los valores que les asigne 
\begin_inset Formula $e$
\end_inset

 al resto de las variables (incluidas las que fueron a reemplazar a las
 variables auxiliares de 
\begin_inset Formula $M$
\end_inset

) se dara que
\end_layout

\begin_deeper
\begin_layout Enumerate
si 
\begin_inset Formula $(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})\notin D_{P}$
\end_inset

, entonces 
\begin_inset Formula $\left[\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right]$
\end_inset

 no se detiene
\end_layout

\begin_layout Enumerate
si 
\begin_inset Formula $(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})\in D_{P}$
\end_inset

 y 
\begin_inset Formula $P(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})=1$
\end_inset

, entonces luego de una cantidad finita de pasos, 
\begin_inset Formula $\left[\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right]$
\end_inset

 direcciona al label 
\begin_inset Formula $\mathrm{L}\bar{k}$
\end_inset

 quedando en un estado 
\begin_inset Formula $e^{\prime}$
\end_inset

 el cual solo puede diferir de 
\begin_inset Formula $e$
\end_inset

 en los valores que le asigna a las variables que fueron a reemplazar a
 las variables auxiliares de 
\begin_inset Formula $M$
\end_inset

.
 Al resto de las variables, incluidas 
\begin_inset Formula $\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}$
\end_inset

 no las modifica
\end_layout

\begin_layout Enumerate
si 
\begin_inset Formula $(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})\in D_{P}$
\end_inset

 y 
\begin_inset Formula $P(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})=0$
\end_inset

, entonces luego de una cantidad finita de pasos, 
\begin_inset Formula $\left[\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right]$
\end_inset

 se detiene (i.e.
 intenta realizar la siguiente a su ultima instruccion) quedando en un estado
 
\begin_inset Formula $e^{\prime}$
\end_inset

 el cual solo puede diferir de 
\begin_inset Formula $e$
\end_inset

 en los valores que le asigna a las variables que fueron a reemplazar a
 las variables auxiliares de 
\begin_inset Formula $M$
\end_inset

.
 Al resto de las variables, incluidas 
\begin_inset Formula $\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}}$
\end_inset

 no las modifica 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\noindent
La palabra 
\begin_inset Formula $\left[\mathrm{IF\ }P(\mathrm{N}\overline{k_{1}},...,\mathrm{N}\overline{k_{n}},\mathrm{P}\overline{j_{1}},...,\mathrm{P}\overline{j_{m}})\ \mathrm{GOTO\ L}\bar{k}\right]$
\end_inset

 es llamada la expansion del macro con respecto a la eleccion de variables
 y labels realizada
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "macro predicados"

\end_inset

Sea 
\begin_inset Formula $P:D_{P}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 un predicado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computable.
 Entonces en 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 hay un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por (a) de la proposicion anterior tenemos un macro 
\begin_inset Formula $\left[\mathrm{V}\overline{n+1}\leftarrow P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]$
\end_inset

.
 Notese que la palabra
\begin_inset Formula 
\[
\left[\mathrm{V}\overline{n+1}\leftarrow P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]\mathrm{IFV}\overline{n+1}\mathrm{\neq}0\mathrm{GOTOA}1
\]

\end_inset

es el macro buscado.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos al lector probar la resiproca de la proposicion anterior, es decir
 si 
\begin_inset Formula $P:D_{P}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 es tal que en 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 hay un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

entonces 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-enumerables
\end_layout

\begin_layout Standard
Ya que la nocion de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable es el modelo matematico Neumanniano o imperativo del concepto
 de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, nos podriamos preguntar entonces cual es el modelo
 matematico Neumanniano del concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Si prestamos atencion a la definicion de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable, notaremos que depende de la existencia de ciertas
 funciones 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables por lo cual la siguiente definicion cae de maduro:
\end_layout

\begin_layout Standard
Un conjunto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 sera llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-enumerable
\shape default
 cuando sea vacio o haya una funcion 
\begin_inset Formula $F:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que 
\begin_inset Formula $I_{F}=S$
\end_inset

 y 
\begin_inset Formula $F_{(i)}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-computable, para cada 
\begin_inset Formula $i\in\{1,...,n+m\}$
\end_inset

.
\end_layout

\begin_layout Standard
Deberia entonces quedar claro que si el concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable modeliza correctamente al concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, entonces el concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable recien definido modeliza correctamente al concepto de conjunto
 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Notese que segun la definicion que acabamos de escribir, un conjunto no
 vacio 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable si y solo si hay programas 
\begin_inset Formula $\mathcal{P}_{1},...,\mathcal{P}_{n+m}$
\end_inset

 tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{Dom}(\Psi_{\mathcal{P}_{1}}^{1,0,\#})=...=\mathrm{Dom}(\Psi_{\mathcal{P}_{n}}^{1,0,\#})=\omega$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{Dom}(\Psi_{\mathcal{P}_{n+1}}^{1,0,\ast})=...=\mathrm{Dom}(\Psi_{\mathcal{P}_{n}+m}^{1,0,\ast})=\omega$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $S=\operatorname{Im}[\Psi_{\mathcal{P}_{1}}^{1,0,\#},...,\Psi_{\mathcal{P}_{n}}^{1,0,\#},\Psi_{\mathcal{P}_{n+1}}^{1,0,\ast},...,\Psi_{\mathcal{P}_{n}+m}^{1,0,\ast}]$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Como puede notarse los programas 
\begin_inset Formula $\mathcal{P}_{1},...,\mathcal{P}_{n+m}$
\end_inset

 puestos en paralelo a funcionar desde el estado 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

 producen en forma natural un procedimiento efectivo (con dato de entrada
 
\begin_inset Formula $x\in\omega$
\end_inset

) que enumera a 
\begin_inset Formula $S$
\end_inset

.
 Por supuesto podemos decir que en tal caso los programas 
\begin_inset Formula $\mathcal{P}_{1},...,\mathcal{P}_{n+m}$
\end_inset

 enumeran a 
\begin_inset Formula $S$
\end_inset

.
 La siguiente proposicion muestra que tambien las cosas se pueden hacer
 con un solo programa
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "P enumera a S"

\end_inset

Sea 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 un conjunto no vacio.
 Entonces son equivalentes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Hay un programa 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 tal que:
\end_layout

\begin_deeper
\begin_layout Enumerate
Para cada 
\begin_inset Formula $x\in\omega$
\end_inset

, tenemos que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo desde el estado 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

 y llega a un estado 
\begin_inset Formula $\left\Vert x_{1},...x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

, donde 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S$
\end_inset

.
\end_layout

\begin_layout Enumerate
Para cada 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S$
\end_inset

 hay un 
\begin_inset Formula $x\in\omega$
\end_inset

 tal que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo desde el estado 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

 y llega al estado 
\begin_inset Formula $\left\Vert x_{1},...x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Hay un programa 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 tal que:
\end_layout

\begin_deeper
\begin_layout Enumerate
Para cada 
\begin_inset Formula $x\in\omega$
\end_inset

, tenemos que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo desde el estado 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

 y llega a un estado de la forma 
\begin_inset Formula $((x_{1},...,x_{n},y_{1},...),(\alpha_{1},...,\alpha_{m},\beta_{1},...))$
\end_inset

, donde 
\begin_inset Formula $(x_{1},...,x_{n},\alpha_{1},...,\alpha_{m})\in S$
\end_inset

.
\end_layout

\begin_layout Enumerate
Para cada 
\begin_inset Formula $(x_{1},...x_{n},\alpha_{1},...,\alpha_{m})\in S$
\end_inset

 hay un 
\begin_inset Formula $x\in\omega$
\end_inset

 tal que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo desde el estado 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

 y llega a un estado de la forma 
\begin_inset Formula $((x_{1},...,x_{n},y_{1},...),(\alpha_{1},...,\alpha_{m},\beta_{1},...))$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1)
\begin_inset Formula $\Rightarrow$
\end_inset

(2).
 Ya que 
\begin_inset Formula $S$
\end_inset

 es no vacio, por definicion tenemos que hay una 
\begin_inset Formula $F:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que 
\begin_inset Formula $I_{F}=S$
\end_inset

 y 
\begin_inset Formula $F_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable, para cada 
\begin_inset Formula $i\in\{1,...,n+m\}$
\end_inset

.
 Por la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "macro funciones"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que existen macros:
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right]\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
 & \left[\mathrm{V}2\leftarrow F_{(n)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{W}1\leftarrow F_{(n+1)}(\mathrm{V}1)\right]\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
 & \left[\mathrm{W}1\leftarrow F_{(n+m)}(\mathrm{V}1)\right]
\end{align*}

\end_inset

Sea 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 el siguiente programa:
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{P}\overline{m}\leftarrow F_{(n+m)}(\mathrm{N}1)\right]\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
 & \left[\mathrm{P}1\leftarrow F_{(n+1)}(\mathrm{N}1)\right]\\
 & \left[\mathrm{N}\overline{n}\leftarrow F_{(n)}(\mathrm{N}1)\right]\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
 & \left[\mathrm{N}1\leftarrow F_{(1)}(\mathrm{N}1)\right]
\end{align*}

\end_inset

donde se supone que las expansiones de los macros usados son hechas usando
 variables auxiliares no pertenecientes a la lista 
\begin_inset Formula $\mathrm{N}1,...,\mathrm{N}\overline{n},\mathrm{P}1,...,\mathrm{P}\overline{m}$
\end_inset

 (por supuesto, dada la fortaleza de nuestros macros se puede usa una misma
 variable auxiliar para dos distintas expansiones), y tambien se supone
 que los labels auxiliares usados en dichas expansiones son todos distintos,
 es decir no usamos el mismo label auxiliar en dos expansiones distintas
 (por que?).
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $k$
\end_inset

 tal que las variables de 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 estan todas en la lista 
\begin_inset Formula $\mathrm{N}1,...,\mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k}$
\end_inset

.
 Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa:
\begin_inset Formula 
\[
\mathcal{Q}\mathrm{N}\overline{n+1}\leftarrow0\mathrm{N}\overline{n+2}\leftarrow0...\mathrm{N}\overline{k}\leftarrow0\mathrm{P}\overline{m+1}\leftarrow\varepsilon\mathrm{P}\overline{m+2}\leftarrow\varepsilon...\mathrm{P}\overline{k}\leftarrow\varepsilon
\]

\end_inset

Dejamos al lector corroborar que el programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 cumple las propiedades a y b
\end_layout

\begin_layout Standard
(2)
\begin_inset Formula $\Rightarrow$
\end_inset

(3).
 Directo.
\end_layout

\begin_layout Standard
(3)
\begin_inset Formula $\Rightarrow$
\end_inset

(1).
 Supongamos 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 cumple a y b de (3).
 Sean
\begin_inset Formula 
\begin{align*}
\mathcal{P}_{1} & =\mathcal{P}\mathrm{N}1\leftarrow\mathrm{N}1\\
\mathcal{P}_{2} & =\mathcal{P}\mathrm{N}1\leftarrow\mathrm{N}2\\
 & \vdots\\
\mathcal{P}_{n} & =\mathcal{P}\mathrm{N}1\leftarrow\mathrm{N}\overline{n}\\
\mathcal{P}_{n+1} & =\mathcal{P}\mathrm{P}1\leftarrow\mathrm{P}1\\
\mathcal{P}_{n+2} & =\mathcal{P}\mathrm{P}1\leftarrow\mathrm{P}2\\
 & \vdots\\
\mathcal{P}_{n+m} & =\mathcal{P}\mathrm{P}1\leftarrow\mathrm{P}\overline{m}
\end{align*}

\end_inset

Definamos
\begin_inset Formula 
\begin{align*}
F_{1} & =\Psi_{\mathcal{P}_{1}}^{1,0,\#}\\
F_{2} & =\Psi_{\mathcal{P}_{2}}^{1,0,\#}\\
 & \vdots\\
F_{n} & =\Psi_{\mathcal{P}_{n}}^{1,0,\#}\\
F_{n+1} & =\Psi_{\mathcal{P}_{n+1}}^{1,0,\ast}\\
F_{n+2} & =\Psi_{\mathcal{P}_{n+2}}^{1,0,\ast}\\
 & \vdots\\
F_{n+m} & =\Psi_{\mathcal{P}_{n+m}}^{1,0,\ast}
\end{align*}

\end_inset

Notese que cada 
\begin_inset Formula $F_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable y tiene dominio igual a 
\begin_inset Formula $\omega$
\end_inset

.
 Sea 
\begin_inset Formula $F=[F_{1},...,F_{n+m}]$
\end_inset

.
 Tenemos por definicion que 
\begin_inset Formula $D_{F}=\omega$
\end_inset

 y ya que 
\begin_inset Formula $F_{(i)}=F_{i}$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n+m$
\end_inset

 tenemos que cada 
\begin_inset Formula $F_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 Dejamos al lector verificar que 
\begin_inset Formula $I_{F}=S$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Cuando un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 cumpla las propiedades dadas en (3) de la proposicion anterior respecto
 de un conjunto 
\begin_inset Formula $S$
\end_inset

, diremos que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 
\shape italic
enumera 
\shape default
a 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard
Cabe destacar que (3)
\begin_inset Formula $\Rightarrow$
\end_inset

(1) de la proposicion anterior es muy util a la hora de probar que un conjunto
 dado es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-computables
\end_layout

\begin_layout Standard
La version imperativa del concepto de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable es facil de dar: un conjunto 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 sera llamado 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-computable
\shape default
 cuando la funcion 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 sea 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 O sea que 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable sii hay un programa 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 el cual computa a 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

, es decir:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S$
\end_inset

, entonces 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo desde 
\begin_inset Formula $\left\Vert x_{1},...x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

 y la variable 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 queda con contenido igual a 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

, entonces 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo desde 
\begin_inset Formula $\left\Vert x_{1},...x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

 y la variable 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 queda con contenido igual a 
\begin_inset Formula $0$
\end_inset

 
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\mathcal{P}$
\end_inset

 es un programa el cual computa a 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

, diremos que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 
\shape italic
decide la pertenecia a 
\shape default

\begin_inset Formula $S$
\end_inset

, con respecto al conjunto 
\begin_inset Formula $\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection*
Macros asociados a conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-computables
\end_layout

\begin_layout Standard
La proposicion anterior nos dice que si 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 es un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-computable, entonces, ya que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable, hay un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Escribiremos el nombre de este macro de la siguiente manera mas intuitiva:
\begin_inset Formula 
\[
\left[\mathrm{IF}\;(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\in S\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Notese que las expanciones de este macro, dado que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-total, ya sea terminan por la ultima instruccion de la expansion o direccionan
 a la primera instruccion que tenga label igual al label que reemplazo a
 
\begin_inset Formula $\mathrm{A}1$
\end_inset

 en la expansion.
 Es importante notar que para asegurar la existencia de este macro utilizamos
 que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable lo cual no siempre sucedera para un conjunto 
\begin_inset Formula $S$
\end_inset

.
 Por ejemplo, puede pasar que 
\begin_inset Formula $S$
\end_inset

 sea el dominio de una funcion 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computable pero que 
\begin_inset Formula $S$
\end_inset

 no sea 
\begin_inset Formula $\Sigma$
\end_inset

-computable (esto se vera mas adelante) y en tal caso no existira un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\in S\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

ya que si tal macro existiera seria facil hacer un programa que compute
 a 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}$
\end_inset

 y 
\begin_inset Formula $S$
\end_inset

 seria 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 Es muy comun el error de suponer que existe un macro 
\begin_inset Formula $\left[\mathrm{IF}\;(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\in S\;\mathrm{GOTO}\;\mathrm{A}1\right]$
\end_inset

 cuando 
\begin_inset Formula $S$
\end_inset

 es el dominio de una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Batallas entre paradigmas
\end_layout

\begin_layout Standard
En esta seccion compararemos los tres paradigmas de computabilidad efectiva
 que hemos desarrollado anteriormente.
 Para esto probaremos que cada uno de dichos paradigmas 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

vence
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 al otro en el sentido que incluye por lo menos todas las funciones que
 incluye el otro en su modelizacion del concepto de funcion 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Neumann vence a Godel
\end_layout

\begin_layout Standard
Usando macros podemos ahora probar que el paradigma imperativo de Neumann
 es por lo menos tan abarcativo como el funcional de Godel.
 Mas concretamente:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "RimplicaComp"

\end_inset

Si 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva, entonces 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Probaremos por induccion en 
\begin_inset Formula $k$
\end_inset

 que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset

Si 
\begin_inset Formula $h\in\mathrm{R}_{k}^{\Sigma}$
\end_inset

, entonces 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computable.
 
\end_layout

\begin_layout Standard
\noindent
El caso 
\begin_inset Formula $k=0$
\end_inset

 es dejado al lector.
 Supongamos (*) vale para 
\begin_inset Formula $k$
\end_inset

, veremos que vale para 
\begin_inset Formula $k+1$
\end_inset

.
 Sea 
\begin_inset Formula $h\in\mathrm{R}_{k+1}^{\Sigma}-\mathrm{R}_{k}^{\Sigma}.$
\end_inset

 Hay varios casos
\end_layout

\begin_layout Standard
Caso 1.
 Supongamos 
\begin_inset Formula $h=M(P)$
\end_inset

, con 
\begin_inset Formula $P:\omega\times\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

, un predicado perteneciente a 
\begin_inset Formula $\mathrm{R}_{k}^{\Sigma}$
\end_inset

.
 Por hipotesis inductiva, 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computable y por lo tanto tenemos un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\overline{n+1},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

lo cual nos permite realizar el siguiente programa
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}2 & \left[\mathrm{IF}\;P(\mathrm{N}\overline{n+1},\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m})\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
 & \mathrm{N}\overline{n+1}\leftarrow\mathrm{N}\overline{n+1}+1\\
 & \mathrm{GOTO}\;\mathrm{L}2\\
\mathrm{L}1 & \mathrm{N}1\leftarrow\mathrm{N}\overline{n+1}
\end{array}
\]

\end_inset

Es facil chequear que este programa computa 
\begin_inset Formula $h.$
\end_inset


\end_layout

\begin_layout Standard
Caso 2.
 Supongamos 
\begin_inset Formula $h=R(f,\mathcal{G})$
\end_inset

, con
\begin_inset Formula 
\begin{align*}
f & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\Sigma^{\ast}\\
\mathcal{G}_{a} & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\times\Sigma^{\ast}\times\Sigma^{\ast}\rightarrow\Sigma^{\ast}\text{, }a\in\Sigma
\end{align*}

\end_inset

elementos de 
\begin_inset Formula $\mathrm{R}_{k}^{\Sigma}$
\end_inset

.
 Sea 
\begin_inset Formula $\Sigma=\{a_{1},...,a_{r}\}.$
\end_inset

 Por hipotesis inductiva, las funciones 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $\mathcal{G}_{a}$
\end_inset

, 
\begin_inset Formula $a\in\Sigma$
\end_inset

, son 
\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-
\shape default
computables y por lo tanto podemos hacer el siguiente programa via el uso
 de macros
\begin_inset Formula 
\[
\begin{array}{rl}
 & \left[\mathrm{P}\overline{m+3}\leftarrow f(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m})\right]\\
\mathrm{L}\overline{r+1} & \mathrm{IF}\;\mathrm{P}\overline{m+1}\ \mathrm{BEGINS\ }a_{1}\text{ }\mathrm{GOTO}\;\mathrm{L}1\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
 & \mathrm{IF}\;\mathrm{P}\overline{m+1}\ \mathrm{BEGINS\ }a_{r}\text{ }\mathrm{GOTO}\;\mathrm{L}\bar{r}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+2}\\
\mathrm{L}1 & \mathrm{P}\overline{m+1}\leftarrow\text{ }^{\curvearrowright}\mathrm{P}\overline{m+1}\\
 & \left[\mathrm{P}\overline{m+3}\leftarrow\mathcal{G}_{a_{1}}(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m},\mathrm{P}\overline{m+2},\mathrm{P}\overline{m+3})\right]\\
 & \mathrm{P}\overline{m+2}\leftarrow\mathrm{P}\overline{m+2}.a_{1}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+1}\\
 & \ \ \ \ \ \ \ \ \ \ \ \ \vdots\\
\mathrm{L}\bar{r} & \mathrm{P}\overline{m+1}\leftarrow\text{ }^{\curvearrowright}\mathrm{P}\overline{m+1}\\
 & \left[\mathrm{P}\overline{m+3}\leftarrow\mathcal{G}_{a_{r}}(\mathrm{N}1,...,\mathrm{N}\bar{n},\mathrm{P}1,...,\mathrm{P}\bar{m},\mathrm{P}\overline{m+2},\mathrm{P}\overline{m+3})\right]\\
 & \mathrm{P}\overline{m+2}\leftarrow\mathrm{P}\overline{m+2}.a_{r}\\
 & \mathrm{GOTO}\;\mathrm{L}\overline{r+1}\\
\mathrm{L}\overline{r+2} & \mathrm{P}1\leftarrow\mathrm{P}\overline{m+3}
\end{array}
\]

\end_inset

Es facil chequear que este programa computa 
\begin_inset Formula $h.$
\end_inset


\end_layout

\begin_layout Standard
El resto de los casos son dejados al lector.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 
\begin_inset CommandInset label
LatexCommand label
name "recursivo implica macro"

\end_inset

Si
\begin_inset Formula 
\begin{align*}
f & :D_{f}\subseteq\omega^{n}\times\Sigma^{\ast}{}^{m}\rightarrow\omega\\
g & :D_{g}\subseteq\omega^{n}\times\Sigma^{\ast}{}^{m}\rightarrow\Sigma^{\ast}\\
P & :D_{P}\subseteq\omega^{n}\times\Sigma^{\ast}{}^{m}\rightarrow\{0,1\}
\end{align*}

\end_inset

son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas, entonces hay macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]\\
 & \left[\mathrm{W}\overline{m+1}\leftarrow g(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]\\
 & \left[\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Se lleno de macros
\end_layout

\begin_layout Standard
Cabe destacar que el corolario anterior nos dice que hay macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{V}\overline{n+1}\leftarrow f(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]\\
 & \left[\mathrm{W}\overline{m+1}\leftarrow g(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\right]\\
 & \left[\mathrm{IF}\;P(\mathrm{V}1,...,\mathrm{V}\bar{n},\mathrm{W}1,...,\mathrm{W}\bar{m})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\end{align*}

\end_inset

para todas las funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas y predicados 
\begin_inset Formula $\Sigma$
\end_inset

-mixtos que hemos trabajado hasta el momento en la materia ya que todas
 eran 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Esto transforma al lenguaje 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 en un potente y relativamente comodo lenguaje de programacion ya que ahora
 tenemos macros para todas las funciones y predicados cotidianos en la matematic
a.
 Por ejemplo a continuacion usaremos la existencia de los macros 
\begin_inset Formula $[\mathrm{IF\ V}1$
\end_inset

 es par
\begin_inset Formula $\ \mathrm{GOTO\ A}1]$
\end_inset

 y 
\begin_inset Formula $[\mathrm{V}2\leftarrow\lfloor\mathrm{V}1/2\rfloor]$
\end_inset

 para probar el siguiente resultado cuya prueba esta inspirada en su analoga
 del paradigma de computabilidad efectiva.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 son conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-enumerables.
 Entonces 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Podemos suponer que ni 
\begin_inset Formula $S_{1}$
\end_inset

 ni 
\begin_inset Formula $S_{2}$
\end_inset

 son vacios ya que de lo contrario los resultados son triviales.
 Ademas supondremos que 
\begin_inset Formula $n=2$
\end_inset

 y 
\begin_inset Formula $m=1$
\end_inset

.
\end_layout

\begin_layout Standard
La idea de la prueba es la misma que la que usamos para probar que la union
 de conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Daremos usando macros un programa que enumera a 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 y luego aplicaremos la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "P enumera a S"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Por hipotesis hay funciones 
\begin_inset Formula $F:\omega\rightarrow\omega\times\omega\times\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $G:\omega\rightarrow\omega\times\omega\times\Sigma^{\ast}$
\end_inset

 tales que 
\begin_inset Formula $F_{(1)}$
\end_inset

, 
\begin_inset Formula $F_{(2)}$
\end_inset

, 
\begin_inset Formula $F_{(3)}$
\end_inset

, 
\begin_inset Formula $G_{(1)}$
\end_inset

, 
\begin_inset Formula $G_{(2)}$
\end_inset

 y 
\begin_inset Formula $G_{(3)}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-computables, 
\begin_inset Formula $\operatorname{Im}(F)=S_{1}$
\end_inset

 y 
\begin_inset Formula $\operatorname{Im}(G)=S_{2}$
\end_inset

.
 O sea que hay macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{V}2\leftarrow F_{(2)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{W}1\leftarrow F_{(3)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{V}2\leftarrow G_{(1)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{V}2\leftarrow G_{(2)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{W}1\leftarrow G_{(3)}(\mathrm{V}1)\right]
\end{align*}

\end_inset

Ya que el predicado 
\begin_inset Formula $Par=\lambda x[x$
\end_inset

 es par
\begin_inset Formula $]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., el Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo implica macro"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que hay un macro:
\begin_inset Formula 
\[
[\mathrm{IF\ }Par(\mathrm{V}1)\ \mathrm{GOTO\ A}1]
\]

\end_inset

el cual escribiremos de la siguiente manera mas intuitiva
\begin_inset Formula 
\[
[\mathrm{IF\ V}1\text{ es par }\mathrm{GOTO\ A}1]
\]

\end_inset

Ya que la funcion 
\begin_inset Formula $D=\lambda x[\lfloor x/2\rfloor]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., el Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo implica macro"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que hay un macro:
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow D(\mathrm{V}1)]
\]

\end_inset

el cual escribiremos de la siguiente manera mas intuitiva
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow\lfloor\mathrm{V}1/2\rfloor]
\]

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa:
\begin_inset Formula 
\[
\begin{array}{ll}
 & [\mathrm{IF\ N}1\text{ es par }\mathrm{GOTO\ L}1\\
 & \mathrm{N}1\leftarrow\mathrm{N}1\dot{-}1\\
 & [\mathrm{N}1111\leftarrow\lfloor\mathrm{N}1/2\rfloor]\\
 & \left[\mathrm{N}1\leftarrow G_{(1)}(\mathrm{N}1111)\right]\\
 & \left[\mathrm{N}2\leftarrow G_{(2)}(\mathrm{N}1111)\right]\\
 & \left[\mathrm{P}1\leftarrow G_{(3)}(\mathrm{N}1111)\right]\\
 & \mathrm{GOTO\ L}2\\
\mathrm{L}1 & [\mathrm{N}1111\leftarrow\lfloor\mathrm{N}1/2\rfloor]\\
 & \left[\mathrm{N}1\leftarrow F_{(1)}(\mathrm{N}1111)\right]\\
 & \left[\mathrm{N}2\leftarrow F_{(2)}(\mathrm{N}1111)\right]\\
 & \left[\mathrm{P}1\leftarrow F_{(3)}(\mathrm{N}1111)\right]\\
\mathrm{L}2 & \mathrm{SKIP}
\end{array}
\]

\end_inset

Es facil ver que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 cumple a y b de (3) de la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "P enumera a S"
plural "false"
caps "false"
noprefix "false"

\end_inset

 por lo cual 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tal como se vio en este ejemplo, el Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo implica macro"
plural "false"
caps "false"
noprefix "false"

\end_inset

 junto con nuestra gran coleccion de funciones ya probadamente 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas, nos permite simular con programas muchos de los procedimientos
 efectivos realizados anteriormente.
 Mas capacidad de simulacion obtendremos luego de ver que Godel vence a
 Neumann ya que la equivalencia de estos dos paradigmas nos asegura la existenci
a de macros que permitiran dentro de un programa hablar acerca del funcionamient
o de otro programa.
 Esto sera clave a la hora de simular con programas a procedimientos efectivos
 que en su funcionamiento involucran el funcionamiento de otros procedimientos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Godel vence a Neumann
\end_layout

\begin_layout Standard
Para probar que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva debemos hacer un profundo estudio de la recursividad del lenguaje
 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
 Primero analizaremos la recursividad de la sintaxis de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Analisis de la recursividad de la sintaxis de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset


\end_layout

\begin_layout Standard
Primero probaremos dos lemas que muestran que la sintaxis de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursiva primitiva.
 Recordemos que 
\begin_inset Formula $Sig:Num^{\ast}\rightarrow Num^{\ast}$
\end_inset

 fue definida de la siguiente manera
\begin_inset Formula 
\begin{align*}
Sig(\varepsilon) & =1\\
Sig(\alpha0) & =\alpha1\\
Sig(\alpha1) & =\alpha2\\
Sig(\alpha2) & =\alpha3\\
Sig(\alpha3) & =\alpha4\\
Sig(\alpha4) & =\alpha5\\
Sig(\alpha5) & =\alpha6\\
Sig(\alpha6) & =\alpha7\\
Sig(\alpha7) & =\alpha8\\
Sig(\alpha8) & =\alpha9\\
Sig(\alpha9) & =Sig(\alpha)0
\end{align*}

\end_inset

Y tambien definimos 
\begin_inset Formula $Dec:\omega\rightarrow Num^{\ast}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\begin{align*}
Dec(0) & =\varepsilon\\
Dec(n+1) & =Sig(Dec(n))
\end{align*}

\end_inset

Recordemos tambien que para hacer mas agil la notacion escribimos 
\begin_inset Formula $\bar{n}$
\end_inset

 en lugar de 
\begin_inset Formula $Dec(n)$
\end_inset

.
\end_layout

\begin_layout Standard
Es obvio de las definiciones que ambas funciones son 
\begin_inset Formula $Num$
\end_inset

-p.r..
 Mas aun tenemos
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto cualquiera.
 Las funciones 
\begin_inset Formula $Sig$
\end_inset

 y 
\begin_inset Formula $Dec$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es facil ver que 
\begin_inset Formula $Sig$
\end_inset

 y 
\begin_inset Formula $Dec$
\end_inset

 son 
\begin_inset Formula $Num$
\end_inset

-p.r..
 Ya que tambien son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-mixtas, el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que ambas son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que 
\begin_inset Formula $Bas:\mathrm{Ins}^{\Sigma}\rightarrow(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

, fue definida por
\begin_inset Formula 
\[
Bas(I)=\left\{ \begin{array}{ccl}
J &  & \text{si }I\text{ es de la forma }\mathrm{L}\bar{k}J\text{, con }k\in\mathbf{N}\text{ y }J\in\mathrm{Ins}^{\Sigma}\\
I &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

Definamos 
\begin_inset Formula $Lab:\mathrm{Ins}^{\Sigma}\rightarrow(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
Lab(I)=\left\{ \begin{array}{lll}
\mathrm{L}\bar{k} &  & \text{si }I\text{ es de la forma }\mathrm{L}\bar{k}J\text{, con }k\in\mathbf{N}\text{ y }J\in\mathrm{Ins}^{\Sigma}\\
\varepsilon &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "cota longitud de la barra"

\end_inset

Para cada 
\begin_inset Formula $n,x\in\omega$
\end_inset

, tenemos que 
\begin_inset Formula $\left\vert \bar{n}\right\vert \leq x$
\end_inset

 si y solo si 
\begin_inset Formula $n\leq10^{x}-1$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "Ins-es-pr"

\end_inset


\begin_inset Formula $\mathrm{Ins}^{\Sigma}$
\end_inset

 es un conjunto 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Para simplificar la prueba asumiremos que 
\begin_inset Formula $\Sigma=\{@,\blacktriangle\}$
\end_inset

.
 Ya que 
\begin_inset Formula $\mathrm{Ins}^{\Sigma}$
\end_inset

 es union de los siguientes conjuntos
\begin_inset Formula 
\begin{align*}
L_{1} & =\left\{ \mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{k}+1:k\in\mathbf{N}\right\} \\
L_{2} & =\left\{ \mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{k}\dot{-}1:k\in\mathbf{N}\right\} \\
L_{3} & =\left\{ \mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{n}:k,n\in\mathbf{N}\right\} \\
L_{4} & =\left\{ \mathrm{N}\bar{k}\leftarrow0:k\in\mathbf{N}\right\} \\
L_{5} & =\left\{ \mathrm{IF}\;\mathrm{N}\bar{k}\neq0\;\mathrm{GOTO}\;\mathrm{L}\bar{m}:k,m\in\mathbf{N}\right\} \\
L_{6} & =\left\{ \mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{k}.@:k\in\mathbf{N}\right\} \\
L_{7} & =\left\{ \mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{k}.\blacktriangle:k\in\mathbf{N}\right\} \\
L_{8} & =\left\{ \mathrm{P}\bar{k}\leftarrow\text{ }^{\curvearrowright}\mathrm{P}\bar{k}:k\in\mathbf{N}\right\} \\
L_{9} & =\left\{ \mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{n}:k,n\in\mathbf{N}\right\} \\
L_{10} & =\left\{ \mathrm{P}\bar{k}\leftarrow\varepsilon:k\in\mathbf{N}\right\} \\
L_{11} & =\left\{ \mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;@\;\mathrm{GOTO}\;\mathrm{L}\bar{m}:k,m\in\mathbf{N}\right\} \\
L_{12} & =\left\{ \mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;\blacktriangle\;\mathrm{GOTO}\;\mathrm{L}\bar{m}:k,m\in\mathbf{N}\right\} \\
L_{13} & =\left\{ \mathrm{GOTO}\;\mathrm{L}\bar{m}:m\in\mathbf{N}\right\} \\
L_{14} & =\left\{ \mathrm{SKIP}\right\} \\
L_{15} & =\left\{ \mathrm{L}\bar{k}\alpha:k\in\mathbf{N\;}\text{y }\alpha\in L_{1}\cup...\cup L_{14}\right\} 
\end{align*}

\end_inset

solo debemos probar que 
\begin_inset Formula $L_{1},...,L_{15}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Veremos primero por ejemplo que
\begin_inset Formula 
\[
L_{11}=\left\{ \mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m}:k,m\in\mathbf{N}\right\} 
\]

\end_inset

es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Primero notese que 
\begin_inset Formula $\alpha\in L_{11}$
\end_inset

 si y solo si existen 
\begin_inset Formula $k,m\in\mathbf{N}$
\end_inset

 tales que
\begin_inset Formula 
\[
\alpha=\mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m}
\]

\end_inset

Mas formalmente tenemos que 
\begin_inset Formula $\alpha\in L_{11}$
\end_inset

 si y solo si
\begin_inset Formula 
\[
(\exists k\in\mathbf{N})(\exists m\in\mathbf{N})\;\alpha=\mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m}
\]

\end_inset

Ya que cuando existen tales 
\begin_inset Formula $k,m$
\end_inset

 tenemos que 
\begin_inset Formula $\bar{k}$
\end_inset

 y 
\begin_inset Formula $\bar{m}$
\end_inset

 son subpalabras de 
\begin_inset Formula $\alpha$
\end_inset

, el lema anterior nos dice que 
\begin_inset Formula $\alpha\in L_{11}$
\end_inset

 si y solo si
\begin_inset Formula 
\[
(\exists k\in\mathbf{N})_{k\leq10^{\left\vert \alpha\right\vert }}(\exists m\in\mathbf{N})_{m\leq10^{\left\vert \alpha\right\vert }}\;\alpha=\mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m}
\]

\end_inset

Sea
\begin_inset Formula 
\[
P=\lambda mk\alpha\left[\alpha=\mathrm{IFP}\bar{k}\mathrm{BEGINS}@\mathrm{GOTOL}\bar{m}\right]
\]

\end_inset

Ya que 
\begin_inset Formula $D_{\lambda k\left[\bar{k}\right]}=\omega$
\end_inset

, tenemos que 
\begin_inset Formula $D_{P}=\omega^{2}\times(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

.
 Notese que
\begin_inset Formula 
\[
P=\lambda\alpha\beta\left[\alpha=\beta\right]\circ\left[p_{3}^{2,1},f\right]
\]

\end_inset

donde
\begin_inset Formula 
\[
f=\lambda\alpha_{1}\alpha_{2}\alpha_{3}\alpha_{4}\left[\alpha_{1}\alpha_{2}\alpha_{3}\alpha_{4}\right]\circ\left[C_{\mathrm{IFP}}^{2,1},\lambda k\left[\bar{k}\right]\circ p_{2}^{2,1},C_{\mathrm{BEGINS}@\mathrm{GOTOL}}^{2,1},\lambda k\left[\bar{k}\right]\circ p_{1}^{2,1}\right]
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
\end_layout

\begin_layout Standard
Notese que
\begin_inset Formula 
\[
\chi_{L_{11}}^{(\Sigma\cup\Sigma_{p})^{\ast}}=\lambda\alpha\left[(\exists k\in\mathbf{N})_{k\leq10^{\left\vert \alpha\right\vert }}(\exists m\in\mathbf{N})_{m\leq10^{\left\vert \alpha\right\vert }}\;P(m,k,\alpha)\right]
\]

\end_inset

Esto nos dice que podemos usar dos veces el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cuantificacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 para ver que 
\begin_inset Formula $\chi_{L_{11}}^{(\Sigma\cup\Sigma_{p})^{\ast}}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Veamos como.
 Sea
\begin_inset Formula 
\[
Q=\lambda k\alpha\left[(\exists m\in\mathbf{N})_{m\leq10^{\left\vert \alpha\right\vert }}\;P(m,k,\alpha)\right]
\]

\end_inset

Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cuantificacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que
\begin_inset Formula 
\[
\lambda xk\alpha\left[(\exists m\in\mathbf{N})_{m\leq x}\;P(m,k,\alpha)\right]
\]

\end_inset

es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 lo cual nos dice que
\begin_inset Formula 
\[
Q=\lambda xk\alpha\left[(\exists m\in\mathbf{N})_{m\leq x}\;P(m,k,\alpha)\right]\circ\left[\lambda\alpha\left[10^{\left\vert \alpha\right\vert }\right]\circ p_{2}^{1,1},p_{1}^{1,1},p_{2}^{1,1}\right]
\]

\end_inset

lo es.
 Ya que
\begin_inset Formula 
\[
\chi_{L_{11}}^{(\Sigma\cup\Sigma_{p})^{\ast}}=\lambda\alpha\left[(\exists k\in\mathbf{N})_{k\leq10^{\left\vert \alpha\right\vert }}\;Q(k,\alpha)\right]
\]

\end_inset

podemos en forma similar aplicar el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cuantificacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 y obtener finalmente que 
\begin_inset Formula $\chi_{L_{11}}^{(\Sigma\cup\Sigma_{p})^{\ast}}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
\end_layout

\begin_layout Standard
En forma similar podemos probar que 
\begin_inset Formula $L_{1},...,L_{14}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Esto nos dice que 
\begin_inset Formula $L_{1}\cup...\cup L_{14}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Notese que 
\begin_inset Formula $L_{1}\cup...\cup L_{14}$
\end_inset

 es el conjunto de las instrucciones basicas de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
 Llamemos 
\begin_inset Formula $\mathrm{InsBas}^{\Sigma}$
\end_inset

 a dicho conjunto.
 Para ver que 
\begin_inset Formula $L_{15}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 notemos que
\begin_inset Formula 
\[
\chi_{L_{15}}^{(\Sigma\cup\Sigma_{p})^{\ast}}=\lambda\alpha\left[(\exists k\in\mathbf{N})_{k\leq10^{\left\vert \alpha\right\vert }}(\exists\beta\in\mathrm{InsBas}^{\Sigma})_{\left\vert \beta\right\vert \leq\left\vert \alpha\right\vert }\;\alpha=\mathrm{L}\bar{k}\beta\right]
\]

\end_inset

lo cual nos dice que aplicando dos veces el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cuantificacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 obtenemos que 
\begin_inset Formula $\chi_{L_{15}}^{(\Sigma\cup\Sigma_{p})^{\ast}}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Ya que 
\begin_inset Formula $\mathrm{Ins}^{\Sigma}=\mathrm{InsBas}^{\Sigma}\cup L_{15}$
\end_inset

 tenemos que 
\begin_inset Formula $\mathrm{Ins}^{\Sigma}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
@@finpagina@@
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $Bas$
\end_inset

 y 
\begin_inset Formula $Lab$
\end_inset

 son funciones 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

.
 Sea 
\begin_inset Formula $L=\{\mathrm{L}\bar{k}:k\in\mathbf{N}\}\cup\{\varepsilon\}$
\end_inset

.
 Dejamos al lector probar que 
\begin_inset Formula $L$
\end_inset

 es un conjunto 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Sea
\begin_inset Formula 
\[
P=\lambda I\alpha\left[\alpha\in\mathrm{Ins}^{\Sigma}\wedge I\in\mathrm{Ins}^{\Sigma}\wedge[\alpha]_{1}\neq\mathrm{L}\wedge(\exists\beta\in L)\ I=\beta\alpha\right]
\]

\end_inset

Note que 
\begin_inset Formula $D_{P}=(\Sigma\cup\Sigma_{p})^{\ast2}$
\end_inset

.
 Dejamos al lector probar que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Notese ademas que cuando 
\begin_inset Formula $I\in\mathrm{Ins}^{\Sigma}$
\end_inset

 tenemos que 
\begin_inset Formula $P(I,\alpha)=1$
\end_inset

 sii 
\begin_inset Formula $\alpha=Bas(I)$
\end_inset

.
 Dejamos al lector probar que 
\begin_inset Formula $Bas=M^{\leq}\left(P\right)$
\end_inset

 por lo que para ver que 
\begin_inset Formula $Bas$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., solo nos falta ver que la funcion 
\begin_inset Formula $Bas$
\end_inset

 es acotada por alguna funcion 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 y 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-total.
 Pero esto es trivial ya que 
\begin_inset Formula $\left\vert Bas(I)\right\vert \leq\left\vert I\right\vert =\lambda\alpha[\left\vert \alpha\right\vert ](I)$
\end_inset

, para cada 
\begin_inset Formula $I\in\mathrm{Ins}^{\Sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
Finalmente note que
\begin_inset Formula 
\[
Lab=M^{\leq}\left(\lambda I\alpha\left[\alpha Bas(I)=I\right]\right)
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $Lab$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que dado un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 habiamos definido 
\begin_inset Formula $I_{i}^{\mathcal{P}}=\varepsilon$
\end_inset

, para 
\begin_inset Formula $i=0$
\end_inset

 o 
\begin_inset Formula $i>n(\mathcal{P}).$
\end_inset

 O sea que la funcion 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-mixta 
\begin_inset Formula $\lambda i\mathcal{P}\left[I_{i}^{\mathcal{P}}\right]$
\end_inset

 tiene dominio igual a 
\begin_inset Formula $\omega\times\mathrm{Pro}^{\Sigma}$
\end_inset

.
 Notese que usamos notacion lambda respecto del alfabeto 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

.
 Ademas notese que usamos la variable 
\begin_inset Formula $\mathcal{P}$
\end_inset

 en la notacion lambda por un tema de comodidad psicologica dado que la
 expresion 
\begin_inset Formula $I_{i}^{\alpha}$
\end_inset

 esta definida solo cuando 
\begin_inset Formula $\alpha$
\end_inset

 es un programa pero podriamos haber escrito 
\begin_inset Formula $\lambda i\alpha\left[I_{i}^{\alpha}\right]$
\end_inset

 y sigue siendo la misma funcion.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "Pro-es-pr"

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $\mathrm{Pro}^{\Sigma}$
\end_inset

 es un conjunto 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\lambda\mathcal{P}\left[n(\mathcal{P})\right]$
\end_inset

 y 
\begin_inset Formula $\lambda i\mathcal{P}\left[I_{i}^{\mathcal{P}}\right]$
\end_inset

 son funciones 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $\mathrm{Pro}^{\Sigma}=D_{\lambda\mathcal{P}\left[n(\mathcal{P})\right]}$
\end_inset

 tenemos que (b) implica (a).
 Para probar (b) Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

.
 Sea 
\begin_inset Formula $P$
\end_inset

 el siguiente predicado
\end_layout

\begin_layout Standard
\begin_inset Formula $\lambda x\left[Lt(x)>0\wedge(\forall t\in\mathbf{N})_{t\leq Lt(x)}\;\ast^{\leq}((x)_{t})\in\mathrm{Ins}^{\Sigma}\wedge\right.$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ (\forall t\in\mathbf{N})_{t\leq Lt(x)}(\forall m\in\mathbf{N})\;\lnot(\mathrm{L}\bar{m}\ $
\end_inset

t-final 
\begin_inset Formula $\ast^{\leq}((x)_{t}))\vee$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \left.(\exists j\in\mathbf{N})_{j\leq Lt(x)}(\exists\alpha\in(\Sigma\cup\Sigma_{p})-Num)\;\mathrm{L}\bar{m}\alpha\ \text{t-inicial}\ast^{\leq}((x)_{j})\right]$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Notese que 
\begin_inset Formula $D_{P}=\mathbf{N}$
\end_inset

 y que 
\begin_inset Formula $P(x)=1$
\end_inset

 sii 
\begin_inset Formula $Lt(x)>0$
\end_inset

, 
\begin_inset Formula $\ast^{\leq}((x)_{t})\in\mathrm{Ins}^{\Sigma}$
\end_inset

, para cada 
\begin_inset Formula $t=1,...,Lt(x)$
\end_inset

 y ademas 
\begin_inset Formula $\subset_{t=1}^{t=Lt(x)}\ast^{\leq}((x)_{t})\in\mathrm{Pro}^{\Sigma}$
\end_inset

.
 Para ver que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 solo nos falta acotar el cuantificador 
\begin_inset Formula $(\forall m\in\mathbf{N})$
\end_inset

 de la expresion lambda que define a 
\begin_inset Formula $P$
\end_inset

.
 Ya que nos interesan los valores de 
\begin_inset Formula $m$
\end_inset

 para los cuales 
\begin_inset Formula $\bar{m}$
\end_inset

 es posiblemente una subpalabra de alguna de las palabras 
\begin_inset Formula $\ast^{\leq}((x)_{j})$
\end_inset

, el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cota longitud de la barra"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que una cota posible es 
\begin_inset Formula $10^{\max\{\left\vert \ast^{\leq}((x)_{j})\right\vert :1\leq j\leq Lt(x)\}}-1$
\end_inset

.
 Dejamos al lector los detalles de la prueba de que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Sea
\begin_inset Formula 
\[
Q=\lambda x\alpha\left[P(x)\wedge\alpha=\subset_{t=1}^{t=Lt(x)}\ast^{\leq}((x)_{t})\right]\text{.}
\]

\end_inset

Note que 
\begin_inset Formula $D_{Q}=\mathbf{N}\times(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

.
 Claramente 
\begin_inset Formula $Q$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Ademas note que 
\begin_inset Formula $D_{M(Q)}=\mathrm{Pro}^{\Sigma}$
\end_inset

.
 Notese que para 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

, tenemos que 
\begin_inset Formula $M(Q)(\mathcal{P})$
\end_inset

 es aquel numero tal que pensado como infinitupla (via mirar su secuencia
 de exponentes) codifica la secuencia de instrucciones que forman a 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Es decir
\begin_inset Formula 
\[
M(Q)(\mathcal{P})=\left\langle \#^{\leq}(I_{1}^{\mathcal{P}}),\#^{\leq}(I_{2}^{\mathcal{P}}),...,\#^{\leq}(I_{n(\mathcal{P})}^{\mathcal{P}}),0,0,...\right\rangle 
\]

\end_inset

Por (b) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $M(Q)$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 ya que para cada 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 tenemos que
\begin_inset Formula 
\begin{align*}
M(Q)(\mathcal{P}) & =\left\langle \#^{\leq}(I_{1}^{\mathcal{P}}),\#^{\leq}(I_{2}^{\mathcal{P}}),...,\#^{\leq}(I_{n(\mathcal{P})}^{\mathcal{P}}),0,0,...\right\rangle \\
 & =\underset{i=1}{\overset{n(\mathcal{P})}{\Pi}}pr(i)^{\#^{\leq}(I_{1}^{\mathcal{P}})}\\
 & \leq\underset{i=1}{\overset{\left\vert \mathcal{P}\right\vert }{\Pi}}pr(i)^{\#^{\leq}(\mathcal{P})}
\end{align*}

\end_inset

Ademas tenemos que
\begin_inset Formula 
\begin{align*}
\lambda\mathcal{P}\left[n(\mathcal{P})\right] & =\lambda x\left[Lt(x)\right]\circ M(Q)\\
\lambda i\mathcal{P}\left[I_{i}^{\mathcal{P}}\right] & =\ast^{\leq}\circ g\circ\left[p_{1}^{1,1},M(Q)\circ p_{2}^{1,1}\right]
\end{align*}

\end_inset

donde 
\begin_inset Formula $g=C_{0}^{1,1}|_{\{0\}\times\omega}\cup\lambda ix\left[(x)_{i}\right]$
\end_inset

, lo cual dice que 
\begin_inset Formula $\lambda\mathcal{P}\left[n(\mathcal{P})\right]$
\end_inset

 y 
\begin_inset Formula $\lambda i\mathcal{P}\left[I_{i}^{\mathcal{P}}\right]$
\end_inset

 son funciones 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Analisis de la recursividad de la semantica de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset


\end_layout

\begin_layout Standard
Para estudiar la recursividad de la semantica de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 deberemos definir varias funciones que tienen que ver con el funcionamiento
 de un programa y estudiar su recursividad.
\end_layout

\begin_layout Paragraph
Las funciones 
\begin_inset Formula $i^{n,m}$
\end_inset

, 
\begin_inset Formula $E_{\#}^{n,m}$
\end_inset

 y 
\begin_inset Formula $E_{\ast}^{n,m}$
\end_inset


\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $n,m\geq0$
\end_inset

 fijos.
 Definamos entonces las funciones
\begin_inset Formula 
\begin{align*}
i^{n,m} & :\omega\times\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}\rightarrow\omega\\
E_{\#}^{n,m} & :\omega\times\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}\rightarrow\omega^{[\mathbf{N}]}\\
E_{\ast}^{n,m} & :\omega\times\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}\rightarrow\Sigma^{\ast[\mathbf{N}]}
\end{align*}

\end_inset

de la siguiente manera
\begin_inset Formula 
\begin{align*}
(i^{n,m}(0,\vec{x},\vec{\alpha},\mathcal{P}),E_{\#}^{n,m}(0,\vec{x},\vec{\alpha},\mathcal{P}),E_{\ast}^{n,m}(0,\vec{x},\vec{\alpha},\mathcal{P})) & =(1,(x_{1},...,x_{n},0,...),(\alpha_{1},...,\alpha_{m},\varepsilon,...))\\
(i^{n,m}(t+1,\vec{x},\vec{\alpha},\mathcal{P}),E_{\#}^{n,m}(t+1,\vec{x},\vec{\alpha},\mathcal{P}),E_{\ast}^{n,m}(t+1,\vec{x},\vec{\alpha},\mathcal{P})) & =S_{\mathcal{P}}(i^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),E_{\#}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),E_{\ast}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}))
\end{align*}

\end_inset

Notese que
\begin_inset Formula 
\[
(i^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),E_{\#}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),E_{\ast}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}))
\]

\end_inset

es la descripcion instantanea que se obtiene luego de correr 
\begin_inset Formula $\mathcal{P}$
\end_inset

 una cantidad 
\begin_inset Formula $t$
\end_inset

 de pasos partiendo del estado
\begin_inset Formula 
\[
((x_{1},...,x_{n},0,...),(\alpha_{1},...,\alpha_{m},\varepsilon,...))
\]

\end_inset

Es importante notar que si bien 
\begin_inset Formula $i^{n,m}$
\end_inset

 es una funcion 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-mixta, ni 
\begin_inset Formula $E_{\#}^{n,m}$
\end_inset

 ni 
\begin_inset Formula $E_{\ast}^{n,m}$
\end_inset

 lo son.
\end_layout

\begin_layout Standard
Definamos para cada 
\begin_inset Formula $j\in\mathbf{N}$
\end_inset

, funciones
\begin_inset Formula 
\begin{align*}
E_{\#j}^{n,m} & :\omega\times\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}\rightarrow\omega\\
E_{\ast j}^{n,m} & :\omega\times\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}\rightarrow\Sigma^{\ast}
\end{align*}

\end_inset

de la siguiente manera
\begin_inset Formula 
\begin{align*}
E_{\#j}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}) & =j\text{-esima coordenada de }E_{\#}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P})\\
E_{\ast j}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}) & =j\text{-esima coordenada de }E_{\ast}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P})
\end{align*}

\end_inset

Notese que
\begin_inset Formula 
\begin{align*}
E_{\#}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}) & =(E_{\#1}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),E_{\#2}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),...)\\
E_{\ast}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}) & =(E_{\ast1}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),E_{\ast2}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),...)
\end{align*}

\end_inset

Nuestro proximo objetivo es mostrar que las funciones 
\begin_inset Formula $i^{n,m}$
\end_inset

, 
\begin_inset Formula $E_{\#j}^{n,m}$
\end_inset

, 
\begin_inset Formula $E_{\ast j}^{n,m}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
Para esto primero debemos probar un lema el cual muestre que una ves codificadas
 las descripciones instantaneas en forma numerica, las funciones que dan
 la descripcion instantanea sucesora son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Dado un orden total 
\begin_inset Formula $\leq$
\end_inset

 sobre 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

, codificaremos las descripciones instantaneas haciendo uso de las biyecciones
\begin_inset Formula 
\[
\begin{array}{rcl}
\omega^{\left[\mathbf{N}\right]} & \rightarrow & \mathbf{N}\\
(s_{1},s_{2},...) & \rightarrow & \left\langle s_{1},s_{2},...\right\rangle 
\end{array}\;\;\;\;\;\;\;\;\;\;\;\;\begin{array}{rcl}
\Sigma^{\ast\left[\mathbf{N}\right]} & \rightarrow & \mathbf{N}\\
(\sigma_{1},\sigma_{2},...) & \rightarrow & \left\langle \#^{\leq}(\sigma_{1}),\#^{\leq}(\sigma_{2}),...\right\rangle 
\end{array}
\]

\end_inset

Es decir que a la descripcion instantanea
\begin_inset Formula 
\[
(i,(s_{1},s_{2},...),(\sigma_{1},\sigma_{2},...))
\]

\end_inset

la codificaremos con la terna
\begin_inset Formula 
\[
(i,\left\langle s_{1},s_{2},...\right\rangle ,\left\langle \#^{\leq}(\sigma_{1}),\#^{\leq}(\sigma_{2}),...\right\rangle )\in\omega\times\mathbf{N}\times\mathbf{N}
\]

\end_inset

Es decir que una terna 
\begin_inset Formula $(i,x,y)\in\omega\times\mathbf{N}\times\mathbf{N}$
\end_inset

 codificara a la descripcion instantanea
\begin_inset Formula 
\[
(i,((x)_{1},(x)_{2},...),(\ast^{\leq}((y)_{1}),\ast^{\leq}((y)_{2}),...))
\]

\end_inset

Definamos
\begin_inset Formula 
\begin{align*}
s & :\omega\times\mathbf{N}\times\mathbf{N}\times\mathrm{Pro}^{\Sigma}\rightarrow\omega\\
S_{\#} & :\omega\times\mathbf{N}\times\mathbf{N}\times\mathrm{Pro}^{\Sigma}\rightarrow\omega\\
S_{\ast} & :\omega\times\mathbf{N}\times\mathbf{N}\times\mathrm{Pro}^{\Sigma}\rightarrow\omega
\end{align*}

\end_inset

de la siguiente manera
\begin_inset Formula 
\[
\begin{array}[t]{ll}
s(i,x,y,\mathcal{P})= & \text{primera coordenada de la codificacion de la descripcion instantanea}\\
 & \text{sucesora de }(i,((x)_{1},(x)_{2},...),(\ast^{\leq}((y)_{1}),\ast^{\leq}((y)_{2}),...))\text{ en }\mathcal{P}
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}[t]{ll}
S_{\#}(i,x,y,\mathcal{P})= & \text{segunda coordenada de la codificacion de la descripcion instantanea}\\
 & \text{sucesora de }(i,((x)_{1},(x)_{2},...),(\ast^{\leq}((y)_{1}),\ast^{\leq}((y)_{2}),...))\text{ en }\mathcal{P}
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}[t]{ll}
S_{\ast}(i,x,y,\mathcal{P})= & \text{tercera coordenada de la codificacion de la descripcion instantanea}\\
 & \text{sucesora de }(i,((x)_{1},(x)_{2},...),(\ast^{\leq}((y)_{1}),\ast^{\leq}((y)_{2}),...))\text{ en }\mathcal{P}
\end{array}
\]

\end_inset

Notese que la definicion de estas funciones depende del orden total 
\begin_inset Formula $\leq$
\end_inset

 sobre 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

.
\end_layout

\begin_layout Standard
@@finpagina@@
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "descripcion instantanea sucesora es PR"

\end_inset

Dado un orden total 
\begin_inset Formula $\leq$
\end_inset

 sobre 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

, las funciones 
\begin_inset Formula $s$
\end_inset

, 
\begin_inset Formula $S_{\#}$
\end_inset

 y 
\begin_inset Formula $S_{\ast}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Necesitaremos algunas funciones 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Dada una instruccion 
\begin_inset Formula $I$
\end_inset

 en la cual al menos ocurre una variable, usaremos 
\begin_inset Formula $\#Var1(I)$
\end_inset

 para denotar el numero de la primer variable que ocurre en 
\begin_inset Formula $I$
\end_inset

.
 Por ejemplo
\begin_inset Formula 
\[
\#Var1\left(\mathrm{L}\bar{n}\;\mathrm{IF\;N}\bar{k}\neq0\;\mathrm{GOTO\;L}\bar{m}\right)=k
\]

\end_inset

Notese que 
\begin_inset Formula $\lambda I[\#Var1(I)]$
\end_inset

 tiene dominio igual a 
\begin_inset Formula $\mathrm{Ins}^{\Sigma}-L$
\end_inset

, donde 
\begin_inset Formula $L$
\end_inset

 es la union de los siguientes conjuntos
\begin_inset Formula 
\begin{gather*}
\{\mathrm{GOTO\ L}\bar{m}:m\in\mathbf{N\}\cup}\{\mathrm{L}\bar{k}\ \mathrm{GOTO\ L}\bar{m}:k,m\in\mathbf{N\}}\\
\left\{ \mathrm{SKIP}\right\} \mathbf{\cup}\{\mathrm{L}\bar{k}\ \mathrm{SKIP}:k\in\mathbf{N\}}
\end{gather*}

\end_inset

Dada una instruccion 
\begin_inset Formula $I$
\end_inset

 en la cual ocurren dos variables, usaremos 
\begin_inset Formula $\#Var2(I)$
\end_inset

 para denotar el numero de la segunda variable que ocurre en 
\begin_inset Formula $I$
\end_inset

.
 Por ejemplo
\begin_inset Formula 
\[
\#Var2\left(\mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{m}\right)=m
\]

\end_inset

Notese que el dominio de 
\begin_inset Formula $\lambda I[\#Var2(I)]$
\end_inset

 es igual a la union de los siguientes conjuntos
\begin_inset Formula 
\begin{align*}
\{\mathrm{N}\bar{k} & \leftarrow\mathrm{N}\bar{m}:k,m\in\mathbf{N\}\cup}\{\mathrm{L}\bar{j}\ \mathrm{N}\bar{k}\leftarrow\mathrm{N}\bar{m}:j,k,m\in\mathbf{N\}}\\
\{\mathrm{P}\bar{k} & \leftarrow\mathrm{P}\bar{m}:k,m\in\mathbf{N\}\cup}\{\mathrm{L}\bar{j}\ \mathrm{P}\bar{k}\leftarrow\mathrm{P}\bar{m}:j,k,m\in\mathbf{N\}}
\end{align*}

\end_inset

Ademas notese que para una instruccion 
\begin_inset Formula $I$
\end_inset

 tenemos que
\begin_inset Formula 
\begin{align*}
\#Var1(I) & =\min_{k}(\mathrm{N}\bar{k}\mathrm{\leftarrow}\text{ }\mathrm{ocu}\text{ }I\vee\mathrm{N}\bar{k}\mathrm{\neq}\text{ }\mathrm{ocu}\text{ }I\vee\mathrm{P}\bar{k}\mathrm{\leftarrow}\text{ }\mathrm{ocu}\text{ }I\vee\mathrm{P}\bar{k}\mathrm{B}\;\mathrm{ocu}\text{ }I)\\
\#Var2(I) & =\min_{k}(\mathrm{N}\bar{k}\ \text{t-final }I\vee\mathrm{N}\bar{k}\mathrm{+}\text{ }\mathrm{ocu}\text{ }I\vee\mathrm{N}\bar{k}\mathrm{\dot{-}}\text{ }\mathrm{ocu}\text{ }I\vee\mathrm{P}\bar{k}\ \text{t-final }I\vee\mathrm{P}\bar{k}.\text{ }\mathrm{ocu}\text{ }I)
\end{align*}

\end_inset

Esto nos dice que si llamamos 
\begin_inset Formula $P$
\end_inset

 al predicado
\begin_inset Formula 
\[
\lambda k\alpha\left[\alpha\in\mathrm{Ins}^{\Sigma}\wedge(\mathrm{N}\bar{k}\mathrm{\leftarrow}\text{ }\mathrm{ocu}\text{ }\alpha\vee\mathrm{N}\bar{k}\mathrm{\neq}\text{ }\mathrm{ocu}\text{ }\alpha\vee\mathrm{P}\bar{k}\mathrm{\leftarrow}\text{ }\mathrm{ocu}\text{ }\alpha\vee\mathrm{P}\bar{k}\mathrm{B}\;\mathrm{ocu}\text{ }\alpha)\right]
\]

\end_inset

entonces 
\begin_inset Formula $\lambda I[\#Var1(I)]=M(P)$
\end_inset

 por lo cual 
\begin_inset Formula $\lambda I[\#Var1(I)]$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 Similarmente se puede ver que 
\begin_inset Formula $\lambda I[\#Var2(I)]$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Sea
\begin_inset Formula 
\[
\begin{array}{rll}
F_{\dot{-}}:\mathbf{N}\times\mathbf{N} & \rightarrow & \omega\\
(x,j) & \rightarrow & \left\langle (x)_{1},....,(x)_{j-1},(x)_{j}\dot{-}1,(x)_{j+1},...\right\rangle 
\end{array}
\]

\end_inset

Ya que
\begin_inset Formula 
\[
F_{\dot{-}}(x,j)=\left\{ \begin{array}{lll}
Q(x,pr(j)) &  & \text{si }pr(j)\text{ divide }x\\
x &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

tenemos que 
\begin_inset Formula $F_{\dot{-}}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Sea
\begin_inset Formula 
\[
\begin{array}{rll}
F_{+}:\mathbf{N}\times\mathbf{N} & \rightarrow & \omega\\
(x,j) & \rightarrow & \left\langle (x)_{1},....,(x)_{j-1},(x)_{j}+1,(x)_{j+1},...\right\rangle 
\end{array}
\]

\end_inset

Ya que 
\begin_inset Formula $F_{+}(x,j)=x.pr(j)$
\end_inset

 tenemos que 
\begin_inset Formula $F_{+}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Sea
\begin_inset Formula 
\[
\begin{array}{rll}
F_{\leftarrow}:\mathbf{N}\times\mathbf{N}\times\mathbf{N} & \rightarrow & \omega\\
(x,j,k) & \rightarrow & \left\langle (x)_{1},....,(x)_{j-1},(x)_{k},(x)_{j+1},...\right\rangle 
\end{array}
\]

\end_inset

Ya que 
\begin_inset Formula $F_{\leftarrow}(x,j,k)=Q(x,pr(j)^{(x)_{j}}).pr(j)^{(x)_{k}}$
\end_inset

 tenemos que 
\begin_inset Formula $F_{\leftarrow}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Sea
\begin_inset Formula 
\[
\begin{array}{rll}
F_{0}:\mathbf{N}\times\mathbf{N} & \rightarrow & \omega\\
(x,j) & \rightarrow & \left\langle (x)_{1},....,(x)_{j-1},0,(x)_{j+1},...\right\rangle 
\end{array}
\]

\end_inset

Es facil ver que 
\begin_inset Formula $F_{0}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Para cada 
\begin_inset Formula $a\in\Sigma$
\end_inset

, sea
\begin_inset Formula 
\[
\begin{array}{rll}
F_{a}:\mathbf{N}\times\mathbf{N} & \rightarrow & \omega\\
(x,j) & \rightarrow & \left\langle (x)_{1},....,(x)_{j-1},\#^{\leq}(\ast^{\leq}((x)_{j})a),(x)_{j+1},...\right\rangle 
\end{array}
\]

\end_inset

Es facil ver que 
\begin_inset Formula $F_{a}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 En forma similar puede ser probado que
\begin_inset Formula 
\[
\begin{array}{rll}
F_{\curvearrowright}:\mathbf{N}\times\mathbf{N} & \rightarrow & \omega\\
(x,j) & \rightarrow & \left\langle (x)_{1},....,(x)_{j-1},\#^{\leq}(^{\curvearrowright}(\ast^{\leq}((x)_{j}))),(x)_{j+1},...\right\rangle 
\end{array}
\]

\end_inset

es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
\end_layout

\begin_layout Standard
Dado 
\begin_inset Formula $(i,x,y,\mathcal{P})\in\omega\times\mathbf{N}\times\mathbf{N}\times\mathrm{Pro}^{\Sigma}$
\end_inset

, tenemos varios casos en los cuales los valores 
\begin_inset Formula $s(i,x,y,\mathcal{P}),S_{\#}(i,x,y,\mathcal{P})$
\end_inset

 y 
\begin_inset Formula $S_{\ast}(i,x,y,\mathcal{P})$
\end_inset

 pueden ser obtenidos usando las funciones antes definidas:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

CASO 
\begin_inset Formula $i=0\vee i>n(\mathcal{P})$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{j}\leftarrow\mathrm{N}\bar{j}+1$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =F_{+}(x,\#Var1(I_{i}^{\mathcal{P}}))\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{j}\leftarrow\mathrm{N}\bar{j}\dot{-}1$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =F_{\dot{-}}(x,\#Var1(I_{i}^{\mathcal{P}}))\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j,k\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{j}\leftarrow\mathrm{N}\bar{k}$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =F_{\leftarrow}(x,\#Var1(I_{i}^{\mathcal{P}}),\#Var2(I_{i}^{\mathcal{P}}))\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j,k\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{j}\leftarrow0$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =F_{0}(x,\#Var1(I_{i}^{\mathcal{P}}))\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j,m\in\omega)\;\left(Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{N}\bar{j}\neq0\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\wedge(x)_{j}=0\right)$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(7)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j,m\in\omega)\;\left(Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{N}\bar{j}\neq0\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\wedge(x)_{j}\neq0\right)$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =\min_{l}\left(Lab(I_{l}^{\mathcal{P}})\neq\varepsilon\wedge Lab(I_{l}^{\mathcal{P}})\text{ }\mathrm{t}\text{\textrm{-final} }I_{i}^{\mathcal{P}}\right)\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(8)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{j}\leftarrow\mathrm{P}\bar{j}.a$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =F_{a}(y,\#Var1(I_{i}^{\mathcal{P}}))
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(9)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{j}\leftarrow$
\end_inset

 
\begin_inset Formula $^{\curvearrowright}\mathrm{P}\bar{j}$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =F_{\curvearrowright}(y,\#Var1(I_{i}^{\mathcal{P}}))
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(10)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j,k\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{j}\leftarrow\mathrm{P}\bar{k}$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =F_{\leftarrow}(y,\#Var1(I_{i}^{\mathcal{P}}),\#Var2(I_{i}^{\mathcal{P}}))
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(11)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{j}\leftarrow\varepsilon$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =F_{0}(y,\#Var1(I_{i}^{\mathcal{P}}))
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(12)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j,m\in\omega)(\exists a\in\Sigma)\;\left(Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{P}\bar{j}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}\wedge[\ast^{\leq}((y)_{j})]_{1}\neq a\right)$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(13)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j,m\in\omega)(\exists a\in\Sigma)\;\left(Bas(I_{i}^{\mathcal{P}})=\mathrm{IF\;P}\bar{j}\;\mathrm{BEGINS\;}a\;\mathrm{GOTO\;L}\bar{m}\wedge[\ast^{\leq}((y)_{j})]_{1}=a\right)$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =\min_{l}\left(Lab(I_{l}^{\mathcal{P}})\neq\varepsilon\wedge Lab(I_{l}^{\mathcal{P}})\text{ }\mathrm{t}\text{\textrm{-final} }I_{i}^{\mathcal{P}}\right)\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(14)
\end_layout

\end_inset

CASO 
\begin_inset Formula $(\exists j\in\omega)\;Bas(I_{i}^{\mathcal{P}})=\mathrm{GOTO}$
\end_inset

 
\begin_inset Formula $\mathrm{L}\bar{j}$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =\min_{l}\left(Lab(I_{l}^{\mathcal{P}})\neq\varepsilon\wedge Lab(I_{l}^{\mathcal{P}})\text{ }\mathrm{t}\text{\textrm{-final} }I_{i}^{\mathcal{P}}\right)\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(15)
\end_layout

\end_inset

CASO 
\begin_inset Formula $Bas(I_{i}^{\mathcal{P}})=\mathrm{SKIP}$
\end_inset

.
 Entonces
\begin_inset Formula 
\begin{align*}
s(i,x,y,\mathcal{P}) & =i+1\\
S_{\#}(i,x,y,\mathcal{P}) & =x\\
S_{\ast}(i,x,y,\mathcal{P}) & =y
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
O sea que los casos anteriores nos permiten definir conjuntos 
\begin_inset Formula $S_{1},...,S_{15}$
\end_inset

, los cuales son disjuntos de a pares y cuya union da el conjunto 
\begin_inset Formula $\omega\times\mathbf{N}\times\mathbf{N}\times\mathrm{Pro}^{\Sigma}$
\end_inset

, de manera que cada una de las funciones 
\begin_inset Formula $s,S_{\#}$
\end_inset

 y 
\begin_inset Formula $S_{\ast}$
\end_inset

 pueden escribirse como union disjunta de funciones 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 restrinjidas respectivamente a los conjuntos 
\begin_inset Formula $S_{1},...,S_{15}$
\end_inset

.
 Ya que los conjuntos 
\begin_inset Formula $S_{1},...,S_{15}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "dpc"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $s,S_{\#}$
\end_inset

 y 
\begin_inset Formula $S_{\ast}$
\end_inset

 lo son.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Aparte del lema anterior, para probar que las funciones 
\begin_inset Formula $i^{n,m}$
\end_inset

, 
\begin_inset Formula $E_{\#j}^{n,m}$
\end_inset

 y 
\begin_inset Formula $E_{\ast j}^{n,m}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., nos sera necesario el siguiente resultado.
 Recordemos que para 
\begin_inset Formula $x_{1},...,x_{n}\in\omega$
\end_inset

, usabamos 
\begin_inset Formula $\left\langle x_{1},...,x_{n}\right\rangle $
\end_inset

 para denotar 
\begin_inset Formula $\left\langle x_{1},...,x_{n},0,...\right\rangle $
\end_inset

.
 Ademas recordemos que en el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "CodificadorasSonPR"
plural "false"
caps "false"
noprefix "false"

\end_inset

 probamos que para cada 
\begin_inset Formula $n\geq1$
\end_inset

, la funcion 
\begin_inset Formula $\lambda x_{1}...x_{n}\left[\left\langle x_{1},...,x_{n}\right\rangle \right]$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "recursion primitiva multiple"

\end_inset

Sean
\begin_inset Formula 
\begin{align*}
f_{i} & :S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega\\
g_{i} & :\omega^{k}\times\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega\\
F_{i} & :\omega\times S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}\rightarrow\omega
\end{align*}

\end_inset

con 
\begin_inset Formula $i=1,...,k$
\end_inset

, funciones 
\begin_inset Formula $\Sigma$
\end_inset

-mixtas.
 Supongamos que
\begin_inset Formula 
\begin{align*}
F_{i}(0,\vec{x},\vec{\alpha}) & =f_{i}(0,\vec{x},\vec{\alpha})\\
F_{i}(t+1,\vec{x},\vec{\alpha}) & =g_{i}(F_{1}(t,\vec{x},\vec{\alpha}),...,F_{k}(t,\vec{x},\vec{\alpha}),t,\vec{x},\vec{\alpha})
\end{align*}

\end_inset

para cada 
\begin_inset Formula $i=1,...,k$
\end_inset

, 
\begin_inset Formula $t\in\omega$
\end_inset

 y 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in S_{1}\times...\times S_{n}\times L_{1}\times...\times L_{m}$
\end_inset

.
 Entonces si las funciones 
\begin_inset Formula $f_{1},...,f_{k},g_{1},...,g_{k}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., las funciones 
\begin_inset Formula $F_{1},...,F_{k}$
\end_inset

 lo son.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Para mayor claridad haremos el caso 
\begin_inset Formula $k=2$
\end_inset

.
 Sea
\begin_inset Formula 
\[
F=\lambda t\vec{x}\vec{\alpha}\left[\left\langle F_{1}(t,\vec{x},\vec{\alpha}),F_{2}(t,\vec{x},\vec{\alpha})\right\rangle \right]
\]

\end_inset

Es claro que si 
\begin_inset Formula $F$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., entonces lo es cada 
\begin_inset Formula $F_{i}$
\end_inset

.
 Notese que
\begin_inset Formula 
\begin{align*}
F(0,\vec{x},\vec{\alpha}) & =\left\langle f_{1}(\vec{x},\vec{\alpha}),f_{2}(\vec{x},\vec{\alpha})\right\rangle \\
F(t+1,\vec{x},\vec{\alpha}) & =\left\langle g_{1}((F(t,\vec{x},\vec{\alpha}))_{1},(F(t,\vec{x},\vec{\alpha}))_{2},t,\vec{x},\vec{\alpha}),g_{2}((F(t,\vec{x},\vec{\alpha}))_{1},(F(t,\vec{x},\vec{\alpha}))_{2},t,\vec{x},\vec{\alpha})\right\rangle 
\end{align*}

\end_inset

lo cual nos dice que 
\begin_inset Formula $F=R(f,g)$
\end_inset

 donde
\begin_inset Formula 
\begin{align*}
f & =\lambda\vec{x}\vec{\alpha}\left[\left\langle f_{1}(\vec{x},\vec{\alpha}),f_{2}(\vec{x},\vec{\alpha})\right\rangle \right]\\
g & =\lambda At\vec{x}\vec{\alpha}\left[\left\langle g_{1}((A)_{1},(A)_{2},t,\vec{x},\vec{\alpha}),g_{2}((A)_{1},(A)_{2},t,\vec{x},\vec{\alpha})\right\rangle \right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
@@finpagina@@
\end_layout

\begin_layout Standard
Ahora usando los dos lemas anteriores podemos probar el siguiente importante
 resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 Sean 
\begin_inset Formula $n,m\geq0$
\end_inset

.
 Las funciones 
\begin_inset Formula $i^{n,m}$
\end_inset

, 
\begin_inset Formula $E_{\#j}^{n,m}$
\end_inset

, 
\begin_inset Formula $E_{\ast j}^{n,m}$
\end_inset

, 
\begin_inset Formula $j=1,2,...$
\end_inset

, son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

 y sean 
\begin_inset Formula $s$
\end_inset

, 
\begin_inset Formula $S_{\#}$
\end_inset

 y 
\begin_inset Formula $S_{\ast}$
\end_inset

 las funciones definidas previamente al Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "descripcion instantanea sucesora es PR"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Definamos
\begin_inset Formula 
\begin{align*}
K_{\#}^{n,m} & =\lambda t\vec{x}\vec{\alpha}\mathcal{P}\left[\left\langle E_{\#1}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),E_{\#2}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),...\right\rangle \right]\\
K_{\ast}^{n,m} & =\lambda t\vec{x}\vec{\alpha}\mathcal{P}\left[\left\langle \#^{\leq}(E_{\ast1}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P})),\#^{\leq}(E_{\ast2}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P})),...\right\rangle \right]
\end{align*}

\end_inset

Notese que
\begin_inset Formula 
\begin{align*}
i^{n,m}(0,\vec{x},\vec{\alpha},\mathcal{P}) & =1\\
K_{\#}^{n,m}(0,\vec{x},\vec{\alpha},\mathcal{P}) & =\left\langle x_{1},...,x_{n}\right\rangle \\
K_{\ast}^{n,m}(0,\vec{x},\vec{\alpha},\mathcal{P}) & =\left\langle \#^{\leq}(\alpha_{1}),...,\#^{\leq}(\alpha_{m})\right\rangle \\
i^{n,m}(t+1,\vec{x},\vec{\alpha},\mathcal{P}) & =s(i^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),K_{\#}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),K_{\ast}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}))\\
K_{\#}^{n,m}(t+1,\vec{x},\vec{\alpha},\mathcal{P}) & =S_{\#}(i^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),K_{\#}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),K_{\ast}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}))\\
K_{\ast}^{n,m}(t+1,\vec{x},\vec{\alpha},\mathcal{P}) & =S_{\ast}(i^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),K_{\#}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}),K_{\ast}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}))
\end{align*}

\end_inset

Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursion primitiva multiple"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $i^{n,m}$
\end_inset

, 
\begin_inset Formula $K_{\#}^{n,m}$
\end_inset

 y 
\begin_inset Formula $K_{\ast}^{n,m}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Ademas notese que
\begin_inset Formula 
\begin{align*}
E_{\#j}^{n,m} & =\lambda t\vec{x}\vec{\alpha}\mathcal{P}\left[(K_{\#}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}))_{j}\right]\\
E_{\ast j}^{n,m} & =\lambda t\vec{x}\vec{\alpha}\mathcal{P}\left[\ast^{\leq}((K_{\ast}^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}))_{j})\right]
\end{align*}

\end_inset

por lo cual las funciones 
\begin_inset Formula $E_{\#j}^{n,m}$
\end_inset

, 
\begin_inset Formula $E_{\ast j}^{n,m}$
\end_inset

, 
\begin_inset Formula $j=1,2,...$
\end_inset

, son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Las funciones 
\begin_inset Formula $Halt^{n,m}$
\end_inset

 y 
\begin_inset Formula $T^{n,m}$
\end_inset


\end_layout

\begin_layout Standard
Dados 
\begin_inset Formula $n,m\in\omega$
\end_inset

, definamos:
\begin_inset Formula 
\[
Halt^{n,m}=\lambda t\vec{x}\vec{\alpha}\mathcal{P}\left[i^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P})=n(\mathcal{P})+1\right]
\]

\end_inset

Notese que 
\begin_inset Formula $D_{Halt^{n,m}}=\omega\times\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}$
\end_inset

 (ojo que aqui la notacion lambda es respecto del alfabeto 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

).
 Ademas notese que usamos la variable 
\begin_inset Formula $\mathcal{P}$
\end_inset

 en la notacion lambda por un tema de comodidad psicologica dado que 
\begin_inset Formula $i^{n,m}$
\end_inset

 esta definida solo cuando la ultima coordenada es un programa pero podriamos
 haber escrito 
\begin_inset Formula $\lambda t\vec{x}\vec{\alpha}\alpha\left[i^{n,m}(t,\vec{x},\vec{\alpha},\alpha)=n(\alpha)+1\right]$
\end_inset

 y sigue siendo la misma funcion.
\end_layout

\begin_layout Standard
Cabe destacar que 
\begin_inset Formula $Halt^{n,m}$
\end_inset

 tiene una descripcion muy intuitiva, ya que dado 
\begin_inset Formula $(t,\vec{x},\vec{\alpha},\mathcal{P})\in\omega\times\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}$
\end_inset

, tenemos que 
\begin_inset Formula $Halt^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P})=1$
\end_inset

 si y solo si el programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene luego de 
\begin_inset Formula $t$
\end_inset

 pasos partiendo desde el estado 
\begin_inset Formula $\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $Halt^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notar que 
\begin_inset Formula $Halt^{n,m}=\lambda xy[x=y]\circ\left[i^{n,m},\lambda\mathcal{P}[n(\mathcal{P})+1]\circ p_{1+n+m+1}^{1+n,m+1}\right]$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora definamos 
\begin_inset Formula $T^{n,m}=M(Halt^{n,m})$
\end_inset

.
 Notese que
\begin_inset Formula 
\[
D_{T^{n,m}}=\{(\vec{x},\vec{\alpha},\mathcal{P}):\mathcal{P}\text{ se detiene partiendo de }\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert \}
\]

\end_inset

y para 
\begin_inset Formula $(\vec{x},\vec{\alpha},\mathcal{P})\in D_{T^{n,m}}$
\end_inset

 tenemos que 
\begin_inset Formula $T^{n,m}(\vec{x},\vec{\alpha},\mathcal{P})=$
\end_inset

 cantidad de pasos necesarios para que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detenga partiendo de 
\begin_inset Formula $\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

.
 En algun sentido, la funcion 
\begin_inset Formula $T^{n,m}$
\end_inset

 mide el tiempo que tarda en detenerse 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset Formula $T^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursiva 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es directo del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "minimizacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 ya que 
\begin_inset Formula $Halt^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Las funciones 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 y 
\begin_inset Formula $\Phi_{\ast}^{n,m}$
\end_inset


\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $n,m\in\omega$
\end_inset

 definamos la funcion 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\begin{align*}
D_{\Phi_{\#}^{n,m}} & =\left\{ (\vec{x},\vec{\alpha},\mathcal{P})\in\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}:(\vec{x},\vec{\alpha})\in D_{\Psi_{\mathcal{P}}^{n,m,\#}}\right\} \\
\Phi_{\#}^{n,m}(\vec{x},\vec{\alpha},\mathcal{P}) & =\Psi_{\mathcal{P}}^{n,m,\#}(\vec{x},\vec{\alpha})\text{, para cada }(\vec{x},\vec{\alpha},\mathcal{P})\in D_{\Phi_{\#}^{n,m}}
\end{align*}

\end_inset

Notese que
\begin_inset Formula 
\[
D_{\Phi_{\#}^{n,m}}=\{(\vec{x},\vec{\alpha},\mathcal{P}):\mathcal{P}\text{ se detiene partiendo de }\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert \}
\]

\end_inset

y para cada 
\begin_inset Formula $(\vec{x},\vec{\alpha},\mathcal{P})\in D_{\Phi_{\#}^{n,m}}$
\end_inset

, se tiene que 
\begin_inset Formula $\Phi_{\#}^{n,m}(\vec{x},\vec{\alpha},\mathcal{P})=$
\end_inset

 valor que queda en la variable 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 cuando 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo de 
\begin_inset Formula $\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

.
\end_layout

\begin_layout Standard
Similarmente, definamos la funcion 
\begin_inset Formula $\Phi_{\ast}^{n,m}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\begin{align*}
D_{\Phi_{\ast}^{n,m}} & =\left\{ (\vec{x},\vec{\alpha},\mathcal{P})\in\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}:(\vec{x},\vec{\alpha})\in D_{\Psi_{\mathcal{P}}^{n,m,\ast}}\right\} \\
\Phi_{\ast}^{n,m}(\vec{x},\vec{\alpha},\mathcal{P}) & =\Psi_{\mathcal{P}}^{n,m,\ast}(\vec{x},\vec{\alpha})\text{, para cada }(\vec{x},\vec{\alpha},\mathcal{P})\in D_{\Phi_{\ast}^{n,m}}
\end{align*}

\end_inset

Notese que
\begin_inset Formula 
\begin{align*}
\Phi_{\#}^{n,m} & =\lambda\vec{x}\vec{\alpha}\mathcal{P}\left[\Psi_{\mathcal{P}}^{n,m,\#}(\vec{x},\vec{\alpha})\right]\\
\Phi_{\ast}^{n,m} & =\lambda\vec{x}\vec{\alpha}\mathcal{P}\left[\Psi_{\mathcal{P}}^{n,m,\ast}(\vec{x},\vec{\alpha})\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Las funciones 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 y 
\begin_inset Formula $\Phi_{\ast}^{n,m}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursivas.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Veremos que 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursiva.
 Notar que 
\begin_inset Formula $D_{T^{n,m}}=D_{\Phi_{\#}^{n,m}}$
\end_inset

.
 Notese que para 
\begin_inset Formula $(\vec{x},\vec{\alpha},\mathcal{P})\in D_{T^{n,m}}=D_{\Phi_{\#}^{n,m}}$
\end_inset

 tenemos que
\begin_inset Formula 
\[
\Phi_{\#}^{n,m}(\vec{x},\vec{\alpha},\mathcal{P})=E_{\#1}^{n,m}\left(T^{n,m}(\vec{x},\vec{\alpha},\mathcal{P}),\vec{x},\vec{\alpha},\mathcal{P}\right)
\]

\end_inset

lo cual con un poco mas de trabajo nos permite probar que
\begin_inset Formula 
\[
\Phi_{\#}^{n,m}=E_{\#1}^{n,m}\circ\left[T^{n,m},p_{1}^{n,m+1},...,p_{n+m+1}^{n,m+1}\right]
\]

\end_inset

Ya que la funcion 
\begin_inset Formula $E_{\#1}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 y 
\begin_inset Formula $T^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-r., tenemos que 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Godel vence a Neumann
\end_layout

\begin_layout Standard
Ahora nos sera facil probar que el paradigma de Godel es por lo menos tan
 abarcativo como el imperativo de Von Neumann.
 Mas concretamente:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "computable-implica-recursiva"

\end_inset

Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Haremos el caso 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Sea 
\begin_inset Formula $\mathcal{P}_{0}$
\end_inset

 un programa que compute a 
\begin_inset Formula $f$
\end_inset

.
 Primero veremos que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursiva.
 Note que
\begin_inset Formula 
\[
f=\Phi_{\ast}^{n,m}\circ\left[p_{1}^{n,m},...,p_{n+m}^{n,m},C_{\mathcal{P}_{0}}^{n,m}\right]
\]

\end_inset

donde cabe destacar que 
\begin_inset Formula $p_{1}^{n,m},...,p_{n+m}^{n,m}$
\end_inset

 son las proyecciones respecto del alfabeto 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

, es decir que tienen dominio 
\begin_inset Formula $\omega^{n}\times(\Sigma\cup\Sigma_{p})^{\ast m}$
\end_inset

.
 Ya que 
\begin_inset Formula $\Phi_{\ast}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursiva tenemos que 
\begin_inset Formula $f$
\end_inset

 lo es.
 O sea que el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Un corolario interesante que se puede obtener del teorema anterior es que
 toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva puede obtenerse combinando las reglas basicas en una forma muy
 particular.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva, entonces existe un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $P:\mathbf{N}\times\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 y una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\begin_inset Formula $g:\mathbf{N}\rightarrow O$
\end_inset

 tales que 
\begin_inset Formula $f=g\circ M(P).$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos que 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Sea 
\begin_inset Formula $\mathcal{P}_{0}$
\end_inset

 un programa el cual compute a 
\begin_inset Formula $f$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Note que podemos tomar
\begin_inset Formula 
\begin{align*}
P & =\lambda t\vec{x}\vec{\alpha}[Halt^{n,m}\left((t)_{1},\vec{x},\vec{\alpha},\mathcal{P}_{0}\right)\wedge(t)_{2}=\#^{\leq}(E_{\ast1}^{n,m}((t)_{1},\vec{x},\vec{\alpha},\mathcal{P}_{0}))]\\
g & =\lambda t\left[\ast^{\leq}((t)_{2})\right]
\end{align*}

\end_inset

(Justifique por que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
A continuacion veremos ejemplos naturales de funciones 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursivas que no son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursivas primitivas.
 Cabe destacar que la prueba se basa en la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo no implica PR"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (enunciada sin demostracion) la cual nos dice que cualquiera sea el alfabeto
 finito 
\begin_inset Formula $\Sigma$
\end_inset

, siempre hay una funcion que es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva y no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva primitiva
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "T y FI no son PR"

\end_inset

Cualesquiera sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

, se tiene que las funciones 
\begin_inset Formula $T^{n,m}$
\end_inset

, 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 y 
\begin_inset Formula $\Phi_{\ast}^{n,m}$
\end_inset

 no son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Fijemos 
\begin_inset Formula $n,m\in\omega$
\end_inset

.
 Probaremos que 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 sii 
\begin_inset Formula $\Phi_{\#}^{0,0}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Sean 
\begin_inset Formula $f_{1},f_{2}:\omega^{n}\times\Sigma^{\ast m}\rightarrow(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

 dadas por
\begin_inset Formula 
\begin{align*}
f_{1}(\vec{x},\vec{\alpha}) & =(\mathrm{N}1\leftarrow\mathrm{N}1+1)^{x_{1}}...(\mathrm{N}\bar{n}\leftarrow\mathrm{N}\bar{n}+1)^{x_{n}}\\
f_{1}(\vec{x},\vec{\alpha}) & =\left(\subset_{i=1}^{i=\left\vert \alpha_{1}\right\vert }\mathrm{P}1\leftarrow\mathrm{P}1.[\alpha_{1}]_{i}\right)...\left(\subset_{i=1}^{i=\left\vert \alpha_{m}\right\vert }\mathrm{P}1\leftarrow\mathrm{P}1.[\alpha_{m}]_{i}\right)
\end{align*}

\end_inset

Sea 
\begin_inset Formula $f:\omega^{n}\times\Sigma^{\ast m}\times\mathrm{Pro}^{\Sigma}\rightarrow(\Sigma\cup\Sigma_{p})^{\ast}$
\end_inset

 dada por
\begin_inset Formula 
\[
f(\vec{x},\vec{\alpha},\mathcal{P})=f_{1}(\vec{x},\vec{\alpha})f_{1}(\vec{x},\vec{\alpha})\mathcal{P}
\]

\end_inset

Es facil ver que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Notese que 
\begin_inset Formula $\Phi_{\#}^{n,m}=\Phi_{\#}^{0,0}\circ f$
\end_inset

.
 Ademas notese que
\begin_inset Formula 
\[
\Phi_{\#}^{0,0}=\Phi_{\#}^{n,m}\circ\left[C_{0}^{0,1},...,C_{0}^{0,1},C_{\varepsilon}^{0,1},...,C_{\varepsilon}^{0,1},p_{1}^{0,1}\right]
\]

\end_inset

Ya que 
\begin_inset Formula $f$
\end_inset

 y las funciones 
\begin_inset Formula $C_{0}^{0,1},C_{\varepsilon}^{0,1},p_{1}^{0,1}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., tenemos que 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 sii 
\begin_inset Formula $\Phi_{\#}^{0,0}$
\end_inset

 lo es.
\end_layout

\begin_layout Standard
Supongamos ahora que para algunos 
\begin_inset Formula $k,l\in\omega$
\end_inset

 se tiene que 
\begin_inset Formula $\Phi_{\#}^{k,l}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Llegaremos a un absurdo.
 Por lo antes probado tenemos que 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., cualesquiera sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

.
 Notese que de la prueba del teorema anterior sigue que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable con imagen contenida en 
\begin_inset Formula $\omega$
\end_inset

 es de la forma 
\begin_inset Formula $\Phi_{\#}^{n,m}\circ\left[p_{1}^{n,m},...,p_{n+m}^{n,m},C_{\mathcal{P}_{0}}^{n,m}\right]$
\end_inset

, para algunos 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y 
\begin_inset Formula $\mathcal{P}_{0}\in\mathrm{Pro}^{\Sigma}$
\end_inset

.
 Pero entonces toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable con imagen contenida en 
\begin_inset Formula $\omega$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., lo cual por el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "computable-implica-recursiva"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable con imagen contenida en 
\begin_inset Formula $\omega$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Esto contradice la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo no implica PR"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Ahora supongamos que hay 
\begin_inset Formula $n,m\in\omega$
\end_inset

 tales que 
\begin_inset Formula $T^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Llegaremos a un absurdo.
 Como ya vimos en la prueba de un teorema reciente, se tiene que
\begin_inset Formula 
\[
\Phi_{\#}^{n,m}=E_{\#1}^{n,m}\circ\left[T^{n,m},p_{1}^{n,m+1},...,p_{n+m+1}^{n,m+1}\right]
\]

\end_inset

Pero entonces ya que 
\begin_inset Formula $E_{\#1}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., tenemos que 
\begin_inset Formula $\Phi_{\#}^{n,m}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., lo cual como ya vimos recien no es cierto.
 El absurdo nos dice que 
\begin_inset Formula $T^{n,m}$
\end_inset

 no es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 
\begin_inset CommandInset label
LatexCommand label
name "minimizacion de PR que no es PR"

\end_inset

La minimizacion de un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 no necesariamente es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por definicion 
\begin_inset Formula $T^{n,m}=M(Halt^{n,m})$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Uso de macros asociados a las funciones 
\begin_inset Formula $Halt^{n,m}$
\end_inset

, 
\begin_inset Formula $E_{\#}^{n,m}$
\end_inset

 y 
\begin_inset Formula $E_{\ast}^{n,m}$
\end_inset


\end_layout

\begin_layout Standard
Aqui veremos, con ejemplos, como ciertos macros nos permitiran dentro de
 un programa hablar acerca del funcionamiento de otro programa.
 Esto junto con el hecho que cada funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva y cada predicado 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo tienen su macro asociado (Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo implica macro"
plural "false"
caps "false"
noprefix "false"

\end_inset

), sera muy util a la hora del diseo de programas y nos permitira simular
 dentro del paradigma imperativo muchas ideas usadas para el diseo de procedimi
entos efectivos.
 En este sentido la convinacion de los dos paradigmas (recursivo e imperativo)
 nos permite fortalecer notablemente al paradigma imperativo en su roll
 modelizador (o simulador) de los procedimientos efectivos.
 Esto es importante ya que el paradigma mas comodo, amplio e intuitivo,
 a la hora de decidir si algo es o no computable, es sin duda el filosofico
 o efectivo.
\end_layout

\begin_layout Standard
Veamos el primer ejemplo.
 Sea 
\begin_inset Formula $\Sigma=\{@,!\}$
\end_inset

 y sea 
\begin_inset Formula $\mathcal{P}_{0}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 tal que 
\begin_inset Formula $0\in\mathrm{Dom}\Psi_{\mathcal{P}_{0}}^{1,0,\#}$
\end_inset

 y 
\begin_inset Formula $\Psi_{\mathcal{P}_{0}}^{1,0,\#}(0)=2$
\end_inset

.
 Probaremos que
\begin_inset Formula 
\[
S=\{x\in\mathrm{Dom}\Psi_{\mathcal{P}_{0}}^{1,0,\#}:\Psi_{\mathcal{P}_{0}}^{1,0,\#}(x)\neq0\}
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable.
 Notese que 
\begin_inset Formula $0\in S$
\end_inset

.
 Por definicion de conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable, deberemos encontrar un programa 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 tal que 
\begin_inset Formula $\mathrm{Dom}\Psi_{\mathcal{P}}^{1,0,\#}=\omega$
\end_inset

 y 
\begin_inset Formula $\operatorname{Im}\Psi_{\mathcal{P}}^{1,0,\#}=S$
\end_inset

.
 Dicho en palabras, el programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 debera cumplir:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

siempre que lo corramos desde un estado de la forma 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

, con 
\begin_inset Formula $x\in\omega$
\end_inset

, debe detenerse y el contenido de la variable 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 bajo detencion debera ser un elemento de 
\begin_inset Formula $S$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

para cada 
\begin_inset Formula $s\in S$
\end_inset

 debera haber un 
\begin_inset Formula $x\in\omega$
\end_inset

 tal que 
\begin_inset Formula $s$
\end_inset

 es el valor de la variable 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 bajo detencion cuando corremos 
\begin_inset Formula $\mathcal{P}$
\end_inset

 desde 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
A continuacion daremos una descripcion intuitiva del funcionamiento de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 (pseudocodigo) para luego escribirlo correctamente usando macros.
 El programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 comenzara del estado 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

 y hara las siguientes tareas
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 1: si 
\begin_inset Formula $x=0$
\end_inset

 ir a Etapa 6, en caso contrario ir a Etapa 2.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 2: calcular 
\begin_inset Formula $(x)_{1}$
\end_inset

 y 
\begin_inset Formula $(x)_{2}$
\end_inset

 e ir a Etapa 3.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 3: si 
\begin_inset Formula $\mathcal{P}_{0}$
\end_inset

 termina desde 
\begin_inset Formula $\left\Vert (x)_{1}\right\Vert $
\end_inset

 en 
\begin_inset Formula $(x)_{2}$
\end_inset

 pasos ir a Etapa 4, en caso contrario ir a Etapa 6
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 4: si el valor que queda en 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 luego de correr 
\begin_inset Formula $\mathcal{P}_{0}$
\end_inset

 una cantidad 
\begin_inset Formula $(x)_{2}$
\end_inset

 de pasos, partiendo de 
\begin_inset Formula $\left\Vert (x)_{1}\right\Vert $
\end_inset

, es distinto de 0, entonces ir a Etapa 5.
 En caso contrario ir a Etapa 6.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 5: asignar a 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 el valor 
\begin_inset Formula $(x)_{1}$
\end_inset

 y terminar
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 6: asignar a 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 el valor 
\begin_inset Formula $0$
\end_inset

 y terminar 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que la descripcion anterior no es ni mas ni menos que un procedimiento
 efectivo que enumera a 
\begin_inset Formula $S$
\end_inset

, y nuestra mision es simularlo dentro del lenguaje 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

.
 Para esto usaremos varios macros.
 Ya que la funcion 
\begin_inset Formula $f=\lambda x[(x)_{1}]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., el Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo implica macro"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que hay un macro:
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow f(\mathrm{V}1)]
\]

\end_inset

el cual escribiremos de la siguiente manera mas intuitiva:
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow(\mathrm{V}1)_{1}]
\]

\end_inset

Similarmente hay un macro:
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow(\mathrm{V}1)_{2}]
\]

\end_inset

Tambien, ya que el predicado 
\begin_inset Formula $P=\lambda x[x=0]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo, hay un macro:
\begin_inset Formula 
\[
\left[\mathrm{IF}\;P(\mathrm{V}1)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

el cual escribiremos de la siguiente manera:
\begin_inset Formula 
\[
\left[\mathrm{IF}\;\mathrm{V}1=0\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Definamos
\begin_inset Formula 
\[
H=\lambda tx\left[Halt^{1,0}(t,x,\mathcal{P}_{0})\right]
\]

\end_inset

Notar que 
\begin_inset Formula $D_{H}=\omega^{2}$
\end_inset

 y que 
\begin_inset Formula $H$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta.
 Ademas sabemos que la funcion 
\begin_inset Formula $Halt^{1,0}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 por lo cual resulta facilmente que 
\begin_inset Formula $H$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Por la Proposicion de Independencia del Alfabeto tenemos que 
\begin_inset Formula $H$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 O sea que el Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo implica macro"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que hay un macro:
\begin_inset Formula 
\[
\left[\mathrm{IF}\;H(\mathrm{V}1,\mathrm{V}2)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Para hacer mas intuitivo el uso de este macro lo escribiremos de la siguiente
 manera
\begin_inset Formula 
\[
\left[\mathrm{IF}\;Halt^{1,0}(\mathrm{V}1,\mathrm{V}2,\mathcal{P}_{0})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Sea
\begin_inset Formula 
\[
g=\lambda tx\left[E_{\#1}^{1,0}(t,x,\mathcal{P}_{0})\right]
\]

\end_inset

Ya que 
\begin_inset Formula $g$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva (por que?), hay un macro:
\begin_inset Formula 
\[
\left[\mathrm{V}3\leftarrow g(\mathrm{V}1,\mathrm{V}2)\right]
\]

\end_inset

Para hacer mas intuitivo el uso de este macro lo escribiremos de la siguiente
 manera
\begin_inset Formula 
\[
\left[\mathrm{V}3\leftarrow E_{\#1}^{1,0}(\mathrm{V}1,\mathrm{V}2,\mathcal{P}_{0})\right]
\]

\end_inset

Ahora si podemos dar nuestro progama 
\begin_inset Formula $\mathcal{P}$
\end_inset

 que enumera a 
\begin_inset Formula $S$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{ll}
 & \mathrm{IF}\;\mathrm{N}1\neq0\;\mathrm{GOTO}\;\mathrm{L}1\\
 & \mathrm{GOTO}\;\mathrm{L}2\\
\mathrm{L}1 & [\mathrm{N}3\leftarrow(\mathrm{N}1)_{1}]\\
 & [\mathrm{N}4\leftarrow(\mathrm{N}1)_{2}]\\
 & \left[\mathrm{IF}\;Halt^{1,0}(\mathrm{N}4,\mathrm{N}3,\mathcal{P}_{0})\;\mathrm{GOTO}\;\mathrm{L}3\right]\\
 & \mathrm{GOTO}\;\mathrm{L}2\\
\mathrm{L}3 & \left[\mathrm{N}5\leftarrow E_{\#1}^{1,0}(\mathrm{N}4,\mathrm{N}3,\mathcal{P}_{0})\right]\\
 & [\mathrm{IF}\;\mathrm{N}5=0\;\mathrm{GOTO}\;\mathrm{L}2]\\
 & \mathrm{N}1\leftarrow\mathrm{N}3\\
 & \mathrm{GOTO}\;\mathrm{L}4\\
\mathrm{L}2 & \mathrm{N}1\leftarrow0\\
\mathrm{L}4 & \mathrm{SKIP}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Enumeracion de conjuntos de programas
\end_layout

\begin_layout Standard
Ya que los programas de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 son palabras del alfabeto 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

, nos podemos preguntar cuando un conjunto 
\begin_inset Formula $L$
\end_inset

 de programas es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-enumerable.
 Daremos un ejemplo.
 Sea 
\begin_inset Formula $\Sigma=\{@,!\}$
\end_inset

 y sea
\begin_inset Formula 
\[
L=\{\mathcal{P}\in\mathrm{Pro}^{\Sigma}:\Psi_{\mathcal{P}}^{1,0,\#}(10)=10\}
\]

\end_inset

Veremos que 
\begin_inset Formula $L$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-enumerable, dando un programa 
\begin_inset Formula $\mathcal{Q}\in\mathrm{Pro}^{\Sigma\cup\Sigma_{p}}$
\end_inset

 que enumere a 
\begin_inset Formula $L$
\end_inset

, es decir tal que 
\family roman
Dom
\family default

\begin_inset Formula $(\Psi_{\mathcal{Q}}^{1,0,\ast})=\omega$
\end_inset

 y 
\begin_inset Formula $\operatorname{Im}(\Psi_{\mathcal{Q}}^{1,0,\ast})=L$
\end_inset

.
 Cabe destacar que aqui hay en juego dos versiones de nuestro lenguaje imperativ
o, es decir enumeraremos un conjunto de programas de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 usando un programa de 
\begin_inset Formula $\mathcal{S}^{\Sigma\cup\Sigma_{p}}$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre el conjunto 
\begin_inset Formula $\Sigma\cup\Sigma_{p}$
\end_inset

.
\end_layout

\begin_layout Standard
A continuacion daremos una descripcion intuitiva del funcionamiento de 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 (pseudocodigo) para luego escribirlo correctamente usando macros.
 Notese que 
\begin_inset Formula $\mathrm{SKIP}\in L$
\end_inset

.
 El programa 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 comenzara del estado 
\begin_inset Formula $\left\Vert x\right\Vert $
\end_inset

 y hara las siguientes tareas
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 1: si 
\begin_inset Formula $x=0$
\end_inset

 ir a Etapa 6, en caso contrario ir a Etapa 2.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 2: calcular 
\begin_inset Formula $(x)_{1}$
\end_inset

, 
\begin_inset Formula $(x)_{2}$
\end_inset

 y 
\begin_inset Formula $\ast^{\leq}((x)_{1})$
\end_inset

 e ir a Etapa 3.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 3: si 
\begin_inset Formula $\ast^{\leq}((x)_{1})\in\mathrm{Pro}^{\Sigma}$
\end_inset

 y termina partiendo desde 
\begin_inset Formula $\left\Vert 10\right\Vert $
\end_inset

 en 
\begin_inset Formula $(x)_{2}$
\end_inset

 pasos ir a Etapa 4, en caso contrario ir a Etapa 6
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 4: si el valor que queda en 
\begin_inset Formula $\mathrm{N}1$
\end_inset

 luego de correr 
\begin_inset Formula $\ast^{\leq}((x)_{1})$
\end_inset

 una cantidad 
\begin_inset Formula $(x)_{2}$
\end_inset

 de pasos, partiendo de 
\begin_inset Formula $\left\Vert 10\right\Vert $
\end_inset

 es igual a 10, entonces ir a Etapa 5.
 En caso contrario ir a Etapa 6.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 5: asignar a 
\begin_inset Formula $\mathrm{P}1$
\end_inset

 la palabra 
\begin_inset Formula $\ast^{\leq}((x)_{1})$
\end_inset

 y terminar
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Etapa 6: asignar a 
\begin_inset Formula $\mathrm{P}1$
\end_inset

 la palabra 
\begin_inset Formula $\mathrm{SKIP}$
\end_inset

 y terminar 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que la descripcion anterior no es ni mas ni menos que un procedimiento
 efectivo que enumera a 
\begin_inset Formula $L$
\end_inset

, y nuestra mision es simularlo dentro del lenguaje 
\begin_inset Formula $\mathcal{S}^{\Sigma\cup\Sigma_{p}}$
\end_inset

.
 Para esto usaremos varios macros.
 Es importante notar que los macros que usaremos corresponden al lenguaje
 
\begin_inset Formula $\mathcal{S}^{\Sigma\cup\Sigma_{p}}$
\end_inset

 ya que los usaremos en 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 el cual sera un programa de 
\begin_inset Formula $\mathcal{S}^{\Sigma\cup\Sigma_{p}}$
\end_inset

.
\end_layout

\begin_layout Standard
Ya que las funciones 
\begin_inset Formula $\lambda x[(x)_{1}]$
\end_inset

 y 
\begin_inset Formula $\lambda x[(x)_{2}]$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursivas el Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "recursivo implica macro"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que hay macros asociados a estas funciones los cuales escribiremos
 de la siguiente manera mas intuitiva:
\begin_inset Formula 
\begin{align*}
[\mathrm{V}2 & \leftarrow(\mathrm{V}1)_{1}]\\{}
[\mathrm{V}2 & \leftarrow(\mathrm{V}1)_{2}]
\end{align*}

\end_inset

Ya que el predicado 
\begin_inset Formula $P=\lambda x[x=10]$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursivo tenemos su macro asociado el cual escribiremos de la siguiente
 manera:
\begin_inset Formula 
\[
\left[\mathrm{IF}\;\mathrm{V}1=10\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Por un lema anterior sabemos que 
\begin_inset Formula $\mathrm{Pro}^{\Sigma}$
\end_inset

 es un conjunto 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., por lo cual 
\begin_inset Formula $\chi_{\mathrm{Pro}^{\Sigma}}^{(\Sigma\cup\Sigma_{p})^{\ast}}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r., por lo cual hay un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;\chi_{\mathrm{Pro}^{\Sigma}}^{(\Sigma\cup\Sigma_{p})^{\ast}}(\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

el cual escribiremos de la siguiente manera
\begin_inset Formula 
\[
\left[\mathrm{IF}\;\mathrm{W}1\in\mathrm{Pro}^{\Sigma}\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Ya que el predicado 
\begin_inset Formula $Halt^{1,0}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursivo tenemos un macro asociado a el, el cual escribiremos de la siguiente
 forma
\begin_inset Formula 
\[
\left[\mathrm{IF}\;Halt^{1,0}(\mathrm{V}1,\mathrm{V}2,\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Ya que 
\begin_inset Formula $E_{\#1}^{1,0}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-recursivo tenemos un macro asociado a ella, el cual escribiremos de la
 siguiente forma
\begin_inset Formula 
\[
\left[\mathrm{V}3\leftarrow E_{\#1}^{1,0}(\mathrm{V}1,\mathrm{V}2,\mathrm{W}1)\right]
\]

\end_inset

Tambien usaremos macros
\begin_inset Formula 
\begin{gather*}
[\mathrm{V}1\leftarrow10]\\
\left[\mathrm{W}1\leftarrow\mathrm{SKIP}\right]
\end{gather*}

\end_inset

(dejamos al lector hacerlos a mano o tambien se puede justificar su existencia
 via la proposicion de existencia de macros aplicada a las funciones 
\begin_inset Formula $C_{10}^{0,0}$
\end_inset

 y 
\begin_inset Formula $C_{\mathrm{SKIP}}^{0,0}$
\end_inset

).
\end_layout

\begin_layout Standard
Ahora si podemos hacer el programa 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 que enumera a 
\begin_inset Formula $L$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{ll}
 & \mathrm{IF}\;\mathrm{N}1\neq0\;\mathrm{GOTO}\;\mathrm{L}1\\
 & \mathrm{GOTO}\;\mathrm{L}2\\
\mathrm{L}1 & [\mathrm{N}2\leftarrow(\mathrm{N}1)_{1}]\\
 & [\mathrm{N}3\leftarrow(\mathrm{N}1)_{2}]\\
 & [\mathrm{P}1\leftarrow\ast^{\leq}(\mathrm{N}2)]\\
 & \left[\mathrm{IF}\;\mathrm{P}1\in\mathrm{Pro}^{\Sigma}\;\mathrm{GOTO}\;\mathrm{L}3\right]\\
 & \mathrm{GOTO}\;\mathrm{L}2\\
\mathrm{L}3 & [\mathrm{N}4\leftarrow10]\\
 & \left[\mathrm{IF}\;Halt^{1,0}(\mathrm{N}3,\mathrm{N}4,\mathrm{P}1)\;\mathrm{GOTO}\;\mathrm{L}4\right]\\
 & \mathrm{GOTO}\;\mathrm{L}2\\
\mathrm{L}4 & \left[\mathrm{N}5\leftarrow E_{\#1}^{1,0}(\mathrm{N}3,\mathrm{N}4,\mathrm{P}1)\right]\\
 & [\mathrm{IF}\;\mathrm{N}5=10\;\mathrm{GOTO}\;\mathrm{L}4]\\
\mathrm{L}2 & \left[\mathrm{P}1\leftarrow\mathrm{SKIP}\right]\\
\mathrm{L}4 & \mathrm{SKIP}
\end{array}
\]

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Cuando 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}$
\end_inset

 podemos correr un programa 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 partiendo de un estado que asigne a sus variables alfabeticas programas
 (ya que los programas son meras palabras de 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

).
 En particular podriamos correr un programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 desde el estado 
\begin_inset Formula $\left\Vert \mathcal{P}\right\Vert $
\end_inset

.
 Llamaremos 
\begin_inset Formula $A$
\end_inset

 al conjunto formado por aquellos programas 
\begin_inset Formula $\mathcal{P}$
\end_inset

 tales que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo del estado 
\begin_inset Formula $\left\Vert \mathcal{P}\right\Vert $
\end_inset

.
 Es decir
\begin_inset Formula 
\[
A=\{\mathcal{P}\in\mathrm{Pro}^{\Sigma}:\exists t\in\omega\text{ tal que }Halt^{0,1}(t,\mathcal{P},\mathcal{P})=1\}
\]

\end_inset

Por ejemplo 
\begin_inset Formula $\mathrm{SKIP}\in A$
\end_inset

.
 Dicho rapida y sugestivamente 
\begin_inset Formula $A$
\end_inset

 es el conjunto formado por aquellos programas que se detienen partiendo
 de si mismos.
 Dejamos al lector hacer un programa que enumere a 
\begin_inset Formula $A$
\end_inset

.
 Como veremos mas adelante este conjunto, si bien es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable, no es 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Godel vence a Turing
\end_layout

\begin_layout Standard
Para probar que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva debemos estudiar la recursividad del funcionamiento de las maquinas
 de Turing.
 Cabe destacar que tal como se lo explico en la Subseccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "BasicosMaquinasDeTuring"
plural "false"
caps "false"
noprefix "false"

\end_inset

 supondremos siempre que el conjunto de estados de una maquina de Turing
 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,F\right)$
\end_inset

 es un alfabeto disjunto con 
\begin_inset Formula $\Gamma$
\end_inset

.
\end_layout

\begin_layout Standard
Primero probaremos algunos lemas basicos.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,F\right)$
\end_inset

 una maquina de Turing.
 Entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $Des$
\end_inset

 es un conjunto 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $St:Des\rightarrow Q$
\end_inset

 es una funcion 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que la funcion 
\begin_inset Formula $\delta$
\end_inset

 de una maquina de Turing 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,F\right)$
\end_inset

 no es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-mixta.
 Sin envargo los siguientes predicados 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-mixtos contienen toda la informacion de 
\begin_inset Formula $\delta$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{rcl}
P_{L}:Q\times\Gamma\times Q\times\Gamma & \rightarrow & \omega\\
(p,\sigma,q,\gamma) & \rightarrow & \left\{ \begin{array}{ccl}
1 &  & \text{si }\delta(q,\gamma)=(p,\sigma,L)\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{rcl}
P_{L}:Q\times\Gamma\times Q\times\Gamma & \rightarrow & \omega\\
(p,\sigma,q,\gamma) & \rightarrow & \left\{ \begin{array}{ccl}
1 &  & \text{si }(p,\sigma,L)\in\delta(q,\gamma)\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{rcl}
P_{R}:Q\times\Gamma\times Q\times\Gamma & \rightarrow & \omega\\
(p,\sigma,q,\gamma) & \rightarrow & \left\{ \begin{array}{ccl}
1 &  & \text{si }\delta(q,\gamma)=(p,\sigma,R)\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{rcl}
P_{K}:Q\times\Gamma\times Q\times\Gamma & \rightarrow & \omega\\
(p,\sigma,q,\gamma) & \rightarrow & \left\{ \begin{array}{ccl}
1 &  & \text{si }\delta(q,\gamma)=(p,\sigma,K)\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,F\right)$
\end_inset

 una maquina de Turing.
 Entonces los predicados 
\begin_inset Formula $P_{L},P_{R}$
\end_inset

 y 
\begin_inset Formula $P_{K}$
\end_inset

 son 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que los tres predicados tienen dominio finito, el Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "dom-finito"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que son 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que dado 
\begin_inset Formula $\alpha\in(Q\cup\Gamma)^{\ast}$
\end_inset

, definimos 
\begin_inset Formula $\left\lfloor \alpha\right\rfloor $
\end_inset

 de la siguiente manera
\begin_inset Formula 
\begin{align*}
\left\lfloor \varepsilon\right\rfloor  & =\varepsilon\\
\left\lfloor \alpha\sigma\right\rfloor  & =\alpha\sigma\text{, si }\sigma\neq B\\
\left\lfloor \alpha B\right\rfloor  & =\left\lfloor \alpha\right\rfloor 
\end{align*}

\end_inset

Es decir 
\begin_inset Formula $\left\lfloor \alpha\right\rfloor $
\end_inset

 es el resultado de remover de 
\begin_inset Formula $\alpha$
\end_inset

 el tramo final mas grande de la forma 
\begin_inset Formula $B^{n}$
\end_inset

.
\end_layout

\begin_layout Standard
Tambien dada cualquier palabra 
\begin_inset Formula $\alpha$
\end_inset

 definimos
\begin_inset Formula 
\begin{align*}
^{\curvearrowright}\alpha & =\left\{ \begin{array}{lll}
\left[\alpha\right]_{2}...\left[\alpha\right]_{\left\vert \alpha\right\vert } & \text{si} & \left\vert \alpha\right\vert \geq2\\
\varepsilon & \text{si} & \left\vert \alpha\right\vert \leq1
\end{array}\right.\\
\alpha^{\curvearrowleft} & =\left\{ \begin{array}{lll}
\left[\alpha\right]_{1}...\left[\alpha\right]_{\left\vert \alpha\right\vert -1} & \text{si} & \left\vert \alpha\right\vert \geq2\\
\varepsilon & \text{si} & \left\vert \alpha\right\vert \leq1
\end{array}\right.
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Las funciones 
\begin_inset Formula $\lambda\alpha[\left\lfloor \alpha\right\rfloor ]$
\end_inset

, 
\begin_inset Formula $\lambda\alpha[^{\curvearrowright}\alpha]$
\end_inset

 y 
\begin_inset Formula $\lambda\alpha[\alpha^{\curvearrowleft}]$
\end_inset

 son 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r..
 (Notar que la notacion 
\begin_inset Formula $\lambda$
\end_inset

 aqui es respecto del alfabeto 
\begin_inset Formula $\Gamma\cup Q$
\end_inset

 por lo cual las tres funciones tienen dominio igual a 
\begin_inset Formula $(\Gamma\cup Q)^{\ast}$
\end_inset

.) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que dada una maquina de Turing 
\begin_inset Formula $M$
\end_inset

, la expresion 
\begin_inset Formula $d\underset{M}{\vdash}d^{\prime}$
\end_inset

 fue definida solo en el caso en que 
\begin_inset Formula $d$
\end_inset

 y 
\begin_inset Formula $d^{\prime}$
\end_inset

 son descripciones instantaneas.
 Es decir que el predicado 
\begin_inset Formula $\lambda dd^{\prime}\left[d\vdash d^{\prime}\right]$
\end_inset

 tiene dominio igual a 
\begin_inset Formula $Des\times Des$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 El predicado 
\begin_inset Formula $\lambda dd^{\prime}\left[d\underset{M}{\vdash}d^{\prime}\right]$
\end_inset

 es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $\tilde{P}_{L}:Des\times Des\times\Gamma\times\Gamma^{\ast}\times\Gamma^{\ast}\times Q\times Q\rightarrow\omega$
\end_inset

 definido por 
\begin_inset Formula $\tilde{P}_{L}(d,d^{\prime},\sigma,\alpha,\beta,p,q)=1$
\end_inset

 sii
\begin_inset Formula 
\[
d=\alpha p\beta\wedge(q,\sigma,L)=\delta\left(p,\left[\beta B\right]_{1}\right)\wedge\alpha\neq\varepsilon\wedge d^{\prime}=\left\lfloor \alpha^{\curvearrowleft}q\left[\alpha\right]_{\left\vert \alpha\right\vert }\sigma^{\curvearrowright}\beta\right\rfloor 
\]

\end_inset

Sea 
\begin_inset Formula $\tilde{P}_{R}:Des\times Des\times\Gamma\times\Gamma^{\ast}\times\Gamma^{\ast}\times Q\times Q\rightarrow\omega$
\end_inset

 definido por 
\begin_inset Formula $\tilde{P}_{R}(d,d^{\prime},\sigma,\alpha,\beta,p,q)=1$
\end_inset

 sii
\begin_inset Formula 
\[
d=\alpha p\beta\wedge(q,\sigma,R)=\delta\left(p,\left[\beta B\right]_{1}\right)\wedge d^{\prime}=\alpha\sigma q^{\curvearrowright}\beta
\]

\end_inset

Sea 
\begin_inset Formula $\tilde{P}_{K}:Des\times Des\times\Gamma\times\Gamma^{\ast}\times\Gamma^{\ast}\times Q\times Q\rightarrow\omega$
\end_inset

 definido por 
\begin_inset Formula $\tilde{P}_{K}(d,d^{\prime},\sigma,\alpha,\beta,p,q)=1$
\end_inset

 sii
\begin_inset Formula 
\[
d=\alpha p\beta\wedge(q,\sigma,K)=\delta\left(p,\left[\beta B\right]_{1}\right)\wedge d^{\prime}=\left\lfloor \alpha q\sigma^{\curvearrowright}\beta\right\rfloor 
\]

\end_inset

Se deja al lector la verificacion de que estos predicados son 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r..
 Notese que 
\begin_inset Formula $\lambda dd^{\prime}\left[d\underset{M}{\vdash}d^{\prime}\right]$
\end_inset

 es igual al predicado
\begin_inset Formula 
\[
\lambda dd^{\prime}\left[(\exists\sigma\in\Gamma)(\exists\alpha,\beta\in\Gamma^{\ast})(\exists p,q\in Q)(\tilde{P}_{R}\vee\tilde{P}_{L}\vee\tilde{P}_{K})(d,d^{\prime},\sigma,\alpha,\beta,p,q)\right]
\]

\end_inset

lo cual por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cuantificacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $\lambda dd^{\prime}\left[d\underset{M}{\vdash}d^{\prime}\right]$
\end_inset

 es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset Formula $\lambda ndd^{\prime}\left[d\underset{M}{\overset{n}{\vdash}}d^{\prime}\right]$
\end_inset

 es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $Q=\lambda dd^{\prime}\left[d\underset{M}{\vdash}d^{\prime}\right]\cup C_{0}^{0,2}|_{(\Gamma\cup Q)^{\ast2}-Des^{2}}$
\end_inset

 es decir 
\begin_inset Formula $Q$
\end_inset

 es el resultado de extender con el valor 
\begin_inset Formula $0$
\end_inset

 al predicado 
\begin_inset Formula $\lambda dd^{\prime}\left[d\underset{M}{\vdash}d^{\prime}\right]$
\end_inset

 de manera que este definido en todo 
\begin_inset Formula $(\Gamma\cup Q)^{\ast2}$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Gamma\cup Q$
\end_inset

 y sea 
\begin_inset Formula $Q_{1}:\mathbf{N}\times Des\times Des\rightarrow\omega$
\end_inset

 definido por 
\begin_inset Formula $Q_{1}(x,d,d^{\prime})=1$
\end_inset

 sii
\end_layout

\begin_layout Standard
\begin_inset Formula $\left((\forall i\in\mathbf{N})_{i\leq Lt(x)}\ast^{\leq}((x)_{i})\in Des\right)\wedge\ast^{\leq}((x)_{1})=d\wedge$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ast^{\leq}((x)_{Lt(x)})=d^{\prime}\wedge\left((\forall i\in\mathbf{N})_{i\leq Lt(x)\dot{-}1}\;Q(\ast^{\leq}((x)_{i}),\ast^{\leq}((x)_{i+1}))\right)$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Notese que dicho rapidamente 
\begin_inset Formula $Q_{1}(x,d,d^{\prime})=1$
\end_inset

 sii 
\begin_inset Formula $x$
\end_inset

 codifica una computacion que parte de 
\begin_inset Formula $d$
\end_inset

 y llega a 
\begin_inset Formula $d^{\prime}$
\end_inset

.
 Se deja al lector la verificacion de que este predicado es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r..
 Notese que
\begin_inset Formula 
\[
\lambda ndd^{\prime}\left[d\underset{M}{\overset{n}{\vdash}}d^{\prime}\right]=\lambda ndd^{\prime}\left[\left(\exists x\in\mathbf{N}\right)\;Lt(x)=n+1\wedge Q_{1}(x,d,d^{\prime})\right]
\]

\end_inset

Es decir que solo nos falta acotar el cuantificador existencial, para poder
 aplicar el lema de cuantificacion acotada.
 Ya que cuando 
\begin_inset Formula $d_{1},...,d_{n+1}\in Des$
\end_inset

 son tales que 
\begin_inset Formula $d_{1}\underset{M}{\vdash}d_{2}\underset{M}{\vdash}\cdots\underset{M}{\vdash}d_{n+1}$
\end_inset

 tenemos que
\begin_inset Formula 
\[
\left\vert d_{i}\right\vert \leq\left\vert d_{1}\right\vert +n\text{, para }i=1,...,n
\]

\end_inset

una posible cota para dicho cuantificador es
\begin_inset Formula 
\[
\prod_{i=1}^{n+1}pr(i)^{\left\vert \Gamma\cup Q\right\vert ^{\left\vert d\right\vert +n}}\text{.}
\]

\end_inset

O sea que, por el lema de cuantificacion acotada, tenemos que el predicado
 
\begin_inset Formula $\lambda ndd^{\prime}\left[d\underset{M}{\overset{n}{\vdash}}d^{\prime}\right]$
\end_inset

 es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
@@finpagina@@
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "TuringComputableImplicaRecursiva"

\end_inset

Supongamos 
\begin_inset Formula $f:S\subseteq\omega^{n}\times\Sigma^{\ast}{}^{m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable.
 Entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

 y sea 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,\shortmid,F\right)$
\end_inset

 una maquina de Turing deterministica con unit la cual compute a 
\begin_inset Formula $f$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Notese que por el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia"
plural "false"
caps "false"
noprefix "false"

\end_inset

, la funcion 
\begin_inset Formula $\ast^{\leq}$
\end_inset

 es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $P:\mathbf{N}\times\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 dado por 
\begin_inset Formula $P(x,\vec{x},\vec{\alpha})=1$
\end_inset

 sii
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\exists q\in Q)\;\left\lfloor q_{0}B\shortmid^{x_{1}}...B\shortmid^{x_{n}}B\alpha_{1}...B\alpha_{m}\right\rfloor \underset{M}{\overset{(x)_{1}}{\vdash}}\left\lfloor qB\ast^{\leq}((x)_{2})\right\rfloor \wedge$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \wedge(\forall d\in Des)_{\left\vert d\right\vert \leq\left\vert \ast^{\leq}((x)_{2})\right\vert +2}\;\lnot\left(\left\lfloor qB\ast^{\leq}((x)_{2})\right\rfloor \underset{M}{\vdash}d\right)$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Dejamos al lector la prueba de que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r..
 Ya que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixto, el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Notese que
\begin_inset Formula 
\[
f=\lambda\vec{x}\vec{\alpha}\left[\ast^{\leq}\left(\left(\min_{x}P(x,\vec{x},\vec{\alpha})\right)_{2}\right)\right]\text{,}
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Turing vence a Neumann
\end_layout

\begin_layout Standard
Probaremos que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable.
 Para esto probaremos un resultado general que nos enseara a simular el
 comportamiento de un programa con una maquina de Turing.
 Es importante notar que la simulacion que nos interesa que haga la maquina
 simuladora no es a nivel de la funcion que computa el programa sino a un
 nivel mas general, es decir nos interesa que simule a dicho programa como
 transformador de estados.
 En particular y usada adecuadamente, la maquina simuladora nos servira
 para confeccionar una maquina que compute una funcion computada por un
 programa dado.
\end_layout

\begin_layout Subsubsection
Construccion de la maquina simuladora de un programa
\end_layout

\begin_layout Standard
Dado 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

, definamos
\begin_inset Formula 
\begin{align*}
N(\mathcal{P}) & =\mathrm{menor}\ k\in\mathbf{N}\ \mathrm{tal\ que\ las\ variables\ que\ ocurren\ en\ }\mathcal{P}\\
 & \mathrm{esta}\text{n}\mathrm{\ todas\ en\ la\ lista\ N}1,...,\mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k}
\end{align*}

\end_inset

Por ejemplo si 
\begin_inset Formula $\mathcal{P}$
\end_inset

 es el siguiente programa (aqui 
\begin_inset Formula $\Sigma=\{\blacktriangle,\#\}$
\end_inset

)
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}1 & \mathrm{N}4\leftarrow\mathrm{N}4+1\\
 & \mathrm{P}1\leftarrow\mathrm{P}1.\blacktriangle\\
 & \mathrm{IF\ N}1\neq0\ \mathrm{GOTO}\;\mathrm{L}1
\end{array}
\]

\end_inset

entonces tenemos 
\begin_inset Formula $N(\mathcal{P})=4$
\end_inset


\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 un programa y sea 
\begin_inset Formula $k$
\end_inset

 fijo y mayor o igual a 
\begin_inset Formula $N(\mathcal{P})$
\end_inset

.
 La construccion de la maquina simuladora dependera de 
\begin_inset Formula $\mathcal{P}$
\end_inset

 y de 
\begin_inset Formula $k$
\end_inset

.
 Notese que cuando 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se corre desde algun estado de la forma
\begin_inset Formula 
\[
\left\Vert x_{1},...,x_{k},\alpha_{1},...,\alpha_{k}\right\Vert 
\]

\end_inset

los sucesivos estados por los que va pasando son todos de la forma
\begin_inset Formula 
\[
\left\Vert y_{1},...,y_{k},\beta_{1},...,\beta_{k}\right\Vert 
\]

\end_inset

es decir en todos ellos las variables con indice mayor que 
\begin_inset Formula $k$
\end_inset

 valen 
\begin_inset Formula $0$
\end_inset

 o 
\begin_inset Formula $\varepsilon$
\end_inset

.
 La razon es simple: ya que en 
\begin_inset Formula $\mathcal{P}$
\end_inset

 no figuran las variables
\begin_inset Formula 
\begin{align*}
 & \mathrm{N}\overline{k+1},\mathrm{N}\overline{k+2},...\\
 & \mathrm{P}\overline{k+1},\mathrm{P}\overline{k+2},...
\end{align*}

\end_inset

estas variables quedan con valores 
\begin_inset Formula $0$
\end_inset

 y 
\begin_inset Formula $\varepsilon$
\end_inset

, respectivamente a lo largo de toda la computacion.
\end_layout

\begin_layout Standard
La maquina simuladora que construiremos simulara a 
\begin_inset Formula $\mathcal{P}$
\end_inset

 en cuanto a su funcionamiento cuando partimos de estados de la forma 
\begin_inset Formula $\left\Vert x_{1},...,x_{k},\alpha_{1},...,\alpha_{k}\right\Vert $
\end_inset

.
 Necesitaremos tener alguna manera de representar en la cinta los diferentes
 estados por los cuales se va pasando, a medida que corremos a 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Esto lo haremos de la siguiente forma: al estado
\begin_inset Formula 
\[
\left\Vert x_{1},...,x_{k},\alpha_{1},...,\alpha_{k}\right\Vert 
\]

\end_inset

lo representaremos en la cinta de la siguiente manera
\begin_inset Formula 
\[
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}BBBB....
\]

\end_inset

Por ejemplo consideremos el programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 mostrado recien y fijemos 
\begin_inset Formula $k=6$
\end_inset

.
 Entonces al estado
\begin_inset Formula 
\[
\left\Vert 3,2,5,0,4,2,\blacktriangle,\blacktriangle\blacktriangle,\varepsilon,\#\blacktriangle,\#,\#\#\#\right\Vert 
\]

\end_inset

lo representaremos en la cinta de la siguiente manera
\begin_inset Formula 
\[
B\mathrm{\shortmid\shortmid\shortmid}B\mathrm{\shortmid\shortmid}B\mathrm{\shortmid\shortmid\shortmid\shortmid\shortmid}BB\mathrm{\shortmid\shortmid\shortmid\shortmid}B\mathrm{\shortmid\shortmid}B\blacktriangle B\blacktriangle\blacktriangle BB\#\blacktriangle B\#B\#\#\#BBBBB....
\]

\end_inset

A lo que queda entre dos blancos consecutivos (es decir que no hay ningun
 blanco entre ellos) lo llamaremos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

bloque
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, por ejemplo en la cinta de arriba tenemos que los primeros 12 bloques
 son
\begin_inset Formula 
\[
\shortmid\shortmid\shortmid\ \ \ \shortmid\shortmid\ \ \ \shortmid\shortmid\shortmid\shortmid\shortmid\ \ \ \ \varepsilon\ \ \ \ \shortmid\shortmid\shortmid\shortmid\ \ \ \shortmid\shortmid\ \ \ \blacktriangle\ \ \ \ \ \blacktriangle\blacktriangle\ \ \ \ \ \varepsilon\ \ \ \ \ \#\blacktriangle\ \ \ \ \ \#\ \ \ \ \ \#\#\#
\]

\end_inset

y despues los bloques siguientes (que son infinitos ya que la cinta es infinita
 hacia la derecha) son todos iguales a 
\begin_inset Formula $\varepsilon$
\end_inset

.
\end_layout

\begin_layout Standard
Una observacion importante es que esta forma de representacion de estados
 en la cinta depende del 
\begin_inset Formula $k$
\end_inset

 elejido, es decir si tomaramos otro 
\begin_inset Formula $k$
\end_inset

, por ejemplo 
\begin_inset Formula $k=9$
\end_inset

, entonces el estado anterior se representaria de otra forma en la cinta.
 Aqui se ve claramente que la maquina simuladora que construiremos dependera
 del 
\begin_inset Formula $k$
\end_inset

 elejido.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Construccion de las maquinas simuladoras de instrucciones
\end_layout

\begin_layout Standard
Armaremos la maquina simuladora como concatenacion de maquinas las cuales
 simularan, via la representacion anterior, el funcionamiento de las distintas
 instrucciones de 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Asumiremos que en 
\begin_inset Formula $\mathcal{P}$
\end_inset

 no hay instrucciones de la forma 
\begin_inset Formula $\mathrm{GOTO}\;\mathrm{L}\bar{m}$
\end_inset

 ni de la forma 
\begin_inset Formula $\mathrm{L}\bar{n}\ \mathrm{GOTO}\;\mathrm{L}\bar{m}$
\end_inset

.
 Esto simplificara un poco la construccion de la maquina simuladora y de
 hecho lo podemos hacer ya que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable puede ser computada por un programa sin este tipo de instrucciones,
 tal como lo veremos mas adelante (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "simulacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Para poder hacer concretamente las maquinas simuladoras de instrucciones
 deberemos disear antes algunas maquinas auxiliares.
 Todas las maquinas descriptas a continuacion tendran a 
\begin_inset Formula $\shortmid$
\end_inset

 como unit y a 
\begin_inset Formula $B$
\end_inset

 como blanco, tendran a 
\begin_inset Formula $\Sigma$
\end_inset

 como su alfabeto terminal y su alfabeto mayor sera 
\begin_inset Formula $\Gamma=\Sigma\cup\{B,\shortmid\}\cup\{\tilde{a}:a\in\Sigma\cup\{\shortmid\}\}$
\end_inset

.
 Ademas tendran uno o dos estados finales con la propiedad de que si 
\begin_inset Formula $q$
\end_inset

 es un estado final, entonces 
\begin_inset Formula $(q,\sigma)\notin D_{\delta}$
\end_inset

, para cada 
\begin_inset Formula $\sigma\in\Gamma$
\end_inset

.
\end_layout

\begin_layout Standard
Para cada 
\begin_inset Formula $j\geq1$
\end_inset

, sea 
\begin_inset Formula $D_{j}$
\end_inset

 la siguiente maquina:
\end_layout

\begin_layout Standard
@@figura:figure1.png@@
\end_layout

\begin_layout Standard
\noindent
Notese que
\begin_inset Formula 
\[
\begin{array}{lcr}
\alpha B\beta_{1}B\beta_{2}B...B\beta_{j}B\gamma & \overset{\ast}{\vdash} & \alpha B\beta_{1}B\beta_{2}B...B\beta_{j}B\gamma\\
\ \ \uparrow &  & \uparrow\ \ \\
\ \ q_{0} &  & q_{f}\ \ 
\end{array}
\]

\end_inset

siempre que 
\begin_inset Formula $\alpha,\gamma\in\Gamma^{\ast}$
\end_inset

, 
\begin_inset Formula $\beta_{1},...,\beta_{j}\in(\Gamma-\{B\})^{\ast}$
\end_inset

.
 Es decir la maquina 
\begin_inset Formula $D_{j}$
\end_inset

 lo unico que hace es mover el cabezal desde el blanco de la izquierda de
 un bloque determinado, exactamente 
\begin_inset Formula $j$
\end_inset

 bloques a la derecha
\end_layout

\begin_layout Standard
Analogamente 
\begin_inset Formula $I_{j}$
\end_inset

 sera una maquina que desplaza el cabezal 
\begin_inset Formula $j$
\end_inset

 bloques a la izquierda del blanco que esta escaneando.
 Es decir 
\begin_inset Formula $I_{j}$
\end_inset

 cumplira que
\begin_inset Formula 
\[
\begin{array}{lcr}
\alpha B\beta_{j}B...B\beta_{2}B\beta_{1}B\gamma & \overset{\ast}{\vdash} & \alpha B\beta_{j}B...B\beta_{2}B\beta_{1}B\gamma\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \uparrow &  & \uparrow\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q_{0} &  & q_{f}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
\end{array}
\]

\end_inset

siempre que 
\begin_inset Formula $\alpha,\gamma\in\Gamma^{\ast}$
\end_inset

, 
\begin_inset Formula $\beta_{1},...,\beta_{j}\in(\Gamma-\{B\})^{\ast}$
\end_inset

.
 Dejamos al lector la manufactura de esta maquina.
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $j\geq1$
\end_inset

, sea 
\begin_inset Formula $TD_{j}$
\end_inset

 una maquina con un solo estado final 
\begin_inset Formula $q_{f}$
\end_inset

 y tal que
\begin_inset Formula 
\[
\begin{array}{ccc}
\alpha B\gamma & \overset{\ast}{\vdash} & \alpha BB\gamma\\
\uparrow &  & \uparrow\ \ \\
q_{0} &  & q_{f}\ \ 
\end{array}
\]

\end_inset

cada vez que 
\begin_inset Formula $\alpha,\gamma\in\Gamma^{\ast}$
\end_inset

 y 
\begin_inset Formula $\gamma$
\end_inset

 tiene exactamente 
\begin_inset Formula $j$
\end_inset

 ocurrencias de 
\begin_inset Formula $B$
\end_inset

.
 Es decir la maquina 
\begin_inset Formula $TD_{j}$
\end_inset

 corre un espacio a la derecha todo el segmento 
\begin_inset Formula $\gamma$
\end_inset

 y agrega un blanco en el espacio que se genera a la izquierda.
 Por ejemplo, para el caso de 
\begin_inset Formula $\Sigma=\{a\}$
\end_inset

 podemos tomar 
\begin_inset Formula $TD_{3}$
\end_inset

 igual a la siguiente maquina:
\end_layout

\begin_layout Standard
@@figura:figure2.png@@
\end_layout

\begin_layout Standard
Analogamente, para 
\begin_inset Formula $j\geq1$
\end_inset

, sea 
\begin_inset Formula $TI_{j}$
\end_inset

 una maquina tal que
\begin_inset Formula 
\[
\begin{array}{ccc}
\alpha B\sigma\gamma & \overset{\ast}{\vdash} & \alpha B\gamma\\
\uparrow\  &  & \uparrow\\
q_{0}\ \  &  & q_{f}
\end{array}
\]

\end_inset

cada vez que 
\begin_inset Formula $\alpha\in\Gamma^{\ast}$
\end_inset

, 
\begin_inset Formula $\sigma\in\Gamma$
\end_inset

 y 
\begin_inset Formula $\gamma$
\end_inset

 tiene exactamente 
\begin_inset Formula $j$
\end_inset

 ocurrencias de 
\begin_inset Formula $B$
\end_inset

.
 Es decir la maquina 
\begin_inset Formula $TI_{j}$
\end_inset

 corre un espacio a la izquierda todo el segmaneto 
\begin_inset Formula $\gamma$
\end_inset

 (por lo cual en el lugar de 
\begin_inset Formula $\sigma$
\end_inset

 queda el primer simbolo de 
\begin_inset Formula $\gamma$
\end_inset

).
 Dejamos al lector la construccion de por ejemplo 
\begin_inset Formula $TI_{3}$
\end_inset

 para 
\begin_inset Formula $\Sigma=\{a\}$
\end_inset

.
\end_layout

\begin_layout Standard
A continuacion describiremos las distintas maquinas simuladoras de instrucciones
 (y para algunos casos mostraremos concretamente como pueden ser hechas
 usando las maquinas anteriores).
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i\leq k$
\end_inset

, sea 
\begin_inset Formula $M_{i,k}^{+}$
\end_inset

 una maquina tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{i-1}}B\shortmid^{x_{i}+1}B\shortmid^{x_{i+1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{f}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $q_{0}$
\end_inset

 es el estado inicial y 
\begin_inset Formula $q_{f}$
\end_inset

 es el unico estado final de 
\begin_inset Formula $M_{i,k}^{+}$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{i,k}^{+}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{N}\bar{\imath}\leftarrow\mathrm{N}\bar{\imath}+1$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i\leq k$
\end_inset

, sea 
\begin_inset Formula $M_{i,k}^{\dot{-}}$
\end_inset

 una maquina tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{i-1}}B\shortmid^{x_{i}\dot{-}1}B\shortmid^{x_{i+1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{f}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $q_{0}$
\end_inset

 es el estado inicial y 
\begin_inset Formula $q_{f}$
\end_inset

 es el unico estado final de 
\begin_inset Formula $M_{i,k}^{\dot{-}}$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{i,k}^{\dot{-}}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{P}\bar{\imath}\leftarrow\mathrm{P}\bar{\imath}\dot{-}1$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i\leq k$
\end_inset

 y 
\begin_inset Formula $a\in\Sigma$
\end_inset

, sea 
\begin_inset Formula $M_{i,k}^{a}$
\end_inset

 una maquina tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{i-1}B\alpha_{i}aB\alpha_{i+1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{f}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $q_{0}$
\end_inset

 es el estado inicial y 
\begin_inset Formula $q_{f}$
\end_inset

 es el unico estado final de 
\begin_inset Formula $M_{i,k}^{a}$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{i,k}^{a}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{P}\bar{\imath}\leftarrow\mathrm{P}\bar{\imath}.a$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

.
 La maquina 
\begin_inset Formula $M_{i,k}^{a}$
\end_inset

.puede hacerse de la siguiente manera:
\end_layout

\begin_layout Standard
@@figura:figure3.png@@
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i\leq k$
\end_inset

, sea 
\begin_inset Formula $M_{i,k}^{\curvearrowright}$
\end_inset

 una maquina tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{i-1}B^{\curvearrowright}\alpha_{i}B\alpha_{i+1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{f}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $q_{0}$
\end_inset

 es el estado inicial y 
\begin_inset Formula $q_{f}$
\end_inset

 es el unico estado final de 
\begin_inset Formula $M_{i,k}^{\curvearrowright}$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{i,k}^{\curvearrowright}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{P}\bar{\imath}\leftarrow\ ^{\curvearrowright}\mathrm{P}\bar{\imath}$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i,j\leq k$
\end_inset

, sea 
\begin_inset Formula $M_{i\leftarrow j}^{\#,k}$
\end_inset

 una maquina tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{i-1}}B\shortmid^{x_{j}}B\shortmid^{x_{i+1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{f}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $q_{0}$
\end_inset

 es el estado inicial y 
\begin_inset Formula $q_{f}$
\end_inset

 es el unico estado final de 
\begin_inset Formula $M_{i\leftarrow j}^{\#,k}$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{i\leftarrow j}^{\#,k}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{N}\bar{\imath}\leftarrow\mathrm{N}\bar{j}$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i,j\leq k$
\end_inset

, sea 
\begin_inset Formula $M_{i\leftarrow j}^{\ast,k}$
\end_inset

 una maquina tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{i-1}B\alpha_{j}B\alpha_{i+1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{f}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $q_{0}$
\end_inset

 es el estado inicial y 
\begin_inset Formula $q_{f}$
\end_inset

 es el unico estado final de 
\begin_inset Formula $M_{i\leftarrow j}^{\ast,k}$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{i\leftarrow j}^{\ast,k}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{P}\bar{\imath}\leftarrow\mathrm{P}\bar{j}$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

.
 La maquina 
\begin_inset Formula $M_{i\leftarrow j}^{\ast,k}$
\end_inset

, para el caso 
\begin_inset Formula $\Sigma=\{a,b\}$
\end_inset

 y 
\begin_inset Formula $i<j$
\end_inset

 puede hacerse de la siguiente manera:
\end_layout

\begin_layout Standard
@@figura:figure4.png@@
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i\leq k$
\end_inset

, sea 
\begin_inset Formula $M_{i\leftarrow0}^{k}$
\end_inset

 una maquina tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{i-1}}BB\shortmid^{x_{i+1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{f}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $q_{0}$
\end_inset

 es el estado inicial y 
\begin_inset Formula $q_{f}$
\end_inset

 es el unico estado final de 
\begin_inset Formula $M_{i\leftarrow0}^{k}$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{i\leftarrow0}^{k}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{N}\bar{\imath}\leftarrow0$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i\leq k$
\end_inset

, sea 
\begin_inset Formula $M_{i\leftarrow\varepsilon}^{k}$
\end_inset

 una maquina tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{i-1}BB\alpha_{i+1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{f}
\end{array}
\]

\end_inset

donde 
\begin_inset Formula $q_{0}$
\end_inset

 es el estado inicial y 
\begin_inset Formula $q_{f}$
\end_inset

 es el unico estado final de 
\begin_inset Formula $M_{i\leftarrow\varepsilon}^{k}$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{i\leftarrow\varepsilon}^{k}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{P}\bar{\imath}\leftarrow\varepsilon$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
Sea
\begin_inset Formula 
\[
M_{\mathrm{SKIP}}=\left(\{q_{0},q_{f}\},\Gamma,\Sigma,\delta,q_{0},B,\shortmid,\{q_{f}\}\right),
\]

\end_inset

con 
\begin_inset Formula $D_{\delta}=\{(q_{0},B)\}$
\end_inset

 y 
\begin_inset Formula $\delta(q_{0},B)=(q_{f},B,K)$
\end_inset

.
 Es claro que la maquina 
\begin_inset Formula $M_{\mathrm{SKIP}}$
\end_inset

 simula la instruccion 
\begin_inset Formula $\mathrm{SKIP}$
\end_inset

, via la representacion de estados en la cinta con respecto a 
\begin_inset Formula $k$
\end_inset

 (cualquiera sea el 
\begin_inset Formula $k$
\end_inset

).
\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq j\leq k$
\end_inset

, sea 
\begin_inset Formula $IF_{j,k}$
\end_inset

 una maquina con estado inicial 
\begin_inset Formula $q_{0}$
\end_inset

 y dos estados finales 
\begin_inset Formula $q_{si}$
\end_inset

 y 
\begin_inset Formula $q_{no}$
\end_inset

 tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

, si 
\begin_inset Formula $x_{j}\neq0$
\end_inset

, entonces
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{si}
\end{array}
\]

\end_inset

y si 
\begin_inset Formula $x_{j}=0$
\end_inset

, entonces
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{no}
\end{array}
\]

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Para 
\begin_inset Formula $1\leq i\leq k$
\end_inset

 y 
\begin_inset Formula $a\in\Sigma$
\end_inset

, sea 
\begin_inset Formula $IF_{j,k}^{a}$
\end_inset

 una maquina con estado inicial 
\begin_inset Formula $q_{0}$
\end_inset

 y dos estados finales 
\begin_inset Formula $q_{si}$
\end_inset

 y 
\begin_inset Formula $q_{no}$
\end_inset

 tal que cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

, si 
\begin_inset Formula $\alpha_{j}$
\end_inset

 comienza con 
\begin_inset Formula $a$
\end_inset

, entonces
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{si}
\end{array}
\]

\end_inset

y en caso contrario
\begin_inset Formula 
\[
\begin{array}{lcl}
B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k} & \overset{\ast}{\vdash} & B\shortmid^{x_{1}}...B\shortmid^{x_{k}}B\alpha_{1}...B\alpha_{k}\\
\uparrow &  & \uparrow\\
q_{0} &  & q_{no}
\end{array}
\]

\end_inset

La maquina 
\begin_inset Formula $IF_{j,k}^{a}$
\end_inset

 puede hacerse de la siguinete manera:
\end_layout

\begin_layout Standard
@@figura:figure5.png@@
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Ejemplo de maquina simuladora de un programa
\end_layout

\begin_layout Standard
A continuacion veremos un ejemplo de como se arma la maquina simuladora
 de un programa dado.
 Sea 
\begin_inset Formula $\Sigma=\{\blacktriangle,\#\}$
\end_inset

 y sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}3 & \mathrm{N}4\leftarrow\mathrm{N}4+1\\
 & \mathrm{P}1\leftarrow\ ^{\curvearrowright}\mathrm{P}1\\
 & \mathrm{IF\ P}1\ \mathrm{BEGINS\ }\blacktriangle\ \mathrm{GOTO}\;\mathrm{L}3\\
 & \mathrm{P}3\leftarrow\mathrm{P}3.\#
\end{array}
\]

\end_inset

Tomemos 
\begin_inset Formula $k=5$
\end_inset

.
 Es claro que 
\begin_inset Formula $k\geq N(\mathcal{P})=4$
\end_inset

.
 A la maquina que simulara a 
\begin_inset Formula $\mathcal{P}$
\end_inset

 respecto de 
\begin_inset Formula $k$
\end_inset

, la llamaremos 
\begin_inset Formula $M_{sim}$
\end_inset

 y sera la siguiente maquina:
\end_layout

\begin_layout Standard
@@figura:figure6.png@@
\end_layout

\begin_layout Standard
\noindent
Veamos con un ejemplo como 
\begin_inset Formula $M_{sim}$
\end_inset

 simula a 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Supongamos que corremos 
\begin_inset Formula $\mathcal{P}$
\end_inset

 desde el estado
\begin_inset Formula 
\[
\left\Vert 2,1,0,5,3,\#\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#\right\Vert 
\]

\end_inset

Tendremos entonces la siguiente sucesion de descripciones instantaneas:
\begin_inset Formula 
\begin{align*}
 & (1,\left\Vert 2,1,0,5,3,\#\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#\right\Vert )\\
\\
 & (2,\left\Vert 2,1,0,6,3,\#\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#\right\Vert )\\
\\
 & (3,\left\Vert 2,1,0,6,3,\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#\right\Vert )\\
\\
 & (1,\left\Vert 2,1,0,6,3,\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#\right\Vert )\\
\\
 & (2,\left\Vert 2,1,0,7,3,\blacktriangle\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#\right\Vert )\\
\\
 & (3,\left\Vert 2,1,0,7,3,\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#\right\Vert )\\
\\
 & (4,\left\Vert 2,1,0,7,3,\#\#,\varepsilon,\blacktriangle\blacktriangle,\#\blacktriangle,\#\right\Vert )\\
\\
 & (5,\left\Vert 2,1,0,7,3,\#\#,\varepsilon,\blacktriangle\blacktriangle\#,\#\blacktriangle,\#\right\Vert )
\end{align*}

\end_inset

Si hacemos funcionar a 
\begin_inset Formula $M_{sim}$
\end_inset

 desde 
\begin_inset Formula $q_{0}B\shortmid^{2}B\shortmid BB\shortmid^{5}B\shortmid^{3}B\#\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B$
\end_inset

 obtendremos una sucesion de descripciones instantaneas dentro de la cual
 estara la siguiente subsucesion que se corresponde con las descripciones
 instantaneas de la computacion anterior.
\begin_inset Formula 
\begin{align*}
q_{0}B & \shortmid^{2}B\shortmid BB\shortmid^{5}B\shortmid^{3}B\#\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
\\
q_{1}B & \shortmid^{2}B\shortmid BB\shortmid^{6}B\shortmid^{3}B\#\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
q_{2}B & \shortmid^{2}B\shortmid BB\shortmid^{6}B\shortmid^{3}B\#\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
\\
q_{3}B & \shortmid^{2}B\shortmid BB\shortmid^{6}B\shortmid^{3}B\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
q_{4}B & \shortmid^{2}B\shortmid BB\shortmid^{6}B\shortmid^{3}B\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
\\
q_{si}B & \shortmid^{2}B\shortmid BB\shortmid^{6}B\shortmid^{3}B\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
q_{0}B & \shortmid^{2}B\shortmid BB\shortmid^{6}B\shortmid^{3}B\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
\\
q_{1}B & \shortmid^{2}B\shortmid BB\shortmid^{7}B\shortmid^{3}B\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
q_{2}B & \shortmid^{2}B\shortmid BB\shortmid^{7}B\shortmid^{3}B\blacktriangle\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
\\
q_{3}B & \shortmid^{2}B\shortmid BB\shortmid^{7}B\shortmid^{3}B\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
q_{4}B & \shortmid^{2}B\shortmid BB\shortmid^{7}B\shortmid^{3}B\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
\\
q_{no}B & \shortmid^{2}B\shortmid BB\shortmid^{7}B\shortmid^{3}B\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
q_{5}B & \shortmid^{2}B\shortmid BB\shortmid^{7}B\shortmid^{3}B\#\#BB\blacktriangle\blacktriangle B\#\blacktriangle B\#B\\
\\
q_{6}B & \shortmid^{2}B\shortmid BB\shortmid^{7}B\shortmid^{3}B\#\#BB\blacktriangle\blacktriangle\#B\#\blacktriangle B\#B
\end{align*}

\end_inset

Dejamos al lector ver en detalle el paralelismo que hay entre las dos sucesiones
 de descripciones instantaneas arriba expuestas.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
La contruccion de la maquina simuladora
\end_layout

\begin_layout Standard
A continuacion describiremos en general como hacer la maquina simuladora
 de 
\begin_inset Formula $\mathcal{P}$
\end_inset

, respecto de 
\begin_inset Formula $k$
\end_inset

.
 Supongamos que 
\begin_inset Formula $\mathcal{P}=I_{1}...I_{n}$
\end_inset

.
 Para cada 
\begin_inset Formula $i=1,...,n$
\end_inset

, llamaremos 
\begin_inset Formula $M_{i}$
\end_inset

 a la maquina que simulara el efecto que produce la instruccion 
\begin_inset Formula $I_{i}$
\end_inset

, es decir tomemos
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{j,k}^{+}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow\mathrm{N}\bar{j}+1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{j,k}^{\dot{-}}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow\mathrm{N}\bar{j}\dot{-}1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{j,k}^{a}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow\mathrm{P}\bar{j}.a$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{j,k}^{\curvearrowright}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow\ ^{\curvearrowright}\mathrm{P}\bar{j}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{j\leftarrow m}^{\#,k}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow\mathrm{N}\bar{m}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{j\leftarrow m}^{\ast,k}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow\mathrm{P}\bar{m}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{j\leftarrow0}^{k}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{j\leftarrow\varepsilon}^{k}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow\varepsilon$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=M_{\mathrm{SKIP}}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{SKIP}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=IF_{j,k}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{IF}\;\mathrm{N}\bar{j}\not=0$
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Formula $\mathrm{GOTO}\;\mathrm{L}\bar{m}$
\end_inset

, para algun 
\begin_inset Formula $m$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $M_{i}=IF_{j,k}^{a}$
\end_inset

, si 
\begin_inset Formula $Bas(I_{i})=\mathrm{IF}\;\mathrm{P}\bar{j}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}$
\end_inset

, para algun 
\begin_inset Formula $m$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Ya que la maquina 
\begin_inset Formula $M_{i}$
\end_inset

 puede tener uno o dos estados finales, la representaremos como se muestra
 a continuacion:
\end_layout

\begin_layout Standard
@@figura:figure7.png@@
\end_layout

\begin_layout Standard
\noindent
entendiendo que en el caso en que 
\begin_inset Formula $M_{i}$
\end_inset

 tiene un solo estado final, este esta representado por el circulo de abajo
 a la izquierda y en el caso en que 
\begin_inset Formula $M_{i}$
\end_inset

 tiene dos estados finales, el circulo de abajo a la izquierda corresponde
 al estado final 
\begin_inset Formula $q_{no}$
\end_inset

 y el circulo de abajo a la derecha corresponde al estado 
\begin_inset Formula $q_{si}$
\end_inset

.
 Para armar la maquina que simulara a 
\begin_inset Formula $\mathcal{P}$
\end_inset

 hacemos lo siguiente.
 Primero unimos las maquinas 
\begin_inset Formula $M_{1},...,M_{n}$
\end_inset

 de la siguiente manera:
\end_layout

\begin_layout Standard
@@figura:figure8.png@@
\end_layout

\begin_layout Standard
\noindent
Luego para cada 
\begin_inset Formula $i$
\end_inset

 tal que 
\begin_inset Formula $Bas(I_{i})$
\end_inset

 es de la forma 
\begin_inset Formula $\alpha\mathrm{GOTO}\;\mathrm{L}\bar{m}$
\end_inset

, ligamos con una flecha de la forma
\begin_inset Formula 
\[
\underrightarrow{\;\;\;\;\;\;B,B,K\;\;\;\;\;\;}
\]

\end_inset

el estado final 
\begin_inset Formula $q_{si}$
\end_inset

 de la 
\begin_inset Formula $M_{i}$
\end_inset

 con el estado inicial de la 
\begin_inset Formula $M_{h}$
\end_inset

, donde 
\begin_inset Formula $h$
\end_inset

 es tal que 
\begin_inset Formula $I_{h}$
\end_inset

 es la primer instruccion que tiene label 
\begin_inset Formula $\mathrm{L}\bar{m}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
El lema de la simulacion
\end_layout

\begin_layout Standard
A continuacion enunciaremos en forma de lema la existencia de la maquina
 simuladora y de las propiedades esenciales que usaremos luego para probar
 que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "simulacion"

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 y sea 
\begin_inset Formula $k\geq N(\mathcal{P})$
\end_inset

.
 Supongamos que en 
\begin_inset Formula $\mathcal{P}$
\end_inset

 no hay instrucciones de la forma 
\begin_inset Formula $\mathrm{GOTO}\;\mathrm{L}\bar{m}$
\end_inset

 ni de la forma 
\begin_inset Formula $\mathrm{L}\bar{n}\ \mathrm{GOTO}\;\mathrm{L}\bar{m}$
\end_inset

.
 Para cada 
\begin_inset Formula $a\in\Sigma\cup\{\shortmid\}$
\end_inset

, sea 
\begin_inset Formula $\tilde{a}$
\end_inset

 un nuevo simbolo.
 Sea 
\begin_inset Formula $\Gamma=\Sigma\cup\{B,\shortmid\}\cup\{\tilde{a}:a\in\Sigma\cup\{\shortmid\}\}$
\end_inset

.
 Entonces hay una maquina de Turing deterministica con unit 
\begin_inset Formula $M=\left(Q,\Gamma,\Sigma,\delta,q_{0},B,\shortmid,\{q_{f}\}\right)$
\end_inset

 la cual satisface
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $(q_{f},\sigma)\notin D_{\delta}$
\end_inset

, para cada 
\begin_inset Formula $\sigma\in\Gamma$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Cualesquiera sean 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

, el programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo del estado
\begin_inset Formula 
\[
\left\Vert x_{1},...,x_{k},\alpha_{1},...,\alpha_{k}\right\Vert 
\]

\end_inset

sii 
\begin_inset Formula $M$
\end_inset

 se detiene partiendo de la descripcion instantanea
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{k}}B\alpha_{1}B...B\alpha_{k}B\right\rfloor 
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $x_{1},...,x_{k}\in\omega$
\end_inset

 y 
\begin_inset Formula $\alpha_{1},...,\alpha_{k}\in\Sigma^{\ast}$
\end_inset

 son tales que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo del estado
\begin_inset Formula 
\[
\left\Vert x_{1},...,x_{k},\alpha_{1},...,\alpha_{k}\right\Vert 
\]

\end_inset

y llega al estado
\begin_inset Formula 
\[
\left\Vert y_{1},...,y_{k},\beta_{1},...,\beta_{k}\right\Vert 
\]

\end_inset

entonces
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{k}}B\alpha_{1}B...B\alpha_{k}B\right\rfloor \overset{\ast}{\underset{M}{\vdash}}\left\lfloor q_{f}B\shortmid^{y_{1}}B...B\shortmid^{y_{k}}B\beta_{1}B...B\beta_{k}B\right\rfloor 
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Cabe destacar que si bien la veracidad de este lema es sustentada en las
 explicaciones anteriores, una prueba formal rigurosa del mismo resultaria
 extremadamente larga y tediosa.
 La ventaja de que sea un resultado intuitivamente claro nos permite aceptarlo
 y seguir adelante en nuestro analisis.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Turing vence a Neumann
\end_layout

\begin_layout Standard
En lo que sigue usaremos la existencia de la maquina simuladora de un programa
 para probar que toda funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable.
 Antes un lema.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "sinGOTO"

\end_inset

Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\Sigma^{\ast}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable, entonces hay un programa 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 el cual computa a 
\begin_inset Formula $f$
\end_inset

 y el cual cumple con las siguientes propiedades
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

En 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 no hay instrucciones de la forma 
\begin_inset Formula $\mathrm{GOTO}\;\mathrm{L}\bar{\imath}$
\end_inset

 ni de la forma 
\begin_inset Formula $\mathrm{L}\bar{j}\ \mathrm{GOTO}\;\mathrm{L}\bar{\imath}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Cuando 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 termina partiendo de un estado cualquiera dado, el estado alcansado es
 tal que las variables numericas tienen todas el valor 
\begin_inset Formula $0$
\end_inset

 y las alfabeticas tienen todas exepto 
\begin_inset Formula $\mathrm{P}1$
\end_inset

 el valor 
\begin_inset Formula $\varepsilon$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 un programa que compute a 
\begin_inset Formula $f$
\end_inset

.
 Sea 
\begin_inset Formula $r\in\mathbf{N}$
\end_inset

 tal que 
\begin_inset Formula $r>N(\mathcal{P}),n,m$
\end_inset

.
 Sea 
\begin_inset Formula $\mathcal{\tilde{P}}$
\end_inset

 el resultado de reemplazar en 
\begin_inset Formula $\mathcal{P}$
\end_inset

 cada instruccion de la forma
\begin_inset Formula 
\[
\alpha\mathrm{GOTO}\;\mathrm{L}\bar{\imath}
\]

\end_inset

con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{L}\bar{j}:j\in\mathbf{N}\}$
\end_inset

 por 
\begin_inset Formula $\alpha\mathrm{IF\ N}\bar{r}\neq0\ \mathrm{GOTO}\;\mathrm{L}\bar{\imath}$
\end_inset

.
 Ahora sea 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 el siguiente programa
\begin_inset Formula 
\[
\begin{array}{l}
\mathrm{N}\bar{r}\leftarrow\mathrm{N}\bar{r}+1\\
\mathcal{\tilde{P}}\\
\mathrm{N}1\leftarrow0\\
\vdots\\
\mathrm{N}\bar{r}\leftarrow0\\
\mathrm{P}2\leftarrow\varepsilon\\
\vdots\\
\mathrm{P}\bar{r}\leftarrow\varepsilon
\end{array}
\]

\end_inset

Es facil ver que 
\begin_inset Formula $\mathcal{Q}$
\end_inset

 tiene las propiedades (1) y (2).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Por supuesto, hay un lema analogo para el caso en que 
\begin_inset Formula $f$
\end_inset

 llega a 
\begin_inset Formula $\omega$
\end_inset

 en lugar de llegar a 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
 Ahora si, el anunciado teorema:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "ComputableImplicaTuringComputable"

\end_inset

Si 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable, entonces 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable
\shape italic
.

\shape default
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "sinGOTO"
plural "false"
caps "false"
noprefix "false"

\end_inset

 existe 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 el cual computa 
\begin_inset Formula $f$
\end_inset

 y tiene las propiedades (1) y (2).
 Sea 
\begin_inset Formula $k=\max\{n,m,N(\mathcal{P})\}$
\end_inset

 y sea 
\begin_inset Formula $M_{sim}$
\end_inset

 la maquina de Turing con unit que simula a 
\begin_inset Formula $\mathcal{P}$
\end_inset

 respecto de 
\begin_inset Formula $k$
\end_inset

.
 Como puede observarse, la maquina 
\begin_inset Formula $M_{sim}$
\end_inset

, no necesariamente computara a 
\begin_inset Formula $f$
\end_inset

.
 Sea 
\begin_inset Formula $M_{1}$
\end_inset

 la siguiente maquina:
\end_layout

\begin_layout Standard
@@figura:figure9.png@@
\end_layout

\begin_layout Standard
\noindent
(Cuando 
\begin_inset Formula $n=0$
\end_inset

 debemos interpretar que 
\begin_inset Formula $D_{0}=\left(\{q_{0},q_{f}\},\Gamma,\Sigma,\delta,q_{0},B,\shortmid,\{q_{f}\}\right)$
\end_inset

, con 
\begin_inset Formula $D_{\delta}=\{(q_{0},B)\}$
\end_inset

 y 
\begin_inset Formula $\delta(q_{0},B)=(q_{f},B,K)$
\end_inset

.
 Notese que 
\begin_inset Formula $M_{1}$
\end_inset

 cumple que para cada 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in\omega^{n}\times\Sigma^{\ast m}$
\end_inset

,
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}B\right\rfloor \overset{\ast}{\vdash}\left\lfloor q_{f}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B^{k-n}B\alpha_{1}B...B\alpha_{m}B\right\rfloor 
\]

\end_inset

Sea 
\begin_inset Formula $M_{2}$
\end_inset

 la siguiente maquina
\end_layout

\begin_layout Standard
@@figura:figure10.png@@
\end_layout

\begin_layout Standard
\noindent
Notese que 
\begin_inset Formula $M_{2}$
\end_inset

 cumple que para cada 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

,
\begin_inset Formula 
\[
\left\lfloor q_{0}B^{k+1}\alpha\right\rfloor \overset{\ast}{\vdash}\left\lfloor q_{f}B\alpha\right\rfloor 
\]

\end_inset

Sea 
\begin_inset Formula $M$
\end_inset

 la siguiente maquina:
\end_layout

\begin_layout Standard
@@figura:figure11.png@@
\end_layout

\begin_layout Standard
\noindent
A continuacion veremos que 
\begin_inset Formula $M$
\end_inset

 computa a 
\begin_inset Formula $f$
\end_inset

.
 Supongamos que 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in(\omega^{n}\times\Sigma^{\ast m})-D_{f}$
\end_inset

.
 Deberemos ver que 
\begin_inset Formula $M$
\end_inset

 no termina partiendo de
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset


\begin_inset Formula $\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}B\right\rfloor $
\end_inset

 
\end_layout

\begin_layout Standard
Primero notemos que, ya que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 computa a 
\begin_inset Formula $f$
\end_inset

, tenemos que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 no termina partiendo de 
\begin_inset Formula $\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

 por lo cual 
\begin_inset Formula $\mathcal{P}$
\end_inset

 no termina partiendo de
\begin_inset Formula 
\[
\left\Vert x_{1},...,x_{n},\overset{k-n}{\overbrace{0,...,0}},\alpha_{1},...,\alpha_{m},\overset{k-m}{\overbrace{\varepsilon,...,\varepsilon}}\right\Vert 
\]

\end_inset

lo cual implica (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "simulacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

) que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(**)
\end_layout

\end_inset


\begin_inset Formula $M_{sim}$
\end_inset

 no termina partiendo de 
\begin_inset Formula $\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B^{k-n}B\alpha_{1}B...B\alpha_{m}B\right\rfloor $
\end_inset

 
\end_layout

\begin_layout Standard
Ahora notese que si hacemos funcionar a 
\begin_inset Formula $M$
\end_inset

 desde la descripcion instantanea dada en (*), llegaremos (via la copia
 de 
\begin_inset Formula $M_{1}$
\end_inset

 dentro de 
\begin_inset Formula $M$
\end_inset

) indefectiblemente (ya que 
\begin_inset Formula $M$
\end_inset

 es deterministica) a la siguiente descripcion instantanea
\begin_inset Formula 
\[
\left\lfloor q_{2}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B^{k-n}B\alpha_{1}B...B\alpha_{m}B\right\rfloor 
\]

\end_inset

Luego entonces (**) nos dice que al seguir trabajando 
\begin_inset Formula $M$
\end_inset

 (ahora via la copia de 
\begin_inset Formula $M_{sim}$
\end_inset

 dentro de 
\begin_inset Formula $M$
\end_inset

), la maquina 
\begin_inset Formula $M$
\end_inset

 nunca terminara.
\end_layout

\begin_layout Standard
Para terminar de ver que 
\begin_inset Formula $M$
\end_inset

 computa a 
\begin_inset Formula $f$
\end_inset

, tomemos 
\begin_inset Formula $(\vec{x},\vec{\alpha})\in D_{f}$
\end_inset

 y veamos que
\begin_inset Formula 
\[
\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}B\right\rfloor \overset{\ast}{\underset{M}{\vdash}}\left\lfloor q_{5}Bf(\vec{x},\vec{\alpha})\right\rfloor 
\]

\end_inset

y que la maquina 
\begin_inset Formula $M$
\end_inset

 se detiene en 
\begin_inset Formula $\left\lfloor q_{5}Bf(\vec{x},\vec{\alpha})\right\rfloor $
\end_inset

.
 La maquina 
\begin_inset Formula $M$
\end_inset

 se detiene en 
\begin_inset Formula $\left\lfloor q_{5}Bf(\vec{x},\vec{\alpha})\right\rfloor $
\end_inset

 ya que 
\begin_inset Formula $q_{5}$
\end_inset

 es el estado final de una copia de 
\begin_inset Formula $M_{2}$
\end_inset

 y por lo tanto no sale ninguna flecha desde el.
 Ya que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 computa a 
\begin_inset Formula $f$
\end_inset

 y tiene la propiedad (2) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "sinGOTO"
plural "false"
caps "false"
noprefix "false"

\end_inset

, tenemos que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 termina partiendo de 
\begin_inset Formula $\left\Vert x_{1},...,x_{n},\alpha_{1},...,\alpha_{m}\right\Vert $
\end_inset

 y llega al estado 
\begin_inset Formula $\left\Vert f(\vec{x},\vec{\alpha})\right\Vert $
\end_inset

, o lo que es lo mismo, 
\begin_inset Formula $\mathcal{P}$
\end_inset

 termina partiendo de
\begin_inset Formula 
\[
\left\Vert x_{1},...,x_{n},\overset{k-n}{\overbrace{0,...,0}},\alpha_{1},...,\alpha_{m},\overset{k-m}{\overbrace{\varepsilon,...,\varepsilon}}\right\Vert 
\]

\end_inset

y llega al estado
\begin_inset Formula 
\[
\left\Vert \overset{k}{\overbrace{0,...,0}},f(\vec{x},\vec{\alpha}),\overset{k-1}{\overbrace{\varepsilon,...,\varepsilon}}\right\Vert 
\]

\end_inset

Pero entonces el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "simulacion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(***)
\end_layout

\end_inset


\begin_inset Formula $\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B^{k-n}B\alpha_{1}B...B\alpha_{m}B\right\rfloor \overset{\ast}{\underset{M_{sim}}{\vdash}}\left\lfloor q_{f}B^{k+1}f(\vec{x},\vec{\alpha})\right\rfloor $
\end_inset

 
\end_layout

\begin_layout Standard
Como ya lo vimos, si hacemos funcionar a 
\begin_inset Formula $M$
\end_inset

 desde 
\begin_inset Formula $\left\lfloor q_{0}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B\alpha_{1}B...B\alpha_{m}B\right\rfloor $
\end_inset

, llegaremos (via la copia de 
\begin_inset Formula $M_{1}$
\end_inset

 dentro de 
\begin_inset Formula $M$
\end_inset

) indefectiblemente a la siguiente descripcion instantanea
\begin_inset Formula 
\[
\left\lfloor q_{2}B\shortmid^{x_{1}}B...B\shortmid^{x_{n}}B^{k-n}B\alpha_{1}B...B\alpha_{m}B\right\rfloor 
\]

\end_inset

Luego (***) nos dice que, via la copia de 
\begin_inset Formula $M_{sim}$
\end_inset

 dentro de 
\begin_inset Formula $M$
\end_inset

, llegaremos a 
\begin_inset Formula $\left\lfloor q_{3}B^{k+1}f(\vec{x},\vec{\alpha})\right\rfloor $
\end_inset

 e inmediatamente a 
\begin_inset Formula $\left\lfloor q_{4}B^{k+1}f(\vec{x},\vec{\alpha})\right\rfloor $
\end_inset

.
 Finalmente, via la copia de 
\begin_inset Formula $M_{2}$
\end_inset

 dentro de 
\begin_inset Formula $M$
\end_inset

, llegaremos a 
\begin_inset Formula $\left\lfloor q_{5}Bf(\vec{x},\vec{\alpha})\right\rfloor $
\end_inset

, lo cual termina de demostrar que 
\begin_inset Formula $M$
\end_inset

 computa a 
\begin_inset Formula $f$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Conclusiones: La tesis de Church
\end_layout

\begin_layout Standard
En virtud de los teoremas ya probados tenemos el siguiente teorema que asegura
 que los tres paradigmas son equivalentes.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
 Dada una funcion 
\begin_inset Formula $f$
\end_inset

, las siguientes son equivalentes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1)
\begin_inset Formula $\Rightarrow$
\end_inset

(2) es probado en el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "TuringComputableImplicaRecursiva"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 (2)
\begin_inset Formula $\Rightarrow$
\end_inset

(3) es probado en el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "RimplicaComp"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 (3)
\begin_inset Formula $\Rightarrow$
\end_inset

(1) es probado en el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "ComputableImplicaTuringComputable"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tambien los tres paradigmas son equivalentes con respecto a los dos tipos
 de conjuntos estudiados, es decir:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito y sea 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Las siguientes son equivalentes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing enumerable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Directo de las definiciones y el teorema anterior.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito y sea 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Las siguientes son equivalentes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-Turing computable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Directo de las definiciones y el teorema anterior.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Otro modelo matematico de computabilidad efectiva es el llamado lamda calculus,
 introducido por Church, el cual tambien resulta equivalente a los estudiados
 por nosotros.
 El hecho de que tan distintos paradigmas computacionales hayan resultado
 equivalentes hace pensar que en realidad los mismos han tenido exito en
 capturar la totalidad de las funciones 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables.
 Esta aseveracion es conocida como la
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\size larger
Tesis de Church:
\size default
 
\shape italic
Toda funcion 
\shape default

\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-efectivamente computable es 
\shape default

\begin_inset Formula $\Sigma$
\end_inset


\shape italic
-recursiva.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
Si bien no se ha podido dar una prueba estrictamente matematica de la Tesis
 de Church, es un sentimiento comun de los investigadores del area que la
 misma es verdadera.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "survey recursivo"

\end_inset

Resultados basicos presentados en paradigma recursivo
\end_layout

\begin_layout Standard
En esta seccion presentaremos varios de los resultados basicos de computabilidad
, expresados en el paradigma recursivo, ya que es el mas habitual y comodo.
 Varios de estos resultados ya han sido establecidos dentro del desarrollo
 de la computabilidad efectiva en el Capitulo 
\begin_inset CommandInset ref
LatexCommand ref
reference "ParadigmaFilosofico"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 A estos resultados los enunciaremos dentro del paradigma de Godel y daremos
 pruebas rigurosas matematicas de ellos usando la teoria desarrollada hasta
 ahora.
 Sin envargo, veremos que hay otros resultados que son dependientes del
 desarrollo matematico hecho y aportan nueva informacion al paradigma filosofico
 (la indecidibilidad del halting problem, por ejemplo).
\end_layout

\begin_layout Subsection
Lema de division por casos para funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "dpc1"

\end_inset

Supongamos 
\begin_inset Formula $f_{i}:D_{f_{i}}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

, 
\begin_inset Formula $i=1,...,k$
\end_inset

, son funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas tales que 
\begin_inset Formula $D_{f_{i}}\cap D_{f_{j}}=\emptyset$
\end_inset

 para 
\begin_inset Formula $i\neq j$
\end_inset

.
 Entonces la funcion 
\begin_inset Formula $f_{1}\cup...\cup f_{k}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Probaremos el caso 
\begin_inset Formula $k=2$
\end_inset

 y 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Ademas supondremos que 
\begin_inset Formula $n=m=1$
\end_inset

.
 Sean 
\begin_inset Formula $\mathcal{P}_{1}$
\end_inset

 y 
\begin_inset Formula $\mathcal{P}_{2}$
\end_inset

 programas que computen las funciones 
\begin_inset Formula $f_{1}$
\end_inset

 y 
\begin_inset Formula $f_{2}$
\end_inset

, respectivamente.
 Para 
\begin_inset Formula $i=1,2$
\end_inset

, definamos
\begin_inset Formula 
\[
H_{i}=\lambda tx_{1}\alpha_{1}\left[Halt^{1,1}(t,x_{1},\alpha_{1},\mathcal{P}_{i})\right]
\]

\end_inset

Notar que 
\begin_inset Formula $D_{H_{i}}=\omega^{2}\times\Sigma^{\ast}$
\end_inset

 y que 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta.
 Ademas sabemos que la funcion 
\begin_inset Formula $Halt^{1,1}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 por lo cual resulta facilmente que 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Por el Teorema de Independencia del Alfabeto tenemos que 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Entonces 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable por lo cual tenemos que hay un macro:
\begin_inset Formula 
\[
\left[\mathrm{IF}\;H_{i}(\mathrm{V}1,\mathrm{V}2,\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Para hacer mas intuitivo el uso de este macro lo escribiremos de la siguiente
 manera
\begin_inset Formula 
\[
\left[\mathrm{IF}\;Halt^{1,1}(\mathrm{V}1,\mathrm{V}2,\mathrm{W}1,\mathcal{P}_{i})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Ya que cada 
\begin_inset Formula $f_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable, hay macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{W}2\leftarrow f_{1}(\mathrm{V}1,\mathrm{W}1)\right]\\
 & \left[\mathrm{W}2\leftarrow f_{2}(\mathrm{V}1,\mathrm{W}1)\right]
\end{align*}

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa:
\begin_inset Formula 
\[
\begin{array}{l}
\mathrm{L}1\ \mathrm{N}20\leftarrow\mathrm{N}20+1\\
\left[\mathrm{IF}\;Halt^{1,1}(\mathrm{N}20,\mathrm{N}1,\mathrm{P}1,\mathcal{P}_{1})\;\mathrm{GOTO}\;\mathrm{L}2\right]\\
\left[\mathrm{IF}\;Halt^{1,1}(\mathrm{N}20,\mathrm{N}1,\mathrm{P}1,\mathcal{P}_{2})\;\mathrm{GOTO}\;\mathrm{L}3\right]\\
\mathrm{GOTO}\;\mathrm{L}1\\
\mathrm{L}2\ \left[\mathrm{P}1\leftarrow f_{1}(\mathrm{N}1,\mathrm{P}1)\right]\\
\mathrm{GOTO}\;\mathrm{L}4\\
\mathrm{L}3\ \left[\mathrm{P}1\leftarrow f_{2}(\mathrm{N}1,\mathrm{P}1)\right]\\
\mathrm{L}4\ \mathrm{SKIP}
\end{array}
\]

\end_inset

Notese que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 computa la funcion 
\begin_inset Formula $f_{1}\cup f_{2}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
La prueba del lema anterior es de naturaleza imperativa ya que da explicitamente
 un programa (de todas maneras usa el paradigma recursivo o Godeliano para
 justificar la existencia de los macros).
 A continuacion daremos una prueba la cual es mas recursiva (aunque aun
 usa el paradigma imperativo en la existencia de los programas 
\begin_inset Formula $\mathcal{P}_{i}$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sean 
\begin_inset Formula $\mathcal{P}_{1}$
\end_inset

 y 
\begin_inset Formula $\mathcal{P}_{2}$
\end_inset

 programas que computen las funciones 
\begin_inset Formula $f_{1}$
\end_inset

 y 
\begin_inset Formula $f_{2}$
\end_inset

, respectivamente.
 Sean
\begin_inset Formula 
\begin{align*}
P_{1} & =\lambda t\vec{x}\vec{\alpha}\left[Halt^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}_{1})\right]\\
P_{2} & =\lambda t\vec{x}\vec{\alpha}\left[Halt^{n,m}(t,\vec{x},\vec{\alpha},\mathcal{P}_{2})\right]
\end{align*}

\end_inset

Notese que 
\begin_inset Formula $D_{P_{1}}=D_{P_{2}}=\omega\times\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 y que 
\begin_inset Formula $P_{1}$
\end_inset

 y 
\begin_inset Formula $P_{2}$
\end_inset

 son 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Ya que son 
\begin_inset Formula $\Sigma$
\end_inset

-mixtos, el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Tambien notese que 
\begin_inset Formula $D_{M((P_{1}\vee P_{2}))}=D_{f_{1}}\cup D_{f_{2}}$
\end_inset

.
 Definamos
\begin_inset Formula 
\begin{align*}
g_{1} & =\lambda\vec{x}\vec{\alpha}\left[E_{\ast1}^{n,m}(M\left((P_{1}\vee P_{2})\right)(\vec{x},\vec{\alpha}),\vec{x},\vec{\alpha},\mathcal{P}_{1})^{P_{1}(M\left((P_{1}\vee P_{2})\right)(\vec{x},\vec{\alpha}),\vec{x},\vec{\alpha})}\right]\\
g_{2} & =\lambda\vec{x}\vec{\alpha}\left[E_{\ast1}^{n,m}(M\left((P_{1}\vee P_{2})\right)(\vec{x},\vec{\alpha}),\vec{x},\vec{\alpha},\mathcal{P}_{2})^{P_{2}(M\left((P_{1}\vee P_{2})\right)(\vec{x},\vec{\alpha}),\vec{x},\vec{\alpha})}\right]
\end{align*}

\end_inset

Notese que 
\begin_inset Formula $g_{1}$
\end_inset

 y 
\begin_inset Formula $g_{2}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas y que 
\begin_inset Formula $D_{g_{1}}=D_{g_{2}}=D_{f_{1}}\cup D_{f_{2}}$
\end_inset

, Ademas notese que
\begin_inset Formula 
\[
g_{1}(\vec{x},\vec{\alpha})=\left\{ \begin{array}{lll}
f_{1}(\vec{x},\vec{\alpha}) &  & \text{si }(\vec{x},\vec{\alpha})\in D_{f_{1}}\\
\varepsilon &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset


\begin_inset Formula 
\[
g_{2}(\vec{x},\vec{\alpha})=\left\{ \begin{array}{lll}
f_{2}(\vec{x},\vec{\alpha}) &  & \text{si }(\vec{x},\vec{\alpha})\in D_{f_{2}}\\
\varepsilon &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

O sea que 
\begin_inset Formula $f_{1}\cup f_{2}=\lambda\alpha\beta\left[\alpha\beta\right]\circ\left[g_{1},g_{2}\right]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "basicas de conjuntos R y RE"

\end_inset

Conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-recursivos y 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerables
\end_layout

\begin_layout Standard
A continuacion probaremos los resultados basicos sobre conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computables y 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables, dados en las Secciones 
\begin_inset CommandInset ref
LatexCommand ref
reference "conjuntos sigma-efectivamente enumerables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 y 
\begin_inset CommandInset ref
LatexCommand ref
reference "conjuntos sigma-efectivamente computables"
plural "false"
caps "false"
noprefix "false"

\end_inset

, pero enunciados dentro del paradigma de Godel.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $P:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 y 
\begin_inset Formula $Q:S\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 son predicados 
\begin_inset Formula $\Sigma$
\end_inset

-r., entonces 
\begin_inset Formula $(P\vee Q)$
\end_inset

, 
\begin_inset Formula $(P\wedge Q)$
\end_inset

 y 
\begin_inset Formula $\lnot P$
\end_inset

 lo son tambien.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Note que
\begin_inset Formula 
\begin{align*}
\lnot P & =\lambda xy\left[x\dot{-}y\right]\circ\left[C_{1}^{n,m},P\right]\\
(P\wedge Q) & =\lambda xy\left[x.y\right]\circ[P,Q]\\
(P\vee Q) & =\lnot(\lnot P\wedge\lnot Q).
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 son conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-recursivos.
 Entonces 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

, 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 y 
\begin_inset Formula $S_{1}-S_{2}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivos 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es directa del lema anterior.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "union e interseccion de r.e."

\end_inset

Supongamos 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 son conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 Entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Podemos suponer que ni 
\begin_inset Formula $S_{1}$
\end_inset

 ni 
\begin_inset Formula $S_{2}$
\end_inset

 son vacios ya que de lo contrario los resultados son triviales.
 Ademas supondremos que 
\begin_inset Formula $n=2$
\end_inset

 y 
\begin_inset Formula $m=1$
\end_inset

.
\end_layout

\begin_layout Standard
(1).
 La idea de la prueba es la misma que la que usamos para probar que la union
 de conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerables es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Daremos usando macros un programa que enumera a 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 y luego aplicaremos la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "P enumera a S"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Por hipotesis hay funciones 
\begin_inset Formula $F:\omega\rightarrow\omega\times\omega\times\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $G:\omega\rightarrow\omega\times\omega\times\Sigma^{\ast}$
\end_inset

 tales que 
\begin_inset Formula $F_{(1)}$
\end_inset

, 
\begin_inset Formula $F_{(2)}$
\end_inset

, 
\begin_inset Formula $F_{(3)}$
\end_inset

, 
\begin_inset Formula $G_{(1)}$
\end_inset

, 
\begin_inset Formula $G_{(2)}$
\end_inset

 y 
\begin_inset Formula $G_{(3)}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas, 
\begin_inset Formula $\operatorname{Im}(F)=S_{1}$
\end_inset

 y 
\begin_inset Formula $\operatorname{Im}(G)=S_{2}$
\end_inset

.
 Ya que estas funciones tambien son 
\begin_inset Formula $\Sigma$
\end_inset

-computables, hay macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{V}2\leftarrow F_{(2)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{W}1\leftarrow F_{(3)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{V}2\leftarrow G_{(1)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{V}2\leftarrow G_{(2)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{W}1\leftarrow G_{(3)}(\mathrm{V}1)\right]
\end{align*}

\end_inset

Ya que el predicado 
\begin_inset Formula $Par=\lambda x[x$
\end_inset

 es par
\begin_inset Formula $]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., tenemos que 
\begin_inset Formula $Par$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 Es decir que hay un macro:
\begin_inset Formula 
\[
[\mathrm{IF\ }Par(\mathrm{V}1)\ \mathrm{GOTO\ A}1]
\]

\end_inset

el cual escribiremos de la siguiente manera mas intuitiva
\begin_inset Formula 
\[
[\mathrm{IF\ V}1\text{ es par }\mathrm{GOTO\ A}1]
\]

\end_inset

Ya que la funcion 
\begin_inset Formula $D=\lambda x[\lfloor x/2\rfloor]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., tenemos que 
\begin_inset Formula $D$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 Es decir que hay un macro:
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow D(\mathrm{V}1)]
\]

\end_inset

el cual escribiremos de la siguiente manera mas intuitiva
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow\lfloor\mathrm{V}1/2\rfloor]
\]

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa:
\begin_inset Formula 
\[
\begin{array}{ll}
 & [\mathrm{IF\ N}1\text{ es par }\mathrm{GOTO\ L}1\\
 & \mathrm{N}1\leftarrow\mathrm{N}1\dot{-}1\\
 & [\mathrm{N}1111\leftarrow\lfloor\mathrm{N}1/2\rfloor]\\
 & \left[\mathrm{N}1\leftarrow G_{(1)}(\mathrm{N}1111)\right]\\
 & \left[\mathrm{N}2\leftarrow G_{(2)}(\mathrm{N}1111)\right]\\
 & \left[\mathrm{P}1\leftarrow G_{(3)}(\mathrm{N}1111)\right]\\
 & \mathrm{GOTO\ L}2\\
\mathrm{L}1 & [\mathrm{N}1111\leftarrow\lfloor\mathrm{N}1/2\rfloor]\\
 & \left[\mathrm{N}1\leftarrow F_{(1)}(\mathrm{N}1111)\right]\\
 & \left[\mathrm{N}2\leftarrow F_{(2)}(\mathrm{N}1111)\right]\\
 & \left[\mathrm{P}1\leftarrow F_{(3)}(\mathrm{N}1111)\right]\\
\mathrm{L}2 & \mathrm{SKIP}
\end{array}
\]

\end_inset

Es facil ver que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 cumple a y b de (3) de la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "P enumera a S"
plural "false"
caps "false"
noprefix "false"

\end_inset

 por lo cual 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable.
\end_layout

\begin_layout Standard
(2).
 Es dejada al lector 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tal como veremos mas adelante hay conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerables los cuales no son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivos.
 Sin envargo tenemos el siguiente interesante resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "carac recursivos"

\end_inset

Sea 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

.
 Son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 y 
\begin_inset Formula $(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerables 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a)
\begin_inset Formula $\Rightarrow$
\end_inset

(b).
 Si 
\begin_inset Formula $S=\emptyset$
\end_inset

, por definicion 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerable.
 Supongamos entonces 
\begin_inset Formula $S\neq\emptyset$
\end_inset

.
 Haremos el caso en el que 
\begin_inset Formula $n=m=1$
\end_inset

 y 
\begin_inset Formula $(0,\varepsilon)\in S$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Por hipotesis tenemos que 
\begin_inset Formula $\chi_{S}^{\omega\times\Sigma^{\ast}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva por lo cual es 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 O sea que tenemos un macro
\begin_inset Formula 
\[
[\mathrm{IF\ }\chi_{S}^{\omega\times\Sigma^{\ast}}(\mathrm{V}1,\mathrm{W}1)\ \mathrm{GOTO\ A}1]
\]

\end_inset

Ya que la funcion 
\begin_inset Formula $f=\lambda x[(x)_{1}]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., ella es 
\begin_inset Formula $\Sigma$
\end_inset

-computable por lo cual hay un macro
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow f(\mathrm{V}1)]
\]

\end_inset

el cual escribiremos de la siguiente manera:
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow(\mathrm{V}1)_{1}]
\]

\end_inset

Ya que la funcion 
\begin_inset Formula $g=\lambda x[\ast^{\leq}((x)_{2})]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., ella es 
\begin_inset Formula $\Sigma$
\end_inset

-computable por lo cual hay un macro
\begin_inset Formula 
\[
[\mathrm{W}1\leftarrow g(\mathrm{V}1)]
\]

\end_inset

el cual escribiremos de la siguiente manera:
\begin_inset Formula 
\[
[\mathrm{W}1\leftarrow\ast^{\leq}((\mathrm{V}1)_{2})]
\]

\end_inset

(Dejamos al lector entender bien el funcionamiento de estos macros.) Sea
 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa:
\begin_inset Formula 
\[
\begin{array}{l}
\mathrm{N}1\leftarrow\mathrm{N}1+1\\{}
[\mathrm{N}2\leftarrow(\mathrm{N}1)_{1}]\\{}
[\mathrm{P}2\leftarrow\ast^{\leq}(\mathrm{N}1)_{2}]\\{}
[\mathrm{IF\ }\chi_{S}^{\omega\times\Sigma^{\ast}}(\mathrm{N}2,\mathrm{P}2)\ \mathrm{GOTO\ L}1\\
\mathrm{N}1\leftarrow0\\
\mathrm{P}1\leftarrow\varepsilon\\
\mathrm{GOTO\ L}2\\
\mathrm{L}1\ [\mathrm{N}1\leftarrow\mathrm{N}2]\\
\left[\mathrm{P}1\leftarrow\mathrm{P}2)\right]\\
\mathrm{L}2\ \mathrm{SKIP}
\end{array}
\]

\end_inset

Notese que 
\begin_inset Formula $\mathrm{Dom}(\left[\Psi_{\mathcal{P}}^{1,0,\#},\Psi_{\mathcal{P}}^{1,0,\ast}\right])=\omega$
\end_inset

 y que 
\begin_inset Formula $\operatorname{Im}(\left[\Psi_{\mathcal{P}}^{1,0,\#},\Psi_{\mathcal{P}}^{1,0,\ast}\right])=S$
\end_inset

 por lo cual 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable lo que nos dice que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerable.
\end_layout

\begin_layout Standard
(b)
\begin_inset Formula $\Rightarrow$
\end_inset

(a).
 Haremos el caso en que los conjuntos 
\begin_inset Formula $S$
\end_inset

 y 
\begin_inset Formula $(\omega^{n}\times\Sigma^{\ast m})-S$
\end_inset

 son no vacios.
 Tambien supondremos 
\begin_inset Formula $n=m=1$
\end_inset

.
 Por hipotesis hay funciones 
\begin_inset Formula $F:\omega\rightarrow\omega\times\Sigma^{\ast}$
\end_inset

 y 
\begin_inset Formula $G:\omega\rightarrow\omega\times\Sigma^{\ast}$
\end_inset

 tales que 
\begin_inset Formula $F_{(1)}$
\end_inset

, 
\begin_inset Formula $F_{(2)}$
\end_inset

, 
\begin_inset Formula $G_{(1)}$
\end_inset

 y 
\begin_inset Formula $G_{(2)}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas, 
\begin_inset Formula $\operatorname{Im}(F)=S$
\end_inset

 y 
\begin_inset Formula $\operatorname{Im}(G)=(\omega\times\Sigma^{\ast})-S$
\end_inset

.
 Ya que estas funciones tambien son 
\begin_inset Formula $\Sigma$
\end_inset

-computables, hay macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{W}1\leftarrow F_{(2)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{V}1\leftarrow G_{(1)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{W}1\leftarrow G_{(2)}(\mathrm{V}1)\right]
\end{align*}

\end_inset

Ya que los predicados 
\begin_inset Formula $D=\lambda xy[x\neq y]$
\end_inset

 y 
\begin_inset Formula $D^{\prime}=\lambda\alpha\beta[\alpha\neq\beta]$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-computables, hay macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{IF}\;D(\mathrm{V}1,\mathrm{V}2)\;\mathrm{GOTO}\;\mathrm{A}1\right]\\
 & \left[\mathrm{IF}\;D^{\prime}(\mathrm{W}1,\mathrm{W}2)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\end{align*}

\end_inset

los cuales para hacer mas amigable la lectura los escribieremos de la siguiente
 manera
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{IF}\;\mathrm{V}1\neq\mathrm{V}2\;\mathrm{GOTO}\;\mathrm{A}1\right]\\
 & \left[\mathrm{IF}\;\mathrm{W}1\neq\mathrm{W}2\;\mathrm{GOTO}\;\mathrm{A}1\right]
\end{align*}

\end_inset

Tambien usaremos el macro
\begin_inset Formula 
\[
[\mathrm{V}1\leftarrow C_{1}^{0,0}(\Diamond)]
\]

\end_inset

(asociado a la funcion 
\begin_inset Formula $\Sigma$
\end_inset

-computable 
\begin_inset Formula $C_{1}^{0,0}$
\end_inset

), el cual escribiremos de la siguiente manera
\begin_inset Formula 
\[
[\mathrm{V}1\leftarrow1]
\]

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa:
\begin_inset Formula 
\[
\begin{array}{l}
\mathrm{L}1\ [\mathrm{N}2\leftarrow F_{(1)}(\mathrm{N}20)]\\{}
[\mathrm{P}2\leftarrow F_{(2)}(\mathrm{N}20)]\\
\left[\mathrm{IF}\;\mathrm{N}2\neq\mathrm{N}1\;\mathrm{GOTO}\;\mathrm{L}2\right]\\
\left[\mathrm{IF}\;\mathrm{P}2\neq\mathrm{P}1\;\mathrm{GOTO}\;\mathrm{L}2\right]\\{}
[\mathrm{N}1\leftarrow1]\\
\mathrm{GOTO}\;\mathrm{L}3\\
\mathrm{L}2\ [\mathrm{N}2\leftarrow G_{(1)}(\mathrm{N}20)]\\{}
[\mathrm{P}2\leftarrow G_{(2)}(\mathrm{N}20)]\\
\left[\mathrm{IF}\;\mathrm{N}2\neq\mathrm{N}1\;\mathrm{GOTO}\;\mathrm{L}4\right]\\
\left[\mathrm{IF}\;\mathrm{P}2\neq\mathrm{P}1\;\mathrm{GOTO}\;\mathrm{L}4\right]\\
\mathrm{N}1\leftarrow0\\
\mathrm{GOTO}\;\mathrm{L}3\\
\mathrm{L}4\ \mathrm{N}20\leftarrow\mathrm{N}20+1\\
\mathrm{GOTO}\;\mathrm{L}1\\
\mathrm{L}3\ \mathrm{SKIP}
\end{array}
\]

\end_inset

Notese que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 computa a la funcion 
\begin_inset Formula $\chi_{S}^{\omega\times\Sigma^{\ast}}$
\end_inset

 por lo cual 
\begin_inset Formula $\chi_{S}^{\omega\times\Sigma^{\ast}}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable lo que nos dice que es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Esto por definicion nos dice que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "restriccion1"

\end_inset

Supongamos 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva y 
\begin_inset Formula $S\subseteq D_{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e., entonces 
\begin_inset Formula $f|_{S}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Si 
\begin_inset Formula $S=\emptyset$
\end_inset

, entonces 
\begin_inset Formula $f|_{S}=\emptyset$
\end_inset

 y por lo tanto 
\begin_inset Formula $f|_{S}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Supongamos 
\begin_inset Formula $S\neq\emptyset$
\end_inset

.
 Haremos el caso 
\begin_inset Formula $n=m=1$
\end_inset

 y 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Tenemos que hay una 
\begin_inset Formula $F:\omega\rightarrow\omega\times\Sigma^{\ast}$
\end_inset

 tal que 
\begin_inset Formula $\operatorname{Im}F=S$
\end_inset

 y 
\begin_inset Formula $F_{(1)}$
\end_inset

, 
\begin_inset Formula $F_{(2)}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas.
 Ya que 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $F_{(1)}$
\end_inset

 y 
\begin_inset Formula $F_{(2)}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-computables, hay macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{W}2\leftarrow f(\mathrm{V}1,\mathrm{W}1)\right]\\
 & \left[\mathrm{V}2\leftarrow F_{(1)}(\mathrm{V}1)\right]\\
 & \left[\mathrm{W}1\leftarrow F_{(2)}(\mathrm{V}1)\right]
\end{align*}

\end_inset

Usaremos los macros
\begin_inset Formula 
\begin{align*}
 & \left[\mathrm{IF}\;\mathrm{V}1\neq\mathrm{V}2\;\mathrm{GOTO}\;\mathrm{A}1\right]\\
 & \left[\mathrm{IF}\;\mathrm{W}1\neq\mathrm{W}2\;\mathrm{GOTO}\;\mathrm{A}1\right]
\end{align*}

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa
\begin_inset Formula 
\[
\begin{array}{ll}
\mathrm{L}2 & [\mathrm{N}2\leftarrow F_{(1)}(\mathrm{N}20)]\\
 & [\mathrm{P}2\leftarrow F_{(2)}(\mathrm{N}20)]\\
 & \left[\mathrm{IF}\;\mathrm{N}1\neq\mathrm{N}2\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
 & \left[\mathrm{IF}\;\mathrm{P}1\neq\mathrm{P}2\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
 & \left[\mathrm{P}1\leftarrow f(\mathrm{N}1,\mathrm{P}1)\right]\\
 & \mathrm{GOTO}\;\mathrm{L}3\\
\mathrm{L}1 & \mathrm{N}20\leftarrow\mathrm{N}20+1\\
 & \mathrm{GOTO}\;\mathrm{L}2\\
\mathrm{L}3 & \mathrm{SKIP}
\end{array}
\]

\end_inset

Es facil ver que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 computa a 
\begin_inset Formula $f|_{S}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora probaremos el analogo recursivo del Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "equivalencias de efectivamente enumerable"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "equivalencias-r.e."

\end_inset

Dado 
\begin_inset Formula $S\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

, son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerable
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $S=I_{F}$
\end_inset

, para alguna 
\begin_inset Formula $F:D_{F}\subseteq\omega^{k}\times\Sigma^{\ast l}\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que cada 
\begin_inset Formula $F_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $S=D_{f}$
\end_inset

, para alguna funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva 
\begin_inset Formula $f$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $S=\emptyset$
\end_inset

 o 
\begin_inset Formula $S=I_{F}$
\end_inset

, para alguna 
\begin_inset Formula $F:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tal que cada 
\begin_inset Formula $F_{(i)}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 El caso 
\begin_inset Formula $n=m=0$
\end_inset

 es facil y es dejado al lector.
 Supongamos entonces que 
\begin_inset Formula $n+m\geq1$
\end_inset

.
\end_layout

\begin_layout Standard
(2)
\begin_inset Formula $\Rightarrow$
\end_inset

(3).
 Haremos el caso 
\begin_inset Formula $k=l=1$
\end_inset

 y 
\begin_inset Formula $n=m=2$
\end_inset

.
 El caso general es completamente analogo.
 Notese que entonces tenemos que 
\begin_inset Formula $S\subseteq\omega^{2}\times\Sigma^{\ast2}$
\end_inset

 y 
\begin_inset Formula $F:D_{F}\subseteq\omega\times\Sigma^{\ast}\rightarrow\omega^{2}\times\Sigma^{\ast2}$
\end_inset

 es tal que 
\begin_inset Formula $\operatorname{Im}F=S$
\end_inset

 y 
\begin_inset Formula $F_{(1)}$
\end_inset

, 
\begin_inset Formula $F_{(2)}$
\end_inset

, 
\begin_inset Formula $F_{(3)}$
\end_inset

, 
\begin_inset Formula $F_{(4)}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas.
 Para cada 
\begin_inset Formula $i\in\{1,2,3,4\}$
\end_inset

, sea 
\begin_inset Formula $\mathcal{P}_{i}$
\end_inset

 un programa el cual computa a 
\begin_inset Formula $F_{(i)}$
\end_inset

.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Definamos
\begin_inset Formula 
\[
H_{i}=\lambda tx_{1}\alpha_{1}\left[\lnot Halt^{1,1}(t,x_{1},\alpha_{1},\mathcal{P}_{i})\right]
\]

\end_inset

Notar que 
\begin_inset Formula $D_{H_{i}}=\omega^{2}\times\Sigma^{\ast}$
\end_inset

 y que 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-mixta.
 Ademas sabemos que la funcion 
\begin_inset Formula $Halt^{1,1}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 por lo cual resulta facilmente que 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r..
 Por la Proposicion de Independencia del Alfabeto tenemos que 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Entonces 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable por lo cual tenemos que hay un macro:
\begin_inset Formula 
\[
\left[\mathrm{IF}\;H_{i}(\mathrm{V}2,\mathrm{V}1,\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Para hacer mas intuitivo el uso de este macro lo escribiremos de la siguiente
 manera
\begin_inset Formula 
\[
\left[\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{V}2,\mathrm{V}1,\mathrm{W}1,\mathcal{P}_{i})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Para 
\begin_inset Formula $i=1,2$
\end_inset

, definamos
\begin_inset Formula 
\[
E_{i}=\lambda xtx_{1}\alpha_{1}\left[x\neq E_{\#1}^{1,1}(t,x_{1},\alpha_{1},\mathcal{P}_{i})\right]
\]

\end_inset

Para 
\begin_inset Formula $i=3,4$
\end_inset

, definamos
\begin_inset Formula 
\[
E_{i}=\lambda tx_{1}\alpha_{1}\alpha\left[\alpha\neq E_{\ast1}^{1,1}(t,x_{1},\alpha_{1},\mathcal{P}_{i})\right]
\]

\end_inset

Dejamos al lector probar que las funciones 
\begin_inset Formula $E_{i}$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 O sea que son 
\begin_inset Formula $\Sigma$
\end_inset

-computables por lo cual para cada 
\begin_inset Formula $i\in\{1,2\}$
\end_inset

 hay un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;E_{i}(\mathrm{V}2,\mathrm{V}3,\mathrm{V}1,\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

y para cada 
\begin_inset Formula $i\in\{3,4\}$
\end_inset

 hay un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;E_{i}(\mathrm{V}2,\mathrm{V}1,\mathrm{W}1,\mathrm{W}2)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Haremos mas intuitiva la forma de escribir estos macros, por ejemplo para
 
\begin_inset Formula $i=1$
\end_inset

, lo escribiremos de la siguiente manera
\begin_inset Formula 
\[
\left[\mathrm{IF}\;\mathrm{V}2\neq E_{\#1}^{1,1}(\mathrm{V}3,\mathrm{V}1,\mathrm{W}1,\mathcal{P}_{1})\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Ya que la funcion 
\begin_inset Formula $f=\lambda x[(x)_{1}]$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r., ella es 
\begin_inset Formula $\Sigma$
\end_inset

-computable por lo cual hay un macro
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow f(\mathrm{V}1)]
\]

\end_inset

el cual escribiremos de la siguiente manera:
\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow(\mathrm{V}1)_{1}]
\]

\end_inset

Similarmente hay macros:
\begin_inset Formula 
\[
[\mathrm{W}1\leftarrow\ast^{\leq}(\mathrm{V}1)_{3}]
\]

\end_inset


\begin_inset Formula 
\[
[\mathrm{V}2\leftarrow(\mathrm{V}1)_{2}]
\]

\end_inset

(dejamos al lector entender bien el funcionamiento de estos macros).
 Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 el siguiente programa de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{l}
\mathrm{L}1\ \mathrm{N}20\leftarrow\mathrm{N}20+1\\{}
[\mathrm{N}10\leftarrow(\mathrm{N}20)_{1}]\\{}
[\mathrm{N}3\leftarrow(\mathrm{N}20)_{2}]\\{}
[\mathrm{P}3\leftarrow\ast^{\leq}(\mathrm{N}20)_{3}]\\
\left[\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{1})\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
\left[\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{2})\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
\left[\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{3})\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
\left[\mathrm{IF}\;\lnot Halt^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{4})\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
\left[\mathrm{IF}\;\mathrm{N}1\neq E_{\#1}^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{1})\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
\left[\mathrm{IF}\;\mathrm{N}2\neq E_{\#1}^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{2})\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
\left[\mathrm{IF}\;\mathrm{P}1\neq E_{\ast1}^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{3})\;\mathrm{GOTO}\;\mathrm{L}1\right]\\
\left[\mathrm{IF}\;\mathrm{P}2\neq E_{\ast1}^{1,1}(\mathrm{N}10,\mathrm{N}3,\mathrm{P}3,\mathcal{P}_{4})\;\mathrm{GOTO}\;\mathrm{L}1\right]
\end{array}
\]

\end_inset

Dejamos al lector la tarea de comprender el funcionamiento de este programa
 y convenserse de que computa la funcion 
\begin_inset Formula $p_{1}^{2,2}|_{S}$
\end_inset

.
 Pero entonces 
\begin_inset Formula $p_{1}^{2,2}|_{S}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-computable por lo cual es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva, lo cual prueba (3) ya que 
\begin_inset Formula $\mathrm{Dom}(p_{1}^{2,2}|_{S})=S$
\end_inset

.
\end_layout

\begin_layout Standard
(3)
\begin_inset Formula $\Rightarrow$
\end_inset

(4).
 Supongamos 
\begin_inset Formula $S\neq\emptyset$
\end_inset

.
 Sea 
\begin_inset Formula $(z_{1},...,z_{n},\gamma_{1},...,\gamma_{m})\in S$
\end_inset

 fijo.
 Sea 
\begin_inset Formula $\mathcal{P}$
\end_inset

 un programa el cual compute a 
\begin_inset Formula $f$
\end_inset

 y Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Sea 
\begin_inset Formula $P:\mathbf{N}\rightarrow\omega$
\end_inset

 dado por 
\begin_inset Formula $P(x)=1$
\end_inset

 sii
\begin_inset Formula 
\[
Halt^{n,m}\left((x)_{n+m+1},(x)_{1},...,(x)_{n},\ast^{\leq}((x)_{n+1}),...,\ast^{\leq}((x)_{n+m})),\mathcal{P}\right)=1
\]

\end_inset

Es facil ver que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 por lo cual es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $\bar{P}=P\cup C_{0}^{1,0}|_{\{0\}}$
\end_inset

.
 Para 
\begin_inset Formula $i=1,...,n$
\end_inset

, definamos 
\begin_inset Formula $F_{i}:\omega\rightarrow\omega$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
F_{i}(x)=\left\{ \begin{array}{ccc}
(x)_{i} & \text{si} & \bar{P}(x)=1\\
z_{i} & \text{si} & \bar{P}(x)\neq1
\end{array}\right.
\]

\end_inset

Para 
\begin_inset Formula $i=n+1,...,n+m$
\end_inset

, definamos 
\begin_inset Formula $F_{i}:\omega\rightarrow\Sigma^{\ast}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
F_{i}(x)=\left\{ \begin{array}{lll}
\ast^{\leq}((x)_{i}) & \text{si} & \bar{P}(x)=1\\
\gamma_{i-n} & \text{si} & \bar{P}(x)\neq1
\end{array}\right.
\]

\end_inset

Por el lema de division por casos, cada 
\begin_inset Formula $F_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Es facil ver que 
\begin_inset Formula $F=[F_{1},...,F_{n+m}]$
\end_inset

 cumple (4).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
La prueba de (2)
\begin_inset Formula $\Rightarrow$
\end_inset

(3) del teorema anterior es de naturaleza imperativa ya que da explicitamente
 un programa (de todas maneras usa el paradigma recursivo o Godeliano para
 justificar la existencia de los macros).
 A continuacion daremos una prueba de (2)
\begin_inset Formula $\Rightarrow$
\end_inset

(3) la cual es mas recursiva (aunque aun usa el paradigma imperativo en
 la existencia de los programas 
\begin_inset Formula $\mathcal{P}_{i}$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [(2)
\begin_inset Formula $\Rightarrow$
\end_inset

(3)]Para 
\begin_inset Formula $i=1,...,n+m$
\end_inset

, sea 
\begin_inset Formula $\mathcal{P}_{i}$
\end_inset

 un programa el cual computa a 
\begin_inset Formula $F_{(i)}$
\end_inset

 y Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma$
\end_inset

.
 Sea 
\begin_inset Formula $P:\mathbf{N}\times\omega^{n}\times\Sigma^{\ast m}\rightarrow\omega$
\end_inset

 dado por 
\begin_inset Formula $P(t,\vec{x},\vec{\alpha})=1$
\end_inset

 sii se cumplen las siguientes condiciones
\begin_inset Formula 
\begin{align*}
Halt^{k,l}(\left((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast^{\leq}((t)_{k+1}),...,\ast^{\leq}((t)_{k+l})),\mathcal{P}_{1}\right) & =1\\
 & \vdots\\
Halt^{k,l}\left((t)_{k+l+1},(t)_{1}...(t)_{k},\ast^{\leq}((t)_{k+1})...\ast^{\leq}((t)_{k+l})),\mathcal{P}_{n+m}\right) & =1\\
E_{\#1}^{k,l}((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast^{\leq}((t)_{k+1}),...,\ast^{\leq}((t)_{k+l})),\mathcal{P}_{1}) & =x_{1}\\
 & \vdots\\
E_{\#1}^{k,l}((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast^{\leq}((t)_{k+1}),...,\ast^{\leq}((t)_{k+l})),\mathcal{P}_{n}) & =x_{n}\\
E_{\ast1}^{k,l}((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast^{\leq}((t)_{k+1}),...,\ast^{\leq}((t)_{k+l})),\mathcal{P}_{n+1}) & =\alpha_{1}\\
 & \vdots\\
E_{\ast1}^{k,l}((t)_{k+l+1},(t)_{1},...,(t)_{k},\ast^{\leq}((t)_{k+1}),...,\ast^{\leq}((t)_{k+l})),\mathcal{P}_{n+m}) & =\alpha_{m}
\end{align*}

\end_inset

Note que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 y por lo tanto 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Pero entonces 
\begin_inset Formula $M(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 lo cual nos dice que se cumple (3) ya que 
\begin_inset Formula $D_{M(P)}=I_{F}=S$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Supongamos 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva y 
\begin_inset Formula $S\subseteq I_{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e., entonces 
\begin_inset Formula $f^{-1}(S)=\{(\vec{x},\vec{\alpha}):f(\vec{x},\vec{\alpha})\in S\}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por el teorema anterior 
\begin_inset Formula $S=D_{g}$
\end_inset

, para alguna funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva 
\begin_inset Formula $g$
\end_inset

.
 Note que 
\begin_inset Formula $f^{-1}(S)=D_{g\circ f}$
\end_inset

, lo cual nuevamente por el teorema anterior nos dice que 
\begin_inset Formula $f^{-1}(S)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos como ejercicio dar una prueba imperativa del corolario anterior.
 Los Lemas 
\begin_inset CommandInset ref
LatexCommand ref
reference "restriccion1"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset space \space{}
\end_inset

y 
\begin_inset CommandInset ref
LatexCommand ref
reference "union e interseccion de r.e."
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset space \space{}
\end_inset

pueden obtenerse facilmente como corolarios del teorema anterior.
 Se gana en elegancia y simplicidad pero cabe destacar que se pierde en
 intuicion
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Supongamos 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\times\Sigma^{\ast m}\rightarrow O$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva y 
\begin_inset Formula $S\subseteq D_{f}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e., entonces 
\begin_inset Formula $f|_{S}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $O=\Sigma^{\ast}$
\end_inset

.
 Por el teorema anterior 
\begin_inset Formula $S=D_{g}$
\end_inset

, para alguna funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva 
\begin_inset Formula $g$
\end_inset

.
 Notese que componiendo adecuadamente podemos suponer que 
\begin_inset Formula $I_{g}=\{\varepsilon\}.$
\end_inset

 O sea que tenemos 
\begin_inset Formula $f|_{S}=\lambda\alpha\beta\left[\alpha\beta\right]\circ[f,g]$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Supongamos 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 son conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 Entonces 
\begin_inset Formula $S_{1}\cap S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por el teorema anterior 
\begin_inset Formula $S_{i}=D_{g_{i}}$
\end_inset

, con 
\begin_inset Formula $g_{1},g_{2}$
\end_inset

 funciones 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas
\begin_inset Formula $.$
\end_inset

 Notese que podemos suponer que 
\begin_inset Formula $I_{g_{1}},I_{g_{2}}\subseteq\omega$
\end_inset

 por lo que 
\begin_inset Formula $S_{1}\cap S_{2}=D_{\lambda xy\left[xy\right]\circ[g_{1},g_{2}]}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
\begin_inset Formula $.$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Supongamos 
\begin_inset Formula $S_{1},S_{2}\subseteq\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 son conjuntos 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 Entonces 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $S_{1}\neq\emptyset\neq S_{2}.$
\end_inset

 Sean 
\begin_inset Formula $F,G:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 tales que 
\begin_inset Formula $I_{F}=S_{1}$
\end_inset

, 
\begin_inset Formula $I_{G}=S_{2}$
\end_inset

 y las funciones 
\begin_inset Formula $F_{(i)}%TCIMACRO{\U{b4}}%%BeginExpansion\acute{}%EndExpansions\ensuremath{}
$
\end_inset

 y 
\begin_inset Formula $G_{(i)}%TCIMACRO{\U{b4}}%%BeginExpansion\acute{}%EndExpansions\ensuremath{}
$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivas.
 Sean 
\begin_inset Formula $f=\lambda x\left[Q(x,2)\right]$
\end_inset

 y 
\begin_inset Formula $g=\lambda x\left[Q(x\dot{-}1,2)\right].$
\end_inset

 Sea 
\begin_inset Formula $H:\omega\rightarrow\omega^{n}\times\Sigma^{\ast m}$
\end_inset

 dada por
\begin_inset Formula 
\[
H_{(i)}=(F_{(i)}\circ f)\mathrm{|}_{\{x:x\mathrm{\ es\ par}\}}\cup(G_{(i)}\circ g)\mathrm{|}_{\{x:x\mathrm{\ es\ impar}\}}
\]

\end_inset

Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "restriccion1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 y el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "dpc1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, cada 
\begin_inset Formula $H_{i}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Ya que 
\begin_inset Formula $I_{H}=S_{1}\cup S_{2}$
\end_inset

.tenemos que 
\begin_inset Formula $S_{1}\cup S_{2}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
A continuacion dejamos un sketch de una prueba alternativa del Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "carac recursivos"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Dejamos al lector completar los detalles.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a)
\begin_inset Formula $\Rightarrow$
\end_inset

(b)
\begin_inset Formula $.$
\end_inset

 Note que 
\begin_inset Formula $S=D_{Pred\circ\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}}.$
\end_inset


\end_layout

\begin_layout Standard
(b)
\begin_inset Formula $\Rightarrow$
\end_inset

(a).
 Note que 
\begin_inset Formula $\chi_{S}^{\omega^{n}\times\Sigma^{\ast m}}=C_{1}^{n,m}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{S}\cup C_{0}^{n,m}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{(\omega^{n}\times\Sigma^{\ast m})-S}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Los dos siguientes teoremas, nos agregan una equivalencia mas al Teorema
 
\begin_inset CommandInset ref
LatexCommand ref
reference "equivalencias-r.e."
plural "false"
caps "false"
noprefix "false"

\end_inset

, para el caso 
\begin_inset Formula $n=0$
\end_inset

, 
\begin_inset Formula $m=1$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Si 
\begin_inset Formula $L\subseteq\Sigma^{\ast}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e., entonces 
\begin_inset Formula $L=L(M)=H(M)$
\end_inset

 para 
\begin_inset space \space{}
\end_inset

alguna maquina de Turing deterministica 
\begin_inset Formula $M$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 La prueba es similar a la del Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "ComputableImplicaTuringComputable"
plural "false"
caps "false"
noprefix "false"

\end_inset

 asique solo daremos un skech de la misma.
 Por el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "equivalencias-r.e."
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\begin_inset Formula $L=D_{f}$
\end_inset

 para alguna funcion 
\begin_inset Formula $f$
\end_inset

 la cual es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Notese que podemos suponer que 
\begin_inset Formula $\operatorname{Im}f\subseteq\Sigma^{\ast}$
\end_inset

.
 Ya que 
\begin_inset Formula $f$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva, tambien es 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "sinGOTO"
plural "false"
caps "false"
noprefix "false"

\end_inset

 existe 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 el cual computa 
\begin_inset Formula $f$
\end_inset

 y tiene las propiedades (1) y (2).
 Sea 
\begin_inset Formula $k=N(\mathcal{P})$
\end_inset

 y sea 
\begin_inset Formula $M_{sim}$
\end_inset

 la maquina de Turing con unit que simula a 
\begin_inset Formula $\mathcal{P}$
\end_inset

 respecto de 
\begin_inset Formula $k$
\end_inset

.
 Sea 
\begin_inset Formula $M_{1}$
\end_inset

 una maquina de Turing deterministica con un solo estado final 
\begin_inset Formula $q_{f}$
\end_inset

 (del cual no salen flechas) y tal que para todo 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

,
\begin_inset Formula 
\[
\left\lfloor q_{0}B\alpha\right\rfloor \overset{\ast}{\vdash}\left\lfloor q_{f}B^{k+1}\alpha\right\rfloor 
\]

\end_inset

Note que la concatenacion de 
\begin_inset Formula $M_{1}$
\end_inset

 con 
\begin_inset Formula $M$
\end_inset

 produce una maquina de Turing deterministica 
\begin_inset Formula $M_{2}$
\end_inset

 tal que 
\begin_inset Formula $H(M_{2})=L(M_{2})=L$
\end_inset

.
 Dejamos al lector los detalles de la construccion de 
\begin_inset Formula $M_{2}.$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $M=\left(Q,\Sigma,\Gamma,\delta,q_{0},B,F\right)$
\end_inset

 una maquina de Turing.
 Entonces 
\begin_inset Formula $L(M)$
\end_inset

 y 
\begin_inset Formula $H(M)$
\end_inset

 son 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerables.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Veamos que 
\begin_inset Formula $L(M)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerable.
 Sea 
\begin_inset Formula $P$
\end_inset

 el siguiente predicado 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-mixto
\begin_inset Formula 
\[
\lambda n\alpha\left[(\exists d\in Des)\;\left\lfloor q_{0}B\alpha\right\rfloor \underset{M}{\overset{n}{\vdash}}d\wedge St(d)\in F\right]
\]

\end_inset

Notese que 
\begin_inset Formula $D_{P}=\omega\times\Gamma^{\ast}$
\end_inset

.
 Dejamos al lector probar que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $P^{\prime}=P|_{\omega\times\Sigma^{\ast}}$
\end_inset

.
 Notese que 
\begin_inset Formula $P^{\prime}(n,\alpha)=1$
\end_inset

 sii 
\begin_inset Formula $\alpha\in L(M)$
\end_inset

 atestiguado por una computacion de longitud 
\begin_inset Formula $n$
\end_inset

.
 Ya que 
\begin_inset Formula $P^{\prime}$
\end_inset

 es 
\begin_inset Formula $(\Gamma\cup Q)$
\end_inset

-p.r.
 (por que?) y ademas es 
\begin_inset Formula $\Sigma$
\end_inset

-mixto, el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $P^{\prime}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r..
 Ya que 
\begin_inset Formula $L(M)=D_{M(P^{\prime})}$
\end_inset

, el Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "equivalencias-r.e."
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $L(M)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
\end_layout

\begin_layout Standard
Dejamos al lector la prueba parecida de que 
\begin_inset Formula $H(M)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerable.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
El halting problem y los conjuntos 
\begin_inset Formula $A$
\end_inset

 y 
\begin_inset Formula $N$
\end_inset


\end_layout

\begin_layout Standard
Cuando 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}$
\end_inset

, podemos definir
\begin_inset Formula 
\[
AutoHalt^{\Sigma}=\lambda\mathcal{P}\left[(\exists t\in\omega)\;Halt^{0,1}(t,\mathcal{P},\mathcal{P})\right]\text{.}
\]

\end_inset

Notar que el dominio de 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

 es 
\begin_inset Formula $\mathrm{Pro}^{\Sigma}$
\end_inset

 y que para cada 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 tenemos que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset


\begin_inset Formula $AutoHalt(\mathcal{P})=1$
\end_inset

 sii 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo del estado 
\begin_inset Formula $\left\Vert \mathcal{P}\right\Vert $
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "autohalt"

\end_inset

Supongamos 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}$
\end_inset

.
 Entonces 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo y por lo tanto 
\begin_inset Formula $\Sigma$
\end_inset

-computable.
 Por la proposicion de existencia de macros tenemos que hay un macro
\begin_inset Formula 
\[
\left[\mathrm{IF}\;AutoHalt^{\Sigma}(\mathrm{W}1)\;\mathrm{GOTO}\;\mathrm{A}1\right]
\]

\end_inset

Sea 
\begin_inset Formula $\mathcal{P}_{0}$
\end_inset

 el siguiente programa de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset


\begin_inset Formula 
\[
\mathrm{L}1\;\left[\mathrm{IF}\;AutoHalt^{\Sigma}(\mathrm{P}1)\;\mathrm{GOTO}\;\mathrm{L}1\right]
\]

\end_inset

Note que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathcal{P}_{0}$
\end_inset

 termina partiendo desde 
\begin_inset Formula $\left\Vert \mathcal{P}_{0}\right\Vert $
\end_inset

 sii 
\begin_inset Formula $AutoHalt^{\Sigma}(\mathcal{P}_{0})=0$
\end_inset

, 
\end_layout

\begin_layout Standard
\noindent
lo cual produce una contradiccion si tomamos en (*) 
\begin_inset Formula $\mathcal{P}=\mathcal{P}_{0}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Usando el lema anterior y la Tesis de Church podemos probar el siguiente
 impactante resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 
\begin_inset CommandInset label
LatexCommand label
name "autohalt es no EC"

\end_inset

Supongamos 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}$
\end_inset

.
 Entonces 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Es decir no hay ningun procedimiento efectivo que decida si un programa
 de 
\begin_inset Formula $\mathcal{S}^{\Sigma}$
\end_inset

 termina partiendo de si mismo.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Si 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

 fuera 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable, la Tesis de Church nos diria que es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo, contradiciendo el lema anterior.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

 provee de un ejemplo natural en el cual la cuantificacion (no acotada)
 de un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 con dominio rectangular no es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable
\end_layout

\begin_layout Standard
Ahora estamos en condiciones de dar un ejemplo natural de un conjunto 
\begin_inset Formula $A$
\end_inset

 que es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivamente enumerable pero el cual no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "A es RE y no R"

\end_inset

Supongamos que 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}.$
\end_inset

 Entonces
\begin_inset Formula 
\[
A=\left\{ \mathcal{P}\in\mathrm{Pro}^{\Sigma}:AutoHalt^{\Sigma}(\mathcal{P})=1\right\} 
\]

\end_inset

es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 y no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
 Mas aun el conjunto
\begin_inset Formula 
\[
N=\left\{ \mathcal{P}\in\mathrm{Pro}^{\Sigma}:AutoHalt^{\Sigma}(\mathcal{P})=0\right\} 
\]

\end_inset

no es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Para ver que 
\begin_inset Formula $A$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 se lo puede hacer imperativamente dando un programa (usando macros) que
 enumere a 
\begin_inset Formula $A$
\end_inset

.
 De esta forma probariamos que 
\begin_inset Formula $A$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-enumerable y por lo tanto es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 Daremos ahora una prueba no imperativa de este hecho, es decir mas propia
 del paradigma funcional.
 Sea 
\begin_inset Formula $P=\lambda t\mathcal{P}\left[Halt^{0,1}(t,\mathcal{P},\mathcal{P})\right]$
\end_inset

.
 Note que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-p.r.
 por lo que 
\begin_inset Formula $M(P)$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r..
 Ademas note que 
\begin_inset Formula $D_{M(P)}=A$
\end_inset

, lo cual implica que 
\begin_inset Formula $A$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $N$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
 Entonces la funcion 
\begin_inset Formula $C_{0}^{0,1}|_{N}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva ya que 
\begin_inset Formula $C_{0}^{0,1}$
\end_inset

 lo es.
 Ademas ya que 
\begin_inset Formula $A$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 tenemos que 
\begin_inset Formula $C_{1}^{0,1}|_{A}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva.
 Ya que
\begin_inset Formula 
\[
AutoHalt^{\Sigma}=C_{1}^{0,1}|_{A}\cup C_{0}^{0,1}|_{N}
\]

\end_inset

el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "dpc1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo, contradiciendo el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "autohalt"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Esto prueba que 
\begin_inset Formula $N$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-r.e..
\end_layout

\begin_layout Standard
Finalmente supongamos 
\begin_inset Formula $A$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
 Entonces el conjunto
\begin_inset Formula 
\[
N=\left(\Sigma^{\ast}-A\right)\cap\mathrm{Pro}^{\Sigma}
\]

\end_inset

deberia serlo, lo cual es absurdo.
 Hemos probado entonces que 
\begin_inset Formula $A$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Cabe destacar aqui que el dominio de una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva no siempre sera un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
 Por ejemplo si tomamos 
\begin_inset Formula $\Sigma$
\end_inset

 tal que 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}$
\end_inset

, entonces 
\begin_inset Formula $C_{1}^{0,1}|_{A}$
\end_inset

 es una funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva ya que es la restriccion de la funcion 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva 
\begin_inset Formula $C_{1}^{0,1}$
\end_inset

 al conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-r.e.
 
\begin_inset Formula $A$
\end_inset

, pero 
\begin_inset Formula $\mathrm{Dom}(C_{1}^{0,1}|_{A})=A$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Usando la Tesis de Church obtenemos el siguiente resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "A es EE y no EC"

\end_inset

Supongamos que 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}.$
\end_inset

 Entonces 
\begin_inset Formula $A$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable y no es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 El conjunto 
\begin_inset Formula $N$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente enumerable.
 Es decir, 
\begin_inset Formula $A$
\end_inset

 puede ser enumerado por un procedimiento efectivo pero no hay ningun procedimie
nto efectivo que decida la pertenencia a 
\begin_inset Formula $A$
\end_inset

 y no hay ningun procedimiento efectivo que enumere a 
\begin_inset Formula $N$
\end_inset

.
 Mas aun, si un procedimiento efectivo da como salida siempre elementos
 de 
\begin_inset Formula $N$
\end_inset

, entonces hay una cantidad infinita de elementos de 
\begin_inset Formula $N$
\end_inset

 los cuales nunca da como salida 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Con los resultados anteriores estamos en condiciones de dar un ejemplo de
 un predicado 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo, cuya minimizacion no es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable (y por lo tanto es no 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "P recursivo no implica M(P) recursiva"

\end_inset

Supongamos que 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}$
\end_inset

.
 Sea 
\begin_inset Formula $P=C_{1}^{0,1}|_{A}\circ\lambda t\alpha\left[\alpha^{1\dot{-}t}\mathrm{SKIP}^{t}\right]|_{\omega\times\mathrm{Pro}^{\Sigma}}$
\end_inset

.
 La funcion 
\begin_inset Formula $M(P)$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable (y por lo tanto es no 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva) 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que 
\begin_inset Formula $D_{M(P)}=\mathrm{Pro}^{\Sigma}$
\end_inset

 y que para cada 
\begin_inset Formula $\mathcal{P}\in\mathrm{Pro}^{\Sigma}$
\end_inset

 se tiene que
\begin_inset Formula 
\[
M(P)(\mathcal{P})=0\text{ sii }\mathcal{P}\in A
\]

\end_inset

O sea que 
\begin_inset Formula $AutoHalt^{\Sigma}=\lambda x[x=0]\circ M(P)$
\end_inset

 lo cual nos dice que 
\begin_inset Formula $M(P)$
\end_inset

 no es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva ya que si lo fuese lo seria tambien 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

.
 Por la Tesis de Church 
\begin_inset Formula $M(P)$
\end_inset

 tampoco es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Supongamos 
\begin_inset Formula $\Sigma\supseteq\Sigma_{p}$
\end_inset

.
 Sea 
\begin_inset Formula $f=\lambda\mathcal{P}\left[T^{0,1}(\mathcal{P},\mathcal{P})\right]$
\end_inset

.
 Note que 
\begin_inset Formula $D_{f}=A$
\end_inset

 y 
\begin_inset Formula $f(\mathcal{P})$
\end_inset

 es la cantidad de pasos en la que 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene partiendo de 
\begin_inset Formula $\left\Vert \mathcal{P}\right\Vert $
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 No hay ninguna funcion 
\begin_inset Formula $F:\mathrm{Pro}^{\Sigma}\rightarrow\omega$
\end_inset

 la cual sea 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva y extienda a 
\begin_inset Formula $f$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos hay una tal 
\begin_inset Formula $F$
\end_inset

.
 Notese que 
\begin_inset Formula $AutoHalt^{\Sigma}=\lambda\mathcal{P}\left[Halt^{0,1}(F(\mathcal{P}),\mathcal{P},\mathcal{P})\right]$
\end_inset

 lo cual nos dice que 
\begin_inset Formula $AutoHalt^{\Sigma}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursiva, llegando a una contradiccion.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "Seccion estructuras algebraicas ordenadas"

\end_inset

Estructuras algebraicas ordenadas
\end_layout

\begin_layout Standard
En esta seccion estudiaremos varias clases de estructuras algebraicas en
 las cuales hay un orden parcial involucrado.
 Esto tendra una triple utilidad.
 Por un lado algunos de los resultados probados sobre algebras de Boole
 (por ejemplo el teorema de Rasiova y Sikorski) seran utilizados mas adelante
 para la prueba del teorema de completitud de la logica de primer orden.
 Tambien, esta seccion servira para volvernos algebristas maduros (lo mas
 que se pueda) ya que esto nos sera util a la hora de hacer logica matematica.
 La logica matematica es 
\shape italic
matematica aplicada
\shape default
 al estudio de los matematicos, su lenguaje y sus metodos de demostracion,
 y que mas comodo para hacer logica matematica que contar con un matematico
 dentro de uno mismo para estudiarlo!
\end_layout

\begin_layout Standard
Finalmente cabe destacar que los resultados cubiertos en esta seccion son
 importantes en si mismos fuera de su vinculacion con la logica y tienen
 fuertes aplicaciones en otras disciplinas y ramas de la matematica.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Conjuntos parcialmente ordenados
\end_layout

\begin_layout Standard
Recordamos que tal como se lo definio en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "ordenes parciales"
plural "false"
caps "false"
noprefix "false"

\end_inset

, una relacion binaria 
\begin_inset Formula $\leq$
\end_inset

 sobre un conjunto 
\begin_inset Formula $P$
\end_inset

 es llamada un 
\shape italic
orden parcial sobre 
\shape default

\begin_inset Formula $P$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset


\shape default
si se cumplen las siguientes condiciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\leq$
\end_inset

 es reflexiva, i.
 e.
 para todo 
\begin_inset Formula $a\in P$
\end_inset

, 
\begin_inset Formula $a\leq a$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\leq$
\end_inset

 es antisimetrica, i.
 e.
 para todo 
\begin_inset Formula $a,b\in P$
\end_inset

, si 
\begin_inset Formula $a\leq b$
\end_inset

 y 
\begin_inset Formula $b\leq a$
\end_inset

, entonces 
\begin_inset Formula $a=b.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $\leq$
\end_inset

 es transitiva, i.
 e.
 para todo 
\begin_inset Formula $a,b,c\in P$
\end_inset

, si 
\begin_inset Formula $a\leq b$
\end_inset

 y 
\begin_inset Formula $b\leq c$
\end_inset

, entonces 
\begin_inset Formula $a\leq c$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
(recomendamos antes de leer este tema, leer la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "ordenes parciales"
plural "false"
caps "false"
noprefix "false"

\end_inset

, para familiarizarse con la notacion y las propiedades basicas de los ordenes
 parciales).
\end_layout

\begin_layout Standard
Un 
\shape italic
conjunto parcialmente ordenado
\shape default
 
\shape italic
o poset
\shape default
 es un par 
\begin_inset Formula $(P,\leq)$
\end_inset

 donde 
\begin_inset Formula $P$
\end_inset

 es un conjunto no vacio cualquiera y 
\begin_inset Formula $\leq$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $P$
\end_inset

.
 Dado un poset 
\begin_inset Formula $(P,\leq)$
\end_inset

, el conjunto 
\begin_inset Formula $P$
\end_inset

 sera llamado el 
\shape italic
universo
\shape default
 de 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset


\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

 es un poset, donde 
\begin_inset Formula $\leq$
\end_inset

 es el orden usual de los numeros relales
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset


\begin_inset Formula $(\{1,2,3\},\{(1,2),(1,3),(1,1),(2,2),(3,3)\})$
\end_inset

 es un poset
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset


\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

 es un poset, donde 
\begin_inset Formula $\mathrm{\leq}=\{(S,T)\in\mathcal{P}(\omega)^{2}:S\subseteq T\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset


\begin_inset Formula $(\{1\},\{(1,1)\}$
\end_inset

 es un poset
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E5)
\end_layout

\end_inset


\begin_inset Formula $(\mathbf{N},\leq)$
\end_inset

 es un poset, donde 
\begin_inset Formula $\mathrm{\leq}=\{(n,m)\in\mathbf{N}^{2}:n\mid m\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E6)
\end_layout

\end_inset


\begin_inset Formula $(A,\{(a,b):a=b\})$
\end_inset

 es un poset, cualesquiera sea el conjunto no vacio 
\begin_inset Formula $A$
\end_inset

 
\end_layout

\begin_layout Standard
Usaremos la siguiente
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Convencion notacional 1
\end_layout

\end_inset

Si hemos denotado con 
\begin_inset Formula $\leq$
\end_inset

 a cierto orden parcial sobre un conjunto 
\begin_inset Formula $A$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
Denotaremos con 
\begin_inset Formula $<$
\end_inset

 a la relacion binaria 
\begin_inset Formula $\{(a,b)\in A^{2}:a\leq b$
\end_inset

 y 
\begin_inset Formula $a\neq b\}$
\end_inset

.
 Es decir que 
\begin_inset Formula $\mathrm{<}=\{(a,b)\in A^{2}:a\leq b$
\end_inset

 y 
\begin_inset Formula $a\neq b\}$
\end_inset

.
 Cuando se de 
\begin_inset Formula $a<b$
\end_inset

 diremos que 
\begin_inset Formula $a$
\end_inset

 
\shape italic
es menor que 
\shape default

\begin_inset Formula $b$
\end_inset

 o que 
\begin_inset Formula $b$
\end_inset

 
\shape italic
es mayor que 
\shape default

\begin_inset Formula $a$
\end_inset

 (
\shape italic
respecto de 
\shape default

\begin_inset Formula $\leq$
\end_inset

)
\end_layout

\begin_layout Enumerate
Denotaremos con 
\begin_inset Formula $\prec$
\end_inset

 a la relacion binaria
\begin_inset Formula 
\[
\{(a,b)\in A^{2}:a<b\text{ y no existe }z\text{ tal que }a<z<b\}
\]

\end_inset

Cuando se de 
\begin_inset Formula $a\prec b$
\end_inset

 diremos que 
\begin_inset Formula $a$
\end_inset

 
\shape italic
es cubierto por 
\shape default

\begin_inset Formula $b$
\end_inset

 o que 
\begin_inset Formula $b$
\end_inset

 
\shape italic
cubre a 
\shape default

\begin_inset Formula $a$
\end_inset

 (
\shape italic
respecto de 
\shape default

\begin_inset Formula $\leq$
\end_inset

).
 
\end_layout

\end_deeper
\begin_layout Standard
El mismo tipo de convencion notacional se hara cuando denotemos con 
\begin_inset Formula $\leq^{\prime}$
\end_inset

 (o 
\begin_inset Formula $\tilde{\leq}$
\end_inset

, etc) a un orden parcial sobre 
\begin_inset Formula $A$
\end_inset

.
 Es decir tendremos dos relaciones binarias nuevas tacitamente definidas,
 a saber:
\begin_inset Formula 
\begin{align*}
 & \mathrm{<}^{\prime}=\{(a,b)\in A^{2}:a\leq^{\prime}b\text{ y }a\neq b\}\\
 & \mathrm{\prec}^{\prime}=\{(a,b)\in A^{2}:a<^{\prime}b\text{ y no existe }z\text{ tal que }a<^{\prime}z<^{\prime}b\}
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Diagramas de Hasse
\end_layout

\begin_layout Standard
Dado un poset 
\begin_inset Formula $(P,\leq)$
\end_inset

, con 
\begin_inset Formula $P$
\end_inset

 un conjunto finito, podemos realizar un diagrama llamado 
\shape italic
diagrama de Hasse,
\shape default
 siguiendo las siguientes instrucciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Asociar en forma inyectiva, a cada 
\begin_inset Formula $a\in$
\end_inset

 
\begin_inset Formula $P$
\end_inset

 un punto 
\begin_inset Formula $p_{a}$
\end_inset

 del plano
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Trazar un segmento de recta uniendo los puntos 
\begin_inset Formula $p_{a}$
\end_inset

 y 
\begin_inset Formula $p_{b}$
\end_inset

, cada vez que 
\begin_inset Formula $a\prec b$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Realizar lo indicado en los puntos (1) y (2) en tal forma que
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(i)
\end_layout

\end_inset

Si 
\begin_inset Formula $a\prec b$
\end_inset

, entonces 
\begin_inset Formula $p_{a}$
\end_inset

 esta por debajo de 
\begin_inset Formula $p_{b}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(ii)
\end_layout

\end_inset

Si un punto 
\begin_inset Formula $p_{a}$
\end_inset

 ocurre en un segmento del diagrama entonces lo hace en alguno de sus extremos.
 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
La relacion de orden 
\begin_inset Formula $\leq$
\end_inset

 puede ser facilmente obtenida a partir del diagrama, a saber, 
\begin_inset Formula $a\leq b$
\end_inset

 sucedera si y solo si 
\begin_inset Formula $p_{a}=p_{b}$
\end_inset

 o hay una sucesion de segmentos ascendentes desde 
\begin_inset Formula $p_{a}$
\end_inset

 hasta 
\begin_inset Formula $p_{b}$
\end_inset

.
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Elementos maximales, maximos, minimales y minimos
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(P,\leq)$
\end_inset

 un poset.
 Diremos que 
\begin_inset Formula $a\in P$
\end_inset

 es un elemento 
\shape italic
maximal de 
\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

 si no existe un 
\begin_inset Formula $b\in P$
\end_inset

 tal que 
\begin_inset Formula $a<b$
\end_inset

.
 Diremos que 
\begin_inset Formula $a\in P$
\end_inset

 es un elemento 
\shape italic
maximo de 
\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

 si 
\begin_inset Formula $b\leq a$
\end_inset

, para todo 
\begin_inset Formula $b\in P$
\end_inset

.
 En forma analoga se definen los conceptos de elemento 
\shape italic
minimal 
\shape default
y 
\shape italic
minimo
\shape default
.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\leq$
\end_inset

 el orden usual de los numeros reales.
 El poset 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

 no tiene elemento maximo ni minimo.
 Tampoco tiene elementos maximales ni minimales.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

El poset 
\begin_inset Formula $\mathbf{P}=(\{1,2,3\},\{(1,2),(1,3),(1,1),(2,2),(3,3)\})$
\end_inset

 no tiene elemento maximo.
 
\begin_inset Formula $1$
\end_inset

 es un elemento minimo de 
\begin_inset Formula $\mathbf{P}$
\end_inset

.
 El unico elemento minimal de 
\begin_inset Formula $\mathbf{P}$
\end_inset

 es 
\begin_inset Formula $1$
\end_inset

.
 Los elementos 
\begin_inset Formula $2$
\end_inset

 y 
\begin_inset Formula $3$
\end_inset

 son los unicos maximales de 
\begin_inset Formula $\mathbf{P}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset


\begin_inset Formula $1$
\end_inset

 es un elemento maximo de del poset 
\begin_inset Formula $(\{1\},\{(1,1)\})$
\end_inset

.
 Tambien 
\begin_inset Formula $1$
\end_inset

 es un elemento minimo de 
\begin_inset Formula $(\{1\},\{(1,1)\})$
\end_inset

.
 
\end_layout

\begin_layout Standard
Como lo muestra el ejemplo (E3), no siempre hay elementos maximales o maximos
 en un poset.
 Ademas un poset tiene a lo sumo un maximo y un minimo (por que?), los cuales
 en caso de existir algunas veces seran denotados con 
\begin_inset Formula $1$
\end_inset

 y 
\begin_inset Formula $0$
\end_inset

, respectivamente.
 Tambien diremos que 
\begin_inset Formula $(P,\leq)$
\end_inset

 
\shape italic
tiene un
\shape default
 
\begin_inset Formula $1$
\end_inset

 (resp.
 
\begin_inset Formula $0$
\end_inset

) para expresar que 
\begin_inset Formula $(P,\leq)$
\end_inset

 tiene un elemento maximo (resp.
 minimo).
 Notese tambien que todo elemento maximo (resp.
 minimo) de 
\begin_inset Formula $(P,\leq)$
\end_inset

 es un elemento maximal (resp.
 minimal) de 
\begin_inset Formula $(P,\leq)$
\end_inset

 (por que?).
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Supremos
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(P,\leq)$
\end_inset

 un poset.
 Dado 
\begin_inset Formula $S\subseteq P$
\end_inset

, diremos que un elemento 
\begin_inset Formula $a\in P$
\end_inset

 es 
\shape italic
cota superior de 
\shape default

\begin_inset Formula $S$
\end_inset

 
\shape italic
en 
\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

 cuando 
\begin_inset Formula $b\leq a$
\end_inset

, para todo 
\begin_inset Formula $b\in S$
\end_inset

.
 Notese que todo elemento de 
\begin_inset Formula $P$
\end_inset

 es cota superior de 
\begin_inset Formula $\emptyset$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Un elemento 
\begin_inset Formula $a\in P$
\end_inset

 sera llamado 
\shape italic
supremo de 
\shape default

\begin_inset Formula $S$
\end_inset

 
\shape italic
en 
\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

 cuando se den las siguientes dos propiedades
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $a$
\end_inset

 es a cota superior de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $b\in P$
\end_inset

, si 
\begin_inset Formula $b$
\end_inset

 es una cota superior de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

, entonces 
\begin_inset Formula $a\leq b$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Consideremos el poset 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

, donde 
\begin_inset Formula $\leq$
\end_inset

 es el orden usual de los numeros reales.
 Notese que ningun elemento de 
\begin_inset Formula $\mathbf{R}$
\end_inset

 es cota superior de 
\begin_inset Formula $\omega$
\end_inset

 en 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

.
 O sea que ningun elemento de 
\begin_inset Formula $\mathbf{R}$
\end_inset


\begin_inset space \space{}
\end_inset

es supremo de 
\begin_inset Formula $\omega$
\end_inset

 en 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

.
 Sea
\begin_inset Formula 
\begin{align*}
S & =\{-1/n:n\in\mathbf{N}\}\\
 & =\{-1,-1/2,-1/3,...\}
\end{align*}

\end_inset

Es facil ver que 
\begin_inset Formula $0$
\end_inset

 es supremo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Consideremos el poset 
\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

, donde 
\begin_inset Formula $\mathrm{\leq}=\{(A,B)\in\mathcal{P}(\omega)^{2}:A\subseteq B\}$
\end_inset

.
 Sean 
\begin_inset Formula $A,B\in\mathcal{P}(\omega)$
\end_inset

.
 Es facil ver que 
\begin_inset Formula $A\cup B$
\end_inset

 es supremo de 
\begin_inset Formula $\{A,B\}$
\end_inset

 en 
\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como lo muestra el ejemplo (E1) no siempre existe un supremo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Ademas notese que en caso de existir es unico, es decir, si 
\begin_inset Formula $a$
\end_inset

 es supremo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

 y 
\begin_inset Formula $a^{\prime}$
\end_inset

 es supremo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

, entonces 
\begin_inset Formula $a=a^{\prime}$
\end_inset

 (por que?).
 Esto nos permite hablar de EL supremo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

, cuando exista.
 Denotaremos con 
\begin_inset Formula $\sup(S)$
\end_inset

 al supremo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

, en caso de que exista.
 A veces para hacer mas dinamicos los enunciados en lugar de escribir 
\begin_inset Formula $z$
\end_inset

 es supremo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

 escribiremos 
\begin_inset Formula $z=\sup(S)$
\end_inset

 o 
\begin_inset Formula $\sup(S)=z$
\end_inset

.
\end_layout

\begin_layout Standard
Notese que (E1) nos muestra que no siempre el supremo de un conjunto pertenece
 al conjunto.
 Notese ademas que, en caso de existir, el supremo del conjunto 
\begin_inset Formula $\emptyset$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

 es un elemento minimo de 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Esto es porque todo elemento de 
\begin_inset Formula $P$
\end_inset

 es cota superior de 
\begin_inset Formula $\emptyset$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Daremos otro ejemplo muy importante pero antes un poco de matematica basica.
 Recordemos que dados 
\begin_inset Formula $x,y\in\mathbf{N}$
\end_inset

 decimos que 
\begin_inset Formula $x$
\end_inset

 
\shape italic
es multiplo de 
\shape default

\begin_inset Formula $y$
\end_inset

 cuando 
\begin_inset Formula $y$
\end_inset

 divide a 
\begin_inset Formula $x$
\end_inset

.
 Ademas, por definicion, el 
\shape italic
minimo comun multiplo de 
\shape default

\begin_inset Formula $x$
\end_inset

 
\shape italic
e
\shape default
 
\begin_inset Formula $y$
\end_inset

 es el menor elemento del conjunto 
\begin_inset Formula $\{z\in\mathbf{N}:z$
\end_inset

 es multiplo de 
\begin_inset Formula $x$
\end_inset

 y de 
\begin_inset Formula $y\}$
\end_inset

.
 El minimo comun multiplo de 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 se denota con 
\begin_inset Formula $mcm(x,y)$
\end_inset

.
 Una propiedad importante es la siguiente:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset

Si 
\begin_inset Formula $z$
\end_inset

 es multiplo de 
\begin_inset Formula $x$
\end_inset

 y de 
\begin_inset Formula $y$
\end_inset

, entonces 
\begin_inset Formula $mcm(x,y)|z$
\end_inset

, es decir no solo 
\begin_inset Formula $mcm(x,y)$
\end_inset

 es menor o igual a cada multiplo comun de 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

, sino que 
\begin_inset Formula $mcm(x,y)$
\end_inset

 divide a cada multiplo comun de 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 
\end_layout

\begin_layout Standard
Un ejemplo importante de existencia de supremos es el siguiente:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Consideremos el poset 
\begin_inset Formula $(\mathbf{N},D)$
\end_inset

, donde 
\begin_inset Formula $D=\{(x,y)\in\mathbf{N}^{2}:x|y\}$
\end_inset

.
 Dados 
\begin_inset Formula $x,y\in\mathbf{N}$
\end_inset

, se tiene que 
\begin_inset Formula $mcm(x,y)$
\end_inset

 es el supremo de 
\begin_inset Formula $\{x,y\}$
\end_inset

 en 
\begin_inset Formula $(\mathbf{N},D)$
\end_inset

.
 Es claro que 
\begin_inset Formula $mcm(x,y)$
\end_inset

 es cota superior de 
\begin_inset Formula $\{x,y\}$
\end_inset

 en 
\begin_inset Formula $(\mathbf{N},D)$
\end_inset

.
 Ademas la propiedad (*) nos asegura que la propiedad (2) de la definicion
 de supremo se cumple.
 No es obvio que se cumple (2) de la definicion de supremo? Por que es necesario
 aplicar la propiedad (*)? 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Infimos
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(P,\leq)$
\end_inset

 un poset.
 Dado 
\begin_inset Formula $S\subseteq P$
\end_inset

, diremos que un elemento 
\begin_inset Formula $a\in P$
\end_inset

 es 
\shape italic
cota inferior
\shape default
 
\shape italic
de 
\shape default

\begin_inset Formula $S$
\end_inset

 
\shape italic
en 
\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

, cuando 
\begin_inset Formula $a\leq b$
\end_inset

, para cada 
\begin_inset Formula $b\in S$
\end_inset

.
 Notese que todo elemento de 
\begin_inset Formula $P$
\end_inset

 es cota inferior de 
\begin_inset Formula $\emptyset$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Un elemento 
\begin_inset Formula $a\in P$
\end_inset

 sera llamado 
\shape italic
infimo de 
\shape default

\begin_inset Formula $S$
\end_inset

 
\shape italic
en 
\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

 cuando se den las siguientes dos propiedades
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $a$
\end_inset

 es a cota inferior de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $b\in P$
\end_inset

, si 
\begin_inset Formula $b$
\end_inset

 es una cota inferior de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

, entonces 
\begin_inset Formula $b\leq a$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Consideremos el poset 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

, donde 
\begin_inset Formula $\leq$
\end_inset

 es el orden usual de los numeros reales.
 Notese que ningun elemento de 
\begin_inset Formula $\mathbf{R}$
\end_inset

 es cota inferior de 
\begin_inset Formula $\mathbf{Z}$
\end_inset

 en 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

.
 O sea que ningun elemento de 
\begin_inset Formula $\mathbf{R}$
\end_inset


\begin_inset space \space{}
\end_inset

es infimo de 
\begin_inset Formula $\mathbf{Z}$
\end_inset

 en 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

.
 Sea
\begin_inset Formula 
\begin{align*}
S & =\{1/n:n\in\mathbf{N}\}\\
 & =\{1,1/2,1/3,...\}
\end{align*}

\end_inset

Es facil ver que 
\begin_inset Formula $0$
\end_inset

 es infimo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

.
 Notar que 
\begin_inset Formula $\inf S\notin S$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Consideremos el poset 
\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

, donde 
\begin_inset Formula $\mathrm{\leq}=\{(A,B)\in\mathcal{P}(\omega)^{2}:A\subseteq B\}$
\end_inset

.
 Sean 
\begin_inset Formula $A,B\in\mathcal{P}(\omega)$
\end_inset

.
 Es facil ver que 
\begin_inset Formula $A\cap B$
\end_inset

 es infimo de 
\begin_inset Formula $\{A,B\}$
\end_inset

 en 
\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como lo muestra el ejemplo (E1) no siempre existe un infimo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Ademas notese que en caso de existir es unico, es decir, si 
\begin_inset Formula $a$
\end_inset

 es infimo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

 y 
\begin_inset Formula $a^{\prime}$
\end_inset

 es infimo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

, entonces 
\begin_inset Formula $a=a^{\prime}$
\end_inset

 (por que?).
 Esto nos permite hablar de EL infimo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

, cuando exista.
 Denotaremos con 
\begin_inset Formula $\inf(S)$
\end_inset

 al infimo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

, en caso de que exista.
 A veces para hacer mas dinamicos los enunciados en lugar de escribir 
\begin_inset Formula $z$
\end_inset

 es infimo de 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

 escribiremos 
\begin_inset Formula $z=\inf(S)$
\end_inset

 o 
\begin_inset Formula $\inf(S)=z$
\end_inset

.
\end_layout

\begin_layout Standard
Notese que (E1) nos muestra que no siempre el infimo de un conjunto pertenece
 al conjunto.
 Notese ademas que en caso de existir el infimo del conjunto 
\begin_inset Formula $\emptyset$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

 es un elemento maximo de 
\begin_inset Formula $(P,\leq)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Daremos otro ejemplo muy importante pero antes un poco de matematica basica.
 Recordemos que dados 
\begin_inset Formula $x,y\in\mathbf{N}$
\end_inset

, por definicion, el 
\shape italic
maximo comun divisor de 
\shape default

\begin_inset Formula $x$
\end_inset

 
\shape italic
e
\shape default
 
\begin_inset Formula $y$
\end_inset

 es el mayor elemento del conjunto 
\begin_inset Formula $\{z\in\mathbf{N}:z|x$
\end_inset

 y 
\begin_inset Formula $z|y\}$
\end_inset

.
 El maximo comun divisor de 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 se denota con 
\begin_inset Formula $mcd(x,y)$
\end_inset

.
 Una propiedad importante es la siguiente:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(**)
\end_layout

\end_inset

Si 
\begin_inset Formula $z|x$
\end_inset

 y 
\begin_inset Formula $z|y$
\end_inset

, entonces 
\begin_inset Formula $z|mcd(x,y)$
\end_inset

, es decir no solo 
\begin_inset Formula $mcd(x,y)$
\end_inset

 es mayor o igual a cada divisor comun de 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

, sino que 
\begin_inset Formula $mcd(x,y)$
\end_inset

 es divisible por cada divisor comun de 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 
\end_layout

\begin_layout Standard
Un ejemplo importante de existencia de infimos es el siguiente:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Consideremos el poset 
\begin_inset Formula $(\mathbf{N},D)$
\end_inset

, donde 
\begin_inset Formula $D=\{(x,y)\in\mathbf{N}^{2}:x|y\}$
\end_inset

.
 Dados 
\begin_inset Formula $x,y\in\mathbf{N}$
\end_inset

, se tiene que 
\begin_inset Formula $mcd(x,y)$
\end_inset

 es el infimo de 
\begin_inset Formula $\{x,y\}$
\end_inset

 en 
\begin_inset Formula $(\mathbf{N},D)$
\end_inset

.
 Es claro que 
\begin_inset Formula $mcd(x,y)$
\end_inset

 es cota inferior de 
\begin_inset Formula $\{x,y\}$
\end_inset

 en 
\begin_inset Formula $(\mathbf{N},D)$
\end_inset

.
 Ademas la propiedad (**) nos asegura que la propiedad (2) de la definicion
 de infimo se cumple.
 No es obvio que se cumple (2) de la definicion de infimo? Por que es necesario
 aplicar la propiedad (**)? 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Homomorfismos de posets
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $(P,\leq)$
\end_inset

 y 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

 posets.
 Una funcion 
\begin_inset Formula $F:P\rightarrow P^{\prime}$
\end_inset

 sera llamada un 
\shape italic
homomorfismo de 
\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

 si para todo 
\begin_inset Formula $x,y\in P$
\end_inset

 se cumple que 
\begin_inset Formula $x\leq y$
\end_inset

 implica 
\begin_inset Formula $F(x)\leq^{\prime}F(y)$
\end_inset

.
 Escribiremos 
\begin_inset Formula $F:(P,\leq)\rightarrow(P^{\prime},\leq^{\prime})$
\end_inset


\begin_inset space \space{}
\end_inset

para expresar que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

 en 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset


\begin_inset Formula $F:\mathbf{R}\rightarrow\mathbf{R}$
\end_inset

 dada por 
\begin_inset Formula $F(r)=3.r$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

 en 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\mathrm{\leq}=\{(n,m)\in\omega:n=m\}$
\end_inset

 y sea 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

 un poset cualquiera.
 Entonces cualquier funcion 
\begin_inset Formula $F:\omega\rightarrow P^{\prime}$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(\omega,\leq)$
\end_inset

 en 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

 (glup!)
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Consideremos el poset 
\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

, donde 
\begin_inset Formula $\mathrm{\leq}=\{(A,B)\in\mathcal{P}(\omega)^{2}:A\subseteq B\}$
\end_inset

 y el poset 
\begin_inset Formula $(\mathcal{P}(\{1,2,3,4\}),\leq^{\prime})$
\end_inset

, donde 
\begin_inset Formula $\mathrm{\leq}^{\prime}=\{(A,B)\in\mathcal{P}(\{1,2,3,4\})^{2}:A\subseteq B\}$
\end_inset

.
 Entonces 
\begin_inset Formula $F:\mathcal{P}(\omega)\rightarrow\mathcal{P}(1,2,3,4)$
\end_inset

 dada por 
\begin_inset Formula $F(A)=A\cap\{1,2,3,4\}$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

 en 
\begin_inset Formula $(\mathcal{P}(\{1,2,3,4\}),\leq^{\prime})$
\end_inset

 
\end_layout

\begin_layout Standard
Una funcion 
\begin_inset Formula $F:P\rightarrow P^{\prime}$
\end_inset

 sera llamada un 
\shape italic
isomorfismo de 
\shape default

\begin_inset Formula $(P,\leq)$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset


\begin_inset space \space{}
\end_inset

si 
\begin_inset Formula $F$
\end_inset

 es biyectiva, 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(P,\leq)$
\end_inset

 en 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

 y 
\begin_inset Formula $F^{-1}$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

 en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Escribiremos 
\begin_inset Formula $(P,\leq)\cong(P^{\prime},\leq^{\prime})$
\end_inset


\begin_inset space \space{}
\end_inset

cuando exista un isomorfismo de 
\begin_inset Formula $(P,\leq)$
\end_inset

 en 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

 y en tal caso diremos que 
\begin_inset Formula $(P,\leq)$
\end_inset

 y 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset


\begin_inset space \space{}
\end_inset

son 
\shape italic
isomorfos
\shape default
.
 Cabe observar que un homomorfismo biyectivo no necesariamente es un isomorfismo
 como lo muestra el siguiente ejemplo.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Consideremos los posets 
\begin_inset Formula $\mathbf{P}=(\{1,2\},\{(1,1),(2,2)\})$
\end_inset

 y 
\begin_inset Formula $\mathbf{Q}=(\{1,2\},\{(1,1),(2,2),(1,2)\})$
\end_inset

.
 Es facil ver que 
\begin_inset Formula $F:\{1,2\}\rightarrow\{1,2\}$
\end_inset

, dada por 
\begin_inset Formula $F(1)=1$
\end_inset

 y 
\begin_inset Formula $F(2)=2$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $\mathbf{P}$
\end_inset

 en 
\begin_inset Formula $\mathbf{Q}$
\end_inset

.
 Dejamos al lector chequear que 
\begin_inset Formula $F^{-1}$
\end_inset

 no es un homomorfismo de 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 en 
\begin_inset Formula $\mathbf{P}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Notacion:
\end_layout

\end_inset

Dada una funcion 
\begin_inset Formula $F:A\rightarrow B$
\end_inset

 y 
\begin_inset Formula $S\subseteq A$
\end_inset

, denotaremos con 
\begin_inset Formula $F(S)$
\end_inset

 al conjunto 
\begin_inset Formula $\{F(a):a\in S\}$
\end_inset

 
\end_layout

\begin_layout Standard
El siguiente lema aporta evidencia al hecho de que los isomorfismos preservan
 todas las propiedades matematicas.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "isoposets"

\end_inset

Sean 
\begin_inset Formula $(P,\leq)$
\end_inset

 y 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset


\begin_inset space \space{}
\end_inset

posets.
 Supongamos 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo de 
\begin_inset Formula $(P,\leq)$
\end_inset

 en 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Para 
\begin_inset Formula $x,y\in P$
\end_inset

, tenemos que 
\begin_inset Formula $x<y$
\end_inset

 si y solo si 
\begin_inset Formula $F(x)<^{\prime}F(y)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $x\in P$
\end_inset

, se tiene que 
\begin_inset Formula $x$
\end_inset

 es maximo (resp.
 minimo) de 
\begin_inset Formula $(P,\leq)$
\end_inset

 si y solo si 
\begin_inset Formula $F(x)$
\end_inset

 es maximo (resp.
 minimo) de 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $x\in P$
\end_inset

, se tiene que 
\begin_inset Formula $x$
\end_inset

 es maximal (resp.
 minimal) en 
\begin_inset Formula $(P,\leq)$
\end_inset

 si y solo si 
\begin_inset Formula $F(x)$
\end_inset

 es maximal (resp.
 minimal) en 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(d)
\end_layout

\end_inset

Para 
\begin_inset Formula $x,y\in P$
\end_inset

, tenemos que 
\begin_inset Formula $x\prec y$
\end_inset

 si y solo si 
\begin_inset Formula $F(x)\prec^{\prime}F(y)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(e)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $S\subseteq P$
\end_inset

 y cada 
\begin_inset Formula $a\in P$
\end_inset

, se tiene que 
\begin_inset Formula $a$
\end_inset

 es cota superior (resp.
 inferior) de 
\begin_inset Formula $S$
\end_inset

 si y solo si 
\begin_inset Formula $F(a)$
\end_inset

 es cota superior (resp.
 inferior) de 
\begin_inset Formula $F(S)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(f)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $S\subseteq P$
\end_inset

, se tiene que existe 
\begin_inset Formula $\sup(S)$
\end_inset

 si y solo si existe 
\begin_inset Formula $\sup(F(S))$
\end_inset

 y en el caso de que existan tales elementos se tiene que 
\begin_inset Formula $F(\sup(S))=\sup(F(S))$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(g)
\end_layout

\end_inset

Para 
\begin_inset Formula $x,y,z\in P$
\end_inset

, tenemos que 
\begin_inset Formula $z=\sup\{x,y\}$
\end_inset

 si y solo si 
\begin_inset Formula $F(z)=\sup\{F(x),F(y)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(h)
\end_layout

\end_inset

Para 
\begin_inset Formula $x,y,z\in P$
\end_inset

, tenemos que 
\begin_inset Formula $z=\inf\{x,y\}$
\end_inset

 si y solo si 
\begin_inset Formula $F(z)=\inf\{F(x),F(y)\}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (b) Sea 
\begin_inset Formula $a\in P$
\end_inset

 un elemento fijo.
 Supongamos 
\begin_inset Formula $a\in P$
\end_inset

 es maximo de 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Probaremos que 
\begin_inset Formula $F(a)$
\end_inset

 es maximo de 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

.
 Sea 
\begin_inset Formula $b$
\end_inset

 un elemento fijo pero arbitrario de 
\begin_inset Formula $P^{\prime}$
\end_inset

.
 Probaremos que 
\begin_inset Formula $b\leq^{\prime}F(a)$
\end_inset

.
 Sea 
\begin_inset Formula $d\in P$
\end_inset

 tal que 
\begin_inset Formula $F(d)=b$
\end_inset

 (tal 
\begin_inset Formula $d$
\end_inset

 existe y que 
\begin_inset Formula $F$
\end_inset

 es sobreyectiva).
 Ya que 
\begin_inset Formula $a$
\end_inset

 es maximo de 
\begin_inset Formula $(P,\leq)$
\end_inset

 tenemos que 
\begin_inset Formula $d\leq a$
\end_inset

.
 Ya que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo tenemos que 
\begin_inset Formula $F(d)\leq^{\prime}F(a)$
\end_inset

 por lo cual 
\begin_inset Formula $b\leq^{\prime}F(a)$
\end_inset

 ya que 
\begin_inset Formula $F(d)=b$
\end_inset

.
 Ya que 
\begin_inset Formula $b$
\end_inset

 era arbitrario hemos probado que 
\begin_inset Formula $x\leq^{\prime}F(a)$
\end_inset

 para cada 
\begin_inset Formula $x\in P^{\prime}$
\end_inset

, lo cual por definicion nos dice que 
\begin_inset Formula $F(a)$
\end_inset

 es maximo de 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

.
\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $F(a)$
\end_inset

 es maximo de 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

.
 Probaremos que 
\begin_inset Formula $a$
\end_inset

 es maximo de 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Sea 
\begin_inset Formula $b$
\end_inset

 un elemento fijo pero arbitrario de 
\begin_inset Formula $P$
\end_inset

.
 Probaremos que 
\begin_inset Formula $b\leq a$
\end_inset

.
 Ya que 
\begin_inset Formula $F(a)$
\end_inset

 es maximo de 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

 tenemos que 
\begin_inset Formula $F(b)\leq^{\prime}F(a)$
\end_inset

.
 Ya que 
\begin_inset Formula $F^{-1}$
\end_inset

 es un homomorfismo tenemos que 
\begin_inset Formula $F^{-1}(F(b))\leq F^{-1}(F(a))$
\end_inset

, por lo cual 
\begin_inset Formula $b\leq a$
\end_inset

.
 Ya que 
\begin_inset Formula $b$
\end_inset

 era arbitrario hemos probado que 
\begin_inset Formula $x\leq a$
\end_inset

 para cada 
\begin_inset Formula $x\in P$
\end_inset

, lo cual por definicion nos dice que 
\begin_inset Formula $a$
\end_inset

 es maximo de 
\begin_inset Formula $(P,\leq)$
\end_inset

.
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $a$
\end_inset

 era fijo pero arbitrario hemos probado que cualquiera sea 
\begin_inset Formula $x\in P$
\end_inset

, se tiene que 
\begin_inset Formula $x$
\end_inset

 es maximo de 
\begin_inset Formula $(P,\leq)$
\end_inset

 si y solo si 
\begin_inset Formula $F(x)$
\end_inset

 es maximo de 
\begin_inset Formula $(P^{\prime},\leq^{\prime})$
\end_inset

.
\end_layout

\begin_layout Standard
(e) Supongamos que 
\begin_inset Formula $a$
\end_inset

 es cota superior de 
\begin_inset Formula $S$
\end_inset

.
 Veamos que entonces 
\begin_inset Formula $F(a)$
\end_inset

 es cota superior de 
\begin_inset Formula $F(S)$
\end_inset

.
 Sea 
\begin_inset Formula $x\in F(S)$
\end_inset

.
 Sea 
\begin_inset Formula $s\in S$
\end_inset

 tal que 
\begin_inset Formula $x=F(s)$
\end_inset

.
 Ya que 
\begin_inset Formula $s\leq a$
\end_inset

, tenemos que 
\begin_inset Formula $x=F(s)\leq^{\prime}F(a)$
\end_inset

.
 Supongamos ahora que 
\begin_inset Formula $F(a)$
\end_inset

 es cota superior de 
\begin_inset Formula $F(S)$
\end_inset

 y veamos que entonces 
\begin_inset Formula $a$
\end_inset

 es cota superior de 
\begin_inset Formula $S$
\end_inset

.
 Sea 
\begin_inset Formula $s\in S$
\end_inset

.
 Ya que 
\begin_inset Formula $F(s)\leq^{\prime}F(a)$
\end_inset

, tenemos que 
\begin_inset Formula $s=F^{-1}(F(s))\leq F^{-1}(F(a))=a$
\end_inset

.
\end_layout

\begin_layout Standard
(f) Supongamos existe 
\begin_inset Formula $\sup(S)$
\end_inset

.
 Veamos entonces que 
\begin_inset Formula $F(\sup(S))$
\end_inset

 es el supremo de 
\begin_inset Formula $F(S)$
\end_inset

.
 Por (e) 
\begin_inset Formula $F(\sup(S))$
\end_inset

 es cota superior de 
\begin_inset Formula $F(S)$
\end_inset

.
 Supongamos 
\begin_inset Formula $b$
\end_inset

 es cota superior de 
\begin_inset Formula $F(S)$
\end_inset

.
 Entonces 
\begin_inset Formula $F^{-1}(b)$
\end_inset

 es cota superior de 
\begin_inset Formula $S$
\end_inset

, por lo cual 
\begin_inset Formula $\sup(S)\leq F^{-1}(b)$
\end_inset

, produciendo 
\begin_inset Formula $F(\sup(S))\leq^{\prime}b$
\end_inset

.
 En forma analoga se ve que si existe 
\begin_inset Formula $\sup(F(S))$
\end_inset

, entonces 
\begin_inset Formula $F^{-1}(\sup(F(S)))$
\end_inset

 es el supremo de 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard
Las pruebas faltantes son dejadas como ejercicio.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que (d) nos garantiza que si dos posets finitos son isomorfos, entonces
 pueden representarse con el mismo diagrama de Hasse.
\end_layout

\begin_layout Standard
En la prueba de (b) del lema anterior se uso tacitamente la siguiente propiedad
 que es obvia pero clave en la demostracion:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $F$
\end_inset

 es una funcion y 
\begin_inset Formula $b\in\operatorname{Im}(F)$
\end_inset

, entonces 
\begin_inset Formula $b=F(d)$
\end_inset

, para algun 
\begin_inset Formula $d\in D_{F}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Esto da lugar a la siguiente regla la cual es muy util a la hora de hacer
 pruebas:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Regla Pertenecer a la Imagen
\end_layout

\begin_layout Standard
Si ud en el desarrollo de una prueba conoce que un elemento 
\begin_inset Formula $b$
\end_inset

 esta en la imagen de una funcion 
\begin_inset Formula $F$
\end_inset

, entonces escriba al elemento 
\begin_inset Formula $b$
\end_inset

 en la forma 
\begin_inset Formula $F(a)$
\end_inset

, donde 
\begin_inset Formula $a$
\end_inset

 denota algun elemento fijo del dominio de 
\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Muchas veces tener presente dicha regla es la diferencia a que a uno le
 salga o no una prueba determinada.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Version geometrica del concepto de reticulado
\end_layout

\begin_layout Standard
El concepto de reticulado puede ser abordado en dos formas distintas, una
 geometrica (via posets) y la otra algebraica (via estructuras algebraicas
 definidas ecuacionalmente).
 Como veremos mas adelante ambas definiciones son equivalentes.
\end_layout

\begin_layout Standard
Diremos que un poset 
\begin_inset Formula $(P,\leq)$
\end_inset

 es un 
\shape italic
reticulado
\shape default
 si para todo 
\begin_inset Formula $a,b\in P$
\end_inset

, existen (en 
\begin_inset Formula $(P,\leq)$
\end_inset

) 
\begin_inset Formula $\sup(\{a,b\})$
\end_inset

 e 
\begin_inset Formula $\inf(\{a,b\})$
\end_inset

.
 algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

El poset 
\begin_inset Formula $(\mathbf{N},D)$
\end_inset

 es un reticulado (
\begin_inset Formula $D=\{(x,y)\in\mathbf{N}^{2}:x|y\}$
\end_inset

) ya que dados 
\begin_inset Formula $x,y\in\mathbf{N}$
\end_inset

, hemos visto que 
\begin_inset Formula $mcd(x,y)$
\end_inset

 y 
\begin_inset Formula $mcm(x,y)$
\end_inset

 son infimo y supremo del conjunto 
\begin_inset Formula $\{x,y\}$
\end_inset

 en 
\begin_inset Formula $(\mathbf{N},D)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

El poset 
\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

 es un reticulado (
\begin_inset Formula $\mathrm{\leq}=\{(A,B)\in\mathcal{P}(\omega)^{2}:A\subseteq B\}$
\end_inset

) ya que dados 
\begin_inset Formula $A,B\in\mathcal{P}(\omega)$
\end_inset

, hemos visto que 
\begin_inset Formula $A\cap B$
\end_inset

 y 
\begin_inset Formula $A\cup B$
\end_inset

 son infimo y supremo del conjunto 
\begin_inset Formula $\{A,B\}$
\end_inset

 en 
\begin_inset Formula $(\mathcal{P}(\omega),\leq)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que dado un conjunto 
\begin_inset Formula $A$
\end_inset

, por una 
\shape italic
operacion binaria sobre 
\shape default

\begin_inset Formula $A$
\end_inset

 entenderemos una funcion cuyo dominio es 
\begin_inset Formula $A^{2}$
\end_inset

 y cuya imagen esta contenida en 
\begin_inset Formula $A$
\end_inset

.
 En un reticulado 
\begin_inset Formula $(P,\leq)$
\end_inset

 tenemos dos operaciones binarias naturalmente definidas:
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathsf{s}:P^{2} & \rightarrow & P\\
(a,b) & \rightarrow & \sup(\{a,b\})
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl}
\mathsf{i}:P^{2} & \rightarrow & P\\
(a,b) & \rightarrow & \inf(\{a,b\})
\end{array}
\]

\end_inset

Escribiremos 
\begin_inset Formula $a\mathsf{\;s\;}b$
\end_inset

 en lugar de 
\begin_inset Formula $\mathsf{s}(a,b)$
\end_inset

 y 
\begin_inset Formula $a\mathsf{\;i\;}b$
\end_inset

 en lugar de 
\begin_inset Formula $\mathsf{i}(a,b)$
\end_inset

.
\end_layout

\begin_layout Standard
A continuacion nos dedicaremos a probar varias propiedades agradables que
 se cumplen en un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

.
 Recomendamos al lector que en algunos casos practique encontrando pruebas
 perfectas.
 Esto lo entrenara en su capacidad de ser un matematico maduro, la cual
 sera crucial a la hora de hacer logica ya que la logica estudia (modeliza)
 matematicamente el funcionar de un matematico y sera muy practico que cada
 uno cuente con un matematico maduro en su propia mente
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basicasRet1"

\end_inset

Dado un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

 se cumplen las siguientes.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $x\leq x$
\end_inset

 
\begin_inset Formula $\mathsf{s}$
\end_inset

 
\begin_inset Formula $y$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $x\;\mathsf{i\;}y\leq x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $x\;\mathsf{s}\;x=x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;i\;}x=x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset


\begin_inset Formula $x\;\mathsf{s}\;y=y\;\mathsf{s}\;x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;i\;}y=y\mathsf{\;i\;}x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Prueba perfecta de (1).
 Sean 
\begin_inset Formula $a,b\in L$
\end_inset

, fijos.
 Por definicion de 
\begin_inset Formula $\mathsf{s}$
\end_inset

 tenemos que 
\begin_inset Formula $a$
\end_inset

 
\begin_inset Formula $\mathsf{s}$
\end_inset

 
\begin_inset Formula $b=\sup(\{a,b\})$
\end_inset

.
 O sea que por definicion de supremo de un conjunto tenemos que 
\begin_inset Formula $a$
\end_inset

 
\begin_inset Formula $\mathsf{s}$
\end_inset

 
\begin_inset Formula $b$
\end_inset

 es cota superior del conjunto 
\begin_inset Formula $\{a,b\}$
\end_inset

 en 
\begin_inset Formula $(L\leq)$
\end_inset

.
 O sea que 
\begin_inset Formula $a\leq a$
\end_inset

 
\begin_inset Formula $\mathsf{s}$
\end_inset

 
\begin_inset Formula $b$
\end_inset

.
 Ya que 
\begin_inset Formula $a,b$
\end_inset

 eran arbitrarios, hemos probado que vale (1).
\end_layout

\begin_layout Standard
Prueba perfecta de (3).
 Sea 
\begin_inset Formula $a\in L$
\end_inset

, fijo.
 Por definicion de 
\begin_inset Formula $\mathsf{s}$
\end_inset

 tenemos que 
\begin_inset Formula $a$
\end_inset

 
\begin_inset Formula $\mathsf{s}$
\end_inset

 
\begin_inset Formula $a=\sup(\{a,a\})=\sup(\{a\})$
\end_inset

.
 O sea que debemos probar que 
\begin_inset Formula $a=\sup(\{a\})$
\end_inset

.
 Es claro que 
\begin_inset Formula $a$
\end_inset

 es cota superior de 
\begin_inset Formula $\{a\}$
\end_inset

.
 Ademas es claro que si 
\begin_inset Formula $z$
\end_inset

 es cota superior de 
\begin_inset Formula $\{a\}$
\end_inset

, entonces 
\begin_inset Formula $z\geq a$
\end_inset

.
 O sea que por definicion de supremo de un conjunto tenemos que 
\begin_inset Formula $a=\sup(\{a\})$
\end_inset

.
 O sea que hemos probado que 
\begin_inset Formula $a\mathsf{\;s\;}a=a$
\end_inset

.
 Ya que 
\begin_inset Formula $a$
\end_inset

 era arbitrario, hemos probado que vale (3).
\end_layout

\begin_layout Standard
Dejamos al lector completar la prueba.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basicasRet2"

\end_inset

Dado un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

 se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $x\leq y$
\end_inset

 si y solo si 
\begin_inset Formula $x\;\mathsf{s}\;y=y$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $x\leq y$
\end_inset

 si y solo si 
\begin_inset Formula $x\;\mathsf{i}\;y=x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ejercicio 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Las siguientes dos propiedades son conocidas como leyes de absorcion (por
 que?)
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basicasRet3"

\end_inset

Dado un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

, se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $x\;\mathsf{s}\;(x\mathsf{\;i\;}y)=x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;i\;}(x\;\mathsf{s}\;y)=x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1).
 Sean 
\begin_inset Formula $a,b\in L$
\end_inset

, fijos.
 Por definicion de 
\begin_inset Formula $\mathsf{i}$
\end_inset

 debemos probar que 
\begin_inset Formula $\sup(\{a,a\mathsf{\;i\;}b\})=a$
\end_inset

.
 O sea debemos probar que 
\begin_inset Formula $a$
\end_inset

 es la menor cota superior de 
\begin_inset Formula $\{a,a\mathsf{\;i\;}b\}$
\end_inset

.
 Por un lema anterior tenemos que 
\begin_inset Formula $a\mathsf{\;i\;}b\leq a$
\end_inset

 y obviamente se da 
\begin_inset Formula $a\leq a$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $a$
\end_inset

 es cota superior de 
\begin_inset Formula $\{a,a\mathsf{\;i\;}b\}$
\end_inset

.
 Es claro que es menor o igual que cualquier otra cota superior.
 O sea que hemos probado que 
\begin_inset Formula $a\;\mathsf{s}\;(a\mathsf{\;i\;}b)=a$
\end_inset

, lo cual ya que 
\begin_inset Formula $a,b$
\end_inset

 eran elementos arbitrarios nos dice que vale (1).
\end_layout

\begin_layout Standard
(2) es dejada al lector.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Antes de seguir dando propiedades basicas de los reticulados daremos tres
 reglas que seran de suma utilidad para encontrar pruebas.
 Dejamos al lector justificar matematicamente la validez de dichas reglas.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Regla Igualdad en Posets
\end_layout

\begin_layout Standard
Si ud esta intentando probar que en un poset 
\begin_inset Formula $(P,\leq)$
\end_inset

 dos elementos 
\begin_inset Formula $x,y$
\end_inset

 son iguales, desdoble su tarea en las dos tareas siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Probar que 
\begin_inset Formula $x\leq y$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Probar que 
\begin_inset Formula $y\leq x$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Regla Superar un Supremo
\end_layout

\begin_layout Standard
Si ud esta intentando probar que en un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

 se da que 
\begin_inset Formula $z\geq x\;\mathsf{s}\;y$
\end_inset

, desdoble su tarea en las dos tareas siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Probar que 
\begin_inset Formula $z\geq x$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Probar que 
\begin_inset Formula $z\geq y$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Regla Ser Menor o Igual que un Infimo
\end_layout

\begin_layout Standard
Si ud esta intentando probar que en un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

 se da que 
\begin_inset Formula $z\leq x\;\mathsf{i}\;y$
\end_inset

, desdoble su tarea en las dos tareas siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Probar que 
\begin_inset Formula $z\leq x$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Probar que 
\begin_inset Formula $z\leq y$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ambas operaciones 
\begin_inset Formula $\mathsf{s}$
\end_inset


\begin_inset space \space{}
\end_inset

e 
\begin_inset Formula $\mathsf{i}$
\end_inset


\begin_inset space \space{}
\end_inset

son asociativas, es decir:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basicasRet4"

\end_inset

Dado un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

, se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $(x\;\mathsf{s}\;y)\;\mathsf{s}\;z=x\;\mathsf{s}\;(y\;\mathsf{s}\;z)$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $(x\mathsf{\;i\;}y)\mathsf{\;i\;}z=x\mathsf{\;i\;}(y\mathsf{\;i\;}z)$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in L$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Sean 
\begin_inset Formula $a,b,c\in L$
\end_inset

, fijos.
 Usaremos la regla Igualdad en Posets.
 Primero probaremos 
\begin_inset Formula $(a\;\mathsf{s}\;b)\;\mathsf{s}\;c\leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)$
\end_inset

.
 Para esto usaremos la regla Superar un Supremo.
 Es decir que debemos probar que
\begin_inset Formula 
\begin{align*}
(a\;\mathsf{s}\;b) & \leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)\\
c & \leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)
\end{align*}

\end_inset

Para la primer desigualdad usaremos tambien la regla Superar un Supremo,
 por lo cual deberemos probar
\begin_inset Formula 
\begin{align*}
a & \leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)\\
b & \leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)
\end{align*}

\end_inset

O sea que en suma debemos probar las siguientes desigualdades
\begin_inset Formula 
\begin{align*}
a & \leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)\\
b & \leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)\\
c & \leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)
\end{align*}

\end_inset

La primera es directa de un lema anterior, y para la segunda notese que
 el mismo lema nos dice que
\begin_inset Formula 
\[
b\leq(b\;\mathsf{s}\;c)\text{ y }(b\;\mathsf{s}\;c)\leq a\;\mathsf{s}\;(b\;\mathsf{s}\;c)
\]

\end_inset

por lo cual solo resta usar que 
\begin_inset Formula $\leq$
\end_inset

 es transitiva.
 La tercera es completamente analoga a la segunda.
\end_layout

\begin_layout Standard
En forma similar se prueba que 
\begin_inset Formula $a\;\mathsf{s}\;(b\;\mathsf{s}\;c)\leq(a\;\mathsf{s}\;b)\;\mathsf{s}\;c$
\end_inset

.
 Es decir que por la regla Igualdad en Posets tenemos que 
\begin_inset Formula $a\;\mathsf{s}\;(b\;\mathsf{s}\;c)=(a\;\mathsf{s}\;b)\;\mathsf{s}\;c$
\end_inset

.
 Ya que 
\begin_inset Formula $a,b,c$
\end_inset

 eran elementos arbitrarios hemos probado que vale (1).
\end_layout

\begin_layout Standard
(2) es dejada como ejercicio.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente lema prueba que en un reticulado las operaciones 
\begin_inset Formula $\mathsf{s}$
\end_inset


\begin_inset space \space{}
\end_inset

e 
\begin_inset Formula $\mathsf{i}$
\end_inset


\begin_inset space \space{}
\end_inset

preservan el orden.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basicasRet5"

\end_inset

Dado un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

, se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $x\leq z$
\end_inset

 e 
\begin_inset Formula $y\leq w$
\end_inset

 implica 
\begin_inset Formula $x\;\mathsf{s}\ y\leq z\;\mathsf{s}\ w$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z,w\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $x\leq z$
\end_inset

 e 
\begin_inset Formula $y\leq w$
\end_inset

 implica 
\begin_inset Formula $x\mathsf{\;i\;}y\leq z\mathsf{\;i\;}w$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z,w\in L$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Sean 
\begin_inset Formula $a,b,c,d\in L$
\end_inset

, elementos fijos.
 Supongamos que 
\begin_inset Formula $a\leq c$
\end_inset

 e 
\begin_inset Formula $b\leq d$
\end_inset

.
 Probaremos que entonces 
\begin_inset Formula $a\;\mathsf{s}\ b\leq c\;\mathsf{s}\ d$
\end_inset

.
 Por la regla Superar un Supremo basta con probar que
\begin_inset Formula 
\begin{align*}
a & \leq c\;\mathsf{s}\;d\\
b & \leq c\;\mathsf{s}\;d
\end{align*}

\end_inset

Para ver que 
\begin_inset Formula $a\leq c\;\mathsf{s}\;d$
\end_inset

 notese que 
\begin_inset Formula $a\leq c$
\end_inset

 (por hipotesis) y 
\begin_inset Formula $c\leq c\;\mathsf{s}\;d$
\end_inset

, por lo cual podemos usar que 
\begin_inset Formula $\leq$
\end_inset

 es transitiva.
 La desigualdad 
\begin_inset Formula $b\leq c\;\mathsf{s}\;d$
\end_inset

 se prueba en forma similar.
 O sea que hemos probado que
\begin_inset Formula 
\[
a\leq c\text{ y }b\leq d\text{ implica }a\;\mathsf{s}\ b\leq c\;\mathsf{s}\ d
\]

\end_inset

Ya que 
\begin_inset Formula $a,b,c,d$
\end_inset

 eran elementos arbitrarios hemos probado que vale (1).
\end_layout

\begin_layout Standard
(2) es dejada al lector 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basicasRet6"

\end_inset

Dado un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

, se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(x\mathsf{\;i\;}y)\;\mathsf{s}\;(x\mathsf{\;i\;}z)\leq x\mathsf{\;i\;}(y\;\mathsf{s}\;z)$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in L$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sean 
\begin_inset Formula $a,b,c\in L$
\end_inset

, elementos fijos.
 Por la regla Superar un Supremo, basta con probar que
\begin_inset Formula 
\begin{align*}
a\mathsf{\;i\;}b & \leq a\mathsf{\;i\;}(b\;\mathsf{s}\;c)\\
a\mathsf{\;i\;}c & \leq a\mathsf{\;i\;}(b\;\mathsf{s}\;c)
\end{align*}

\end_inset

Pero estas dos desigualdades pueden ser facilmente probadas aplicando (2)
 del lema anterior.
 O sea que 
\begin_inset Formula $(a\mathsf{\;i\;}b)\;\mathsf{s}\;(a\mathsf{\;i\;}c)\leq a\mathsf{\;i\;}(b\;\mathsf{s}\;c)$
\end_inset

, de lo cual se deduce nuestro lema ya que 
\begin_inset Formula $a,b,c$
\end_inset

 eran elementos arbitrarios.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Iterar supremos (resp.
 infimos) da supremos (resp.
 infimos), es decir:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(L,\leq)$
\end_inset

 un reticulado.
 Se tiene que
\begin_inset Formula 
\begin{align*}
(...(x_{1}\;\mathsf{s\;}x_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}x_{n} & =\sup(\{x_{1},...,x_{n}\})\\
(...(x_{1}\mathsf{\;i\;}x_{2})\mathsf{\;i\;}...)\mathsf{\;i\;}x_{n} & =\inf(\{x_{1},...,x_{n}\})
\end{align*}

\end_inset

cualesquiera sean los elementos 
\begin_inset Formula $x_{1},...,x_{n}\in L$
\end_inset

, con 
\begin_inset Formula $n\geq2$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por induccion en 
\begin_inset Formula $n$
\end_inset

.
 Claramente el resultado vale para 
\begin_inset Formula $n=2$
\end_inset

.
 Supongamos vale para 
\begin_inset Formula $n$
\end_inset

 y veamos entonces que vale para 
\begin_inset Formula $n+1$
\end_inset

.
 Sean 
\begin_inset Formula $a_{1},...,a_{n+1}\in L$
\end_inset

, fijos.
 Por hipotesis inductiva tenemos que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $(...(a_{1}\;\mathsf{s}\;a_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}a_{n}=\sup(\{a_{1},...,a_{n}\})$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Veamos entonces que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $((...(a_{1}\;\mathsf{s\;}a_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}a_{n})\;\mathsf{s\;}a_{n+1}=\sup(\{a_{1},...,a_{n+1}\})$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Usando (1), es facil ver que 
\begin_inset Formula $((...(a_{1}\;\mathsf{s\;}a_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}a_{n})\;\mathsf{s\;}a_{n+1}$
\end_inset

 es cota superior de 
\begin_inset Formula $\{a_{1},...,a_{n+1}\}$
\end_inset

.
 Supongamos que 
\begin_inset Formula $z$
\end_inset

 es otra cota superior.
 Ya que 
\begin_inset Formula $z$
\end_inset

 es tambien cota superior del conjunto 
\begin_inset Formula $\{a_{1},...,a_{n}\}$
\end_inset

, por (1) tenemos que
\begin_inset Formula 
\[
(...(a_{1}\;\mathsf{s\;}a_{2})\;\mathsf{s}\;...)\;\mathsf{s\;}a_{n}\leq z
\]

\end_inset

Pero entonces ya que 
\begin_inset Formula $a_{n+1}\leq z$
\end_inset

, tenemos que
\begin_inset Formula 
\[
((...(a_{1}\;\mathsf{s\;}a_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}a_{n})\;\mathsf{s\;}a_{n+1}\leq z
\]

\end_inset

con lo cual hemos probado (2).
 Ya que 
\begin_inset Formula $a_{1},...,a_{n+1}\in L$
\end_inset

 eran elementos arbitrarios, hemos probado que vale el enunciado del lema
 para 
\begin_inset Formula $n+1$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dado que la distribucion de parentesis en una expresion de la forma
\begin_inset Formula 
\[
(...(x_{1}\;\mathsf{s\;}x_{2})\;\mathsf{s\;}...)\;\mathsf{s\;}x_{n}
\]

\end_inset

es irrelevante (ya que
\begin_inset Formula $\;\mathsf{s\;}$
\end_inset

es asociativa), en general suprimiremos los parentesis.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Concluimos esta subseccion enunciando una regla que hemos usado constantemente:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Regla Igualar un Supremo
\end_layout

\begin_layout Enumerate
Si ud esta intentando probar que en un poset 
\begin_inset Formula $(P,\leq)$
\end_inset

 se da que 
\begin_inset Formula $x=\sup(S)$
\end_inset

, desdoble su tarea en las dos tareas siguientes:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Probar que 
\begin_inset Formula $x$
\end_inset

 es cota superior de 
\begin_inset Formula $S$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Probar que si 
\begin_inset Formula $z$
\end_inset

 es una cota superior de 
\begin_inset Formula $S$
\end_inset

, entonces 
\begin_inset Formula $x\leq z$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Las cinco reglas consideradas estan muy vinculadas al concepto de inteligencia
 artificial ya que si quisieramos hacer un probador automatico del tipo
 de teoremas hechos en esta subseccion, claramente estas reglas le darian
 una alternativa de busqueda que podria (y de hecho lo hace) dar el camino
 adecuado para obtener la prueba de un enunciado dado.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Version algebraica del concepto de reticulado
\end_layout

\begin_layout Standard
De la diversas propiedades de las operaciones s e i de un reticulado 
\begin_inset Formula $(L,\leq)$
\end_inset

 distinguiremos las siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I1)
\end_layout

\end_inset


\begin_inset Formula $x\;\mathsf{s}\;x=x\mathsf{\;i\;}x=x$
\end_inset

, cualesquiera sea 
\begin_inset Formula $x\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I2)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;s\;}y=y\;\mathsf{s}\;x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I3)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;i\;}y=y\mathsf{\;i\;}x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I4)
\end_layout

\end_inset


\begin_inset Formula $(x\mathsf{\;s\;}y)\;\mathsf{s}\;z=x\;\mathsf{s}\;(y\;\mathsf{s}\;z)$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I5)
\end_layout

\end_inset


\begin_inset Formula $(x\mathsf{\;i\;}y)\mathsf{\;i\;}z=x\mathsf{\;i\;}(y\mathsf{\;i\;}z)$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I6)
\end_layout

\end_inset


\begin_inset Formula $x\;\mathsf{s}\;(x\mathsf{\;i\;}y)=x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I7)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;i\;}(x\;\mathsf{s}\;y)=x$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset

 
\end_layout

\begin_layout Standard
Podemos abstraernos y pensar que s e i son dos operaciones cualesquiera
 sobre un conjunto 
\begin_inset Formula $L$
\end_inset

 arbitrario y estudiar cuando se satisfacen y cuando no dichas propiedades.
 Por ejemplo si tomamos 
\begin_inset Formula $L=\mathbf{R}$
\end_inset

 y
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathsf{s}:\mathbf{R}^{2} & \rightarrow & \mathbf{R}\\
(a,b) & \rightarrow & a+b
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl}
\mathsf{i}:\mathbf{R}^{2} & \rightarrow & \mathbf{R}\\
(a,b) & \rightarrow & a.b
\end{array}
\]

\end_inset

entonces se cumplen (I2), (I3), (I4) e (I5), pero (I1), (I6) e (I7)
\begin_inset space \space{}
\end_inset

no se cumplen.
 Otro ejemplo, si tomamos 
\begin_inset Formula $L=\{1,2\}$
\end_inset

 y
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathsf{s}:\{1,2\}^{2} & \rightarrow & \{1,2\}\\
(1,1) & \rightarrow & 1\\
(1,2) & \rightarrow & 2\\
(2,1) & \rightarrow & 1\\
(2,2) & \rightarrow & 2
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl}
\mathsf{i}:\{1,2\}^{2} & \rightarrow & \{1,2\}\\
(1,1) & \rightarrow & 1\\
(1,2) & \rightarrow & 1\\
(2,1) & \rightarrow & 1\\
(2,2) & \rightarrow & 1
\end{array}
\]

\end_inset

entonces se cumplen (I3), (I4) e (I5), pero (I1), (I2), (I6) e (I7)
\begin_inset space \space{}
\end_inset

no se cumplen.
 Un tercer ejemplo, si tomamos 
\begin_inset Formula $L=\mathbf{N}$
\end_inset

 y
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathsf{s}:\mathbf{N}^{2} & \rightarrow & \mathbf{N}\\
(a,b) & \rightarrow & \max\{a,b\}
\end{array}\ \ \ \ \ \ \begin{array}{rcl}
\mathsf{i}:\mathbf{N}^{2} & \rightarrow & \mathbf{N}\\
(a,b) & \rightarrow & \text{maximo comun divisor de }a\text{ y }b
\end{array}
\]

\end_inset

entonces se cumplen (I1), (I2), (I3), (I4), (I5) e (I6), pero (I7)
\begin_inset space \space{}
\end_inset

no se cumple.
 Por supuesto si s e i son las operaciones supremo e infimo dadas por algun
 orden parcial 
\begin_inset Formula $\leq$
\end_inset

 sobre 
\begin_inset Formula $L$
\end_inset

 el cual hace de 
\begin_inset Formula $(L,\leq)$
\end_inset

 un reticulado, entonces las propedades (I1),...,(I7) se cumplen y esto es
 justamente lo probado en la ultima serie de lemas.
 El ultimo ejemplo nos permite ver una sutileza.
 Notese que en este ejemplo s es la operacion supremo del reticulado 
\begin_inset Formula $(\mathbf{N},\leq)$
\end_inset

, donde 
\begin_inset Formula $\leq$
\end_inset

 es el orden usual de los naturales, e i es la operacion infimo del reticulado
 
\begin_inset Formula $(\mathbf{N},|)$
\end_inset

, donde 
\begin_inset Formula $|$
\end_inset

 es el orden de la divisibilidad de los naturales.
 Sin envargo la ultima propiedad falla y esto se debe a que s e i son supremo
 e infimo pero respecto de distintos ordenes parciales.
\end_layout

\begin_layout Standard
Lo anterior motiva la siguiente definicion: Una terna 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

, donde 
\begin_inset Formula $L$
\end_inset

 es un conjunto no vacio y 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

 son dos operaciones binarias sobre 
\begin_inset Formula $L$
\end_inset

 sera llamada 
\shape italic
reticulado
\shape default
 cuando cumpla (I1),...,(I7).
 Si 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 es un reticulado, llamaremos a 
\begin_inset Formula $L$
\end_inset

 el 
\shape italic
universo 
\shape default
de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Observacion importante:
\series default
 Notese que hemos llamado a ciertos posets reticulados y a ciertas ternas
 reticulados pero deberia quedar claro que nunca un poset que es un reticulado
 puede ser igual a una terna que es un reticulado ya que son objetos matematicos
 de distinta naturaleza.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tal como lo vimos recien, las ternas dadas por los tres ejemplos anteriores
 no son reticulados ya que fallan alguna de las identidades (I1),...,(I7),
 y si tomamos un poset 
\begin_inset Formula $(L,\leq)$
\end_inset

 el cual sea un reticulado, entonces la terna 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

, con 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

 definidas como supremo e infimo, es un reticulado.
 El siguiente teorema muestra que todo reticulado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 se obtiene de esta forma.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "equivalencia"

\end_inset

Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado.
 La relacion binaria definida por:
\begin_inset Formula 
\[
x\leq y\text{ si y solo si }x\;\mathsf{s}\;y=y
\]

\end_inset

es un orden parcial sobre 
\begin_inset Formula $L$
\end_inset

 para el cual se cumple que:
\begin_inset Formula 
\begin{align*}
\sup(\{x,y\}) & =x\;\mathsf{s}\;y\\
\inf(\{x,y\}) & =x\mathsf{\;i\;}y
\end{align*}

\end_inset

cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dejamos como ejercicio para el lector probar que 
\begin_inset Formula $\leq$
\end_inset

 es reflexiva y antisimetrica con respecto a 
\begin_inset Formula $L$
\end_inset

.
 Veamos que 
\begin_inset Formula $\leq$
\end_inset

 es transitiva con respecto a 
\begin_inset Formula $L$
\end_inset

.
 Supongamos que 
\begin_inset Formula $x\leq y$
\end_inset

 e 
\begin_inset Formula $y\leq z$
\end_inset

.
 Es decir que por definicion de 
\begin_inset Formula $\leq$
\end_inset

 tenemos que
\begin_inset Formula 
\begin{align*}
x\;\mathsf{s}\;y & =y\\
y\;\mathsf{s}\;z & =z
\end{align*}

\end_inset

Entonces
\begin_inset Formula 
\[
x\;\mathsf{s\;}z=x\;\mathsf{s\;}(y\;\mathsf{s\;}z)=(x\;\mathsf{s\;}y)\;\mathsf{s\;}z=y\;\mathsf{s\;}z=z
\]

\end_inset

por lo cual 
\begin_inset Formula $x\leq z$
\end_inset

.
 O sea que ya sabemos que 
\begin_inset Formula $(L,\leq)$
\end_inset

 es un poset.
 Veamos ahora que 
\begin_inset Formula $\sup(\{x,y\})=x\;\mathsf{s\;}y$
\end_inset

.
 Primero debemos ver que 
\begin_inset Formula $x\;\mathsf{s\;}y$
\end_inset

 es una cota superior del conjunto 
\begin_inset Formula $\{x,y\}$
\end_inset

, es decir
\begin_inset Formula 
\begin{align*}
x & \leq x\;\mathsf{s}\;y\\
y & \leq x\;\mathsf{s}\;y
\end{align*}

\end_inset

Por la definicion de 
\begin_inset Formula $\leq$
\end_inset

 debemos probar que
\begin_inset Formula 
\begin{align*}
x\ \mathsf{s}\;(x\;\mathsf{s}\;y) & =x\;\mathsf{s}\;y\\
y\ \mathsf{s}\;(x\;\mathsf{s}\;y) & =x\;\mathsf{s}\;y
\end{align*}

\end_inset

Estas igualdades se pueden probar usando (I1), (I2) y (I4).
 Dejamos al lector hacerlo como ejercicio.
\end_layout

\begin_layout Standard
Nos falta ver entonces que 
\begin_inset Formula $x\;\mathsf{s\;}y$
\end_inset

 es menor o igual que cualquier cota superior de 
\begin_inset Formula $\{x,y\}$
\end_inset

.
 Supongamos 
\begin_inset Formula $x,y\leq z$
\end_inset

.
 Es decir que por definicion de 
\begin_inset Formula $\leq$
\end_inset

 tenemos que
\begin_inset Formula 
\begin{align*}
x\;\mathsf{s}\;z & =z\\
y\;\mathsf{s}\;z & =z
\end{align*}

\end_inset

Pero entonces
\begin_inset Formula 
\[
(x\;\mathsf{s\;}y)\;\mathsf{s\;}z=x\;\mathsf{s\;}(y\;\mathsf{s\;}z)=x\;\mathsf{s\;}z=z
\]

\end_inset

por lo que 
\begin_inset Formula $x\;\mathsf{s\;}y\leq z$
\end_inset

.
 Es decir que 
\begin_inset Formula $x\;\mathsf{s\;}y$
\end_inset

 es la menor cota superior.
\end_layout

\begin_layout Standard
Para probar que 
\begin_inset Formula $\inf(\{x,y\})=x\mathsf{\;i\;}y$
\end_inset

, probaremos que para todo 
\begin_inset Formula $u,v\in L$
\end_inset

,
\begin_inset Formula 
\[
u\leq v\text{ si y solo si }u\mathsf{\;i\;}v=u
\]

\end_inset

lo cual le permitira al lector aplicar un razonamiento similar al usado
 en la prueba de que 
\begin_inset Formula $\sup(\{x,y\})=x\;\mathsf{s\;}y$
\end_inset

.
 Supongamos que 
\begin_inset Formula $u\leq v$
\end_inset

.
 Por definicion tenemos que 
\begin_inset Formula $u\;\mathsf{s}\;v=v$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
u\mathsf{\;i\;}v=u\mathsf{\;i\;}(u\;\mathsf{s}\;v)
\]

\end_inset

Pero por (I7) tenemos que 
\begin_inset Formula $u\mathsf{\;i\;}(u\;\mathsf{s}\;v)=u$
\end_inset

, lo cual implica 
\begin_inset Formula $u\mathsf{\;i\;}v=u$
\end_inset

.
 Reciprocamente si 
\begin_inset Formula $u\mathsf{\;i\;}v=u$
\end_inset

, entonces
\begin_inset Formula 
\begin{align*}
u\;\mathsf{s}\;v & =(u\mathsf{\;i\;}v)\;\mathsf{s}\;v\\
 & =v\;\mathsf{s}\;(u\mathsf{\;i\;}v)\text{ (por (I2))}\\
 & =v\;\mathsf{s}\;(v\mathsf{\;i\;}u)\text{ (por (I3))}\\
 & =v\text{ (por (I6))}
\end{align*}

\end_inset

lo cual nos dice que 
\begin_inset Formula $u\leq v$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejercicio:
\end_layout

\end_inset

Use los resultados anteriores para definir una funcion 
\begin_inset Formula $\mathcal{F}$
\end_inset

 de 
\begin_inset Formula $\{(L,\leq):(L,\leq)$
\end_inset

 es un reticulado
\begin_inset Formula $\}$
\end_inset

 en 
\begin_inset Formula $\{(L,\mathsf{s},\mathsf{i}):(L,\mathsf{s},\mathsf{i})$
\end_inset

 es un reticulado
\begin_inset Formula $\}$
\end_inset

 la cual sea biyectiva 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Refleccion Informatica
\end_layout

\begin_layout Standard
Como vimos recien a nivel de informacion es lo mismo tener un poset que
 es un reticulado que una terna que es un reticulado.
 Es decir, los dos conceptos pueden considerarse dos formas distintas de
 presentar la misma informacion.
 Muchas veces es mas facil especificar un reticulado dando el poset ya que
 simplemente podemos dar su diagrama de Hasse y esto en general es una forma
 economica de dar las operaciones s e i.
\end_layout

\begin_layout Standard
Recordemos que algo similar sucedia con los conceptos equivalentes de relacion
 de equivalencia y particion.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
El orden asociado a un reticulado
\end_layout

\begin_layout Standard
Como vimos el teorema de Dedekind nos dice que un reticulado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 es un objeto geometrico ya que si definimos
\begin_inset Formula 
\[
\mathrm{\leq}=\{(x,y):x\;\mathsf{s}\;y=y\}
\]

\end_inset

entonces 
\begin_inset Formula $\leq$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $L$
\end_inset

 y las operaciones 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

 resultan ser supremo e infimo.
 Llamaremos a 
\begin_inset Formula $\mathrm{\leq}=\{(x,y):x\;\mathsf{s}\;y=y\}$
\end_inset

 el 
\shape italic
orden parcial asociado a 
\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y a 
\begin_inset Formula $(L,\leq)$
\end_inset

 el 
\shape italic
poset asociado a 
\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
 Notese que tambien tenemos que 
\begin_inset Formula $\mathrm{\leq}=\{(x,y):x\;\mathsf{i}\;y=x\}$
\end_inset

 (por que?).
 Muchos conceptos definidos para posets ahora pueden aplicarse cuando tenemos
 un reticulado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
 Por ejemplo, si decimos que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 tiene elemento maximo, esto significara que el poset 
\begin_inset Formula $(L,\leq)$
\end_inset

 tiene elemento maximo.
 Otro ejemplo, si decimos que en 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 se da que el supremo de un conjunto 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $a$
\end_inset

, nos estaremos refiriendo a que en su poset asociado 
\begin_inset Formula $(L,\leq)$
\end_inset

 se da que el supremo de 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Notacion
\end_layout

\begin_layout Standard
Usaremos las siguientes practicas convenciones notacionales
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Convencion notacional 1:
\end_layout

\end_inset

Si 
\begin_inset Formula $L$
\end_inset

 es un conjunto no vacio cuyos elementos son conjuntos y 
\begin_inset Formula $L$
\end_inset

 cumple la siguiente condicion
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $A,B\in L$
\end_inset

, entonces 
\begin_inset Formula $A\cup B,A\cap B\in L$
\end_inset

 
\end_layout

\begin_layout Standard
entonces ciertas veces usaremos 
\begin_inset Formula $\cup$
\end_inset

 (resp.
 
\begin_inset Formula $\cap$
\end_inset

) para denotar la operacion binaria sobre 
\begin_inset Formula $L$
\end_inset

 dada por la union (resp.
 la interceccion).
 Es decir 
\begin_inset Formula $\cup$
\end_inset

 e 
\begin_inset Formula $\cap$
\end_inset

 denotaran las funciones
\begin_inset Formula 
\[
\begin{array}{rcl}
L^{2} & \rightarrow & L\\
(A,B) & \rightarrow & A\cup B
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl}
L^{2} & \rightarrow & L\\
(A,B) & \rightarrow & A\cap B
\end{array}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Convencion notacional 2:
\end_layout

\end_inset

Si 
\begin_inset Formula $L$
\end_inset

 es un conjunto no vacio cuyos elementos son numeros reales entonces ciertas
 veces usaremos 
\begin_inset Formula $\max$
\end_inset

 y 
\begin_inset Formula $\min$
\end_inset

 para denotar las operaciones binarias sobre 
\begin_inset Formula $L$
\end_inset

 dadas por
\begin_inset Formula 
\[
\begin{array}{rcl}
L^{2} & \rightarrow & L\\
(a,b) & \rightarrow & \max(a,b)
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl}
L^{2} & \rightarrow & L\\
(a,b) & \rightarrow & \min(a,b)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Convencion notacional 3:
\end_layout

\end_inset

Si 
\begin_inset Formula $L$
\end_inset

 es un conjunto no vacio cuyos elementos son numeros naturales y 
\begin_inset Formula $L$
\end_inset

 cumple la siguiente condicion
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $a,b\in L$
\end_inset

, entonces 
\begin_inset Formula $mcm(a,b),mcd(a,b)\in L$
\end_inset

 
\end_layout

\begin_layout Standard
entonces ciertas veces usaremos 
\begin_inset Formula $mcm$
\end_inset

 y 
\begin_inset Formula $mcd$
\end_inset

 para denotar las operaciones binarias sobre 
\begin_inset Formula $L$
\end_inset

 dadas por
\begin_inset Formula 
\[
\begin{array}{rcl}
L^{2} & \rightarrow & L\\
(a,b) & \rightarrow & mcm(a,b)
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl}
L^{2} & \rightarrow & L\\
(a,b) & \rightarrow & mcd(a,b)
\end{array}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Convencion notacional 4:
\end_layout

\end_inset

Si 
\begin_inset Formula $P$
\end_inset

 es un conjunto no vacio contenido en 
\begin_inset Formula $\mathbf{N}$
\end_inset

, entonces escribiremos 
\begin_inset Formula $(P,|)$
\end_inset

 para denotar al poset 
\begin_inset Formula $(P,\{(x,y)\in P^{2}:x|y\})$
\end_inset

.
 Similarmente si 
\begin_inset Formula $P$
\end_inset

 es un conjunto cuyos elementos son conjuntos, entonces escribiremos 
\begin_inset Formula $(P,\subseteq)$
\end_inset

 para denotar al poset 
\begin_inset Formula $(P,\{(A,B)\in P^{2}:A\subseteq B\})$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
En virtud de las convenciones notacionales anteriores notese que por ejemplo
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathbf{R,}\max,\min)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $([0,1]\mathbf{,}\max,\min)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathcal{P}(\mathbf{N}),\cup,\cap)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{A\subseteq\mathbf{N}:A$
\end_inset

 es finito
\begin_inset Formula $\},\cup,\cap)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathbf{N},mcm,mcd)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{1,2,3,6,12\},mcm,mcd)$
\end_inset

 
\end_layout

\begin_layout Standard
denotan reticulados pero deberia quedar claro que en los primeros dos ejemplos
 
\begin_inset Formula $\max$
\end_inset

 denota dos distintas operaciones.
 Analogamente sucede con 
\begin_inset Formula $\min$
\end_inset

, 
\begin_inset Formula $\cup$
\end_inset

, 
\begin_inset Formula $\cap$
\end_inset

, 
\begin_inset Formula $mcm$
\end_inset

 y 
\begin_inset Formula $mcd$
\end_inset

.
\end_layout

\begin_layout Standard
Similarmente
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathbf{N,}|)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{1,2,3,6,7\},|)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{\{1\},\{1,7\},\{1,2,3\},\{16,99,65\}\},\subseteq)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{A\subseteq\mathbf{N}:A$
\end_inset

 es finito
\begin_inset Formula $\},\subseteq)$
\end_inset

 
\end_layout

\begin_layout Standard
denotan posets pero deberia quedar claro que en los primeros dos ejemplos
 
\begin_inset Formula $|$
\end_inset

 denota dos distintos ordenes parciales.
 Analogamente sucede con 
\begin_inset Formula $\subseteq$
\end_inset


\end_layout

\begin_layout Standard
Estas ambiguedades no nos traeran problemas si estamos atentos al contexto.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Subreticulados
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $f$
\end_inset

 es una operacion 
\begin_inset Formula $n$
\end_inset

-aria sobre 
\begin_inset Formula $A$
\end_inset

 y 
\begin_inset Formula $S\subseteq A$
\end_inset

, entonces diremos que 
\begin_inset Formula $S$
\end_inset

 es 
\shape italic
cerrado bajo
\shape default
 
\begin_inset Formula $f$
\end_inset


\begin_inset VSpace bigskip
\end_inset


\begin_inset space \space{}
\end_inset

cuando se de que 
\begin_inset Formula $f(a_{1},...,a_{n})\in S$
\end_inset

, cada ves que 
\begin_inset Formula $a_{1},...,a_{n}\in S$
\end_inset

.
 Notese que si 
\begin_inset Formula $n=0$
\end_inset

, entonces 
\begin_inset Formula $S$
\end_inset

 es cerrado bajo 
\begin_inset Formula $f$
\end_inset

 si y solo si 
\begin_inset Formula $f(\Diamond)\in S$
\end_inset

.
\end_layout

\begin_layout Standard
Dados reticulados 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 diremos que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 
\shape italic
es un subreticulado de 
\shape default

\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 si se dan las siguientes condiciones
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $L\subseteq L^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $L$
\end_inset

 es cerrado bajo las operaciones 
\begin_inset Formula $\mathsf{s}^{\prime}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $\mathsf{s}=\mathsf{s}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{L\times L}$
\end_inset

 y 
\begin_inset Formula $\mathsf{i}=\mathsf{i}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{L\times L}$
\end_inset

 
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado.
 Un conjunto 
\begin_inset Formula $S\subseteq L$
\end_inset

 es llamado 
\shape italic
subuniverso 
\shape default
de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 si es no vacio y cerrado bajo las operaciones 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

.
 Es importante notar que si bien los conceptos de subreticulado y subuniverso
 estan muy relacionados, se trata de conceptos diferentes ya que los subreticula
dos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 son reticulados, es decir ternas y los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 son conjuntos, por lo cual no son ternas.
\end_layout

\begin_layout Standard
Es facil de chequear que si 
\begin_inset Formula $S$
\end_inset

 es un subuniverso de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

, entonces 
\begin_inset Formula $(S,\mathsf{s}\mathrm{\mid}_{S\times S},\mathsf{i}\mathrm{\mid}_{S\times S})$
\end_inset

 es un subreticulado de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y que todo subreticulado de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 se obtiene en esta forma.
 Es decir, hay una biyeccion entre el conjunto de los subreticulados de
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y el conjunto de los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 (cual es?).
 Dicho de manera mas rapida: los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 son ni mas ni menos que los universos de los subreticulados de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
\end_layout

\begin_layout Subsection
Homomorfismos de reticulados
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 reticulados.
 Una funcion 
\begin_inset Formula $F:L\rightarrow L^{\prime}$
\end_inset

 sera llamada un 
\shape italic
homomorfismo de 
\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 si para todo 
\begin_inset Formula $x,y\in L$
\end_inset

 se cumple que
\begin_inset Formula 
\begin{align*}
F(x\mathsf{\;s\;}y) & =F(x)\;\mathsf{s}^{\prime}\ F(y)\\
F(x\mathsf{\;i\;}y) & =F(x)\;\mathsf{i}^{\prime}\ F(y).
\end{align*}

\end_inset

Un homomorfismo de
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 sera llamado 
\shape italic
isomorfismo de 
\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime}$
\end_inset

, 
\begin_inset Formula $\mathsf{i}^{\prime}$
\end_inset

 
\begin_inset Formula $)$
\end_inset

 cuando sea biyectivo y su inversa sea tambien un homomorfismo.
 Escribiremos 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})\cong(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 cuando exista un isomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

.
 Escribiremos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

Sea 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i})\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 un homomorfismo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 para expresar que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

.
 No hay que confundirse al leer esta notacion y pensar que 
\begin_inset Formula $F$
\end_inset

 es una funcion cuyo dominio es 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

, lo cual por otra parte no tiene sentido ya que el dominio de una funcion
 nunca puede ser una 
\begin_inset Formula $3$
\end_inset

-upla!
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "hom biyect implica iso"

\end_inset

Si 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i})\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 es un homomorfismo biyectivo, entonces 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Solo falta ver que 
\begin_inset Formula $F^{-1}$
\end_inset

 es un homomorfismo.
 Sean 
\begin_inset Formula $F(x),F(y)$
\end_inset

 dos elementos cualesquiera de 
\begin_inset Formula $L^{\prime}$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
F^{-1}(F(x)\;\mathsf{s}^{\prime}\ F(y))=F^{-1}(F(x\mathsf{\;s\;}y))=x\mathsf{\;s\;}y=F^{-1}(F(x))\;\mathsf{s}\ F^{-1}(F(y))
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sean 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 reticulados y sea 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i})\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 un homomorfismo.
 Entonces 
\begin_inset Formula $I_{F}$
\end_inset

 es un subuniverso de 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

.
 Es decir que 
\begin_inset Formula $F$
\end_inset

 es tambien un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(I_{F},\mathsf{s}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{I_{F}\times I_{F}},\mathsf{i}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{I_{F}\times I_{F}})$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $L$
\end_inset

 es no vacio tenemos que 
\begin_inset Formula $I_{F}$
\end_inset

 tambien es no vacio.
 Sean 
\begin_inset Formula $a,b\in I_{F}$
\end_inset

.
 Sean 
\begin_inset Formula $x,y\in L$
\end_inset

 tales que 
\begin_inset Formula $F(x)=a$
\end_inset

 y 
\begin_inset Formula $F(y)=b$
\end_inset

.
 Se tiene que
\begin_inset Formula 
\begin{align*}
a\;\mathsf{s}^{\prime}\ b & =F(x)\;\mathsf{s}^{\prime}\ F(y)=F(x\mathsf{\;s\;}y)\in I_{F}\\
a\;\mathsf{i}^{\prime}\ b & =F(x)\;\mathsf{i}^{\prime}\ F(y)=F(x\mathsf{\;i\;}y)\in I_{F}
\end{align*}

\end_inset

por lo cual 
\begin_inset Formula $I_{F}$
\end_inset

 es cerrada bajo 
\begin_inset Formula $\mathsf{s}^{\prime}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}^{\prime}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sean 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 reticulados y sean 
\begin_inset Formula $(L\leq)$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\leq^{\prime})$
\end_inset

 los posets asociados.
 Sea 
\begin_inset Formula $F:L\rightarrow L^{\prime}$
\end_inset

 una funcion.
 Entonces 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 si y solo si 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo de 
\begin_inset Formula $(L,\leq)$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\leq^{\prime})$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

.
 Sean 
\begin_inset Formula $x,y\in L$
\end_inset

, tales que 
\begin_inset Formula $x\leq y$
\end_inset

.
 Tenemos que 
\begin_inset Formula $y=x\mathsf{\;s\;}y$
\end_inset

 por lo cual 
\begin_inset Formula $F(y)=F(x\mathsf{\;s\;}y)=F(x)\mathsf{\;s^{\prime}\;}F(y)$
\end_inset

, produciendo 
\begin_inset Formula $F(x)\leq^{\prime}F(y)$
\end_inset

.
 En forma similar se puede ver que 
\begin_inset Formula $F^{-1}$
\end_inset

 es tambien un homomorfismo de 
\begin_inset Formula $(L^{\prime},\leq^{\prime})$
\end_inset

 en 
\begin_inset Formula $(L,\leq)$
\end_inset

.
 Si 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo de 
\begin_inset Formula $(L,\leq)$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\leq^{\prime})$
\end_inset

, entonces (g) y (h) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "isoposets"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dicen que 
\begin_inset Formula $F$
\end_inset

 y 
\begin_inset Formula $F^{-1}$
\end_inset

 son homomorfismos (de reticulados terna) por lo cual 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejercicio:
\end_layout

\end_inset

Encontrar dos reticulados, 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

, tales que haya una funcin biyectiva de 
\begin_inset Formula $L$
\end_inset

 en 
\begin_inset Formula $L^{\prime}$
\end_inset

 que preserve orden pero no sea homomorfismo de reticulados.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Congruencias de reticulados
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado.
 Una 
\shape italic
congruencia sobre
\shape default
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 sera una relacion de equivalencia 
\begin_inset Formula $\theta$
\end_inset

 sobre 
\begin_inset Formula $L$
\end_inset

 la cual cumpla:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $x\theta x^{\prime}$
\end_inset

 y 
\begin_inset Formula $y\theta y^{\prime}$
\end_inset

 implica 
\begin_inset Formula $(x\mathsf{\;s\;}y)\theta(x^{\prime}\mathsf{\;s\;}y^{\prime})$
\end_inset

 y 
\begin_inset Formula $(x\mathsf{\;i\;}y)\theta(x^{\prime}\mathsf{\;i\;}y^{\prime})$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Gracias a esta condicion podemos definir sobre 
\begin_inset Formula $L/\theta$
\end_inset

 dos operaciones binarias 
\begin_inset Formula $\mathsf{\tilde{s}}$
\end_inset

 e 
\begin_inset Formula $\mathsf{\tilde{\imath}}$
\end_inset

, de la siguiente manera:
\begin_inset Formula 
\begin{align*}
x/\theta\mathsf{\;\tilde{s}\;}y/\theta & =(x\mathsf{\;s\;}y)/\theta\\
x/\theta\mathsf{\;\tilde{\imath}\;}y/\theta & =(x\mathsf{\;i\;}y)/\theta
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset

Veamos algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Consideremos el reticulado 
\begin_inset Formula $(\{1,2,3,4,5,6\},\max,\min)$
\end_inset

.
 O sea que aqui 
\begin_inset Formula $L=\{1,2,3,4,5,6\}$
\end_inset

, 
\begin_inset Formula $\mathsf{s}$
\end_inset

 es la operacion 
\begin_inset Formula $\max$
\end_inset

 sobre 
\begin_inset Formula $L$
\end_inset

 y 
\begin_inset Formula $\mathsf{i}$
\end_inset

 es la operacion 
\begin_inset Formula $\min$
\end_inset

 sobre 
\begin_inset Formula $L$
\end_inset

.
 Sea 
\begin_inset Formula $\theta$
\end_inset

 la relacion de equivalencia sobre 
\begin_inset Formula $\{1,2,3,4,5,6\}$
\end_inset

 dada por la particion 
\begin_inset Formula $\{\{1,2\},\{3\},\{4,5\}\}$
\end_inset

.
 Se puede chequear que 
\begin_inset Formula $\theta$
\end_inset

 es una congruencia, es decir satisface (1) de arriba.
 Notese que
\begin_inset Formula 
\begin{align*}
L/\theta & =\{\{1,2\},\{3\},\{4,5\}\}\\
\mathsf{\tilde{s}\;} & =\widetilde{\max}:L/\theta\times L/\theta\rightarrow L/\theta\\
\mathsf{\tilde{\imath}\;} & =\widetilde{\min}:L/\theta\times L/\theta\rightarrow L/\theta
\end{align*}

\end_inset

Por ejemplo tenemos que
\begin_inset Formula 
\[
\{1,2\}\ \widetilde{\max}\ \{3\}=\{3\}
\]

\end_inset

ya que 
\begin_inset Formula $\{1,2\}\ \widetilde{\max}\ \{3\}=1/\theta\ \widetilde{\max}\ 3/\theta=(1\max3)/\theta=3/\theta=\{3\}$
\end_inset

 (escribimos 
\begin_inset Formula $1\max3$
\end_inset

 en lugar de 
\begin_inset Formula $\max(1,3)$
\end_inset

).
 Similarmente tenemos que
\begin_inset Formula 
\begin{align*}
\{4,5\}\ \widetilde{\max}\ \{3\} & =\{4,5\}\\
\{1,2\}\ \widetilde{\min}\ \{4,5\} & =\{1,2\}
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Consideremos el reticulado 
\begin_inset Formula $(\{1,2,3,6\},mcm,mcd)$
\end_inset

 (o sea el rombo) y sea 
\begin_inset Formula $\theta$
\end_inset

 la relacion de equivalencia dada por la particion 
\begin_inset Formula $\{\{1,2\},\{3\},\{6\}\}$
\end_inset

 (haga un dibujo).
 Entonces 
\begin_inset Formula $\theta$
\end_inset

 no es una congruencia sobre 
\begin_inset Formula $(\{1,2,3,6\},mcm,mcd)$
\end_inset

.
 Esto es ya que si tomamos 
\begin_inset Formula 
\begin{align*}
x & =1\\
x^{\prime} & =2\\
y & =3\\
y^{\prime} & =3
\end{align*}

\end_inset

no se cumple la implicacion de (1) de la definicion de congruencia.
 
\end_layout

\begin_layout Standard
La terna 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}})$
\end_inset

 es llamada el 
\shape italic
cociente de
\shape default
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 
\shape italic
sobre
\shape default
 
\begin_inset Formula $\theta$
\end_inset

 y la denotaremos con 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})/\theta$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado y sea 
\begin_inset Formula $\theta$
\end_inset

 una congruencia de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
 Entonces 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}})$
\end_inset

 es un reticulado.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Veamos que la estructura 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}})$
\end_inset

 cumple (I4).
 Sean 
\begin_inset Formula $x/\theta$
\end_inset

, 
\begin_inset Formula $y/\theta$
\end_inset

, 
\begin_inset Formula $z/\theta$
\end_inset

 elementos cualesquiera de 
\begin_inset Formula $L/\theta$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\begin{array}{ccl}
(x/\theta\mathsf{\;\tilde{s}\;}y/\theta)\;\mathsf{\tilde{s}}\;z/\theta & = & (x\mathsf{\;s\;}y)/\theta\;\mathsf{\tilde{s}}\;z/\theta\\
 & = & ((x\mathsf{\;s\;}y)\;\mathsf{s}\;z)/\theta\\
 & = & (x\mathsf{\;s\;}(y\;\mathsf{s}\;z))/\theta\\
 & = & x/\theta\;\mathsf{\tilde{s}}\;(y\;\mathsf{s}\;z)/\theta\\
 & = & x/\theta\mathsf{\;\tilde{s}\;}(y/\theta\;\mathsf{\tilde{s}}\;z/\theta)
\end{array}
\]

\end_inset

En forma similar se puede ver que la estructura 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}})$
\end_inset

 cumple el resto de las identidades que definen reticulado.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Denotaremos con 
\begin_inset Formula $\tilde{\leq}$
\end_inset

 al orden parcial asociado al reticulado 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado y sea 
\begin_inset Formula $\theta$
\end_inset

 una congruencia de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
 Entonces:
\begin_inset Formula 
\[
x/\theta\tilde{\leq}y/\theta\text{ sii }y\theta(x\mathsf{\;s\;}y)
\]

\end_inset

cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por definicion de 
\begin_inset Formula $\tilde{\leq}$
\end_inset

 tenemos que 
\begin_inset Formula $x/\theta\tilde{\leq}y/\theta$
\end_inset

 sii 
\begin_inset Formula $y/\theta=x/\theta\mathsf{\;\tilde{s}\;}y/\theta$
\end_inset

.
 Pero 
\begin_inset Formula $x/\theta\mathsf{\;\tilde{s}\;}y/\theta=(x\mathsf{\;s\;}y)/\theta$
\end_inset

 (por definicion de 
\begin_inset Formula $\mathsf{\tilde{s}}$
\end_inset

) por lo cual tenemos que 
\begin_inset Formula $x/\theta\tilde{\leq}y/\theta$
\end_inset

 sii 
\begin_inset Formula $y/\theta=(x\mathsf{\;s\;}y)/\theta$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 
\begin_inset CommandInset label
LatexCommand label
name "1/tita es un maximo de L/tita"

\end_inset

Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado en el cual hay un elemento maximo 
\begin_inset Formula $1$
\end_inset

 (resp.
 minimo 
\begin_inset Formula $0$
\end_inset

).
 Entonces si 
\begin_inset Formula $\theta$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

, 
\begin_inset Formula $1/\theta$
\end_inset

 (resp.
 
\begin_inset Formula $0/\theta$
\end_inset

) es un elemento maximo (resp.
 minimo) de 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}})$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $1=x\mathsf{\;s\;}1$
\end_inset

, para cada 
\begin_inset Formula $x\in L$
\end_inset

, tenemos que 
\begin_inset Formula $1/\theta=(x\mathsf{\;s\;}1)/\theta$
\end_inset

, para cada 
\begin_inset Formula $x\in L$
\end_inset

, lo cual por el lema anterior nos dice que 
\begin_inset Formula $x/\theta\tilde{\leq}1/\theta$
\end_inset

, para cada 
\begin_inset Formula $x\in L$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente lema nos da una forma natural de encontrar congruencias
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i})\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 es un homomorfismo, entonces 
\begin_inset Formula $\ker F$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dejamos al lector ver que 
\begin_inset Formula $\ker F$
\end_inset

 es una relacion de equivalencia.
 Supongamos 
\begin_inset Formula $x\ker Fx^{\prime}$
\end_inset

 y 
\begin_inset Formula $y\ker Fy^{\prime}$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
F(x\mathsf{\;s\;}y)=F(x)\mathsf{\;s^{\prime}\;}F(y)=F(x^{\prime})\mathsf{\;s^{\prime}\;}F(y^{\prime})=F(x^{\prime}\mathsf{\;s\;}y^{\prime})
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $(x\mathsf{\;s\;}y)\ker F(x^{\prime}\mathsf{\;s\;}y^{\prime})$
\end_inset

.
 En forma similar tenemos que 
\begin_inset Formula $(x\mathsf{\;i\;}y)\ker F(x^{\prime}\mathsf{\;i\;}y^{\prime})$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ya vimos que el nucleo de un homomorfismo es una congruencia.
 El siguiente lema muestra que toda congruencia es el nucleo de un homomorfismo.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "pi sub tita es homomorfismo"

\end_inset

Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado y sea 
\begin_inset Formula $\theta$
\end_inset

 una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
 Entonces 
\begin_inset Formula $\pi_{\theta}$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}})$
\end_inset

.
 Ademas 
\begin_inset Formula $\ker\pi_{\theta}=\theta$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sean 
\begin_inset Formula $x,y\in L$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\pi_{\theta}(x\mathsf{\;s\;}y)=(x\mathsf{\;s\;}y)/\theta=x/\theta\mathsf{\;\tilde{s}\;}y/\theta=\pi_{\theta}(x)\mathsf{\;\tilde{s}\;}\pi_{\theta}(y)
\]

\end_inset

por lo cual 
\begin_inset Formula $\pi_{\theta}$
\end_inset

 preserva la operacion supremo.
 Para la operacion infimo es similar.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Reticulados acotados
\end_layout

\begin_layout Standard
\noindent
Por un 
\shape italic
reticulado acotado
\shape default
 entenderemos una 
\begin_inset Formula $5$
\end_inset

-upla 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

, tal que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 es un reticulado, 
\begin_inset Formula $0,1\in L$
\end_inset

, y ademas se cumplen las siguientes identidades
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I8)
\end_layout

\end_inset


\begin_inset Formula $0\mathsf{\;s\;}x=x$
\end_inset

, para cada 
\begin_inset Formula $x\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I9)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;s\;}1=1$
\end_inset

, para cada 
\begin_inset Formula $x\in L$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
Por ejemplo 
\begin_inset Formula $(\{4,56,449\},\max,\min,4,449)$
\end_inset

 es un reticulado acotado pero es facil ver que 
\begin_inset Formula $(\{4,56,449\},\max,\min,449,56)$
\end_inset

 no lo es.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Reflexion Informatica
\end_layout

\begin_layout Standard
Por supuesto, en virtud de lo desarrollado en la subseccion anterior se
 tiene que si 
\begin_inset Formula $(L,\leq)$
\end_inset

 es un poset el cual es un reticulado y en el cual hay un maximo 
\begin_inset Formula $1$
\end_inset

 y un minimo 
\begin_inset Formula $0$
\end_inset

, entonces si tomamos:
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathsf{s}:L^{2} & \rightarrow & L\\
(a,b) & \rightarrow & \sup(\{a,b\})
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl}
\mathsf{i}:L^{2} & \rightarrow & L\\
(a,b) & \rightarrow & \inf(\{a,b\})
\end{array}
\]

\end_inset

tenemos que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 es un reticulado acotado.
 Ademas en virtud del Teorema de Dedekind todo reticulado acotado se obtiene
 de esta forma.
 O sea que a nivel de informacion, un poset que es un reticulado y tiene
 
\begin_inset Formula $0$
\end_inset

 y 
\begin_inset Formula $1$
\end_inset

 es exactamente lo mismo que un reticulado acotado
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Subreticulados acotados
\end_layout

\begin_layout Standard
Dados reticulados acotados 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 diremos que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 
\shape italic
es un subreticulado acotado de 
\shape default

\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 si se dan las siguientes condiciones
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $L\subseteq L^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $L$
\end_inset

 es cerrado bajo las operaciones 
\begin_inset Formula $\mathsf{s}^{\prime}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $0=0^{\prime}$
\end_inset

 y 
\begin_inset Formula $1=1^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $\mathsf{s}=\mathsf{s}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{L\times L}$
\end_inset

 y 
\begin_inset Formula $\mathsf{i}=\mathsf{i}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{L\times L}$
\end_inset

 
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 un reticulado acotado.
 Un conjunto 
\begin_inset Formula $S\subseteq L$
\end_inset

 es llamado 
\shape italic
subuniverso 
\shape default
de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 si 
\begin_inset Formula $0,1\in S$
\end_inset

 y ademas 
\begin_inset Formula $S$
\end_inset

 es cerrado bajo las operaciones 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

.
 Es importante notar que si bien los conceptos de subreticulado acotado
 y subuniverso estan muy relacionados, se trata de conceptos diferentes
 ya que los subreticulados acotados de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 son reticulados acotados, es decir 
\begin_inset Formula $5$
\end_inset

-uplas y los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 son conjuntos, por lo cual no son 
\begin_inset Formula $5$
\end_inset

-uplas.
\end_layout

\begin_layout Standard
Es facil de chequear que si 
\begin_inset Formula $S$
\end_inset

 es un subuniverso de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

, entonces 
\begin_inset Formula $(S,\mathsf{s}\mathrm{\mid}_{S\times S},\mathsf{i}\mathrm{\mid}_{S\times S},0,1)$
\end_inset

 es un subreticulado acotado de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 y que todo subreticulado acotado de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 se obtiene en esta forma.
 Es decir, hay una biyeccion entre el conjunto de los subreticulados acotados
 de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 y el conjunto de los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 (cual es?).
 Dicho de manera mas rapida: los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 son ni mas ni menos que los universos de los subreticulados acotados de
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

.
\end_layout

\begin_layout Subsection
Homomorfismos de reticulados acotados
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 reticulados acotados.
 Una funcion 
\begin_inset Formula $F:L\rightarrow L^{\prime}$
\end_inset

 sera llamada un 
\shape italic
homomorfismo de 
\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 si para todo 
\begin_inset Formula $x,y\in L$
\end_inset

 se cumple que
\begin_inset Formula 
\begin{align*}
F(x\mathsf{\;s\;}y) & =F(x)\;\mathsf{s}^{\prime}\ F(y)\\
F(x\mathsf{\;i\;}y) & =F(x)\;\mathsf{i}^{\prime}\ F(y)\\
F(0) & =0^{\prime}\\
F(1) & =1^{\prime}
\end{align*}

\end_inset

Un homomorfismo de
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 sera llamado 
\shape italic
isomorfismo 
\shape default
cuando sea biyectivo y su inversa sea tambien un homomorfismo.
 Escribiremos 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)\cong(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset


\begin_inset space \space{}
\end_inset

cuando exista un isomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

.
 Escribiremos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

Sea 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i},0,1)\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 un homomorfismo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 para expresar que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

.
 No hay que confundirse al leer esta notacion y pensar que 
\begin_inset Formula $F$
\end_inset

 es una funcion cuyo dominio es 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

, lo cual por otra parte no tiene sentido ya que el dominio de una funcion
 nunca puede ser una 
\begin_inset Formula $5$
\end_inset

-upla!
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i},0,1)\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 un homomorfismo biyectivo, entonces 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Similar a la prueba del Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "hom biyect implica iso"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i},0,1)\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 es un homomorfismo, entonces 
\begin_inset Formula $I_{F}$
\end_inset

 es un subuniverso de 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

.
 Es decir que 
\begin_inset Formula $F$
\end_inset

 es tambien un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 en 
\begin_inset Formula $(I_{F},\mathsf{s}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{I_{F}\times I_{F}},\mathsf{i}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{I_{F}\times I_{F}},0^{\prime},1^{\prime})$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 tenemos que 
\begin_inset Formula $I_{F}$
\end_inset

 es subuniverso de 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 lo cual ya que 
\begin_inset Formula $0^{\prime},1^{\prime}\in I_{F}$
\end_inset

 implica que 
\begin_inset Formula $I_{F}$
\end_inset

 es un subuniverso de 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Congruencias de reticulados acotados
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 un reticulado acotado.
 Una 
\shape italic
congruencia sobre
\shape default
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 sera una relacion de equivalencia 
\begin_inset Formula $\theta$
\end_inset

 la cual sea una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
 Tenemos definidas sobre 
\begin_inset Formula $L/\theta$
\end_inset

 dos operaciones binarias 
\begin_inset Formula $\mathsf{\tilde{s}}$
\end_inset

 e 
\begin_inset Formula $\mathsf{\tilde{\imath}}$
\end_inset

, de la siguiente manera:
\begin_inset Formula 
\begin{align*}
x/\theta\mathsf{\tilde{s}}y/\theta & =(x\mathsf{\;s\;}y)/\theta\\
x/\theta\mathsf{\tilde{\imath}}y/\theta & =(x\mathsf{\;i\;}y)/\theta
\end{align*}

\end_inset

La 
\begin_inset Formula $5$
\end_inset

-upla 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},0/\theta,1/\theta)$
\end_inset

 es llamada el 
\shape italic
cociente de
\shape default
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 
\shape italic
sobre
\shape default
 
\begin_inset Formula $\theta$
\end_inset

 y la denotaremos con 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)/\theta$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "cociente de reticulados acotados"

\end_inset

Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 un reticulado acotado y 
\begin_inset Formula $\theta$
\end_inset

 una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},0/\theta,1/\theta)$
\end_inset

 es un reticulado acotado.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\pi_{\theta}$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 en 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},0/\theta,1/\theta)$
\end_inset

 cuyo nucleo es 
\begin_inset Formula $\theta$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Es facil ver que 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},0/\theta,1/\theta)$
\end_inset

 cumple (I1), (I2),...,(I9) dado que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 las cumple.
\end_layout

\begin_layout Standard
(b) Sigue directamente del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "pi sub tita es homomorfismo"
plural "false"
caps "false"
noprefix "false"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i},0,1)\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 es un homomorfismo de reticulados acotados, entonces 
\begin_inset Formula $\ker F$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})\ $
\end_inset

en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime})$
\end_inset

 tenemos que por un lema anterior 
\begin_inset Formula $\ker F$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 lo cual por definicion nos dice que 
\begin_inset Formula $\ker F$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

.
 
\end_layout

\begin_layout Section
Reticulados complementados
\end_layout

\begin_layout Standard
\noindent
Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 un reticulado acotado.
 Dado 
\begin_inset Formula $a\in L$
\end_inset

, diremos que 
\begin_inset Formula $a$
\end_inset

 es 
\shape italic
complementado
\shape default
 cuando exista un elemento 
\begin_inset Formula $b\in L$
\end_inset

 (llamado 
\shape italic
complemento de a
\shape default
) tal que:
\begin_inset Formula 
\begin{align*}
a\;\mathsf{s\;}b & =1\\
a\;\mathsf{i\;}b & =0
\end{align*}

\end_inset

Notese que dicho elemento 
\begin_inset Formula $b$
\end_inset

 puede no ser unico, es decir 
\begin_inset Formula $a$
\end_inset

 puede tener varios complementos.
 Recordemos que una operacion unaria sobre un conjunto 
\begin_inset Formula $L$
\end_inset

 es por definicion una funcion de 
\begin_inset Formula $L$
\end_inset

 en 
\begin_inset Formula $L$
\end_inset

.
 Muchas veces si 
\begin_inset Formula $s$
\end_inset

 denota una operacion unaria, entonces escribiremos 
\begin_inset Formula $x^{s}$
\end_inset

 en lugar de 
\begin_inset Formula $s(x)$
\end_inset

.
 Por un 
\shape italic
reticulado complementado
\shape default
 entederemos una 
\begin_inset Formula $6$
\end_inset

-upla 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 tal que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 es un reticulado acotado y 
\begin_inset Formula $^{c}$
\end_inset

 es una operacion unaria sobre 
\begin_inset Formula $L$
\end_inset

 tal que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I10)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;s\;}x^{c}=1$
\end_inset

, para cada 
\begin_inset Formula $x\in L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(I11)
\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;i\;}x^{c}=0$
\end_inset

, para cada 
\begin_inset Formula $x\in L$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Dado un reticulado acotado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 puede haber mas de una operacion unaria 
\begin_inset Formula $g$
\end_inset

 tal que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},g,0,1)$
\end_inset

 resulte un reticulado complementado.
 Intente dar un ejemplo en el cual 
\begin_inset Formula $L$
\end_inset

 tenga 5 elementos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Reflexion Informatica
\end_layout

\begin_layout Standard
Notese que si tenemos un poset 
\begin_inset Formula $(L,\leq)$
\end_inset

 el cual es un reticulado en el cual hay un maximo 
\begin_inset Formula $1$
\end_inset

 y un minimo 
\begin_inset Formula $0$
\end_inset

 y ademas tenemos una funcion 
\begin_inset Formula $g:L\rightarrow L$
\end_inset

 tal que
\begin_inset Formula 
\begin{align*}
\sup\{x,g(x)\} & =1\\
\inf\{x,g(x)\} & =0
\end{align*}

\end_inset

para cada 
\begin_inset Formula $x\in L$
\end_inset

, entonces podemos definir
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathsf{s}:L^{2} & \rightarrow & L\\
(a,b) & \rightarrow & \sup(\{a,b\})
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rcl}
\mathsf{i}:L^{2} & \rightarrow & L\\
(a,b) & \rightarrow & \inf(\{a,b\})
\end{array}
\]

\end_inset

y se obtiene que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},g,0,1)$
\end_inset

 es un reticulado complementado.
 Ademas en virtud del Teorema de Dedekind todo reticulado complementado
 se obtiene de esta forma.
 O sea que a nivel de informacion, tener un poset que es un reticulado con
 
\begin_inset Formula $0$
\end_inset

 y 
\begin_inset Formula $1$
\end_inset

 junto con una operacion unaria que da complementos, es exactamente lo mismo
 que tener un reticulado acotado
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Subreticulados complementados
\end_layout

\begin_layout Standard
Dados reticulados complementados 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 diremos que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 
\shape italic
es un subreticulado complementado de 
\shape default

\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 si se dan las siguientes condiciones
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $L\subseteq L^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $L$
\end_inset

 es cerrado bajo las operaciones 
\begin_inset Formula $\mathsf{s}^{\prime}$
\end_inset

, 
\begin_inset Formula $\mathsf{i}^{\prime}$
\end_inset

 y 
\begin_inset Formula $^{c^{\prime}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $0=0^{\prime}$
\end_inset

 y 
\begin_inset Formula $1=1^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $\mathsf{s}=\mathsf{s}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{L\times L}$
\end_inset

, 
\begin_inset Formula $\mathsf{i}=\mathsf{i}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{L\times L}$
\end_inset

 y 
\begin_inset Formula $^{c}=\ ^{c^{\prime}}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{L}$
\end_inset

 
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 un reticulado complementado.
 Un conjunto 
\begin_inset Formula $S\subseteq L$
\end_inset

 es llamado 
\shape italic
subuniverso 
\shape default
de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 si 
\begin_inset Formula $0,1\in S$
\end_inset

 y ademas 
\begin_inset Formula $S$
\end_inset

 es cerrado bajo las operaciones 
\begin_inset Formula $\mathsf{s}$
\end_inset

, 
\begin_inset Formula $\mathsf{i}$
\end_inset

 y 
\begin_inset Formula $^{c}$
\end_inset

.
 Es importante notar que si bien los conceptos de subreticulado complementado
 y subuniverso estan muy relacionados, se trata de conceptos diferentes
 ya que los subreticulados complementados de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 son reticulados complementados, es decir 
\begin_inset Formula $6$
\end_inset

-uplas y los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 son conjuntos, por lo cual no son 
\begin_inset Formula $6$
\end_inset

-uplas.
\end_layout

\begin_layout Standard
Es facil de chequear que si 
\begin_inset Formula $S$
\end_inset

 es un subuniverso de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

, entonces 
\begin_inset Formula $(S,\mathsf{s}\mathrm{\mid}_{S\times S},\mathsf{i}\mathrm{\mid}_{S\times S},,^{c}\mathrm{\mid}_{S},0,1)$
\end_inset

 es un subreticulado complementado de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 y que todo subreticulado complementado de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 se obtiene en esta forma.
 Es decir, hay una biyeccion entre el conjunto de los subreticulados complementa
dos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 y el conjunto de los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 (cual es?).
 Dicho de manera mas rapida: los subuniversos de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 son ni mas ni menos que los universos de los subreticulados complementados
 de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

.
\end_layout

\begin_layout Subsection
Homomorfismos de reticulados complementados
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 y 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 reticulados complementados.
 Una funcion 
\begin_inset Formula $F:L\rightarrow L^{\prime}$
\end_inset

 sera llamada un 
\shape italic
homomorfismo de 
\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 si para todo 
\begin_inset Formula $x,y\in L$
\end_inset

 se cumple que
\begin_inset Formula 
\begin{align*}
F(x\mathsf{\;s\;}y) & =F(x)\;\mathsf{s}^{\prime}\ F(y)\\
F(x\mathsf{\;i\;}y) & =F(x)\;\mathsf{i}^{\prime}\ F(y)\\
F(x^{c}) & =F(x)^{c^{\prime}}\\
F(0) & =0^{\prime}\\
F(1) & =1^{\prime}
\end{align*}

\end_inset

Un homomorfismo de
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 sera llamado 
\shape italic
isomorfismo 
\shape default
cuando sea biyectivo y su inversa sea un homomorfismo.
 Como es usual usaremos el simbolo 
\begin_inset Formula $\cong$
\end_inset

 para denotar la relacion de isomorfismo.
 Escribiremos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

Sea 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i},^{c},0,1)\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 un homomorfismo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 para expresar que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

.
 No hay que confundirse al leer esta notacion y pensar que 
\begin_inset Formula $F$
\end_inset

 es una funcion cuyo dominio es 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

, lo cual por otra parte no tiene sentido ya que el dominio de una funcion
 nunca puede ser una 
\begin_inset Formula $6$
\end_inset

-upla!
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i},^{c},0,1)\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 un homomorfismo biyectivo, entonces 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es dejada al lector.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i},^{c},0,1)\rightarrow(L^{\prime},\mathsf{s}^{\prime}$
\end_inset

,
\begin_inset Formula $\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset


\begin_inset space \space{}
\end_inset

es un homomorfismo, entonces 
\begin_inset Formula $I_{F}$
\end_inset

 es un subuniverso de 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime}$
\end_inset

,
\begin_inset Formula $\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

.
 Es decir que 
\begin_inset Formula $F$
\end_inset

 es tambien un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 en 
\begin_inset Formula $(I_{F},\mathsf{s}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{I_{F}\times I_{F}},\mathsf{i}^{\prime}$
\end_inset


\family roman

\begin_inset Formula $|$
\end_inset


\family default

\begin_inset Formula $_{I_{F}\times I_{F}},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es dejada al lector.
 
\end_layout

\begin_layout Subsection
Congruencias de reticulados complementados
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 un reticulado complementado.
 Una 
\shape italic
congruencia sobre
\shape default
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 sera una relacion de equivalencia sobre 
\begin_inset Formula $L$
\end_inset

 la cual cumpla:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\theta$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $x/\theta=y/\theta$
\end_inset

 implica 
\begin_inset Formula $x^{c}/\theta=y^{c}/\theta$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Las condiciones anteriores nos permiten definir sobre 
\begin_inset Formula $L/\theta$
\end_inset

 dos operaciones binarias 
\begin_inset Formula $\mathsf{\tilde{s}}$
\end_inset

 e 
\begin_inset Formula $\mathsf{\tilde{\imath}}$
\end_inset

, y una operacion unaria 
\begin_inset Formula $^{\tilde{c}}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\begin{align*}
x/\theta\mathsf{\;\tilde{s}\;}y/\theta & =(x\mathsf{\;s\;}y)/\theta\\
x/\theta\mathsf{\;\tilde{\imath}\;}y/\theta & =(x\mathsf{\;i\;}y)/\theta\\
(x/\theta)^{\tilde{c}} & =x^{c}/\theta
\end{align*}

\end_inset

La 
\begin_inset Formula $6$
\end_inset

-upla 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},^{\tilde{c}},0/\theta,1/\theta)$
\end_inset

 es llamada el 
\shape italic
cociente de
\shape default
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 
\shape italic
sobre
\shape default
 
\begin_inset Formula $\theta$
\end_inset

 y la denotaremos con 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)/\theta$
\end_inset

.
 Tal como era de esperar tenemos entonces
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 un reticulado complementado y sea 
\begin_inset Formula $\theta$
\end_inset

 una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},^{\tilde{c}},0/\theta,1/\theta)$
\end_inset

 es un reticulado complementado.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\pi_{\theta}$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 en 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},^{\tilde{c}},0/\theta,1/\theta)$
\end_inset

 cuyo nucleo es 
\begin_inset Formula $\theta$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Por un lema anterior ya sabemos que 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},0/\theta,1/\theta)$
\end_inset

 es un reticulado acotado.
 Es decir que solo nos falta ver que 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},^{\tilde{c}},0/\theta,1/\theta)$
\end_inset

 sarisface las identidades (I10) y (I11).
 Veamos por ejemplo que satisface la (I10).
 Sea 
\begin_inset Formula $x/\theta$
\end_inset

 un elemento cualquiera de 
\begin_inset Formula $L/\theta$
\end_inset

.
 Ya que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 satisface la (I10), tenemos que 
\begin_inset Formula $x\mathsf{\;s\;}x^{c}=1$
\end_inset

.
 O sea que 
\begin_inset Formula $(x\mathsf{\;s\;}x^{c})/\theta=1/\theta$
\end_inset

 y por lo tanto 
\begin_inset Formula $x/\theta\mathsf{\;\tilde{s}\;}x^{c}/\theta=1/\theta$
\end_inset

.
 Pero por definicion de 
\begin_inset Formula $^{\tilde{c}}$
\end_inset

 tenemos que 
\begin_inset Formula $(x/\theta)^{\tilde{c}}=x^{c}/\theta$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $x/\theta\mathsf{\;\tilde{s}\;}(x/\theta)^{\tilde{c}}=1/\theta$
\end_inset

.
 Dejamos al lector ver que 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},^{\tilde{c}},0/\theta,1/\theta)$
\end_inset

 sarisface la identidad (I11)
\end_layout

\begin_layout Standard
(b) Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cociente de reticulados acotados"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $\pi_{\theta}$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 en 
\begin_inset Formula $(L/\theta,\mathsf{\tilde{s}},\mathsf{\tilde{\imath}},0/\theta,1/\theta)$
\end_inset

 cuyo nucleo es 
\begin_inset Formula $\theta$
\end_inset

.
 Notese que por definicion de 
\begin_inset Formula $^{\tilde{c}}$
\end_inset

 tenemos que 
\begin_inset Formula $x^{c}/\theta=(x/\theta)^{\tilde{c}}$
\end_inset

, es decir 
\begin_inset Formula $\pi_{\theta}(x^{c})=(\pi_{\theta}(x))^{\tilde{c}}$
\end_inset

, cualquiera sea 
\begin_inset Formula $x\in L$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $F:(L,\mathsf{s},\mathsf{i},^{c},0,1)\rightarrow(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},^{c^{\prime}},0^{\prime},1^{\prime})$
\end_inset

 es un homomorfismo de reticulados complementados, entonces 
\begin_inset Formula $\ker F$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 en 
\begin_inset Formula $(L^{\prime},\mathsf{s}^{\prime},\mathsf{i}^{\prime},0^{\prime},1^{\prime})$
\end_inset

 tenemos que por un lema anterior 
\begin_inset Formula $\ker F$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

.
 Es decir que solo falta probar que para todos 
\begin_inset Formula $x,y\in L$
\end_inset

, se tiene que 
\begin_inset Formula $x/\ker F=y/\ker F$
\end_inset

 implica 
\begin_inset Formula $x^{c}/\ker F=y^{c}/\ker F$
\end_inset

, lo cual es dejado al lector 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Algebras de Boole
\end_layout

\begin_layout Standard
Un reticulado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 se llamara 
\shape italic
distributivo 
\shape default
cuando cumpla la siguiente identidad
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Dis
\begin_inset Formula $_{1}$
\end_inset


\end_layout

\end_inset


\begin_inset Formula $x\mathsf{\;i\;}(y\;\mathsf{s}\;z)=(x\mathsf{\;i\;}y)\;\mathsf{s}\;(x\mathsf{\;i\;}z)$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in L$
\end_inset

 
\end_layout

\begin_layout Standard
Diremos que un reticulado acotado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 (resp.
 complementado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

) es 
\shape italic
distributivo
\shape default
 cuando 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 lo sea.
 Consideremos la distributividad dual a Dis
\begin_inset Formula $_{1}$
\end_inset

, es decir
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Dis
\begin_inset Formula $_{2}$
\end_inset


\end_layout

\end_inset


\begin_inset Formula $x\;\mathsf{s}\;(y\mathsf{\;i\;}z)=(x\mathsf{\;s\;}y)\mathsf{\;i\;}(x\;\mathsf{s}\;z)$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,y,z\in L$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado.
 Entonces 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 satisface Dis
\begin_inset Formula $_{1}$
\end_inset

 sii 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 satisface Dis
\begin_inset Formula $_{2}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 satisface Dis
\begin_inset Formula $_{1}$
\end_inset

.
 Sean 
\begin_inset Formula $a,b,c\in L$
\end_inset

 elementos fijos.
 Por Dis
\begin_inset Formula $_{1}$
\end_inset

 tenemos que
\begin_inset Formula 
\[
(a\mathsf{\;s\;}b)\mathsf{\;i\;}(a\;\mathsf{s}\;c)=((a\mathsf{\;s\;}b)\mathsf{\;i\;}a)\;\mathsf{s}\;((a\mathsf{\;s\;}b)\mathsf{\;i\;}c)
\]

\end_inset

Pero por conmutatividad tenemos que
\begin_inset Formula 
\[
((a\mathsf{\;s\;}b)\mathsf{\;i\;}a)\;\mathsf{s}\;((a\mathsf{\;s\;}b)\mathsf{\;i\;}c)=(a\mathsf{\;i\;}(a\mathsf{\;s\;}b))\;\mathsf{s}\;(c\mathsf{\;i\;}(a\mathsf{\;s\;}b))
\]

\end_inset

Por (I7) tenemos que 
\begin_inset Formula $a\mathsf{\;i\;}(a\mathsf{\;s\;}b)=a$
\end_inset

 y por 
\begin_inset Formula $Dis_{1}$
\end_inset

 tenemos que 
\begin_inset Formula $c\mathsf{\;i\;}(a\mathsf{\;s\;}b)=(c\mathsf{\;i\;}a)\mathsf{\;s\;}(c\mathsf{\;i\;}b)$
\end_inset

 por lo cual
\begin_inset Formula 
\[
(a\mathsf{\;i\;}(a\mathsf{\;s\;}b))\;\mathsf{s}\;(c\mathsf{\;i\;}(a\mathsf{\;s\;}b))=a\;\mathsf{s}\;((c\mathsf{\;i\;}a)\mathsf{\;s\;}(c\mathsf{\;i\;}b))
\]

\end_inset

Por asociatividad tenemos que
\begin_inset Formula 
\[
a\;\mathsf{s}\;((c\mathsf{\;i\;}a)\mathsf{\;s\;}(c\mathsf{\;i\;}b))=(a\;\mathsf{s}\;(c\mathsf{\;i\;}a))\mathsf{\;s\;}(c\mathsf{\;i\;}b)
\]

\end_inset

Pero por conmutatividad tenemos que
\begin_inset Formula 
\[
(a\;\mathsf{s}\;(c\mathsf{\;i\;}a))\mathsf{\;s\;}(c\mathsf{\;i\;}b)=(a\;\mathsf{s}\;(a\mathsf{\;i\;}c))\mathsf{\;s\;}(b\mathsf{\;i\;}c)
\]

\end_inset

Lo cual por (I6) nos dice que
\begin_inset Formula 
\[
(a\;\mathsf{s}\;(a\mathsf{\;i\;}c))\mathsf{\;s\;}(b\mathsf{\;i\;}c)=a\mathsf{\;s\;}(b\mathsf{\;i\;}c)
\]

\end_inset

Por transitividad de la igualdad, las igualdades anteriores nos dicen que
\begin_inset Formula 
\[
a\mathsf{\;s\;}(b\mathsf{\;i\;}c)=(a\mathsf{\;s\;}b)\mathsf{\;i\;}(a\;\mathsf{s}\;c)
\]

\end_inset

Pero 
\begin_inset Formula $a,b,c$
\end_inset

 eran elementos arbitrarios por lo que hemos probado que vale 
\begin_inset Formula $Dis_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejercicio:
\end_layout

\end_inset

Use la prueba del lema anterior para hacer un algoritmo el cual tome de
 entrada un reticulado acotado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 y elementos 
\begin_inset Formula $x,y,z\in L$
\end_inset

 tales que 
\begin_inset Formula $y\neq z$
\end_inset

 son complementos de 
\begin_inset Formula $x$
\end_inset

, y de como salida elementos 
\begin_inset Formula $a,b,c$
\end_inset

 tales que 
\begin_inset Formula $a\mathsf{\;i\;}(b\;\mathsf{s}\;c)\neq(a\mathsf{\;i\;}b)\;\mathsf{s}\;(a\mathsf{\;i\;}c)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Por un 
\shape italic
Algebra de Boole 
\shape default
entenderemos un reticulado complementado que es distributivo.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E1
\end_layout

\end_inset

Dado un conjunto no vacio 
\begin_inset Formula $X$
\end_inset

, la 
\begin_inset Formula $6$
\end_inset

-upla 
\begin_inset Formula $(X,\cup,\cap,^{c},\emptyset,X)$
\end_inset

 es un algebra de Boole 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Para probar algunas propiedades fundamentales de un algebra de Boole necesitarem
os el siguiente
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "complementos unicos"

\end_inset

Si 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 un reticulado acotado y distributivo, entonces todo elemento tiene a lo
 sumo un complemento.
 Es decir, si 
\begin_inset Formula $x\;\mathsf{s\;}u=x\;\mathsf{s\;}v=1$
\end_inset

 y 
\begin_inset Formula $x\;\mathsf{i\;}u=x\;\mathsf{i\;}v=0$
\end_inset

, entonces 
\begin_inset Formula $u=v$
\end_inset

, cualesquiera sean 
\begin_inset Formula $x,u,v\in L$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sean 
\begin_inset Formula $a,b,c\in L$
\end_inset

 elementos fijos.
 Supongamos que
\begin_inset Formula 
\begin{align*}
a\;\mathsf{s\;}b & =a\;\mathsf{s\;}c=1\\
a\;\mathsf{i\;}b & =a\;\mathsf{i\;}c=0
\end{align*}

\end_inset

(es decir 
\begin_inset Formula $b$
\end_inset

 y 
\begin_inset Formula $c$
\end_inset

 son ambos complementos de 
\begin_inset Formula $a$
\end_inset

).
 Veremos que entonces 
\begin_inset Formula $b=c$
\end_inset

.
 Notese que
\begin_inset Formula 
\[
b=b\;\mathsf{i\;}1=b\;\mathsf{i\;}(a\;\mathsf{s\;}c)=(b\;\mathsf{i\;}a)\;\mathsf{s\;}(b\;\mathsf{i\;}c)=0\;\mathsf{s\;}(b\;\mathsf{i\;}c)=b\;\mathsf{i\;}c
\]

\end_inset

por lo cual 
\begin_inset Formula $b\leq c$
\end_inset

.
 Analogamente se puede probar que 
\begin_inset Formula $c\leq b$
\end_inset

 por lo cual 
\begin_inset Formula $b=c$
\end_inset

.
 Ya que 
\begin_inset Formula $a,b,c$
\end_inset

 eran elementos cualesquiera de 
\begin_inset Formula $L$
\end_inset

, hemos probado el lema.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Una propiedad muy importante que se da en las algebras de Boole es
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(B,\mathsf{s},\mathsf{i},^{\mathbf{c}},0,1)$
\end_inset

 un lgebra de Boole.
 Cualesquiera sean 
\begin_inset Formula $x,y\in B$
\end_inset

, se tiene que 
\begin_inset Formula $y=(y\;\mathsf{i\;}x)\;\mathsf{s\;}(y\mathsf{\;i\mathsf{\;}}x^{c})$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sean 
\begin_inset Formula $a,b\in B$
\end_inset

, fijos.
 Se tiene que
\begin_inset Formula 
\[
b=b\;\mathsf{i\;}1=b\mathsf{\;i\mathsf{\;}}(a\mathsf{\;s\mathsf{\;}}a^{c})=(b\;\mathsf{i\;}a)\;\mathsf{s\;}(b\mathsf{\;i\mathsf{\;}}a^{c})
\]

\end_inset

Ya que 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 eran elementos cualesquiera de 
\begin_inset Formula $B$
\end_inset

, hemos probado el lema.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{\mathbf{c}},0,1)$
\end_inset

 un lgebra de Boole y sean 
\begin_inset Formula $a,b\in B$
\end_inset

.
 Se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $(a\,\mathsf{i\,}b)^{c}=a^{c}\,\mathsf{s\,}b^{c}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $(a\,\mathsf{s\,}b)^{c}=a^{c}\,\mathsf{i\,}b^{c}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $a^{cc}=a$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $a\,\mathsf{i\,}b=0$
\end_inset

 si y solo si 
\begin_inset Formula $b\leq a^{c}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset


\begin_inset Formula $a\leq b$
\end_inset

 si y solo si 
\begin_inset Formula $b^{c}\leq a^{c}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Es facil ver que 
\begin_inset Formula $a^{c}\,\mathsf{s\,}b^{c}$
\end_inset

 es un complemento de 
\begin_inset Formula $a\,\mathsf{i\,}b$
\end_inset

 (hacer!).
 Pero ya que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{\mathbf{c}},0,1)$
\end_inset

 es un reticulado complementado, tenemos que 
\begin_inset Formula $(a\,\mathsf{i\,}b)^{c}$
\end_inset

 es un complemento de 
\begin_inset Formula $a\,\mathsf{i\,}b$
\end_inset

.
 El Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "complementos unicos"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $(a\,\mathsf{i\,}b)^{c}$
\end_inset

 y 
\begin_inset Formula $a^{c}\,\mathsf{s\,}b^{c}$
\end_inset

 deben ser iguales.
\end_layout

\begin_layout Standard
(2) y (3) se prueban en forma similar (hacer!)
\end_layout

\begin_layout Standard
(4) Supongamos 
\begin_inset Formula $a\,\mathsf{i\,}b=0$
\end_inset

.
 Se tiene
\begin_inset Formula 
\begin{align*}
b & =(b\;\mathsf{i\;}a)\;\mathsf{s\;}(b\mathsf{\;i\mathsf{\;}}a^{c})\mathsf{\,}\\
 & =(a\;\mathsf{i\;}b)\;\mathsf{s\;}(b\mathsf{\;i\mathsf{\;}}a^{c})\\
 & =0\;\mathsf{s\;}(b\mathsf{\;i\mathsf{\;}}a^{c})\\
 & =(b\mathsf{\;i\mathsf{\;}}a^{c})
\end{align*}

\end_inset

lo cual dice que 
\begin_inset Formula $b\leq a^{c}$
\end_inset

.
 Supongamos 
\begin_inset Formula $b\leq a^{c}$
\end_inset

.
 Entonces 
\begin_inset Formula $a\,\mathsf{i\,}b\leq a\,\mathsf{i\,}a^{c}=0$
\end_inset

 por lo cual 
\begin_inset Formula $a\,\mathsf{i\,}b=0$
\end_inset

.
\end_layout

\begin_layout Standard
(5) Supongamos 
\begin_inset Formula $a\leq b$
\end_inset

.
 Entonces 
\begin_inset Formula $a\,\mathsf{i\,}b=a$
\end_inset

, lo cual por (1) nos dice que 
\begin_inset Formula $a^{c}\,\mathsf{s\,}b^{c}=a^{c}$
\end_inset

 obteniendo que 
\begin_inset Formula $b^{c}\leq a^{c}$
\end_inset

.
 La resiproca es dejada al lector (hint: use (3)) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Teoremas del filtro primo y de Rasiowa Sikorski
\end_layout

\begin_layout Standard
Un 
\shape italic
filtro 
\shape default
de un reticulado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 sera un subconjunto 
\begin_inset Formula $F\subseteq L$
\end_inset

 tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $F\neq\emptyset$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $x,y\in F\Rightarrow x\;\mathsf{i\;}y\in F$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $x\in F$
\end_inset

 y 
\begin_inset Formula $x\leq y\Rightarrow y\in F$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
El nombre 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

filtro
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 es inspirado por la propiedad (3) ya que si un filtro o colador atrapa
 a cierto objeto 
\begin_inset Formula $x$
\end_inset

, entonces claramente atrapara a todos los objetos mas grandes que 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Standard
Dado un conjunto 
\begin_inset Formula $S\subseteq L$
\end_inset

, denotemos con 
\begin_inset Formula $[S)$
\end_inset

 el siguiente conjunto
\begin_inset Formula 
\[
\{y\in L:y\geq s_{1}\;\mathsf{i\;}...\;\mathsf{i\;}s_{n}\text{, para algunos }s_{1},...,s_{n}\in S\text{, }n\geq1\}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $S$
\end_inset

 es no vacio.
 Entonces 
\begin_inset Formula $[S)$
\end_inset

 es un filtro.
 Mas aun si 
\begin_inset Formula $F$
\end_inset

 es un filtro y 
\begin_inset Formula $F\supseteq S$
\end_inset

, entonces 
\begin_inset Formula $F\supseteq[S)$
\end_inset

.
 Es decir, 
\begin_inset Formula $[S)$
\end_inset

 es el menor filtro que contiene a 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $S\subseteq[S)$
\end_inset

, tenemos que 
\begin_inset Formula $[S)\neq\emptyset$
\end_inset

.
 Claramente 
\begin_inset Formula $[S)$
\end_inset

 cumple la propiedad (3).
 Veamos cumple la (2).
 Si 
\begin_inset Formula $y\geq s_{1}\;\mathsf{i\;}s_{2}\;\mathsf{i\;}...\;\mathsf{i\;}s_{n}$
\end_inset

 y 
\begin_inset Formula $z\geq t_{1}\;\mathsf{i\;}t_{2}\;\mathsf{i\;}$
\end_inset

...
\begin_inset Formula $\;\mathsf{i\;}t_{m}$
\end_inset

, con 
\begin_inset Formula $s_{1},s_{2},...,s_{n}$
\end_inset

, 
\begin_inset Formula $t_{1},t_{2},...,t_{m}\in S$
\end_inset

, entonces
\begin_inset Formula 
\[
y\;\mathsf{i\;}z\geq s_{1}\;\mathsf{i\;}s_{2}\;\mathsf{i\;}...\;\mathsf{i\;}s_{n}\;\mathsf{i\;}t_{1}\;\mathsf{i\;}t_{2}\;\mathsf{i\;}...\;\mathsf{i\;}t_{m}
\]

\end_inset

lo cual prueba (2).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Llamaremos a 
\begin_inset Formula $[S)$
\end_inset

 el 
\shape italic
filtro generado
\shape default
 
\shape italic
por
\shape default
 
\begin_inset Formula $S$
\end_inset

.
 Cuando 
\begin_inset Formula $S$
\end_inset

 es finito, ya que existe 
\begin_inset Formula $\inf S$
\end_inset

, es claro que 
\begin_inset Formula $[S)=\{y\in L:y\geq\inf S\}$
\end_inset

.
 Cuando 
\begin_inset Formula $S$
\end_inset

 es infinito y existe 
\begin_inset Formula $\inf S$
\end_inset

, en muchos casos se dara que 
\begin_inset Formula $[S)=\{y\in L:y\geq\inf S\}$
\end_inset

 o que 
\begin_inset Formula $[S)=\{y\in L:y>\inf S\}$
\end_inset

, pero no necesariamente esto sucedera siempre.
 Por ejemplo:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Sea 
\begin_inset Formula $\mathbf{L}=(\mathcal{P}(\mathbf{N}),\cup,\cap)$
\end_inset

 y sea 
\begin_inset Formula $S=\{\mathbf{N}-\{n\}:n\in\mathbf{N}\}$
\end_inset

.
 Es facil ver que 
\begin_inset Formula $\inf S=\emptyset$
\end_inset

 y que 
\begin_inset Formula $[S)=\{A\in\mathcal{P}(\mathbf{N}):\mathbf{N}-A$
\end_inset

 es finito
\begin_inset Formula $\}$
\end_inset

 por lo cual no se da que 
\begin_inset Formula $[S)=\{y\in L:y\geq\inf S\}$
\end_inset

 o que 
\begin_inset Formula $[S)=\{y\in L:y>\inf S\}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
En general, si 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 es un reticulado acotado, diremos que 
\begin_inset Formula $F$
\end_inset

 es un 
\shape italic
filtro 
\shape default
de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 cuando 
\begin_inset Formula $F$
\end_inset

 sea un filtro de 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

.
 Lo mismo sucedera con el concepto de filtro de un reticulado complementado
 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset


\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(P,\leq)$
\end_inset

 un poset.
 Un subconjunto 
\begin_inset Formula $C\subseteq P$
\end_inset

 sera llamado una 
\shape italic
cadena
\shape default
 si para cada 
\begin_inset Formula $x,y\in C$
\end_inset

, se tiene que 
\begin_inset Formula $x\leq y$
\end_inset

 o 
\begin_inset Formula $y\leq x$
\end_inset

.
 Por ejemplo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset


\begin_inset Formula $\{1,10,40,600\}$
\end_inset

 y 
\begin_inset Formula $\{2^{n}:n\in\mathbf{N}\}$
\end_inset

 son cadenas del poset 
\begin_inset Formula $(\mathbf{N},|)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset


\begin_inset Formula $\{-3,5,2\}$
\end_inset

 y el intervalo 
\begin_inset Formula $[2,3]$
\end_inset

 son cadenas del poset 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

.
 De hecho todo subconjunto de 
\begin_inset Formula $\mathbf{R}$
\end_inset

 es una cadena de 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset


\begin_inset Formula $C=\{[0,n]:n\in\mathbf{N}\}$
\end_inset

 es una cadena del poset 
\begin_inset Formula $(\mathcal{P}(\mathbf{R}),\subseteq)$
\end_inset

.
 Notese que cada elemento de 
\begin_inset Formula $C$
\end_inset

 es un conjunto (i.e.
 un intervalo).
 
\end_layout

\begin_layout Standard
Es importante notar que las cadenas pueden ser infinitas y que dada una
 cadena infinita 
\begin_inset Formula $C$
\end_inset

 puede no existir una infinitupla 
\begin_inset Formula $(c_{1},c_{2},...)$
\end_inset

 tal que 
\begin_inset Formula $C=\{c_{n}:n\in\mathbf{N}\}$
\end_inset

.
 Este es el caso de la cadena 
\begin_inset Formula $[0,1]$
\end_inset

 del poset 
\begin_inset Formula $(\mathbf{R},\leq)$
\end_inset

, ya que el bien conocido argumento diagonal de Cantor nos dice que no existe
 una manera de enumerar los elementos del intervalo 
\begin_inset Formula $[0,1]$
\end_inset

.
 Esto nos obliga a pensar con cierta madurez a las cadenas y no caer en
 la falacia de pensar que sus elementos forman necesariamente una 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

filita discreta
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Tambien es importante para entender la prueba del Teorema del Filtro Primo
 que viene a continuacion, imaginar las cadenas de posets que sus elementos
 son conjuntos y su orden es la inclusion, es decir dichas cadenas seran
 un conjunto de conjuntos 
\begin_inset Formula $C$
\end_inset

 con la propiedad que dados dos cualesquiera elementos de 
\begin_inset Formula $C$
\end_inset

 siempre alguno contiene al otro.
 Un ejemplo de este tipo de cadenas es dado en (E3).
 Otro ejemplo:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\mathcal{F}=\{F:F$
\end_inset

 es un filtro del reticulado 
\begin_inset Formula $(\mathbf{N},mcm,mcd)\}$
\end_inset

.
 Notar que dado 
\begin_inset Formula $n\in\mathbf{N}$
\end_inset

, el conjunto 
\begin_inset Formula $\{x\in\mathbf{N}:n|x\}$
\end_inset

 es un filtro de 
\begin_inset Formula $(\mathbf{N},mcm,mcd)\}$
\end_inset

.
 Ya que 
\begin_inset Formula $\mathcal{F}$
\end_inset

 es no vacio tenemos que 
\begin_inset Formula $(\mathcal{F},\subseteq)$
\end_inset

 es un poset.
 Entonces
\begin_inset Formula 
\[
C=\{\{x\in\mathbf{N}:n|x\}:n\text{ es potencia de }2\}
\]

\end_inset

es una cadena de 
\begin_inset Formula $(\mathcal{F},\subseteq)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente resultado es una herramienta fundamental en el algebra moderna.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Lema de Zorn
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset

Sea 
\begin_inset Formula $(P,\leq)$
\end_inset

 un poset y supongamos cada cadena de 
\begin_inset Formula $(P,\leq)$
\end_inset

 tiene al menos una cota superior.
 Entonces hay un elemento maximal en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Obviamente en cada poset con universo finito hay al menos un elemento maximal.
 O sea que el Lema de Zorn es interesante para el caso en que 
\begin_inset Formula $P$
\end_inset

 es un conjunto infinito.
 Un argumento para creer en la veracidad del lema podria ser el siguiente
 razonamiento por el absurdo.
 Supongamos que 
\begin_inset Formula $(P,\leq)$
\end_inset

 es un poset en el cual cada cadena tiene al menos una cota superior y supongamo
s ademas que no hay elementos maximales en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Tomemos 
\begin_inset Formula $x_{0}\in P$
\end_inset

 un elemento cualquiera.
 Ya que 
\begin_inset Formula $x_{0}$
\end_inset

 no es maximal, hay un 
\begin_inset Formula $x_{1}\in P$
\end_inset

 tal que 
\begin_inset Formula $x_{0}<x_{1}$
\end_inset

.
 Iterando esta idea vemos que debe haber elementos 
\begin_inset Formula $x_{2},x_{3},...$
\end_inset

 tales que:
\begin_inset Formula 
\[
x_{0}<x_{1}<x_{2}<x_{3}<\cdots
\]

\end_inset

Pero 
\begin_inset Formula $\{x_{0},x_{1},x_{2},x_{3},...\}$
\end_inset

 es una cadena por lo cual hay al menos una cota superior de ella en 
\begin_inset Formula $(P,\leq)$
\end_inset

.
 Sea 
\begin_inset Formula $x_{\omega}$
\end_inset

 una de tales cotas.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Un filtro 
\begin_inset Formula $F$
\end_inset

 de un reticulado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 sera llamado 
\shape italic
primo
\shape default
 cuando se cumplan:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $F\neq L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $x\;\mathsf{s\;}y\in F\Rightarrow x\in F$
\end_inset

 o 
\begin_inset Formula $y\in F$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E1
\end_layout

\end_inset

Todo filtro de 
\begin_inset Formula $(\mathbf{R},\max,\min)$
\end_inset

, distinto de 
\begin_inset Formula $\mathbf{R}$
\end_inset

, es primo (justificar)
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
E2
\end_layout

\end_inset

Sea 
\begin_inset Formula $B=\{X\subseteq\omega:X$
\end_inset

 es finito o 
\begin_inset Formula $\omega-X$
\end_inset

 es finito
\begin_inset Formula $\}$
\end_inset

.
 Como vimos anteriormente 
\begin_inset Formula $B$
\end_inset

 es cerrado bajo las operaciones 
\begin_inset Formula $\cup$
\end_inset

 y 
\begin_inset Formula $\cap$
\end_inset

.
 Sea 
\begin_inset Formula $P=\{X\subseteq\omega:\omega-X$
\end_inset

 es finito
\begin_inset Formula $\}$
\end_inset

.
 Entonces 
\begin_inset Formula $P$
\end_inset

 es un filtro primo de 
\begin_inset Formula $(B,\cup,\cap)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 un reticulado distributivo y 
\begin_inset Formula $F$
\end_inset

 un filtro.
 Supongamos 
\begin_inset Formula $x_{0}\in L-F$
\end_inset

.
 Entonces hay un filtro primo 
\begin_inset Formula $P$
\end_inset

 tal que 
\begin_inset Formula $x_{0}\notin P$
\end_inset

 y 
\begin_inset Formula $F\subseteq P$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea
\begin_inset Formula 
\[
\mathcal{F}=\{F_{1}:F_{1}\text{ es un filtro, }x_{0}\notin F_{1}\text{ y }F\subseteq F_{1}\}.
\]

\end_inset

Notese que 
\begin_inset Formula $\mathcal{F}\neq\emptyset$
\end_inset

, por lo cual 
\begin_inset Formula $(\mathcal{F},\subseteq)$
\end_inset

 es un poset.
 Veamos que cada cadena en 
\begin_inset Formula $(\mathcal{F},\subseteq)$
\end_inset

 tiene una cota superior.
 Sea 
\begin_inset Formula $C$
\end_inset

 una cadena.
 Si 
\begin_inset Formula $C=\emptyset$
\end_inset

, entonces cualquier elemento de 
\begin_inset Formula $\mathcal{F}$
\end_inset

 es cota de 
\begin_inset Formula $C$
\end_inset

.
 Supongamos entonces 
\begin_inset Formula $C\neq\emptyset$
\end_inset

.
 Sea
\begin_inset Formula 
\[
G=\{x:x\in F_{1}\text{, para algun }F_{1}\in C\}.
\]

\end_inset

Veamos que 
\begin_inset Formula $G$
\end_inset

 es un filtro.
 Es claro que 
\begin_inset Formula $G$
\end_inset

 es no vacio.
 Supongamos que 
\begin_inset Formula $x,y\in G$
\end_inset

.
 Sean 
\begin_inset Formula $F_{1},F_{2}\in\mathcal{F}$
\end_inset

 tales que 
\begin_inset Formula $x\in F_{1}$
\end_inset

 y 
\begin_inset Formula $y\in F_{2}$
\end_inset

.
 Si 
\begin_inset Formula $F_{1}\subseteq F_{2}$
\end_inset

, entonces ya que 
\begin_inset Formula $F_{2}$
\end_inset

 es un filtro tenemos que 
\begin_inset Formula $x\;\mathsf{i\;}y\in F_{2}\subseteq G$
\end_inset

.
 Si 
\begin_inset Formula $F_{2}\subseteq F_{1}$
\end_inset

, entonces tenemos que 
\begin_inset Formula $x\;\mathsf{i\;}y\in F_{1}\subseteq G$
\end_inset

.
 Ya que 
\begin_inset Formula $C$
\end_inset

 es una cadena, tenemos que siempre 
\begin_inset Formula $x\;\mathsf{i\;}y\in G$
\end_inset

.
 En forma analoga se prueba la propiedad restante por lo cual tenemos que
 
\begin_inset Formula $G$
\end_inset

 es un filtro.
 Ademas 
\begin_inset Formula $x_{0}\notin G$
\end_inset

, por lo que 
\begin_inset Formula $G\in\mathcal{F}$
\end_inset

 es cota superior de 
\begin_inset Formula $C$
\end_inset

.
 Por el lema de Zorn, 
\begin_inset Formula $(\mathcal{F},\subseteq)$
\end_inset

 tiene un elemento maximal 
\begin_inset Formula $P$
\end_inset

.
 Veamos que 
\begin_inset Formula $P$
\end_inset

 es un filtro primo.
 Supongamos 
\begin_inset Formula $x\;\mathsf{s\;}y\in P$
\end_inset

 y 
\begin_inset Formula $x,y\notin P$
\end_inset

.
 Notese que 
\begin_inset Formula $[P\cup\{x\})$
\end_inset

 es un filtro el cual contiene propiamente a 
\begin_inset Formula $P$
\end_inset

.
 Entonces ya que 
\begin_inset Formula $P$
\end_inset

 es un elemento maximal de 
\begin_inset Formula $(\mathcal{F},\subseteq)$
\end_inset

, tenemos que 
\begin_inset Formula $x_{0}\in[P\cup\{x\})$
\end_inset

.
 Analogamente tenemos que 
\begin_inset Formula $x_{0}\in[P\cup\{y\})$
\end_inset

.
 Ya que 
\begin_inset Formula $x_{0}\in[P\cup\{x\})$
\end_inset

, tenemos que hay elementos 
\begin_inset Formula $p_{1},...,p_{n}\in P$
\end_inset

, tales que
\begin_inset Formula 
\[
x_{0}\geq p_{1}\;\mathsf{i\;}...\;\mathsf{i\;}p_{n}\;\mathsf{i\;}x
\]

\end_inset

(se deja como ejercicio justificar esto).
 Ya que 
\begin_inset Formula $x_{0}\in[P\cup\{y\})$
\end_inset

, tenemos que hay elementos 
\begin_inset Formula $q_{1},...,q_{m}\in P$
\end_inset

, tales que
\begin_inset Formula 
\[
x_{0}\geq q_{1}\;\mathsf{i\;}...\;\mathsf{i\;}q_{m}\;\mathsf{i\;}y
\]

\end_inset

Si
\begin_inset space \space{}
\end_inset

llamamos 
\begin_inset Formula $p$
\end_inset

 al siguiente elemento de 
\begin_inset Formula $P$
\end_inset


\begin_inset Formula 
\[
p_{1}\;\mathsf{i\;}...\;\mathsf{i\;}p_{n}\;\mathsf{i\;}q_{1}\;\mathsf{i\;}...\;\mathsf{i\;}q_{m}
\]

\end_inset

tenemos que
\begin_inset Formula 
\begin{align*}
x_{0} & \geq p\;\mathsf{i\;}x\\
x_{0} & \geq p\;\mathsf{i\;}y
\end{align*}

\end_inset

Se tiene entonces que 
\begin_inset Formula $x_{0}\geq(p\;\mathsf{i\;}x)\;\mathsf{s\;}(p\;\mathsf{i\;}y)=p\;\mathsf{i\;}(x\;\mathsf{s\;}y)\in P$
\end_inset

, lo cual es absurdo ya que 
\begin_inset Formula $x_{0}\notin P$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Sea 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},0,1)$
\end_inset

 un reticulado acotado distributivo.
 Si 
\begin_inset Formula $\emptyset\neq S\subseteq L$
\end_inset

 es tal que 
\begin_inset Formula $s_{1}\;\mathsf{i\;}s_{2}\;\mathsf{i\;}...\;\mathsf{i\;}s_{n}\neq0$
\end_inset

, para cada 
\begin_inset Formula $s_{1},...,s_{n}\in S$
\end_inset

, entonces hay un filtro primo que contiene a 
\begin_inset Formula $S$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que 
\begin_inset Formula $[S)\neq L$
\end_inset

 por lo cual se puede aplicar el Teorema del filtro primo.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(B,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 un algebra de Boole.
 Entonces para un filtro 
\begin_inset Formula $F\subsetneq B$
\end_inset

 las siguientes son equivalentes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $F$
\end_inset

 es primo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $x\in F$
\end_inset

 o 
\begin_inset Formula $x^{c}\in F$
\end_inset

, para cada 
\begin_inset Formula $x\in B$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1)
\begin_inset Formula $\Rightarrow$
\end_inset

(2).
 Ya que 
\begin_inset Formula $x\;\mathsf{s\;}x^{c}=1\in F$
\end_inset

, (2) se cumple si 
\begin_inset Formula $F$
\end_inset

 es primo.
\end_layout

\begin_layout Standard
(2)
\begin_inset Formula $\Rightarrow$
\end_inset

(1).
 Ya sabemos por hipotesis que 
\begin_inset Formula $F$
\end_inset

 es un filtro y que 
\begin_inset Formula $F\neq B$
\end_inset

.
 Supongamos que 
\begin_inset Formula $x\;\mathsf{s\;}y\in F$
\end_inset

 y que 
\begin_inset Formula $x\not\in F$
\end_inset

.
 Entonces por (2), 
\begin_inset Formula $x^{c}\in F$
\end_inset

 y por lo tanto tenemos que
\begin_inset Formula 
\[
y\geq x^{c}\;\mathsf{i\;}y=(x^{c}\;\mathsf{i\;}x)\;\mathsf{s\;}(x^{c}\;\mathsf{i\;}y)=x^{c}\;\mathsf{i\;}(x\;\mathsf{s\;}y)\in F,
\]

\end_inset

lo cual dice que 
\begin_inset Formula $y\in F$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Necesitaremos el siguiente lema.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(B,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 un algebra de Boole.
 Supongamos que 
\begin_inset Formula $b\neq0$
\end_inset

 y 
\begin_inset Formula $a=\inf A$
\end_inset

, con 
\begin_inset Formula $A\subseteq B$
\end_inset

.
 Entonces si 
\begin_inset Formula $b\;\mathsf{i\;}a=0$
\end_inset

, existe un 
\begin_inset Formula $e\in A$
\end_inset

 tal que 
\begin_inset Formula $b\;\mathsf{i\;}e^{c}\neq0$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos que para cada 
\begin_inset Formula $e\in A$
\end_inset

, tengamos que 
\begin_inset Formula $b\;\mathsf{i\;}e^{c}=0$
\end_inset

.
 Entonces tenemos que para cada 
\begin_inset Formula $e\in A$
\end_inset

,
\begin_inset Formula 
\[
b=b\;\mathsf{i\;}(e\;\mathsf{s\;}e^{c})=(b\;\mathsf{i\;}e)\;\mathsf{s\;}(b\;\mathsf{i\;}e^{c})=b\;\mathsf{i\;}e,
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $b$
\end_inset

 es cota inferior de 
\begin_inset Formula $A$
\end_inset

.
 Pero entonces 
\begin_inset Formula $b\leq a$
\end_inset

, por lo cual 
\begin_inset Formula $b=b\;\mathsf{i\;}a=0$
\end_inset

, contradiciendo la hipotesis.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Es claro que si 
\begin_inset Formula $P$
\end_inset

 es un filtro primo de un algebra de Boole 
\begin_inset Formula $(B,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

, entonces cualquiera sea el conjunto finito 
\begin_inset Formula $S$
\end_inset

 contenido en 
\begin_inset Formula $P$
\end_inset

, se tiene que 
\begin_inset Formula $\inf S\in P$
\end_inset

.
 Cuando tomamos un subconjunto 
\begin_inset Formula $S\subseteq P$
\end_inset

 el cual es infinito, la cosa cambia sustancialmente.
 Primero cabe destacar que puede suceder que 
\begin_inset Formula $S$
\end_inset

 no tenga infimo en 
\begin_inset Formula $(B,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

.
 Pero tambien puede pasar que 
\begin_inset Formula $S$
\end_inset

 tenga infimo pero que 
\begin_inset Formula $\inf S$
\end_inset

 no pertenesca a 
\begin_inset Formula $P$
\end_inset

.
 Por ejemplo, si tomamos el algebra de Boole 
\begin_inset Formula $(B,\cup,\cap,^{c},\emptyset,\omega)$
\end_inset

, donde
\begin_inset Formula 
\[
B=\{X\subseteq\omega:X\text{ es finito o }\omega-X\text{ es finito}\}
\]

\end_inset

podemos observar que
\begin_inset Formula 
\[
P=\{X\subseteq\omega:\omega-X\text{ es finito}\}
\]

\end_inset

es un filtro primo y que
\begin_inset Formula 
\[
S=\{\omega-\{n\}:n\in\omega\}
\]

\end_inset

esta contenido en 
\begin_inset Formula $P$
\end_inset

 pero 
\begin_inset Formula $\inf S=\emptyset$
\end_inset

 no pertenece a 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente teorema sera clave en nuestra prueba del teorema de completitud
 de la logica de primer orden.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 (Rasiova y Sikorski) Sea 
\begin_inset Formula $(B,\mathsf{s},\mathsf{i},^{c},0,1)$
\end_inset

 un algebra de Boole.
 Sea 
\begin_inset Formula $x\in B$
\end_inset

, 
\begin_inset Formula $x\neq0$
\end_inset

.
 Supongamos que 
\begin_inset Formula $(A_{1},A_{2},...)$
\end_inset

 es una infinitupla de subconjuntos de 
\begin_inset Formula $B$
\end_inset

 tal que existe 
\begin_inset Formula $\inf(A_{j})$
\end_inset

, para cada 
\begin_inset Formula $j=1,2....$
\end_inset

 Entonces hay un filtro primo 
\begin_inset Formula $P$
\end_inset

 el cual cumple:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $x\in P$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $P\supseteq A_{j}\Rightarrow P\ni\inf(A_{j})$
\end_inset

, para cada 
\begin_inset Formula $j=1,2,....$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sean 
\begin_inset Formula $a_{j}=\inf(A_{j})$
\end_inset

, 
\begin_inset Formula $j=1,2,...$
\end_inset

.
 Construiremos inductivamente una infinitupla 
\begin_inset Formula $(b_{0},b_{1},...)$
\end_inset

 de elementos de 
\begin_inset Formula $B$
\end_inset

 tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $b_{0}=x$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $b_{0}\;\mathsf{i\;}$
\end_inset

...
\begin_inset Formula $\;\mathsf{i\;}b_{n}\neq0$
\end_inset

, para cada 
\begin_inset Formula $n\geq0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $b_{j}=a_{j}$
\end_inset

 o 
\begin_inset Formula $b_{j}^{c}\in A_{j}$
\end_inset

, para cada 
\begin_inset Formula $j\geq1$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
Definamos 
\begin_inset Formula $b_{0}=x$
\end_inset

.
 Supongamos ya definimos 
\begin_inset Formula $b_{0},...,b_{n}$
\end_inset

, veamos como definir 
\begin_inset Formula $b_{n+1}$
\end_inset

.
 Si 
\begin_inset Formula $(b_{0}\;\mathsf{i\;}...\;\mathsf{i\;}b_{n})\;\mathsf{i\;}a_{n+1}\neq0$
\end_inset

, entonces definamos 
\begin_inset Formula $b_{n+1}=a_{n+1}$
\end_inset

.
 Si 
\begin_inset Formula $(b_{0}\;\mathsf{i\;}...\;\mathsf{i\;}b_{n})\;\mathsf{i\;}a_{n+1}=0$
\end_inset

, entonces por el lema anterior, tenemos que hay un 
\begin_inset Formula $e\in A_{n+1}$
\end_inset

 tal que 
\begin_inset Formula $(b_{0}\;\mathsf{i\;}...\;\mathsf{i\;}b_{n})\;\mathsf{i\;}e^{c}\neq0$
\end_inset

, lo cual nos permite definir 
\begin_inset Formula $b_{n+1}=e^{c}$
\end_inset

.
\end_layout

\begin_layout Standard
Usando (2) se puede probar que el conjunto 
\begin_inset Formula $S=\{b_{0},b_{1},...\}$
\end_inset

 satisface la hipotesis del primer corolario del Teorema del filtro primo,
 por lo cual hay un filtro primo 
\begin_inset Formula $P$
\end_inset

 tal que 
\begin_inset Formula $\{b_{0},b_{1},...\}\subseteq P$
\end_inset

.
 Es claro que 
\begin_inset Formula $x\in P$
\end_inset

 y es facil chequear usando (3) que 
\begin_inset Formula $P$
\end_inset

 satisface la propiedad (b).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Cerramos la seccion con una convencion notacional que se usara mas que nada
 en los ejercicios y la tombola.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout

\series bold
Convencion notacional:
\end_layout

\end_inset

Notese que hemos definido distintos tipos de estructuras (i.e.
 posets, reticulados como ternas, etc) y en todas ellas su primera coordenada
 es llamada el 
\shape italic
universo
\shape default
 de dicha estructura.
 En general usaremos letras mayusculas en bold para denotar una estructura
 dada y en tal caso usaremos la convension de que su correspondiente mayuscula
 en italica denotara el universo de dicha estructura.
 Por ejemplo si decimos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

sea 
\begin_inset Formula $\mathbf{L}$
\end_inset

 un reticulado acotado
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, entonces ya queda implicita la informacion de que denotaremos con 
\begin_inset Formula $L$
\end_inset

 al universo de 
\begin_inset Formula $\mathbf{L}$
\end_inset

.
 Ademas deberia quedar claro que en tal caso 
\begin_inset Formula $\mathbf{L}$
\end_inset

 es una 5-upla.
\end_layout

\begin_deeper
\begin_layout Standard
Tambien si 
\begin_inset Formula $\mathbf{L}^{\prime}$
\end_inset

 denota una estructura, 
\begin_inset Formula $L^{\prime}$
\end_inset

 denotara su universo.
 Similarmente si 
\begin_inset Formula $\mathbf{\tilde{L}}$
\end_inset

 denota una estructura, 
\begin_inset Formula $\tilde{L}$
\end_inset

 denotara su universo, etc.
\end_layout

\begin_layout Standard
Notese que entonces, si escribimos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

Sea 
\begin_inset Formula $F:\mathbf{L}\rightarrow\mathbf{L}^{\prime}$
\end_inset

 es un homomorfismo de reticulados complementados
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, estaremos suponiendo que 
\begin_inset Formula $\mathbf{L}$
\end_inset

 y 
\begin_inset Formula $\mathbf{L}^{\prime}$
\end_inset

 son reticulados complementados (i.e.
 ciertas 6-uplas) y que 
\begin_inset Formula $F$
\end_inset

 es una funcion de 
\begin_inset Formula $L$
\end_inset

 en 
\begin_inset Formula $L^{\prime}$
\end_inset

 la cual es un homomorfismo de 
\begin_inset Formula $\mathbf{L}$
\end_inset

 en 
\begin_inset Formula $\mathbf{L}^{\prime}$
\end_inset

.
 Aqui hay que tener cuidado ya que 
\begin_inset Formula $D_{F}$
\end_inset

 es 
\begin_inset Formula $L$
\end_inset

 y no 
\begin_inset Formula $\mathbf{L}$
\end_inset

 lo cual seria imposible ya que 
\begin_inset Formula $\mathbf{L}$
\end_inset

 no es un conjunto!
\end_layout

\begin_layout Standard
Tambien notese que si 
\begin_inset Formula $\mathbf{L}$
\end_inset

 denota un reticulado acotado y 
\begin_inset Formula $\theta$
\end_inset

 es una congruencia de 
\begin_inset Formula $\mathbf{L}$
\end_inset

, entonces 
\begin_inset Formula $\mathbf{L}/\theta$
\end_inset

 denotara el cociente de 
\begin_inset Formula $\mathbf{L}$
\end_inset

 sobre 
\begin_inset Formula $\theta$
\end_inset

, a saber cierto reticulado acotado cuyo universo es 
\begin_inset Formula $L/\theta$
\end_inset

.
 Es decir que 
\begin_inset Formula $Ti(\mathbf{L}/\theta)=5\mathrm{-UPLA}$
\end_inset

 y 
\begin_inset Formula $Ti(L/\theta)=\mathrm{CONJUNTO}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "Estructuras y su lenguaje elemental asociado"

\end_inset

Estructuras y su lenguaje elemental asociado
\end_layout

\begin_layout Standard
Como ya vimos en la seccion anterior, hay distintos tipos de estructuras
 a las cuales se las puede estudiar usando metodos similares.
 Con cada tipo de estructura tenemos asociado cierto tipo de enunciados
 o sentencias que llamaremos 
\shape italic
formulas elementales
\shape default
.
 Tambien una ves que fijemos ciertas sentencias elementales que axiomaticen
 tal tipo de estructura, tendremos asociado un tipo de pruebas que llamaremos
 
\shape italic
elementales
\shape default
 ya que solo usaran dichos axiomas, deducciones muy simples y obvias de
 justificar con pequeas fraces en castellano y ademas en su escritura lo
 concerniente a la matematica misma se escribira usando solo sentencias
 elementales.
 No daremos ahora una definicion matematica de estos conceptos pero los
 describiremos en forma intuitiva mediante ejemplos.
 Cabe destacar que los conceptos de formula elemental y prueba elemental
 son relativos al tipo de estructura que se esta considerando.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Formulas elementales para posets
\end_layout

\begin_layout Standard
Se construyen en forma finitaria usando simbolos de la siguiente lista:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;=\;\leq$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Variables: 
\begin_inset Formula $x,y,z,w,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Nombres para elementos fijos: 
\begin_inset Formula $a,b,c,d,...$
\end_inset

 
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x\leq y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x=y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(a\leq z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(b=c)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall y(y\leq x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall y(y\leq a)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x(x\leq x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z\;((x\leq y\wedge y\leq z)\rightarrow x\leq z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y((x\leq y\wedge y\leq x)\rightarrow x=y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\exists x\forall y(y\leq x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\lnot\exists y(x\leq y\wedge\lnot(y=x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall y(y\leq x)\rightarrow\lnot\exists y(x\leq y\wedge\lnot(y=x))$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que siempre 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

cuantificamos por delante
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, es decir que la palabra 
\begin_inset Formula $(x\leq a)\forall x$
\end_inset

 NO es una formula elemental de posets (aunque es claro que puede atribuirsele
 un sentido ya que podemos pensar que dice que 
\begin_inset Formula $a$
\end_inset

 es un elemento maximo).
 Mas alla de que no hemos definido matematicamente el concepto de formula
 elemental de posets, es importante entender que las formulas elementales
 son palabras, es decir 
\begin_inset Formula $Ti(\varphi)=\mathrm{PALABRA}$
\end_inset

, cada ves que 
\begin_inset Formula $\varphi$
\end_inset

 es una formula elemental de posets.
\end_layout

\begin_layout Standard
Para que una formula se vuelva verdadera o falsa tenemos que tener un poset
 concreto 
\begin_inset Formula $(P,\leq)$
\end_inset

 y ademas asignarles valores concretos de 
\begin_inset Formula $P$
\end_inset

 a las variables libres y a los nombres de elementos fijos que ocurren en
 dicha formula.
 Cuando la formula no tiene variables libres diremos que es una 
\shape italic
sentencia elemental de posets
\shape default
.
 Notese que en tal caso sera verdadera o falsa en un poset dado dependiendo
 solo de los valores que tomen los nombres para elementos fijos que ocurren
 en ella.
 Tambien cabe destacar que los cuantificadores siempre ranguean sobre 
\begin_inset Formula $P$
\end_inset

, es decir 
\begin_inset Formula $\forall x$
\end_inset

 se interpretara como 
\begin_inset Formula $\forall x\in P$
\end_inset

 y 
\begin_inset Formula $\exists x$
\end_inset

 se interpretara como 
\begin_inset Formula $\exists x\in P$
\end_inset

.
 La diferencia entre las variables y los nombres de elementos fijos es que
 si bien ambos pueden variar su valor los nombres de elementos fijos suelen
 denotar un valor fijo del poset durante todo un desarrollo o demostracion.
 Tampoco se cuantificaran los nombres de elementos fijos, es decir solo
 cuantificamos variables.
 O sea que 
\begin_inset Formula $\forall a(a=x)$
\end_inset

 no es una formula elemental.
\end_layout

\begin_layout Standard
Por ejemplo en el poset 
\begin_inset Formula $(\mathbf{N},|)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

La formula 
\begin_inset Formula $(x\leq y)$
\end_inset

 es verdadera cuando le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 
\begin_inset Formula $6$
\end_inset

 y a 
\begin_inset Formula $y$
\end_inset

 el valor 
\begin_inset Formula $36$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\forall y(a\leq y)$
\end_inset

 es verdadera cuando le asignamos a 
\begin_inset Formula $a$
\end_inset

 el valor 
\begin_inset Formula $1$
\end_inset

 y falsa si le asignamos el valor 
\begin_inset Formula $5$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\exists y(x\leq y\wedge\lnot(y=x))$
\end_inset

 es verdadera cuando le asignamos a 
\begin_inset Formula $x$
\end_inset

 cualquier valor de 
\begin_inset Formula $\mathbf{N}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

La sentencia 
\begin_inset Formula $\forall x\forall y(x\leq y\vee y\leq x)$
\end_inset

 es falsa en 
\begin_inset Formula $(\mathbf{N},|)$
\end_inset

 
\end_layout

\begin_layout Standard
Tambien es bueno pensar que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

La formula 
\begin_inset Formula $\forall y(a\leq y)$
\end_inset

 dice que 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset


\begin_inset Formula $a$
\end_inset

 es un elemento minimo de 
\begin_inset Formula $(P,\leq)$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, la cual sera o no verdadera en 
\begin_inset Formula $(P,\leq)$
\end_inset

 dependiendo de que valor tenga asignado 
\begin_inset Formula $a$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

La formula 
\begin_inset Formula $\lnot\exists y(x\leq y\wedge\lnot(y=x))$
\end_inset

 dice que 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset


\begin_inset Formula $x$
\end_inset

 es un elemento maximal de 
\begin_inset Formula $(P,\leq)$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, la cual sera o no verdadera en 
\begin_inset Formula $(P,\leq)$
\end_inset

 dependiendo de que valor tenga asignado 
\begin_inset Formula $x$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Variables libres
\end_layout

\begin_layout Standard
Para tener una mejor intuicion del concepto de variable libre de una formula
 elemental de posets, nos explayaremos un poco mas dando varios ejemplos.
 Primero deberiamos notar que si una variable ocurre varias veces en una
 formula, entonces algunas de aquellas ocurrencias seran libres y otras
 no.
 Por ejemplo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

En la formula 
\begin_inset Formula $(x\leq a)\rightarrow\exists x\ ((a\leq x)\wedge(b\leq x))$
\end_inset

 la primer ocurrencia de 
\begin_inset Formula $x$
\end_inset

 es libre y las otras tres ocurrencias de 
\begin_inset Formula $x$
\end_inset

 no son libres 
\end_layout

\begin_layout Standard
Como es usual a las ocurrencias que no son libres las llamaremos 
\shape italic
acotadas
\shape default
.
 O sea que toda ocurrencia de una variable en una formula es ya sea libre
 o acotada.
 Por ejemplo, en la formula
\begin_inset Formula 
\[
(z\leq y)\wedge\forall y(z\leq y)
\]

\end_inset

la variable 
\begin_inset Formula $y$
\end_inset

 ocurre tres veces, la primera ocurrencia es libre y la segunda y tercera
 son acotadas.
\end_layout

\begin_layout Standard
Cuando digamos que 
\begin_inset Formula $x$
\end_inset

 
\shape italic
es una variable libre de una formula
\shape default
 
\begin_inset Formula $\varphi$
\end_inset

 nos estaremos refiriendo a que la variable 
\begin_inset Formula $x$
\end_inset

 ocurre al menos una ves libremente en 
\begin_inset Formula $\varphi$
\end_inset

, aunque tambien puede ocurrir acotadamente en 
\begin_inset Formula $\varphi$
\end_inset

.
 En el ejemplo anterior justamente se da ese caso y 
\begin_inset Formula $x$
\end_inset

 es una variable libre de dicha formula.
 Por ejemplo las variables libres de la formula
\begin_inset Formula 
\[
((x\leq z)\vee\exists x\forall y\ ((a\leq x)\wedge(y\leq x)))\rightarrow\forall y(z\leq y)
\]

\end_inset

son 
\begin_inset Formula $x$
\end_inset

 y 
\begin_inset Formula $z$
\end_inset

.
 Las dos ocurrencias de 
\begin_inset Formula $z$
\end_inset

 son libres, todas las ocurrencias de 
\begin_inset Formula $y$
\end_inset

 son acotadas, la primer ocurrencia de 
\begin_inset Formula $x$
\end_inset

 es libre y las otras tres ocurrencias de 
\begin_inset Formula $x$
\end_inset

 son acotadas.
\end_layout

\begin_layout Subsubsection
Alcance de la ocurrencia de un cuantificador
\end_layout

\begin_layout Standard
Un 
\shape italic
cuantificador
\shape default
 sera una palabra formada por alguno de los simbolos
\begin_inset Formula 
\[
\forall\ \ \ \ \exists
\]

\end_inset

seguido de una variable.
 Es decir
\begin_inset Formula 
\[
\exists x\ \ \ \forall x\ \ \ \exists y\ \ \ \forall y\ \ \ \exists z\ \ \ \forall z\ \ \ldots
\]

\end_inset

son los cuantificadores.
\end_layout

\begin_layout Standard
Una propiedad importante de las formulas elementales es que siempre que
 un cuantificador ocurra en una formula, seguido a dicha ocurrencia ocurrira
 una formula elemental (la cual ademas es unica).
 Ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

En la formula
\begin_inset Formula 
\[
(((x\leq y)\wedge\forall y\lnot(y=a))\rightarrow\forall y(z\leq y))\vee(x\leq z)
\]

\end_inset

seguido a la segunda ocurrencia del cuantificador 
\begin_inset Formula $\forall y$
\end_inset

 ocurre la formula 
\begin_inset Formula $(z\leq y)$
\end_inset

 y seguido a la primer ocurrencia del cuantificador 
\begin_inset Formula $\forall y$
\end_inset

 ocurre la formula 
\begin_inset Formula $\lnot(y=a)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

En la formula
\begin_inset Formula 
\[
\forall x\forall y(x\leq y\vee y\leq x)
\]

\end_inset

seguido a la unica ocurrencia del cuantificador 
\begin_inset Formula $\forall y$
\end_inset

 ocurre la formula 
\begin_inset Formula $(x\leq y\vee y\leq x)$
\end_inset

 y seguido a la unica ocurrencia del cuantificador 
\begin_inset Formula $\forall x$
\end_inset

 ocurre la formula 
\begin_inset Formula $\forall y(x\leq y\vee y\leq x)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Esto nos da lugar al concepto de 
\shape italic
alcance
\shape default
 de una ocurrencia de un cuantificador en una formula elemental.
 Intuitivamente hablando, el alcance de una ocurrencia de un cuantificador
 es el espacio ocupado por la unica formula que ocurre inmediatamente despues
 de dicha ocurrencia del cuantificador.
 Parece un trabalenguas pero con ejemplos se entendera la idea.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

En la formula
\begin_inset Formula 
\[
(((x\leq y)\wedge\forall y\underline{\lnot(y=a)})\rightarrow\forall y(z\leq y))\vee(x\leq z)
\]

\end_inset

hemos subrayado el alcance de la primer ocurrencia del cuantificador 
\begin_inset Formula $\forall y$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

En la formula
\begin_inset Formula 
\[
\forall x\underline{\forall y(x\leq y\vee y\leq x)}
\]

\end_inset

hemos subrayado el alcance de la unica ocurrencia del cuantificador 
\begin_inset Formula $\forall x$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

En la formula
\begin_inset Formula 
\[
((x\leq z)\vee\exists x\underline{\forall y((a\leq x)\wedge(y\leq x))})\rightarrow\exists x(x\leq y)
\]

\end_inset

hemos subrayado el alcance de la primer ocurrencia del cuantificador 
\begin_inset Formula $\exists x$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que una ocurrencia de una variable 
\begin_inset Formula $v$
\end_inset

 en una formula elemental 
\begin_inset Formula $\varphi$
\end_inset

 sera acotada si y solo si ya sea es parte de la ocurrencia de un cuantificador
 
\begin_inset Formula $Qv$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

, con 
\begin_inset Formula $Q\in\{\forall,\exists\}$
\end_inset

, o dicha ocurrencia sucede dentro del alcance de la ocurrencia de un cuantifica
dor 
\begin_inset Formula $Q^{\prime}v$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

, con 
\begin_inset Formula $Q^{\prime}\in\{\forall,\exists\}$
\end_inset

.
\end_layout

\begin_layout Standard
Deberia quedar claro que el roll jugado por una variable 
\begin_inset Formula $v$
\end_inset

 en sus ocurrencias acotadas (dentro de la ocurrencia de un cuantificador
 
\begin_inset Formula $Qv$
\end_inset

 y su alcance) es en algun sentido 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

mudo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 o 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

impersonal
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 en el sentido que podriamos reemplazar dichas ocurrencias de 
\begin_inset Formula $v$
\end_inset

 por una variable 
\begin_inset Formula $w$
\end_inset

 que no ocurra en la formula y el significado de la formula resultante seria
 el mismo que el de la formula original.
 Por ejemplo la formula
\begin_inset Formula 
\[
\lnot(x=a)\wedge\forall y((x\leq y)\wedge(x\leq y))
\]

\end_inset

nos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

dice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 que 
\begin_inset Formula $x$
\end_inset

 es distinto a 
\begin_inset Formula $a$
\end_inset

 y que 
\begin_inset Formula $x$
\end_inset

 es comparable con todo otro elemento del poset; y si reemplazamos cada
 ocurrencia de 
\begin_inset Formula $y$
\end_inset

 en el bloque 
\begin_inset Formula $\forall y((x\leq y)\wedge(x\leq y))$
\end_inset

 por la variable 
\begin_inset Formula $z$
\end_inset

, obtenemos
\begin_inset Formula 
\[
\lnot(x=a)\wedge\forall z((x\leq z)\wedge(x\leq z))
\]

\end_inset

la cual claramente dice lo mismo acerca de 
\begin_inset Formula $x$
\end_inset

 y 
\begin_inset Formula $a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Pruebas elementales de posets
\end_layout

\begin_layout Standard
Notese que el concepto de poset se puede axiomatizar con sentencias elementales
 de las recien descriptas, a saber, un 
\shape italic
poset
\shape default
 es un par 
\begin_inset Formula $(P,\leq)$
\end_inset

 tal que 
\begin_inset Formula $P$
\end_inset

 es un conjunto no vacio, 
\begin_inset Formula $\leq$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $P$
\end_inset

 y se cumplen:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x(x\leq x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\;((x\leq y\wedge y\leq z)\rightarrow x\leq z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y((x\leq y\wedge y\leq x)\rightarrow x=y)$
\end_inset

 
\end_layout

\begin_layout Standard
Muchas de las pruebas dadas sobre posets consisten en probar que cierta
 sentencia elemental se cumple en todos los posets.
 Por ejemplo la sentencia elemental
\begin_inset Formula 
\[
\mu=\forall x\forall y\left((\forall z\ z\leq x\wedge\forall z\ z\leq y)\rightarrow x=y\right)
\]

\end_inset

claramente se cumple en todos los posets ya que ella expresa que si en un
 poset 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 son elementos maximos, entonces 
\begin_inset Formula $x=y$
\end_inset

.
 Mas aun, la prueba de este hecho puede escribirse usando solo formulas
 elementales de posets y ciertas aclaraciones minimas de castellano que
 sirven para justificar los distintos pasos en forma obvia.
 A este tipo de pruebas las llamaremos 
\shape italic
pruebas elementales de posets
\shape default
.
 A continuacion damos la prueba elemental de 
\begin_inset Formula $\mu$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [Prueba elemental de 
\begin_inset Formula $\mu$
\end_inset

]Denotemos con 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 un par de elementos de 
\begin_inset Formula $A$
\end_inset

, fijos.
 Supongamos
\begin_inset Formula 
\[
(\forall z\ z\leq a\wedge\forall z\ z\leq b)
\]

\end_inset

En particular 
\begin_inset Formula $\forall z\ z\leq b$
\end_inset

 nos dice que 
\begin_inset Formula $a\leq b$
\end_inset

 y 
\begin_inset Formula $\forall z\ z\leq a$
\end_inset

 nos dice que 
\begin_inset Formula $b\leq a$
\end_inset

, por lo cual tenemos que
\begin_inset Formula 
\[
a\leq b\wedge b\leq a
\]

\end_inset

Pero el axioma
\begin_inset Formula 
\[
\forall x\forall y((x\leq y\wedge y\leq x)\rightarrow x=y)
\]

\end_inset

nos dice que
\begin_inset Formula 
\[
(a\leq b\wedge b\leq a)\rightarrow a=b
\]

\end_inset

obteniendo de esta forma que 
\begin_inset Formula $a=b$
\end_inset

.
 O sea que hemos probado que
\begin_inset Formula 
\[
(\forall z\ z\leq a\wedge\forall z\ z\leq b)\rightarrow a=b
\]

\end_inset

Como 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 eran elementos cualesquiera, obtenemos que vale 
\begin_inset Formula $\mu$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Formulas elementales de reticulados terna
\end_layout

\begin_layout Standard
Se construyen en forma finitaria usando simbolos de la siguiente lista:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;=\;\mathsf{s\;\ i}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Variables: 
\begin_inset Formula $x,y,z,w,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Nombres para elementos fijos: 
\begin_inset Formula $a,b,c,d,...$
\end_inset

 
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x\;\mathsf{s\;}y=a)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x=y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $((a\;\mathsf{s\;}z)\;\mathsf{i\;}x)=((x\;\mathsf{i\;}y)\;\mathsf{s\;}x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(b=c)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z((x\mathsf{\;s\;}y)\;\mathsf{s}\;z=x\;\mathsf{s}\;(y\;\mathsf{s}\;z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall y(x\;\mathsf{s\;}y=a\rightarrow b=y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\exists y(x\;\mathsf{s\;}y=a)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z\;((x=y\wedge y=z)\rightarrow x=z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\lnot\exists y(x\;\mathsf{s\;}y=y\wedge\lnot(x=y))$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que dado que estamos considerando ahora reticulados ternas, las 
\shape italic
formulas elementales de reticulados ternas
\shape default
 no pueden usar el simbolo 
\begin_inset Formula $\leq$
\end_inset

 ya que no esta explicito en la presentacion de este tipo de estructura.
 Para que una formula se vuelva verdadera o falsa tenemos que tener un reticulad
o concreto 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y ademas asignarles valores concretos de 
\begin_inset Formula $L$
\end_inset

 a las variables libres y a los nombres de elementos fijos que ocurran en
 dicha formula.
 Cuando la formula no tiene variables libres diremos que es una 
\shape italic
sentencia elemental de reticulados ternas
\shape default
.
 Notese que en tal caso sera verdadera en un reticulado terna dado, dependiendo
 solo de los valores que tomen los nombres de constantes fijas que ocurren
 en ella.
\end_layout

\begin_layout Standard
Por ejemplo en el reticulado 
\begin_inset Formula $(\mathbf{N},mcm,mcd)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

la formula 
\begin_inset Formula $(x\;\mathsf{s\;}y=y)$
\end_inset

 es verdadera cuando le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 
\begin_inset Formula $6$
\end_inset

 y a 
\begin_inset Formula $y$
\end_inset

 el valor 
\begin_inset Formula $36$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\forall y(a=a\;\mathsf{i\;}y)$
\end_inset

 es verdadera cuando le asignamos a 
\begin_inset Formula $a$
\end_inset

 el valor 
\begin_inset Formula $1$
\end_inset

 y falsa si le asignamos el valor 
\begin_inset Formula $5$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

La sentencia 
\begin_inset Formula $\forall x\forall y(x\mathsf{\;i\;}y=y\mathsf{\;s\;}x)$
\end_inset

 es falsa en 
\begin_inset Formula $(\mathbf{N},mcm,mcd)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Pruebas elementales de reticulados terna
\end_layout

\begin_layout Standard
Igual que para el caso de los posets el concepto de reticulado terna fue
 definido con sentencias elementales de las recien descriptas, es decir:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\;\mathsf{s}\;x=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\mathsf{\;i\;}x=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\mathsf{\;s\;}y=y\;\mathsf{s}\;x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\mathsf{\;i\;}y=y\mathsf{\;i\;}x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z((x\mathsf{\;s\;}y)\;\mathsf{s}\;z=x\;\mathsf{s}\;(y\;\mathsf{s}\;z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z((x\mathsf{\;i\;}y)\mathsf{\;i\;}z=x\mathsf{\;i\;}(y\mathsf{\;i\;}z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\;\mathsf{s}\;(x\mathsf{\;i\;}y)=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\mathsf{\;i\;}(x\;\mathsf{s}\;y)=x)$
\end_inset

 
\end_layout

\begin_layout Standard
Analogamente al caso de los posets, llamaremos 
\shape italic
pruebas elementales de reticulados terna
\shape default
 a aquellas pruebas que partiendo de los axiomas anteriores demuestran cierta
 sentencia elemental usando en el camino solo sentencias elementales de
 reticulados ternas y ciertas aclaraciones minimas de castellano que sirven
 para justificar los distintos pasos en forma obvia.
\end_layout

\begin_layout Standard
Como ejemplo daremos a continuacion una prueba elemental de reticulados
 terna de la sentencia 
\begin_inset Formula $\eta=\forall x\forall y(x\;\mathsf{s}\;y=y\rightarrow x\;\mathsf{i}\;y=x)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [Prueba elemental de 
\begin_inset Formula $\eta$
\end_inset

]Denotemos con 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 un par de elementos de 
\begin_inset Formula $A$
\end_inset

, fijos.
 Supongamos
\begin_inset Formula 
\[
(a\;\mathsf{s}\;b=b)
\]

\end_inset

El axioma
\begin_inset Formula 
\[
\forall x\forall y(x\mathsf{\;i\;}(x\;\mathsf{s}\;y)=x)
\]

\end_inset

nos dice que
\begin_inset Formula 
\[
a\mathsf{\;i\;}(a\;\mathsf{s}\;b)=a
\]

\end_inset

O sea que reemplazando en esta igualdad 
\begin_inset Formula $a\;\mathsf{s}\;b$
\end_inset

 por 
\begin_inset Formula $b$
\end_inset

 obtenemos:
\begin_inset Formula 
\[
a\mathsf{\;i\;}b=a
\]

\end_inset

Ya que habiamos supuesto que 
\begin_inset Formula $a\;\mathsf{s}\;b=b$
\end_inset

 hemos probado en realidad que
\begin_inset Formula 
\[
a\;\mathsf{s}\;b=b\rightarrow a\mathsf{\;i\;}b=a
\]

\end_inset

Como 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 eran elementos cualesquiera, obtenemos que vale 
\begin_inset Formula $\forall x\forall y(x\;\mathsf{s}\;y=y\rightarrow x\;\mathsf{i}\;y=x)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Encontrar pruebas elementales de reticulados terna tiene cierta dificultad
 ya que solo podemos usar los axiomas de reticulados terna y ademas no podemos
 escribir el simbolo 
\begin_inset Formula $\leq$
\end_inset

.
 De todas maneras podemos escribir 
\begin_inset Formula $t\;\mathsf{s}\;s=s$
\end_inset

 en lugar de 
\begin_inset Formula $t\leq s$
\end_inset

 y de esta manera simular en nuestras formulas elementales al simbolo 
\begin_inset Formula $\leq$
\end_inset

.
 Otro escollo para encontrar facilmente pruebas elementales de reticulados
 ternas es que de los axiomas no es obvio que las operaciones s e i sean
 supremo e infimo respecto del orden dado por la ecuacion 
\begin_inset Formula $x\;\mathsf{s}\;y=y$
\end_inset

.
 Esto puede ser resuelto si nos inspiramos en la prueba del Teorema de Dedeking
 pero de todas maneras las pruebas se complican un poco en su escritura.
\end_layout

\begin_layout Standard
A continuacion introduciremos un tipo nuevo de estructura reticulada para
 las cuales las pruebas elementales seran mas faciles de encontrar.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Reticulados cuaterna
\end_layout

\begin_layout Standard
Por un 
\shape italic
reticulado cuaterna
\shape default
 entenderemos una 
\begin_inset Formula $4$
\end_inset

-upla 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},\leq)$
\end_inset

 tal que 
\begin_inset Formula $L$
\end_inset

 es un conjunto no vacio, 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

 son operaciones binarias sobre 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $\leq$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $L$
\end_inset

 y se cumplen los siguientes axiomas:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{A}_{\leq R}=\forall x(x\leq x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{A}_{\leq T}=\forall x\forall y\forall z\;((x\leq y\wedge y\leq z)\rightarrow x\leq z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{A}_{\leq A}=\forall x\forall y((x\leq y\wedge y\leq x)\rightarrow x=y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{A}_{\mathsf{s}esC}=\forall x\forall y\;(x\leq x\;\mathsf{s}\;y\wedge y\leq x\;\mathsf{s}\;y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{A}_{\mathsf{s}\leq C}=\forall x\forall y\forall z\;\left((x\leq z\wedge y\leq z)\rightarrow x\;\text{\ensuremath{\mathsf{s\;}}}y\leq z\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{A}_{\mathsf{i}esC}=\forall x\forall y\;(x\;\mathsf{i}\;y\leq x\wedge x\;\mathsf{i}\;y\leq y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\mathrm{A}_{\mathsf{i}\geq C}=\forall x\forall y\forall z\;\left((z\leq x\wedge z\leq y)\rightarrow z\leq x\;\mathsf{i}\;y\right)$
\end_inset

 
\end_layout

\begin_layout Standard
Obviamente los tres primeros nos garantizan que 
\begin_inset Formula $(L,\leq)$
\end_inset

 es un poset.
 Ademas notese que el axioma 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}esC}$
\end_inset

 nos garantiza que cualesquiera sean 
\begin_inset Formula $x,y\in L$
\end_inset

 se tiene que 
\begin_inset Formula $x\;\mathsf{s}\;y$
\end_inset

 es cota superior del conjunto 
\begin_inset Formula $\{x,y\}$
\end_inset

.
 El axioma 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}\leq C}$
\end_inset

 nos dice que cualesquiera sean los elementos 
\begin_inset Formula $x,y\in L$
\end_inset

, se tiene que 
\begin_inset Formula $x\;\mathsf{s}\;s$
\end_inset

 es menor o igual que que cualquier cota superior del conjunto 
\begin_inset Formula $\{x,y\}$
\end_inset

.
 Por supuesto esto nos garaniza que 
\begin_inset Formula $x\;\mathsf{s}\;y=\mathrm{sup}\{x,y\}$
\end_inset

.
 Similarmente los axiomas 
\begin_inset Formula $\mathrm{A}_{\mathsf{i}esC}$
\end_inset

 y 
\begin_inset Formula $\mathrm{A}_{\mathsf{i}\geq C}$
\end_inset

 garantizan que 
\begin_inset Formula $x\;\mathsf{s}\;y=\inf\{x,y\}$
\end_inset

.
\end_layout

\begin_layout Standard
O sea que, en virtud del teorema de Dedeking, tenemos que un reticulado
 cuaterna no es ni mas ni menos que una 
\begin_inset Formula $4$
\end_inset

-upla 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},\leq)$
\end_inset

 tal que 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 es un reticulado terna y 
\begin_inset Formula $\leq$
\end_inset

 es su orden parcial asociado.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Formulas elementales de reticulados cuaterna
\end_layout

\begin_layout Standard
Se construyen en forma finitaria usando simbolos de la siguiente lista:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;=\;\mathsf{s\;}\;\mathsf{i\;}\leq$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Variables: 
\begin_inset Formula $x,y,z,w,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Nombres para elementos fijos: 
\begin_inset Formula $a,b,c,d,...$
\end_inset

 
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x\leq y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x=y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(a\leq z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x\;\mathsf{s\;}y=a)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $((a\;\mathsf{s\;}z)\;\mathsf{i\;}x)=((x\;\mathsf{i\;}y)\;\mathsf{s\;}x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z((x\mathsf{\;s\;}y)\;\mathsf{s}\;z\leq x\;\mathsf{s}\;(y\;\mathsf{s}\;z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\lnot\exists y(x\;\mathsf{s\;}y=y\wedge\lnot(x=y))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z\;((x\leq y\wedge y\leq z)\rightarrow x\leq z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(\forall x\exists y(x\;\mathsf{s\;}y=a))\rightarrow(a\leq a)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Pruebas elementales de reticulados cuaterna
\end_layout

\begin_layout Standard
Tal como para los otros tipos de estructuras, llamaremos 
\shape italic
pruebas elementales de reticulados cuaterna
\shape default
 a aquellas pruebas que partiendo de los axiomas 
\begin_inset Formula $\mathrm{A}_{\leq R}$
\end_inset

, 
\begin_inset Formula $\mathrm{A}_{\leq A}$
\end_inset

, 
\begin_inset Formula $\mathrm{A}_{\leq T}$
\end_inset

, 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}esC}$
\end_inset

, 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}\leq C}$
\end_inset

, 
\begin_inset Formula $\mathrm{A}_{\mathsf{i}esC}$
\end_inset

 y 
\begin_inset Formula $\mathrm{A}_{\mathsf{i}\geq C}$
\end_inset

 demuestran cierta sentencia elemental, usando en el camino solo sentencias
 elementales de reticulados cuaternas y ciertas aclaraciones minimas de
 castellano que sirven para justificar los distintos pasos en forma obvia.
\end_layout

\begin_layout Standard
Muchas de las pruebas dadas en la Guia 2 pueden adaptarse naturalmente para
 ser pruebas elementales de reticulados cuaterna.
 Para hacer esta adaptacion notese que el axioma 
\begin_inset Formula $\mathrm{A}_{\leq A}$
\end_inset

 puede ser usado en lugar de aplicar la regla Igualdad en Posets y similarmente
 los axiomas 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}\leq C}$
\end_inset

 y 
\begin_inset Formula $\mathrm{A}_{\mathsf{i}\geq C}$
\end_inset

 se pueden usar en lugar de las reglas Superar un Supremo y Ser Menor o
 Igual que un Infimo.
 Por ejemplo veamos una prueba elemental de la sentencia 
\begin_inset Formula $\rho=\forall x\forall y(x\;\mathsf{s}\;y=y\;\mathsf{s}\;x)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [Prueba elemental de 
\begin_inset Formula $\rho$
\end_inset

:]Sean 
\begin_inset Formula $a,b\in L$
\end_inset

 elementos fijos.
 Por el axioma 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}esC}$
\end_inset

 (intanciado haciendo 
\begin_inset Formula $x=b$
\end_inset

 y 
\begin_inset Formula $y=a$
\end_inset

) tenemos que
\begin_inset Formula 
\[
b\leq b\;\mathsf{s}\;a\wedge a\leq b\;\mathsf{s}\;a
\]

\end_inset

De lo cual sacamos obviamente que
\begin_inset Formula 
\[
a\leq b\;\mathsf{s}\;a\wedge b\leq b\;\mathsf{s}\;a
\]

\end_inset

Ademas el axioma 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}\leq C}$
\end_inset

 (instanciado haciendo 
\begin_inset Formula $x=a$
\end_inset

, 
\begin_inset Formula $y=b$
\end_inset

 y 
\begin_inset Formula $z=b\;\mathsf{s}\;a$
\end_inset

) nos dice que
\begin_inset Formula 
\[
\left((a\leq b\;\mathsf{s}\;a\wedge b\leq b\;\mathsf{s}\;a)\rightarrow a\;\text{\ensuremath{\mathsf{s\;}}}b\leq b\;\mathsf{s}\;a\right)
\]

\end_inset

O sea que de las ultimas dos sentencias obtenemos trivialmente que
\begin_inset Formula 
\[
a\;\text{\ensuremath{\mathsf{s\;}}}b\leq b\;\mathsf{s}\;a
\]

\end_inset

En forma analoga se puede probar que
\begin_inset Formula 
\[
b\;\mathsf{s}\;a\leq a\;\text{\ensuremath{\mathsf{s\;}}}b
\]

\end_inset

Lo cual nos dice trivialmente que
\begin_inset Formula 
\[
a\;\text{\ensuremath{\mathsf{s\;}}}b\leq b\;\mathsf{s}\;a\wedge b\;\mathsf{s}\;a\leq a\;\text{\ensuremath{\mathsf{s\;}}}b
\]

\end_inset

Pero el axioma 
\begin_inset Formula $\mathrm{A}_{\leq A}$
\end_inset

 nos dice que
\begin_inset Formula 
\[
(a\;\text{\ensuremath{\mathsf{s\;}}}b\leq b\;\mathsf{s}\;a\wedge b\;\mathsf{s}\;a\leq a\;\text{\ensuremath{\mathsf{s\;}}}b)\rightarrow a\;\text{\ensuremath{\mathsf{s\;}}}b=b\;\mathsf{s}\;a
\]

\end_inset

De lo cual obviamente obtenemos que
\begin_inset Formula 
\[
a\;\text{\ensuremath{\mathsf{s\;}}}b=b\;\mathsf{s}\;a
\]

\end_inset

Ya que 
\begin_inset Formula $a,b$
\end_inset

 eran elementos fijos pero arbitrarios, hemos probado que
\begin_inset Formula 
\[
\forall x\forall y(x\;\mathsf{s}\;y=y\;\mathsf{s}\;x)
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Por supuesto, en la parte de la prueba en la que decimos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

En forma analoga se puede probar que 
\begin_inset Formula $b\;\mathsf{s}\;a\leq a\;\mathsf{s\;}$
\end_inset


\begin_inset Formula $b$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 deberiamos poner las lineas que corresponden para obtener la prueba elemental
 completa.
\end_layout

\begin_layout Standard
Ahora daremos una prueba elemental de la sentencia 
\begin_inset Formula $\mu=\forall x\forall y(x\leq y\leftrightarrow x\;\mathsf{s}\;y=y)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [Prueba elemental de 
\begin_inset Formula $\mu$
\end_inset

:]Sean 
\begin_inset Formula $a,b\in L$
\end_inset

 elementos fijos.
 Supongamos que 
\begin_inset Formula $a\leq b$
\end_inset

.
 Probaremos que 
\begin_inset Formula $a\;\mathsf{s}\;b=b$
\end_inset

.
 Notese que por el axioma 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}esC}$
\end_inset

 tenemos que
\begin_inset Formula 
\[
b\leq a\;\mathsf{s}\;b
\]

\end_inset

Por el axioma 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}\leq C}$
\end_inset

 tenemos que
\begin_inset Formula 
\[
\left((a\leq b\wedge b\leq b)\rightarrow a\;\text{\ensuremath{\mathsf{s\;}}}b\leq b\right)
\]

\end_inset

Pero por el axioma 
\begin_inset Formula $\mathrm{A}_{\leq R}$
\end_inset

 tenemos que 
\begin_inset Formula $b\leq b$
\end_inset

 y por hipotesis tenemos que 
\begin_inset Formula $a\leq b$
\end_inset

 por lo cual
\begin_inset Formula 
\[
a\leq b\wedge b\leq b
\]

\end_inset

Obviamente esto nos dice que 
\begin_inset Formula $a\;\mathsf{s\;}$
\end_inset


\begin_inset Formula $b\leq b$
\end_inset

.
 O sea que hemos probado
\begin_inset Formula 
\[
a\;\mathsf{s\;}b\leq b\wedge b\leq a\;\mathsf{s\;}b
\]

\end_inset

Lo cual por el axioma 
\begin_inset Formula $\mathrm{A}_{\leq A}$
\end_inset

 nos dice que 
\begin_inset Formula $a\;\mathsf{s}\;b=b$
\end_inset

.
 Ya que habiamos asumido que 
\begin_inset Formula $a\leq b$
\end_inset

 en realidad hemos probado que
\begin_inset Formula 
\[
a\leq b\rightarrow a\;\mathsf{s}\;b=b
\]

\end_inset

Supongamos ahora que 
\begin_inset Formula $a\;\mathsf{s}\;b=b$
\end_inset

.
 Por el axioma 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}esC}$
\end_inset

 tenemos que 
\begin_inset Formula $a\leq a\;\mathsf{s}\;b$
\end_inset

.
 Ya que 
\begin_inset Formula $a\;\mathsf{s}\;b=b$
\end_inset

 obtenemos que 
\begin_inset Formula $a\leq b$
\end_inset

.
 O sea que realmente hemos probado que
\begin_inset Formula 
\[
a\;\mathsf{s}\;b=b\rightarrow a\leq b
\]

\end_inset

Lo cual por la otra implicacion probada nos dice que
\begin_inset Formula 
\[
a\leq b\leftrightarrow a\;\mathsf{s}\;b=b
\]

\end_inset

Ya que 
\begin_inset Formula $a,b$
\end_inset

 eran elementos fijos pero arbitrarios, hemos probado que
\begin_inset Formula 
\[
\forall x\forall y(x\leq y\leftrightarrow x\;\mathsf{s}\;y=y)
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Formulas elementales de reticulados complementados
\end_layout

\begin_layout Standard
Ya que los reticulados complementados son 
\begin_inset Formula $6$
\end_inset

-uplas 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i},c,0,1)$
\end_inset

 las formulas elementales se construyen en forma finitaria usando simbolos
 de la siguiente lista:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;=\;\mathsf{s\;\ i}$
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Formula $c\ \ 0\ \ 1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Variables: 
\begin_inset Formula $x,y,z,w,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Nombres para elementos fijos: 
\begin_inset Formula $a,b,c,d,...$
\end_inset

 
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(0\;\mathsf{s\;}c(y)=a)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x\;\mathsf{s\;}1=a)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $((c(a)\;\mathsf{s\;}z)\;\mathsf{i\;}x)=((x\;\mathsf{i\;}y)\;\mathsf{s\;}x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(c(c(c(b)))=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z((x\mathsf{\;s\;}y)\;\mathsf{s}\;z=x\;\mathsf{s}\;(y\;\mathsf{s}\;z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(x\;\mathsf{s\;}y=1\wedge x\;\mathsf{i\;}y=0)\rightarrow x=c(y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z\;((x=y\wedge y=z)\rightarrow x=z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\exists x\exists z\exists y\ c((a\;\mathsf{s\;}z)\;\mathsf{i\;}x))=((x\;\mathsf{i\;}c(y))\;\mathsf{s\;}x))$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Pruebas elementales de reticulados complementados
\end_layout

\begin_layout Standard
Igual que para el caso de los reticulados terna el concepto de reticulado
 complementado fue definido con sentencias elementales de las recien descriptas,
 es decir:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\;\mathsf{s}\;x=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\mathsf{\;i\;}x=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\mathsf{\;s\;}y=y\;\mathsf{s}\;x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\mathsf{\;i\;}y=y\mathsf{\;i\;}x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z((x\mathsf{\;s\;}y)\;\mathsf{s}\;z=x\;\mathsf{s}\;(y\;\mathsf{s}\;z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z((x\mathsf{\;i\;}y)\mathsf{\;i\;}z=x\mathsf{\;i\;}(y\mathsf{\;i\;}z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\;\mathsf{s}\;(x\mathsf{\;i\;}y)=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(x\mathsf{\;i\;}(x\;\mathsf{s}\;y)=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x(0\mathsf{\;s\;}x=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x(x\mathsf{\;s\;}1=1)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x(x\mathsf{\;s\;}c(x)=1)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x(x\mathsf{\;i\;}c(x)=0)$
\end_inset

 
\end_layout

\begin_layout Standard
Llamaremos 
\shape italic
pruebas elementales de reticulados complementados 
\shape default
a aquellas pruebas que partiendo de los axiomas anteriores demuestran cierta
 sentencia elemental usando en el camino solo sentencias elementales de
 reticulados complementados y ciertas aclaraciones minimas de castellano
 que sirven para justificar los distintos pasos en forma obvia.
 Aqui tambien como en el caso de reticulados terna tenemos el problema de
 no poder escribir el simbolo 
\begin_inset Formula $\leq$
\end_inset

 en nuestras pruebas elementales de reticulados complementados y tambien
 el escollo de que los axiomas no hacen referencia obvia a que las operaciones
 s e i sean operciones supremo e infimo respecto del orden asociado.
 Sin envargo muchas pruebas se pueden hacer en forma natural.
 Por ejemplo, notar que toda prueba elemental de reticulados terna es tambien
 una prueba elemental de reticulados complementados, por lo cual tenemos
 una prueba elemental de reticulados complementados de la sentencia
\begin_inset Formula 
\[
\forall x\forall y(x\;\mathsf{s}\;y=y\rightarrow x\;\mathsf{i}\;y=x)
\]

\end_inset

Otro ejemplo:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [Prueba elemental de 
\begin_inset Formula $\forall x(x\mathsf{\;i\;}1=x)$
\end_inset

:]Sea 
\begin_inset Formula $a\in L$
\end_inset

 fijo.
 El axioma
\begin_inset Formula 
\[
\forall x(x\mathsf{\;s\;}1=1)
\]

\end_inset

nos dice que
\begin_inset Formula 
\[
a\mathsf{\;s\;}1=1
\]

\end_inset

Ya que
\begin_inset Formula 
\[
\forall x\forall y(x\;\mathsf{s}\;y=y\rightarrow x\;\mathsf{i}\;y=x)
\]

\end_inset

(teorema ya probado) tenemos que
\begin_inset Formula 
\[
a\;\mathsf{s}\;1=1\rightarrow a\;\mathsf{i}\;1=a
\]

\end_inset

O sea que
\begin_inset Formula 
\[
a\;\mathsf{i}\;1=a
\]

\end_inset

Ya que 
\begin_inset Formula $a$
\end_inset

 era arbitrario, hemos probado que
\begin_inset Formula 
\[
\forall x(x\;\mathsf{i}\;1=x)
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que si realmente queremos tener la prueba elemental completa de 
\begin_inset Formula $\forall x(x\;\mathsf{i}\;1=x)$
\end_inset

 deberiamos agregar en la prueba anterior las lineas correspondientes a
 la prueba de 
\begin_inset Formula $\forall x\forall y(x\;\mathsf{s}\;y=y\rightarrow x\;\mathsf{i}\;y=x)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dejamos al lector decribir tal como se viene haciendo desde el comienso
 de esta seccion los conceptos de formula elemental de reticulados acotados
 y prueba elemental de reticulados acotados.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Grafos
\end_layout

\begin_layout Standard
Un 
\shape italic
grafo
\shape default
 es un par 
\begin_inset Formula $(G,r)$
\end_inset

 donde 
\begin_inset Formula $G$
\end_inset

 es un conjunto no vacio, 
\begin_inset Formula $r$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $G$
\end_inset

 y se cumple que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow r(y,x))$
\end_inset

 
\end_layout

\begin_layout Standard
(notese que escribimos 
\begin_inset Formula $r(x,y)$
\end_inset

 para expresar que 
\begin_inset Formula $(x,y)\in r$
\end_inset

).
 Hay varias presentaciones del concepto de grafo no dirigido pero el lector
 no tardara en darse cuenta que estas estructuras son equivalentes a las
 que el haya estudiado bajo el nombre de grafos no dirigidos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Formulas elementales de grafos
\end_layout

\begin_layout Standard
Las formulas elementales de grafos son aquellas que se pueden construir
 en forma finitaria usando simbolos de la siguiente lista:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;=r$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Variables: 
\begin_inset Formula $x,y,z,w,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Nombres para elementos fijos: 
\begin_inset Formula $a,b,c,d,...$
\end_inset

 
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $r(x,y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $r(a,z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall yr(a,y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z\;((r(x,y)\wedge r(y,z))\rightarrow r(x,z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\exists x\forall z\lnot r(x,z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\exists y(r(x,y)\wedge\forall z\ r(y,z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z\;((x=y\wedge y=z)\rightarrow x=z)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Pruebas elementales de grafos
\end_layout

\begin_layout Standard
Llamaremos 
\shape italic
pruebas elementales de grafos 
\shape default
a aquellas pruebas que partiendo del axioma 
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow r(y,x))$
\end_inset

 demuestran cierta sentencia elemental de grafos usando en el camino solo
 sentencias elementales de grafos y ciertas aclaraciones minimas de castellano
 que sirven para justificar los distintos pasos en forma obvia.
 Es dificil encontrar pruebas elementales de grafos que no sean complicadas.
 Aceptando cierto grado de complejidad hay muchas.
 Un dato interesante es que el conjunto de sentencias elementales de grafos
 que tienen una prueba elemental es no recursivo, es decir no hay un procedimien
to efectivo que decida si una sentencia elemental de grafos dada tiene una
 prueba elemental.
 Esto habla acerca de cuan complicada puede ser la estructura o fisonomia
 de las sentencias elementales de grafos que pueden ser probadas elementalmente.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Median algebras
\end_layout

\begin_layout Standard
Una 
\shape italic
median algebra
\shape default
 es un par 
\begin_inset Formula $(A,M)$
\end_inset

 donde 
\begin_inset Formula $A$
\end_inset

 es un conjunto no vacio, 
\begin_inset Formula $M$
\end_inset

 es una operacion 
\begin_inset Formula $3$
\end_inset

-aria sobre 
\begin_inset Formula $A$
\end_inset

 (i.e.
 
\begin_inset Formula $M:A^{3}\rightarrow A$
\end_inset

) y se cumplen:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z(M(x,y,z)=M(x,z,y))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z(M(x,y,z)=M(y,z,x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(M(x,x,y)=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\forall u\forall v(M(M(x,y,z),u,v))=M(x,M(y,u,v),M(z,u,v)))$
\end_inset

 
\end_layout

\begin_layout Standard
Por ejemplo si tomamos un reticulado 
\begin_inset Formula $(L,\mathsf{s},\mathsf{i})$
\end_inset

 y definimos 
\begin_inset Formula $M(x,y,z)=(x\;\mathsf{i\;}y)\;\mathsf{s\;}(x\;\mathsf{i\;}z)\;\mathsf{s\;}(y\;\mathsf{i\;}z)$
\end_inset

, para cada 
\begin_inset Formula $x,y,z\in L$
\end_inset

, entonces 
\begin_inset Formula $(L,M)$
\end_inset

 es una median algebra.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Formulas elementales de median algebras
\end_layout

\begin_layout Standard
Las formulas elementales de median algebras son aquellas que se pueden construir
 en forma finitaria usando simbolos de la siguiente lista:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;=M$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Variables: 
\begin_inset Formula $x,y,z,w,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Nombres para elementos fijos: 
\begin_inset Formula $a,b,c,d,...$
\end_inset

 
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $M(x,y,z)=a$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $M(a,b,M(M(M(x,y,z),u,v),x,a)=M(y,u,a)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall y(M(x,y,z)=z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\exists y(M(x,y,y)=y\rightarrow\forall z\ M(a,y,z)=M(x,x,x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\exists x\forall z\lnot(M(a,a,a)=a\vee\exists z(M(a,y,z)=b))$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Pruebas elementales de median algebras
\end_layout

\begin_layout Standard
Llamaremos 
\shape italic
pruebas elementales de median algebras 
\shape default
a aquellas pruebas que partiendo de los axiomas de median algebras demuestran
 cierta sentencia elemental de median algebras usando en el camino solo
 sentencias elementales de median algebras y ciertas aclaraciones minimas
 de castellano que sirven para justificar los distintos pasos en forma obvia.
 Es dificil encontrar pruebas elementales de median algebras que no sean
 complicadas.
 Un ejemplo:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [Prueba elemental de 
\begin_inset Formula $\forall x\forall y(M(x,y,y)=y)$
\end_inset

:]Sean 
\begin_inset Formula $a,b\in A$
\end_inset

 fijos.
 Por el axioma 
\begin_inset Formula $\forall x\forall y\forall z(M(x,y,z)=M(y,z,x))$
\end_inset

 tenemos que
\begin_inset Formula 
\[
M(a,b,b)=M(b,b,a)
\]

\end_inset

Por el axioma 
\begin_inset Formula $\forall x\forall y(M(x,x,y)=x)$
\end_inset

 tenemos que
\begin_inset Formula 
\[
M(b,b,a)=b
\]

\end_inset

O sea que
\begin_inset Formula 
\[
M(a,b,b)=b
\]

\end_inset

Ya que 
\begin_inset Formula $a,b$
\end_inset

 eran cualesquiera, hemos probado que 
\begin_inset Formula $\forall x\forall y(M(x,y,y)=y)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Grafos bicoloreados
\end_layout

\begin_layout Standard
Recordemos que dado un grafo 
\begin_inset Formula $(G,r)$
\end_inset

, un 
\shape italic
coloreo de 
\shape default

\begin_inset Formula $(G,r)$
\end_inset

 es una asignacion de colores a cada elemento de 
\begin_inset Formula $G$
\end_inset

 de manera que nunca dos elementos de 
\begin_inset Formula $G$
\end_inset

 que esten reacionados tengan el mismo color.
 En el caso que solo usemos dos colores, le llamaremos un 
\shape italic
bicoloreo de 
\shape default

\begin_inset Formula $(G,r)$
\end_inset

.
 Notese que un bicoloreo puede ser representado con un subconjunto de 
\begin_inset Formula $G$
\end_inset

.
 Por ejemplo si el bicoloreo coloreaba a los elementos de 
\begin_inset Formula $G$
\end_inset

 con dos colores, verde y rojo, podemos tomar 
\begin_inset Formula $R=\{g\in G:g$
\end_inset

 es rojo
\begin_inset Formula $\}$
\end_inset

 y esto determina nuestro bicoloreo ya que 
\begin_inset Formula $G-R$
\end_inset

 sera justamente el conjunto de elemenos verdes.
 O sea que matematicamente hablando podemos dar la siguiente definicion.
 Un 
\shape italic
bicoloreo de 
\shape default

\begin_inset Formula $(G,r)$
\end_inset

 es un subconjunto 
\begin_inset Formula $R$
\end_inset

 de 
\begin_inset Formula $G$
\end_inset

 el cual cumple que cualesquiera sean 
\begin_inset Formula $x,y\in G$
\end_inset

 se tiene que
\begin_inset Formula 
\[
\text{si }(x,y)\in r\text{, entonces }x\in R\text{ si y solo si }y\notin R
\]

\end_inset

Esto nos inspira para dar la definicion de un nuevo tipo de estructura.
\end_layout

\begin_layout Standard
Un 
\shape italic
grafo bicoloreado
\shape default
 es una terna 
\begin_inset Formula $(G,r,R)$
\end_inset

, donde 
\begin_inset Formula $(G,r)$
\end_inset

 es un grafo y 
\begin_inset Formula $R$
\end_inset

 es un bicoloreo de 
\begin_inset Formula $(G,r)$
\end_inset

.
 Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\{1,2\},\{(1,2),(2,1)\},\{1\})$
\end_inset

 es un grafo bicoloreado
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Tomemos
\begin_inset Formula 
\begin{align*}
G & =\omega\\
r & =\{(x,x+1):x\in\omega\}\cup\{(x+1,x):x\in\omega\}\\
R & =\{x\in\omega:x\text{ es par}\}
\end{align*}

\end_inset

Entonces 
\begin_inset Formula $(G,r,R)$
\end_inset

 es un grafo bicoloreado
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\{1,2,3,4\},\emptyset,R)$
\end_inset

 es un grafo bicoloreado, cualesquera sea 
\begin_inset Formula $R\subseteq\{1,2,3,4\}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Formulas elementales de grafos bicoloreados
\end_layout

\begin_layout Standard
Para escribir las formulas elementales de grafos bicoloreados, pensaremos
 a 
\begin_inset Formula $R$
\end_inset

 como una 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

relacion unaria
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y escribiremos 
\begin_inset Formula $R(x)$
\end_inset

 para expresar que 
\begin_inset Formula $x\in R$
\end_inset

.
 Asi como cuando escribimos 
\begin_inset Formula $r(x,y)$
\end_inset

 pensamos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset


\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 estan conectados
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, cuando escribamos 
\begin_inset Formula $R(x)$
\end_inset

 pensaremos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset


\begin_inset Formula $x$
\end_inset

 es rojo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Esto hace mas lejibles nuestras expresiones.
\end_layout

\begin_layout Standard
Las formulas elementales de grafos bicoloreados son aquellas que se pueden
 construir en forma finitaria usando simbolos de la siguiente lista:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;=r\ \ R$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Variables: 
\begin_inset Formula $x,y,z,w,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Nombres para elementos fijos: 
\begin_inset Formula $a,b,c,d,...$
\end_inset

 
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $R(a)\wedge r(x,y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\exists z(r(a,z)\rightarrow R(z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall yr(a,y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y((R(x)\wedge R(y))\rightarrow x=y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\exists x\forall z(\lnot R(z)\rightarrow r(x,z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow(R(x)\leftrightarrow\lnot R(y)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\forall z\;((x=y\wedge y=z)\rightarrow x=z)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Pruebas elementales de grafos bicoloreados
\end_layout

\begin_layout Standard
Notese que los grafos bicoloreados pueden axiomatizarse con las sentencias
 elementales:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow r(y,x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow(R(x)\leftrightarrow\lnot R(y)))$
\end_inset

 
\end_layout

\begin_layout Standard
Llamaremos 
\shape italic
pruebas elementales de grafos bicoloreados 
\shape default
a aquellas pruebas que partiendo de los dos axiomas anteriores demuestran
 cierta sentencia elemental de grafos bicoloreados usando en el camino solo
 sentencias elementales de grafos bicoloreados y ciertas aclaraciones minimas
 de castellano que sirven para justificar los distintos pasos en forma obvia.
 Es dificil encontrar pruebas elementales de grafos bicoloreados que no
 sean complicadas.
 Un par de ejemplos simples:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [Prueba elemental de 
\begin_inset Formula $\forall x\lnot r(x,x)$
\end_inset

:]Sea 
\begin_inset Formula $a\in G$
\end_inset

 fijo.
 Supongamos 
\begin_inset Formula $r(a,a)$
\end_inset

.
 Por el axioma 
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow(R(x)\leftrightarrow\lnot R(y)))$
\end_inset

 tenemos que 
\begin_inset Formula $(r(a,a)\rightarrow(R(a)\leftrightarrow\lnot R(a))$
\end_inset

.
 O sea que tenemos que
\begin_inset Formula 
\[
R(a)\leftrightarrow\lnot R(a)
\]

\end_inset

lo cual claramente es un absurdo.
 El absurdo proviene de suponer 
\begin_inset Formula $r(a,a)$
\end_inset

 lo cual nos dice que 
\begin_inset Formula $\lnot r(a,a)$
\end_inset

.
 Ya que 
\begin_inset Formula $a$
\end_inset

 era arbitrario, hemos probado que 
\begin_inset Formula $\forall x\lnot r(x,x)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 [Prueba elemental de 
\begin_inset Formula $\forall x\forall y\forall z\lnot(r(x,y)\wedge r(x,z)\wedge r(y,z))$
\end_inset

:]Sean 
\begin_inset Formula $a,b,c\in G$
\end_inset

 fijos.
 Supongamos 
\begin_inset Formula $r(a,b)\wedge r(a,c)\wedge r(b,c)$
\end_inset

.
 Supongamos que 
\begin_inset Formula $R(a)$
\end_inset

.
 Ya que 
\begin_inset Formula $r(a,b)$
\end_inset

 el axioma 
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow(R(x)\leftrightarrow\lnot R(y)))$
\end_inset

 nos dice que se da 
\begin_inset Formula $R(a)\leftrightarrow\lnot R(b)$
\end_inset

, de lo cual sacamos que 
\begin_inset Formula $\lnot R(b)$
\end_inset

.
 Ya que 
\begin_inset Formula $r(a,c)$
\end_inset

 el mismo axioma nos dice que se da 
\begin_inset Formula $R(a)\leftrightarrow\lnot R(c)$
\end_inset

, de lo cual sacamos que 
\begin_inset Formula $\lnot R(c)$
\end_inset

.
 Ya que 
\begin_inset Formula $r(b,c)$
\end_inset

 el mismo axioma nos dice que 
\begin_inset Formula $R(b)\leftrightarrow\lnot R(c)$
\end_inset

, de lo cual sacamos 
\begin_inset Formula $R(b)$
\end_inset

 (ya que se daba 
\begin_inset Formula $\lnot R(c)$
\end_inset

).
 O sea que probamos que se da 
\begin_inset Formula $R(b)\wedge\lnot R(b)$
\end_inset

, lo cual es absurdo.
 El absurdo proviene de suponer que se daba 
\begin_inset Formula $R(a)$
\end_inset

, por lo cual hemos probado que se da 
\begin_inset Formula $\lnot R(a)$
\end_inset

.
 Ya que 
\begin_inset Formula $r(a,b)$
\end_inset

 el axioma 
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow(R(x)\leftrightarrow\lnot R(y)))$
\end_inset

 nos dice que se da 
\begin_inset Formula $R(a)\leftrightarrow\lnot R(b)$
\end_inset

, de lo cual sacamos que 
\begin_inset Formula $R(b)$
\end_inset

 (ya que se da 
\begin_inset Formula $\lnot R(a)$
\end_inset

).
 Ya que 
\begin_inset Formula $r(a,c)$
\end_inset

 el mismo axioma nos dice que se da 
\begin_inset Formula $R(a)\leftrightarrow\lnot R(c)$
\end_inset

, de lo cual sacamos que 
\begin_inset Formula $R(c)$
\end_inset

.
 O sea que se da 
\begin_inset Formula $R(b)\wedge R(c)$
\end_inset

.
 Ya que 
\begin_inset Formula $r(b,c)$
\end_inset

 el mismo axioma nos dice que 
\begin_inset Formula $R(b)\leftrightarrow\lnot R(c)$
\end_inset

, lo cual contradice 
\begin_inset Formula $R(b)\wedge R(c)$
\end_inset

.
 El absurdo proviene de suponer que se daba 
\begin_inset Formula $r(a,b)\wedge r(a,c)\wedge r(b,c)$
\end_inset

 por lo cual hemos probado que 
\begin_inset Formula $\lnot(r(a,b)\wedge r(a,c)\wedge r(b,c))$
\end_inset

.
 Ya que 
\begin_inset Formula $a,b,c$
\end_inset

 eran arbitrarios, hemos probado que 
\begin_inset Formula $\forall x\forall y\forall z\lnot(r(x,y)\wedge r(x,z)\wedge r(y,z))$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Chapter
Logica matematica
\end_layout

\begin_layout Standard
En la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Seccion estructuras algebraicas ordenadas"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos focalizamos en aprender algebra con la intencion de volvernos lo mas
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

algebristas profecionales
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 que podamos.
 Para esto fuimos exigentes a la hora de delimitar y manejar nuestro lenguaje
 matematico y tambien a la hora de hacer pruebas pusimos mucha atencion
 en hacerlas 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

perfectas
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 en el sentido de que sean similares a las que haria un algebrista formado.
\end_layout

\begin_layout Standard
Pero para que hicimos esto? Muy simple: la logica matematica es 
\shape italic
matematica aplicada
\shape default
 al estudio de los matematicos, su lenguaje y sus metodos de demostracion,
 y que mas comodo para hacer logica matematica que contar con un matematico
 dentro de uno mismo para estudiarlo! Tal como
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

un biologo estudia la estructura y funcionamiento de los seres vivos
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

un astronomo estudia los cuerpos celestes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

un fisico estudia la materia y su comportamiento 
\end_layout

\begin_layout Standard
\noindent
un logico matematico estudia con herramientas matematicas a los mismos matematic
os en cuanto a sus caracteristicas en su roll haciendo matematica.
 Es decir nos interesa dar un modelo matematico que describa en forma matematica
 precisa el funcionamiento de un matematico en cuanto a su lenguaje y sus
 metodos de demostracion.
 Pero algo debe quedar muy claro: haremos matematica aplicada, es decir,
 no es nuestra intencion decirle a un matematico como debe razonar! Todo
 lo contrario, sabemos que los matematicos profecionales actuales razonan
 correctamente y que su estilo de prueba es correcto, dado el avansado estado
 actual de la disciplina y de sus profecionales.
 Simplemente los estudiaremos con herramientas matematicas para tratar de
 dar una descripcion matematica de su lenguaje y de sus metodos de demostracion.
\end_layout

\begin_layout Standard
Por supuesto hacer logica matematica puede ser muy dificil o escurridizo
 ya que como todos sabemos los matematicos tienen metodos dificiles de entender
 y un lenguaje verdaderamente complicado.
\end_layout

\begin_layout Standard
La forma en la que encararemos el problema sera la siguiente.
 En lugar de estudiar a un matematico en su actividad real crearemos un
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

contexto matematico simplificado
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 en el cual tambien tenga sentido hacer matematica profecional y luego estudiare
mos a un matematico haciendo matematica en este contexto.
 Por supueto esto baja mucho el nivel de nuestra ambicion cientifica como
 logicos matematicos ya que en lugar de estudiar a los matematicos en su
 vida real, los estudiaremos en un contexto simplificado.
 Sin envargo como veremos mas adelante nuestra simplificacion no nos hara
 perder generalidad y los resultados obtenidos daran un modelo matematico
 del quehacer matematico real.
 Este hecho es uno de los logros mas importantes de la ciencia moderna.
\end_layout

\begin_layout Standard
Para crear este 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

contexto matematico simplificado
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 nos serviran los conceptos de lenguaje elemental y prueba elemental.
 Mas concretamente fijaremos un tipo de estructura, por ejemplo los reticulados
 cuaterna, y estudiaremos a un matematico profecional haciendo matematica
 en este contexto elemental.
 Es decir le pediremos que realice pruebas de propiedades que valgan en
 todos los reticulados cuaterna pero lo restringirenos en su lenguaje, es
 decir le pediremos que se restrinja a usar solo formulas elementales de
 reticulados cuaterna y que las pruebas que realice sean tambien elementales
 de reticulados cuaterna.
 El matematico rapidamente entendera la consigna y posiblemente refunfue
 un poco porque claramente lo estamos restrinjiendo mucho en relacion a
 su manera de hacer matematica (por ejemplo no podra hablar de filtros primos,
 etc).
 De todas maneras las posibilidades de hacer matematica profunda e interesante
 aun con esta restriccion son inmensas, es decir hay verdades de reticulados
 cuaterna que son elementales en enunciado y prueba pero son extremadamente
 dificiles, ingeniosas y profundas.
\end_layout

\begin_layout Standard
En este proyecto de hacer logica matematica estudiando a un matematico haciendo
 matematica elemental de reticulados cuaterna hay varias cosas para hacer
 y las establecemos a continuacion.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programa de logica sobre reticulados cuaterna
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Dar una definicion matematica del concepto de formula elemental de reticulados
 cuaterna
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Dar una definicion matematica de cuando una formula elemental es verdadera
 en un reticulado cuaterna dado para una asignacion dada de valores de dicho
 reticulado a las variables libres y a los nombres de constantes fijas de
 la formula
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

(Plato gordo) Dar un modelo matematico del concepto de prueba elemental
 de reticulados cuaterna.
 A estos objetos matematicos que modelizaran a las pruebas elementales de
 los matematicos los llamaremos pruebas formales de reticulados cuaterna.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

(Sublime) Intentar probar matematicamente que nuestro concepto de prueba
 es una correcta modelizacion matematica de la idea intuitiva de prueba
 elemental que todo matematico profecional posee.
 
\end_layout

\begin_layout Standard
Como veremos, los cuatro puntos anteriores pueden ser hechos satisfactoriamente
 y constituyen el comienzo de la logica matematica con cuantificadores.
 Cabe aclarar que la realizacion del cuarto punto es realmente sorprendente
 ya que es un caso de una prueba matematica rigurosa de un hecho que involucra
 un concepto intuitivo como lo es el de prueba elemental
\end_layout

\begin_layout Standard
\begin_inset Formula $\bigskip$
\end_inset


\end_layout

\begin_layout Standard
Ya que la realizacion de los 4 puntos anteriores no depende en absoluto
 de que hayamos elejido el tipo de estructura de los reticulados cuaterna
 (es decir, el desarrollo que resuelve los 4 puntos anteriores para los
 reticulados cuaterna puede adaptarse facilmente para cualquiera de los
 otros tipos de estructuras descriptos en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

), haremos las cosas con mas generalidad.
\end_layout

\begin_layout Standard
Primero, basados en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

, generalizaremos el concepto de estructura.
 La generalizacion que daremos del concepto de estructura es realmente muy
 amplia y nos llevara mucho trabajo de entrenamiento poder manejarla con
 madurez y naturalidad.
 Luego, estableceremos para un tipo generico de estructura el programa de
 logica arriba escrito para el caso particular de los reticulados cuaterna.
 En las subsiguientes secciones nos dedicaremos a resolver dicho programa
 general.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Tipos
\end_layout

\begin_layout Standard
Para generalizar el concepto de estructura es conveniente primero dar definicion
es generales de los conceptos de operacion y de relacion sobre un conjunto.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $A$
\end_inset

 un conjunto y sea 
\begin_inset Formula $n\in\mathbf{N}$
\end_inset

.
 Por una 
\shape italic
operacion 
\shape default

\begin_inset Formula $n$
\end_inset


\shape italic
-aria sobre 
\shape default

\begin_inset Formula $A$
\end_inset

 entenderemos una funcion cuyo dominio es 
\begin_inset Formula $A^{n}$
\end_inset

 y cuya imagen esta contenida en 
\begin_inset Formula $A$
\end_inset

.
 Por una 
\shape italic
relacion 
\shape default

\begin_inset Formula $n$
\end_inset


\shape italic
-aria sobre 
\shape default

\begin_inset Formula $A$
\end_inset

 entenderemos un subconjunto de 
\begin_inset Formula $A^{n}$
\end_inset

.
 Notar que por la definicion anterior una relacion unaria sobre 
\begin_inset Formula $A$
\end_inset

 no es ni mas ni menos que un subconjunto de 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
Como venimos viendo hay una variedad de tipos de estructuras las cuales
 tienen un sentido o interes matematico claro y todas son de un formato
 similar, a saber uplas formadas por una primera coordenada que es un conjunto
 no vacio (llamado el universo de la estructura) y luego ciertas relaciones,
 operaciones y elementos distinguidos, dependiendo del caso.
 Otra cosa a notar es que para cada tipo de estructura hay ciertos simbolos
 fijos que usamos en forma generica para denotar sus relaciones, operaciones
 y elementos distinguidos.
 Por ejemplo:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Para los posets usamos el simbolo 
\begin_inset Formula $\leq$
\end_inset

 para denotar la relacion de orden parcial en un sentido generico.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Para el caso de los reticulados terna usamos en forma generica los simbolos
 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

 para denotar sus operaciones supremo e infimo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Para el caso de los reticulados acotados usamos en forma generica los simbolos
 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

 para denotar sus operaciones supremo e infimo y los numerales 
\begin_inset Formula $0$
\end_inset

 y 
\begin_inset Formula $1$
\end_inset

 para denotar sus elementos distinguidos, a saber maximo y minimo respectivament
e.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Para el caso de los reticulados complementados usamos en forma generica
 los simbolos 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

 para denotar sus operaciones supremo e infimo, el simbolo 
\begin_inset Formula $c$
\end_inset

 para denotar su operacion 
\begin_inset Formula $1$
\end_inset

-aria de complementacion y los numerales 
\begin_inset Formula $0$
\end_inset

 y 
\begin_inset Formula $1$
\end_inset

 para denotar sus elementos distinguidos, a saber maximo y minimo respectivament
e.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Para el caso de los reticulados cuaterna usamos en forma generica los simbolos
 
\begin_inset Formula $\mathsf{s}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}$
\end_inset

 para denotar sus operaciones supremo e infimo y el simbolo 
\begin_inset Formula $\leq$
\end_inset

 para denotar su orden parcial
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Para las median algebras usamos genericamente el simbolo 
\begin_inset Formula $M$
\end_inset

 para denotar su operacion 
\begin_inset Formula $3$
\end_inset

-aria.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Para los grafos usamos el simbolo 
\begin_inset Formula $r$
\end_inset

 para denotar en forma generica la relacion binaria del grafo en cuestion.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Para los grafos bicoloreados usamos el simbolo 
\begin_inset Formula $r$
\end_inset

 para denotar en forma generica la relacion binaria del grafo y el simbolo
 
\begin_inset Formula $R$
\end_inset

 para denotar la relacion unaria que determina el bicoloreo
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
O sea que para cada tipo de estructuras se distinguen tres conjuntos de
 simbolos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

un conjunto 
\begin_inset Formula $\mathcal{R}$
\end_inset

 formado por los simbolos que denotaran genericamente las relaciones de
 las estructuras
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

un conjunto 
\begin_inset Formula $\mathcal{F}$
\end_inset

 formado por los simbolos que denotaran genericamente las operaciones de
 las estructuras
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

un conjunto 
\begin_inset Formula $\mathcal{C}$
\end_inset

 formado por los simbolos que denotaran genericamente los elementos distinguidos
 de las estructuras 
\end_layout

\begin_layout Standard
Ademas otra informacion importante que se tiene para cada tipo de estructura
 es la aridad de las operaciones que denotan los simbolos de 
\begin_inset Formula $\mathcal{F}$
\end_inset

 y la aridad de las relaciones que denotan los simbolos de 
\begin_inset Formula $\mathcal{R}$
\end_inset

.
 A esto lo representaremos con una funcion 
\begin_inset Formula $a:\mathcal{F}\cup\mathcal{R}\rightarrow\mathbf{N}$
\end_inset

 la cual le asocia a cada simbolo de 
\begin_inset Formula $\mathcal{F}\cup\mathcal{R}$
\end_inset

 la aridad del objeto que denota.
\end_layout

\begin_layout Standard
Ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Posets: 
\begin_inset Formula $\mathcal{C}=\emptyset\ \ \ \ \ \mathcal{F}=\emptyset\ \ \ \ \ \mathcal{R}=\{\leq\}\ \ \ \ a=\{(\leq,2)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Reticulados terna: 
\begin_inset Formula $\mathcal{C}=\emptyset\ \ \ \ \ \mathcal{F}=\{\mathsf{s},\mathsf{i}\}\ \ \ \ \ \mathcal{R}=\emptyset\ \ \ \ \ a=\{(\mathsf{s},2),(\mathsf{i},2)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Reticulados acotados: 
\begin_inset Formula $\mathcal{C}=\{0,1\}\ \ \ \ \ \mathcal{F}=\{\mathsf{s},\mathsf{i}\}\ \ \ \ \ \mathcal{R}=\emptyset\ \ \ \ a=\{(\mathsf{s},2),(\mathsf{i},2)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Reticulados comp.: 
\begin_inset Formula $\mathcal{C}=\{0,1\}\ \ \ \ \ \mathcal{F}=\{\mathsf{s},\mathsf{i},c\}\ \ \ \ \ \mathcal{R}=\emptyset\ \ \ \ a=\{(\mathsf{s},2),(\mathsf{i},2),(c,1)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Reticulados cuaterna: 
\begin_inset Formula $\mathcal{C}=\emptyset\ \ \ \ \ \mathcal{F}=\{\mathsf{s},\mathsf{i}\}\ \ \ \ \ \mathcal{R}=\{\leq\}\ \ \ \ a=\{(\mathsf{s},2),(\mathsf{i},2),(\leq,2)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Median algebras: 
\begin_inset Formula $\mathcal{C}=\emptyset\ \ \ \ \ \mathcal{F}=\{M\}\ \ \ \ \ \mathcal{R}=\emptyset\ \ \ \ a=\{(M,3)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Grafos: 
\begin_inset Formula $\mathcal{C}=\emptyset\ \ \ \ \ \mathcal{F}=\emptyset\ \ \ \ \ \mathcal{R}=\{r\}\ \ \ \ a=\{(r,2)\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Grafos bicoloreados: 
\begin_inset Formula $\mathcal{C}=\emptyset\ \ \ \ \ \mathcal{F}=\emptyset\ \ \ \ \ \mathcal{R}=\{r,R\}\ \ \ \ a=\{(r,2),(R,1)\}$
\end_inset

 
\end_layout

\begin_layout Standard
Por supuesto aqui es muy importante no confundir los simbolos con las operacione
s que eventualmente ellos denotan.
 O sea en todos los ejemplos anteriores los elementos de 
\begin_inset Formula $\mathcal{C}$
\end_inset

, 
\begin_inset Formula $\mathcal{F}$
\end_inset

 y 
\begin_inset Formula $\mathcal{R}$
\end_inset

 son simbolos, es decir su 
\begin_inset Formula $Ti$
\end_inset

 es PALABRA.
 Es decir, segun el contexto si escribimos 
\begin_inset Formula $\leq$
\end_inset

, puede ser que nos estemos refiriendo a un orden parcial o simplemente
 al mismo simbolo 
\begin_inset Formula $\leq$
\end_inset


\end_layout

\begin_layout Standard
Lo anterior motiva la siguiente definicion de tipo (de estructura).
 Antes de darla recordemos que si 
\begin_inset Formula $\alpha,\beta$
\end_inset

 son palabras cualesquiera, decimos que 
\begin_inset Formula $\alpha$
\end_inset

 
\shape italic
es subpalabra (propia) de 
\shape default

\begin_inset Formula $\beta$
\end_inset

 cuando (
\begin_inset Formula $\alpha\notin\{\varepsilon,\beta\}$
\end_inset

 y) existen palabras 
\begin_inset Formula $\delta,\gamma$
\end_inset

 tales que 
\begin_inset Formula $\beta=\delta\alpha\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
Ahora si, nuestra definicion de tipo:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Por un 
\shape italic
tipo
\shape default
 (
\shape italic
de primer orden
\shape default
) entenderemos una 4-upla 
\begin_inset Formula $\tau=(\mathcal{C},\mathcal{F},\mathcal{R},a)$
\end_inset

 tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Hay alfabetos finitos 
\begin_inset Formula $\Sigma_{1}$
\end_inset

, 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 y 
\begin_inset Formula $\Sigma_{3}$
\end_inset

 tales:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathcal{C}\subseteq\Sigma_{1}^{+}$
\end_inset

, 
\begin_inset Formula $\mathcal{F}\subseteq\Sigma_{2}^{+}$
\end_inset

 y 
\begin_inset Formula $\mathcal{R}\subseteq\Sigma_{3}^{+}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Sigma_{1}$
\end_inset

, 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 y 
\begin_inset Formula $\Sigma_{3}$
\end_inset

 son disjuntos de a pares.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Sigma_{1}\cup\Sigma_{2}\cup\Sigma_{3}$
\end_inset

 no contiene ningun simbolo de la lista
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;\equiv\mathsf{X\;}\mathit{0}\;\mathit{1\;}...\;\mathit{9}\;\mathbf{0}\;\mathbf{1}\ ...\;\mathbf{9}$
\end_inset

 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $a:\mathcal{F}\cup\mathcal{R}\rightarrow\mathbf{N}$
\end_inset

 es una funcion que a cada 
\begin_inset Formula $p\in\mathcal{F}\cup\mathcal{R}$
\end_inset

 le asocia un numero natural 
\begin_inset Formula $a(p)$
\end_inset

, llamado la 
\shape italic
aridad
\shape default
 de 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Ninguna palabra de 
\begin_inset Formula $\mathcal{C}$
\end_inset

 (resp.
 
\begin_inset Formula $\mathcal{F}$
\end_inset

, 
\begin_inset Formula $\mathcal{R}$
\end_inset

) es subpalabra propia de otra palabra de 
\begin_inset Formula $\mathcal{C}$
\end_inset

 (resp.
 
\begin_inset Formula $\mathcal{F}$
\end_inset

, 
\begin_inset Formula $\mathcal{R}$
\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que los elementos de 
\begin_inset Formula $\mathcal{C}$
\end_inset

, 
\begin_inset Formula $\mathcal{F}$
\end_inset

 y 
\begin_inset Formula $\mathcal{R}$
\end_inset

 pueden ser palabras y no solo simbolos como en los casos de los tipos de
 estructuras conocidas.
 Mas adelante cuando definamos las 
\shape italic
formulas de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

 se entenderan las restricciones puestas en c.
 de (1) y en (3).
\end_layout

\begin_layout Standard
A los elementos de 
\begin_inset Formula $\mathcal{C}$
\end_inset

 (resp.
 
\begin_inset Formula $\mathcal{F}$
\end_inset

, 
\begin_inset Formula $\mathcal{R}$
\end_inset

) los llamaremos 
\shape italic
nombres de constante 
\shape default
(resp.
 
\shape italic
nombres de funcion, nombres de relacion
\shape default
) 
\shape italic
de tipo
\shape default
 
\begin_inset Formula $\tau$
\end_inset

.
 Para cada 
\begin_inset Formula $n\in\mathbf{N}$
\end_inset

, definamos
\begin_inset Formula 
\begin{align*}
\mathcal{F}_{n} & =\{f\in\mathcal{F}:a(f)=n\}\\
\mathcal{R}_{n} & =\{r\in\mathcal{R}:a(r)=n\}
\end{align*}

\end_inset

Al tipo 
\begin_inset Formula $(\emptyset,\emptyset,\{\leq\},\{(\leq,2)\})$
\end_inset

 lo llamaremos el 
\shape italic
tipo de los posets
\shape default
.
 Al tipo 
\begin_inset Formula $(\emptyset,\{\mathsf{s},\mathsf{i}\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2)\})$
\end_inset

 lo llamaremos el 
\shape italic
tipo de los reticulados terna
\shape default
.
 Al tipo
\begin_inset Formula 
\[
(\{0,1\},\{\mathsf{s},\mathsf{i}\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2)\})
\]

\end_inset

lo llamaremos el 
\shape italic
tipo de los reticulados acotados
\shape default
.
 Al tipo
\begin_inset Formula 
\[
(\{0,1\},\{\mathsf{s},\mathsf{i},c\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2),(c,1)\})
\]

\end_inset

lo llamaremos el 
\shape italic
tipo de los reticulados complementados
\shape default
.
 Al tipo
\begin_inset Formula 
\[
(\emptyset,\{\mathsf{s},\mathsf{i}\},\{\leq\},\{(\mathsf{s},2),(\mathsf{i},2),(\leq,2)\})
\]

\end_inset

lo llamaremos el 
\shape italic
tipo de los reticulados cuaterna
\shape default
.
 Al tipo 
\begin_inset Formula $(\emptyset,\{M\},\emptyset,\{(M,3)\})$
\end_inset

 lo llamaremos el 
\shape italic
tipo de las median algebras
\shape default
.
 Al tipo 
\begin_inset Formula $(\emptyset,\emptyset,\{r\},\{(r,2)\})$
\end_inset

 lo llamaremos el 
\shape italic
tipo de los grafos
\shape default
.
 Al tipo
\begin_inset Formula 
\[
(\emptyset,\emptyset,\{r,R\},\{(r,2),(R,1)\})
\]

\end_inset

lo llamaremos el 
\shape italic
tipo de los grafos bicoloreados.
\end_layout

\begin_layout Standard
Algunos ejemplos de tipos:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(\mathrm{MAS})=4$
\end_inset

, 
\begin_inset Formula $a(\mathrm{P})=1$
\end_inset

 y 
\begin_inset Formula $a(\mathrm{Her})=3$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{0,1\},\{+,\times\},\emptyset,a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(+)=2$
\end_inset

 y 
\begin_inset Formula $a(\times)=2$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{\square\},\{\clubsuit\clubsuit,\mathrm{Pic}\},\{\vartriangleright,\Vert\},a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(\clubsuit\clubsuit)=6$
\end_inset

, 
\begin_inset Formula $a(\mathrm{Pic})=1$
\end_inset

, 
\begin_inset Formula $a(\vartriangleright)=4$
\end_inset

 y 
\begin_inset Formula $a(\Vert)=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{\mathrm{dod},\mathrm{dood},\mathrm{doood},...\},\{\mathrm{Fu}\},\{\mathrm{He}\},a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(\mathrm{Fu})=1$
\end_inset

 y 
\begin_inset Formula $a(\mathrm{He})=3$
\end_inset

.
 Notese que este tipo tiene infinitos nombres de constante.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\begin_layout Standard
Ahora si estamos en condiciones de dar una definicion general de estructura.
 Daremos una definicion matematica de 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

Estructura de tipo 
\begin_inset Formula $\tau$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 En virtud de nuestras estructuras conocidas uno podria intentar definir
 estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 como cierta 
\begin_inset Formula $n$
\end_inset

-upla pero esto trae problemas ya que en un tipo 
\begin_inset Formula $\tau$
\end_inset

 los nombres de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

 no tienen por que estar ordenados.
 De todas maneras la idea es muy similar y nos aproximaremos primero con
 ejemplos para entender mas facilmente el concepto.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\tau$
\end_inset

 el tipo
\begin_inset Formula 
\[
(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},\{(\mathrm{MAS},4),(\mathrm{P},1),(\mathrm{Her},3)\})
\]

\end_inset

Intuitivamente hablando, una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 consiste en un conjunto no vacio 
\begin_inset Formula $A$
\end_inset

 (que se llamara el universo de dicha estructura) junto con una interpretacion
 de cada uno de los nombres del conjunto 
\begin_inset Formula $\{\mathrm{uno},\mathrm{doli},\mathrm{MAS},\mathrm{P},\mathrm{Her}\}$
\end_inset

.
 Esta interpretacion debe asignarle a
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{uno}$
\end_inset

 un elemento de 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{doli}$
\end_inset

 un elemento de 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{MAS}$
\end_inset

 una operacion 4-aria sobre 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{P}$
\end_inset

 una operacion 1-aria sobre 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{Her}$
\end_inset

 una relacion 3-aria sobre 
\begin_inset Formula $A$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Lo que debe quedar claro es que estos elementos, operaciones y relaciones
 pueden ser cualesquiera, es decir no deben cumplir nada en especial.
 Por ejemplo si tomamos 
\begin_inset Formula $\mathbf{R}$
\end_inset

 como universo podemos interpretar
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{uno}$
\end_inset

 como el numero 
\begin_inset Formula $\pi$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{doli}$
\end_inset

 como el numero 
\begin_inset Formula $0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{MAS}$
\end_inset

 como la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{R}^{4} & \rightarrow & \mathbf{R}\\
(x,y,z,w) & \rightarrow & 2x+4y
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{P}$
\end_inset

 como la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{R} & \rightarrow & \mathbf{R}\\
x & \rightarrow & 5^{x}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{Her}$
\end_inset

 como la relacion
\begin_inset Formula 
\[
\{(x,y,z)\in\mathbf{R}^{3}:x.y.z=9\}
\]

\end_inset


\end_layout

\begin_layout Standard
Analogamente, si 
\begin_inset Formula $\tau$
\end_inset

 es el tipo de los posets, es decir 
\begin_inset Formula $\tau=(\emptyset,\emptyset,\{\leq\},\{(\leq,2)\})$
\end_inset

, una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 consistira de un conjunto no vacio 
\begin_inset Formula $A$
\end_inset

 (que se llamara el universo de dicha estructura) junto con una interpretacion
 del simbolo 
\begin_inset Formula $\leq$
\end_inset

, la cual nos dira que relacion binaria sobre 
\begin_inset Formula $A$
\end_inset

 denotara 
\begin_inset Formula $\leq$
\end_inset

.
 Pero esta relacion binaria puede ser cualquiera por lo cual habra muchas
 estructuras del tipo de los posets que no se corresponderan con posets.
 Solo aquellas en las que 
\begin_inset Formula $\leq$
\end_inset

 se interpreta como un orden parcial sobre su universo se corresponderan
 con los posets.
\end_layout

\begin_layout Standard
Ahora si daremos la definicion matematica de estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo.
 Una 
\shape italic
estructura o modelo de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

 sera un par 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

 tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $A$
\end_inset

 es un conjunto no vacio
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $i$
\end_inset

 es una funcion con dominio 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R},$
\end_inset

 tal que:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $i(c)$
\end_inset

 es un elemento de 
\begin_inset Formula $A$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $i(f)$
\end_inset

 es una operacion 
\begin_inset Formula $n$
\end_inset

-aria sobre 
\begin_inset Formula $A$
\end_inset

, para cada 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $n\geq1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset


\begin_inset Formula $i(r)$
\end_inset

 es una relacion 
\begin_inset Formula $n$
\end_inset

-aria sobre 
\begin_inset Formula $A$
\end_inset

, para cada 
\begin_inset Formula $r\in\mathcal{R}_{n}$
\end_inset

, 
\begin_inset Formula $n\geq1$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

 es una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

, el conjunto 
\begin_inset Formula $A$
\end_inset

 es llamado el 
\shape italic
universo 
\shape default
de 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y la funcion 
\begin_inset Formula $i$
\end_inset

 es llamada la 
\shape italic
funcion interpretacion
\shape default
 de 
\begin_inset Formula $\mathbf{A}$
\end_inset

.
 Si 
\begin_inset Formula $s\in\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

, diremos que 
\begin_inset Formula $i(s)$
\end_inset

 es la interpretacion del simbolo 
\begin_inset Formula $s$
\end_inset

 en 
\begin_inset Formula $\mathbf{A}$
\end_inset

.
 Algunos ejemplos:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Si 
\begin_inset Formula $\tau$
\end_inset

 es el tipo
\begin_inset Formula 
\[
(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},\{(\mathrm{MAS},4),(\mathrm{P},1),(\mathrm{Her},3)\})
\]

\end_inset

entonces 
\begin_inset Formula $(\mathbf{R},i)$
\end_inset

 es una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

, si definimos 
\begin_inset Formula $i$
\end_inset

 igual a la funcion con dominio 
\begin_inset Formula $\{\mathrm{uno},\mathrm{doli},\mathrm{MAS},\mathrm{P},\mathrm{Her}\}$
\end_inset

 dada por
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{uno})=\pi$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{doli})=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{MAS})$
\end_inset

 igual a la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{R}^{4} & \rightarrow & \mathbf{R}\\
(x,y,z,w) & \rightarrow & 2x+4y
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{P})$
\end_inset

 igual a la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{R} & \rightarrow & \mathbf{R}\\
x & \rightarrow & 5^{x}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{Her})=\{(x,y,z)\in\mathbf{R}^{3}:x.y.z=9\}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau=(\emptyset,\emptyset,\{\leq\},\{(\leq,2)\})$
\end_inset

.
 Notese que por definicion una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 es un par 
\begin_inset Formula $(A,i)$
\end_inset

 donde 
\begin_inset Formula $A$
\end_inset

 es un conjunto no vacio y 
\begin_inset Formula $i$
\end_inset

 es una funcion con dominio 
\begin_inset Formula $\{\leq\}$
\end_inset

 tal que 
\begin_inset Formula $i(\leq)$
\end_inset

 es una relacion binaria sobre 
\begin_inset Formula $A$
\end_inset

.
 Algunos ejemplos de estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(\{1,2,3\},\{(\leq,\emptyset)\})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{1,2,3\},\{(\leq,\{2,3\}\times\{1\})\})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{1,\{2\},\emptyset\},\{(\leq,\{(1,\{2\})\})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathbf{N},i)$
\end_inset

, con 
\begin_inset Formula $i$
\end_inset

 dada por 
\begin_inset Formula $i(\leq)=\{(1,2),(1000,1),(1,1)\}$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que aunque 
\begin_inset Formula $\tau$
\end_inset

 es llamado el tipo de los posets, ninguna de las estructuras anteriores
 tiene mucho que ver con un poset.
 Consideremos ahora la estructura 
\begin_inset Formula $(\mathbf{N},i)$
\end_inset

, donde 
\begin_inset Formula $i$
\end_inset

 es la funcion con dominio igual a 
\begin_inset Formula $\{\leq\}$
\end_inset

 dada por
\begin_inset Formula 
\[
i(\leq)=\{(x,y)\in\mathbf{N}^{2}:x|y\}
\]

\end_inset

Notese que estrictamente hablando 
\begin_inset Formula $(\mathbf{N},i)$
\end_inset

 no es un poset ya que 
\begin_inset Formula $i$
\end_inset

 no es un orden parcial sobre 
\begin_inset Formula $\mathbf{N}$
\end_inset

 pero es claro que a nivel de informacion 
\begin_inset Formula $(\mathbf{N},i)$
\end_inset

 y 
\begin_inset Formula $(\mathbf{N},|)$
\end_inset

 son la misma cosa.
 O sea que aquellas estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 en las cuales 
\begin_inset Formula $\leq$
\end_inset

 se interpreta como un orden parcial sobre el universo de la estructura
 son 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente posets
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 Dejamos al lector dar una biyeccion entre el conjunto formado por todos
 los posets y un subconjunto del conjunto de todas las estructuras de tipo
 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 el tipo de los reticulados terna, es decir 
\begin_inset Formula $\tau=(\emptyset,\{\mathsf{s},\mathsf{i}\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2)\})$
\end_inset

.
 Entonces 
\begin_inset Formula $(\mathbf{N},i)$
\end_inset

, donde 
\begin_inset Formula $i=\{(\mathsf{s},\max),(\mathsf{i},\min)\}$
\end_inset

, es una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Notese que estrictamente hablando 
\begin_inset Formula $(\mathbf{N},i)$
\end_inset

 no es un reticulado terna ya que es una 
\begin_inset Formula $2$
\end_inset

-upla y los reticulados ternas son 
\begin_inset Formula $3$
\end_inset

-uplas.
 Pero es claro que a nivel de informacion 
\begin_inset Formula $(\mathbf{N},i)$
\end_inset

 y 
\begin_inset Formula $(\mathbf{N},\max,\min)$
\end_inset

 son la misma cosa.
 Otras estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 son por ejemplo:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(\mathbf{R},\{(\mathsf{s},+),(\mathsf{i},\min)\})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{0,1,2\},\{(\mathsf{s},f),(\mathsf{i},g)\}$
\end_inset

 donde 
\begin_inset Formula $f:\{0,1,2\}^{2}\rightarrow\{0,1,2\}$
\end_inset

 es la funcion constantemente 1 y 
\begin_inset Formula $g:\{0,1,2\}^{2}\rightarrow\{0,1,2\}$
\end_inset

 es la funcion constantemente 2 
\end_layout

\begin_layout Standard
Por supuesto, ninguna de las dos puede considerarse un reticulado terna
 ya que en ambas los simbolos 
\begin_inset Formula $\mathsf{s}$
\end_inset

 y 
\begin_inset Formula $\mathsf{i}$
\end_inset

 no se interpretan como las operaciones supremo e infimo provenientes de
 un orden parcial.
 Dejamos al lector dar una biyeccion entre el conjunto formado por todos
 los reticulados terna y un subconjunto del conjunto de todas las estructuras
 de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 el tipo de los grafos bicoloreados, es decir 
\begin_inset Formula $\tau=(\emptyset,\emptyset,\{r,R\},\{(r,2),(R,1)\})$
\end_inset

.
 Entonces 
\begin_inset Formula $(\{1,2\},i)$
\end_inset

, con 
\begin_inset Formula $i=\{(r,\{(1,2),(2,1)\}),(R,\{1\})\}$
\end_inset

, es una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Notese que
\begin_inset Formula 
\[
(\{1,2\},i(r),i(R))=(\{1,2\},\{(1,2),(2,1)\},\{1\})
\]

\end_inset

es un grafo bicoloreado el cual esencialmente es lo mismo que la estructura
 
\begin_inset Formula $(\{1,2\},i)$
\end_inset

 (a nivel de informacion).
 De todas maneras estrictamente hablando 
\begin_inset Formula $(\{1,2\},i)$
\end_inset

 no es un grafo bicoloreado.
 Otra estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 la cual es 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 un grafo bicoloreado es el par 
\begin_inset Formula $(\omega,i)$
\end_inset

, donde 
\begin_inset Formula $i$
\end_inset

 es la funcion con dominio 
\begin_inset Formula $\{r,R\}$
\end_inset

 dada por
\begin_inset Formula 
\begin{align*}
i(r) & =\{(x,x+1):x\in\omega\}\cup\{(x+1,x):x\in\omega\}\\
i(R) & =\{x\in\omega:x\text{ es par}\}
\end{align*}

\end_inset

Tal como en los otros ejemplos vistos, hay estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 las cuales no pueden considerarse grafos bicoloreados.
 Por ejemplo, la estructura 
\begin_inset Formula $(\mathbf{N},\{(r,\{(1,2)\}),(R,\{3\})\})$
\end_inset

.
 Dejamos al lector dar una biyeccion entre el conjunto formado por todos
 los grafos bicoloreados y un subconjunto del conjunto de todas las estructuras
 de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Independencia entre sintaxis y semantica
\end_layout

\begin_layout Standard
Notese que la definicion de tipo es muy libre en lo que respecta a que palabras
 componen los conjuntos 
\begin_inset Formula $\mathcal{C}$
\end_inset

, 
\begin_inset Formula $\mathcal{F}$
\end_inset

 y 
\begin_inset Formula $\mathcal{R}$
\end_inset

, es decir salvo por ciertas restricciones leves, ellas pueden ser cualquier
 palabra.
 Ademas no es necesario que las palabras de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

 se interpreten en la estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 (via la funcion 
\begin_inset Formula $i$
\end_inset

) como usualmente se interpretan en matematica.
 Algunos ejemplos:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\tau=(\{\leq\},\emptyset,\emptyset,\emptyset)$
\end_inset

 es un tipo y en las estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 el simbolo 
\begin_inset Formula $\leq$
\end_inset

 se interpretara como un elemento del universo y no un orden parcial.
 Por ejemplo 
\begin_inset Formula $(\{1,2,3\},\{(\leq,2)\})$
\end_inset

 es una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\tau^{\prime}=(\emptyset,\emptyset,\{\leq\},\{(\leq,3)\})$
\end_inset

 es un tipo pero en las estructuras de tipo 
\begin_inset Formula $\tau^{\prime}$
\end_inset

 el simbolo 
\begin_inset Formula $\leq$
\end_inset

 se interpreta como una relacion 3-aria sobre el universo.
 Por ejemplo 
\begin_inset Formula $(\mathbf{N},i)$
\end_inset

, con 
\begin_inset Formula $i$
\end_inset

 dada por 
\begin_inset Formula $i(\leq)=\{(x,y,z)\in\mathbf{N}^{3}:x=y=z\}$
\end_inset

, es una estructura de tipo 
\begin_inset Formula $\tau^{\prime}$
\end_inset

.
 En esta estructura el simbolo 
\begin_inset Formula $\leq$
\end_inset

 no se interpreta como un orden parcial sino como una relacion ternaria
 ya que en 
\begin_inset Formula $\tau^{\prime}$
\end_inset

 el simbolo 
\begin_inset Formula $\leq$
\end_inset

 es un simbolo de relacion de aridad 
\begin_inset Formula $3$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\tau^{\prime\prime}=(\emptyset,\{1\},\emptyset,\{(1,3)\})$
\end_inset

 es un tipo y en las estructuras de tipo 
\begin_inset Formula $\tau^{\prime\prime}$
\end_inset

 el simbolo 
\begin_inset Formula $1$
\end_inset

 se interpretara como una funcion 3-aria sobre el universo (tener cuidado
 al leer 
\begin_inset Formula $(\emptyset,\{1\},\emptyset,\{(1,3)\})$
\end_inset

 ya que en esta expresion 
\begin_inset Formula $1$
\end_inset

 es el 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

numeral uno
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 y 
\begin_inset Formula $3$
\end_inset

 es el numero tres).
 Por ejemplo si denotamos con 
\begin_inset Formula $f$
\end_inset

 a la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{Z}^{3} & \rightarrow & \mathbf{Z}\\
(x,y,z) & \rightarrow & x+y+z
\end{array}
\]

\end_inset

entonces 
\begin_inset Formula $(\mathbf{Z},i)$
\end_inset

, con 
\begin_inset Formula $i$
\end_inset

 dada por 
\begin_inset Formula $i(1)=f$
\end_inset

, es una estructura de tipo 
\begin_inset Formula $\tau^{\prime\prime}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Esta libertad en la definicion de tipo y tambien en la definicion de estructura
 de tipo 
\begin_inset Formula $\tau$
\end_inset

 (i.e.
 las estructuras interpretan a los nombres de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

 con total independencia de la fisonomia de las palabras de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

) es clave a la hora de fortalecer la separacion entre sintaxis y semantica,
 idea fundamental en el desarrollo de la logica.
 Para reforzar aun mas esta idea de independencia entre semantica y sintaxis
 veremos algunos ejemplos de conteo de estructuras.
 Antes un lema de conteo que nos sera de suma utilidad.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Dados 
\begin_inset Formula $A,B$
\end_inset

 conjuntos finitos no vacios, hay 
\begin_inset Formula $\left\vert B\right\vert ^{\left\vert A\right\vert }$
\end_inset

 funciones tales que su dominio es 
\begin_inset Formula $A$
\end_inset

 y su imagen esta contenida en 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

si 
\begin_inset Formula $A$
\end_inset

 es un conjunto cualquiera, entonces hay 
\begin_inset Formula $2^{\left\vert A\right\vert }$
\end_inset

 subconjuntos de 
\begin_inset Formula $A$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Supongamos 
\begin_inset Formula $A=\{a_{1},...,a_{n}\}$
\end_inset

, con 
\begin_inset Formula $n=\left\vert A\right\vert $
\end_inset

.
 Sea 
\begin_inset Formula $Fu=\{f:D_{f}=A$
\end_inset

 y 
\begin_inset Formula $I_{f}\subseteq B\}$
\end_inset

.
 Es facil ver que la siguiente funcion es biyectiva
\begin_inset Formula 
\[
\begin{array}{rcl}
Fu & \rightarrow & B^{n}\\
f & \rightarrow & (f(a_{1}),...,f(a_{n}))
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
(2) Ya que los subconjuntos de 
\begin_inset Formula $A$
\end_inset

 estan en correspondencia biunivoca con las funciones de 
\begin_inset Formula $A$
\end_inset

 en 
\begin_inset Formula $\{0,1\}$
\end_inset

 (por que?) podemos aplicar (1) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Daremos a continuacion algunos ejemplos de conteo de estructuras.
 Sea
\begin_inset Formula 
\[
\tau=(\emptyset,\emptyset,\{\leq\},\{(\leq,2)\})
\]

\end_inset

Nos interesa saber cuantas estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 hay que tengan al conjunto 
\begin_inset Formula $\{1,2,3\}$
\end_inset

 como universo.
 Una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 con universo 
\begin_inset Formula $\{1,2,3\}$
\end_inset

 es un par 
\begin_inset Formula $(\{1,2,3\},i)$
\end_inset

 donde 
\begin_inset Formula $i$
\end_inset

 es una funcion tal que su dominio es 
\begin_inset Formula $\{\leq\}$
\end_inset

 y tal que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\leq)$
\end_inset

 es una relacion 2-aria sobre 
\begin_inset Formula $\{1,2,3\}$
\end_inset

, es decir es un subconjunto de 
\begin_inset Formula $\{1,2,3\}^{2}$
\end_inset

 
\end_layout

\begin_layout Standard
O sea que una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 con universo 
\begin_inset Formula $\{1,2,3\}$
\end_inset

 es un par de la forma
\begin_inset Formula 
\[
(\{1,2,3\},\{(\leq,S)\})
\]

\end_inset

donde 
\begin_inset Formula $S$
\end_inset

 es cualquier subconjunto de 
\begin_inset Formula $\{1,2,3\}^{2}$
\end_inset

.
 Ya que, por el lema anterior, hay 
\begin_inset Formula $2^{9}$
\end_inset

 subconjuntos del conjunto 
\begin_inset Formula $\{1,2,3\}^{2}$
\end_inset

, tenemos que hay exactamente 
\begin_inset Formula $2^{9}$
\end_inset

 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 cuyo universo es 
\begin_inset Formula $\{1,2,3\}$
\end_inset

.
 Notese que, estrictamente hablando, ninguna de estas estructuras es un
 poset.
 Sin embargo aquellas en las cuales 
\begin_inset Formula $S$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $\{1,2,3\}$
\end_inset

 pueden considerarse como posets ya que esencialmente estan determinadas
 por un orden parcial.
\end_layout

\begin_layout Standard
Otro ejemplo, tomemos
\begin_inset Formula 
\[
\tau=(\{\mathrm{un},\mathrm{do}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},\{(\mathrm{MAS},4),(\mathrm{P},1),(\mathrm{Her},3)\}
\]

\end_inset

Nos interesa saber cuantas estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 hay que tengan al conjunto 
\begin_inset Formula $\{1,2,3\}$
\end_inset

 como universo.
 Una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 con universo 
\begin_inset Formula $\{1,2,3\}$
\end_inset

 es un par 
\begin_inset Formula $(\{1,2,3\},i)$
\end_inset

 donde 
\begin_inset Formula $i$
\end_inset

 es una funcion tal que su dominio es 
\begin_inset Formula $\{\mathrm{un},\mathrm{do},\mathrm{MAS},\mathrm{P},\mathrm{Her}\}$
\end_inset

 y tal que
\end_layout

\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{un})$
\end_inset

 y 
\begin_inset Formula $i(\mathrm{do})$
\end_inset

 pertenecen a 
\begin_inset Formula $\{1,2,3\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{MAS})$
\end_inset

 es una operacion 4-aria sobre 
\begin_inset Formula $\{1,2,3\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{P})$
\end_inset

 es una operacion 1-aria sobre 
\begin_inset Formula $\{1,2,3\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $i(\mathrm{Her})$
\end_inset

 es una relacion 3-aria sobre 
\begin_inset Formula $\{1,2,3\}$
\end_inset

, es decir es un subconjunto de 
\begin_inset Formula $\{1,2,3\}^{3}$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que hay
\end_layout

\begin_layout Enumerate
3 posibilidades para 
\begin_inset Formula $i(\mathrm{un})$
\end_inset


\end_layout

\begin_layout Enumerate
3 posibilidades para 
\begin_inset Formula $i(\mathrm{do})$
\end_inset


\end_layout

\begin_layout Enumerate
3
\begin_inset Formula $^{(3^{4})}$
\end_inset

 posibilidades para 
\begin_inset Formula $i(\mathrm{MAS})$
\end_inset

 (por (1) del lema anterior con 
\begin_inset Formula $A=\{1,2,3\}^{4}$
\end_inset

 y 
\begin_inset Formula $B=\{1,2,3\}$
\end_inset

)
\end_layout

\begin_layout Enumerate
3
\begin_inset Formula $^{3}$
\end_inset

 posibilidades para 
\begin_inset Formula $i(\mathrm{P})$
\end_inset

 (por (1) del lema anterior con 
\begin_inset Formula $A=\{1,2,3\}$
\end_inset

 y 
\begin_inset Formula $B=\{1,2,3\}$
\end_inset

)
\end_layout

\begin_layout Enumerate
2
\begin_inset Formula $^{(3^{3})}$
\end_inset

 posibilidades para 
\begin_inset Formula $i(\mathrm{Her})$
\end_inset

 (por (2) del lema anterior con 
\begin_inset Formula $A=\{1,2,3\}^{3}$
\end_inset

) 
\end_layout

\begin_layout Standard
O sea que hay exactamente 
\begin_inset Formula $3.3.3^{(3^{4})}.3^{3}.2^{(3^{3})}$
\end_inset

 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 que tienen al conjunto 
\begin_inset Formula $\{1,2,3\}$
\end_inset

 como universo.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Un poco de arrogancia
\end_layout

\begin_layout Standard
Hemos dado, via las definiciones de 
\shape italic
tipo
\shape default
 y de 
\shape italic
estructura de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

, un modelo matematico preciso del concepto intuitivo de estructura que
 veniamos acuando en las guias anteriores.
 Esto es un salto importante ya que ahora tenemos una definicion matematica
 de lo que es una estructura en general y no solo un puado de definiciones
 matematicas de ciertas estructuras particulares.
 Hemos encontrado la esencia del concepto intuitivo de estructura que veniamos
 acuando con casos particulares en las primeras guias.
 La modelizacion es bastante sofisticada al punto que ninguna de las estructuras
 concretas antes estudiadas es estrictamente hablando una estructura de
 tipo 
\begin_inset Formula $\tau$
\end_inset

, aunque cada tipo de estructura concreta estudiada tiene su 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

version
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 dentro de esta definicion general de estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

, la cual es esencialmente el mismo objeto.
 Por ejemplo, para el tipo de los reticulados complementados
\begin_inset Formula 
\[
\tau=(\{0,1\},\{\mathsf{s},\mathsf{i},c\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2),(c,1)\})
\]

\end_inset

las estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 que modelizan a los reticulados complementados son precisamente aquellas
 estructuras 
\begin_inset Formula $(A,i)$
\end_inset

 tales que
\begin_inset Formula 
\[
(A,i(\mathsf{s}),i(\mathsf{i}),i(c),i(0),i(1))
\]

\end_inset

es un reticulado complementado.
 Obviamente estas estructuras no son estrictamente hablando reticulados
 complementados, pero esencialmente son la misma cosa.
\end_layout

\begin_layout Standard
La utilidad de este nuevo concepto general de estructura ira quedando clara
 a medida que avancemos.
 Cabe destacar que este concepto general de estructura no solo ha sido clave
 en el desarrollo de la logica matematica sino que tambien ha sido crusial
 en el desarrollo de la informatica teorica, mas precisamente en el area
 de especificaciones algebraicas, ya que la versatilidad del concepto de
 estructura eterogenea ha permitido crear una teoria de amplio alcance y
 modelizacion de la idea de la especificacion de tipos abstractos de datos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\begin_layout Standard
Recordemos que cada una de las estructuras consideradas en la Guia 6 tiene
 su tipo asociado.
 Es decir:
\begin_inset Formula 
\begin{align*}
\text{Tipo de los posets} & =(\emptyset,\emptyset,\{\leq\},\{(\leq,2)\})\\
\text{Tipo de los ret. ternas} & =(\emptyset,\{\mathsf{s},\mathsf{i}\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2)\})\\
\text{Tipo de los ret. acotados} & =(\{0,1\},\{\mathsf{s},\mathsf{i}\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2)\})\\
\text{Tipo de los ret. comp.} & =(\{0,1\},\{\mathsf{s},\mathsf{i},c\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2),(c,1)\})\\
\text{Tipo de los ret. cuaternas} & =(\emptyset,\{\mathsf{s},\mathsf{i}\},\{\leq\},\{(\mathsf{s},2),(\mathsf{i},2),(\leq,2)\})\\
\text{Tipo de las median algebras} & =(\emptyset,\{M\},\emptyset,\{(M,3)\})\\
\text{Tipo de los grafos} & =(\emptyset,\emptyset,\{r\},\{(r,2)\})\\
\text{Tipo de los grafos bicoloreados} & =(\emptyset,\emptyset,\{r,R\},\{(r,2),(R,1)\})
\end{align*}

\end_inset

Notese que en cada uno de los casos anteriores los simbolos de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

 son los que se usan (junto con los simbolos logicos, las variables y los
 simbolos de elementos fijos) para formar sus correspondientes formulas
 elementales.
 Es decir, lo particular de las formulas elementales de cada tipo de estructura
 estaba dado por los correspondientes simbolos de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

.
 Esto nos permite generalizar nuestro concepto intuitivo de formula elemental
 para el caso de cualquier tipo 
\begin_inset Formula $\tau$
\end_inset

 de estructuras.
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\tau=(\mathcal{C},\mathcal{F},\mathcal{R},a)$
\end_inset

 es un tipo, las 
\shape italic
formulas elementales de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

 se construyen en forma finitaria usando los nombres de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

 junto con los simbolos de la siguiente lista:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\forall\ \exists\;\lnot\;\vee\;\wedge\;\rightarrow\;\leftrightarrow\;(\;)\;,\;=$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Variables: 
\begin_inset Formula $x,y,z,w,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset

Nombres para elementos fijos: 
\begin_inset Formula $a,b,c,d,...$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
La manera en la que se construyen las formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

 a partir de los simbolos anteriores y de las palabras de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

 es esencialmente la misma que usamos en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

 para construir las formulas elementales de los distintos tipos de estructuras
 clasicas.
 Mostraremos esto con varios ejemplos asi el lector queda con una idea clara
 del concepto.
\end_layout

\begin_layout Standard
Por supuesto el concepto de formula elemental de tipo 
\begin_inset Formula $\tau$
\end_inset

 no es un concepto definido en forma precisa sino mas bien una idea basada
 en ciertos ejemplos de la vida real de los matematicos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Si 
\begin_inset Formula $\tau$
\end_inset

 es el tipo
\begin_inset Formula 
\[
(\{\mathrm{un},0\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her},\mathrm{Verde}\},\{(\mathrm{MAS},4),(\mathrm{P},1),(\mathrm{Her},3),(\mathrm{Verde},1)\})
\]

\end_inset

entonces las siguientes son formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathrm{Her}(x,y,z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{Verde}(x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{Verde}(\mathrm{MAS}(a,b,\mathrm{un},z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{Her}(0,\mathrm{MAS}(a,b,\mathrm{un},z),\mathrm{P}(\mathrm{P}(z))))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathrm{un}=\mathrm{do})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathrm{Verde}(\mathrm{MAS}(a,b,\mathrm{un},z))\wedge(\mathrm{un}=\mathrm{do}))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathrm{MAS}(a,b,\mathrm{un},z)=b)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathrm{MAS}(a,b,\mathrm{un},\mathrm{P}(z))=\mathrm{P}(\mathrm{P}(\mathrm{P}(z))))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\exists z(\mathrm{MAS}(a,b,\mathrm{un},z)=b)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\mathrm{Her}(0,y,\mathrm{P}(\mathrm{P}(x)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall y\ ((\mathrm{P}(\mathrm{P}(z))=x)\rightarrow\exists z\ (\mathrm{Verde}(z)\wedge\mathrm{Her}(x,y,z)))$
\end_inset

 
\end_layout

\begin_layout Standard
Por supuesto las aridades de los nombres de 
\begin_inset Formula $\mathcal{F}\cup\mathcal{R}$
\end_inset

 son importantes y deben ser respetadas.
 Por ejemplo
\begin_inset Formula 
\[
(\mathrm{P}(x,y)=x)\ \ \ \ \ \ \mathrm{Her}(x,y)\ \ \ \ \ \ \ \ \mathrm{Verde}(x,y)
\]

\end_inset

no son formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\tau$
\end_inset

 es el tipo
\begin_inset Formula 
\[
(\{0,1\},\{+,\bigtriangleup\},\{\leq,r\},\{(+,2),(\bigtriangleup,5),(\leq,2),(r,2)\})
\]

\end_inset

entonces las siguientes son formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $r(x,z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{\leq}(x,y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{\leq}(\bigtriangleup(x,y,z,0,0),+(x,x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(+(a,b)=\bigtriangleup(x,y,z,0,0))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\bigtriangleup(x,y,z,0,0)=\bigtriangleup(1,1,0,x,z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(+(\bigtriangleup(x,y,z,0,0),z)=1)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\lnot r(x,+(a,+(a,b)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\lnot\forall y(+(x,y)=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\exists z\forall x\ (r(x,+(z,z)\wedge\lnot\mathrm{\leq}(x,z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\;((r(x,y)\wedge r(y,z))\rightarrow r(x,z))$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que hay algunas pequeas diferencias con las formulas elementales
 de las estructuras clasicas ya que aqui respondemos a un formato mas general.
 Por ejemplo hemos escrito 
\begin_inset Formula $\mathrm{\leq}(x,y)$
\end_inset

 en lugar de 
\begin_inset Formula $x\leq y$
\end_inset

 y 
\begin_inset Formula $+(x,y)$
\end_inset

 en lugar de 
\begin_inset Formula $x+y$
\end_inset

.
 Esto es a los fines de homogeneisar la escritura y no hacer un uso distinto
 para las operaciones binarias y las relaciones binarias.
\end_layout

\begin_layout Standard
Por supuesto las aridades de los nombres de 
\begin_inset Formula $\mathcal{F}\cup\mathcal{R}$
\end_inset

 son importantes y deben ser respetadas.
 Por ejemplo
\begin_inset Formula 
\[
(+(x,y,z)=x)\ \ \ \ \ \ r(x,y,z)\ \ \ \ \ \ \ \ \mathrm{\leq}(x,y,z)
\]

\end_inset

no son formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Si 
\begin_inset Formula $\tau$
\end_inset

 es el tipo
\begin_inset Formula 
\[
(\{\mathrm{er}\},\{+\},\{\leq\},\{(+,4),(\leq,5)\})
\]

\end_inset

entonces las siguientes son formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathrm{\leq}(x,y,\mathrm{er},\mathrm{er},\mathrm{er})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{\leq}(+(x,y,z,\mathrm{er}),+(x,x,\mathrm{er},x),a,b,z)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\exists z(+(x,z,x,+(x,x,x,x))=z)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset

Si 
\begin_inset Formula $\tau$
\end_inset

 es el tipo
\begin_inset Formula 
\[
(\{\mathrm{er}\},\{\leq\},\{+\},\{(\leq,3),(+,2)\})
\]

\end_inset

entonces las siguientes son formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(\mathrm{\leq}(x,y,\mathrm{er})=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $+(z,\mathrm{er})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\exists z\lnot\mathrm{+}(z,\mathrm{er})$
\end_inset

 
\end_layout

\begin_layout Standard
(aqui hay que tener en cuenta que 
\begin_inset Formula $\leq$
\end_inset

 es un nombre de funcion de aridad 3 y que 
\begin_inset Formula $+$
\end_inset

 es un nombre de relacion de aridad 2, lo cual es inusual pero perfectamente
 posible en nuestra muy general definicion de tipo)
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E5)
\end_layout

\end_inset

Si 
\begin_inset Formula $\tau$
\end_inset

 es el tipo
\begin_inset Formula 
\[
(\{\leq\},\{+\},\emptyset,\{(+,3)\})
\]

\end_inset

entonces las siguientes son formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(\mathrm{\leq}=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(+(z,\leq,a)=\mathrm{\leq})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(+(+(z,\leq,\leq),x,a)=b)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
(aqui hay que tener en cuenta que 
\begin_inset Formula $\leq$
\end_inset

 es un nombre de constante, lo cual es inusual pero perfectamente posible
 en nuestra muy general definicion de tipo)
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Para que una formula elemental de tipo 
\begin_inset Formula $\tau$
\end_inset

 se vuelva verdadera o falsa tenemos que tener una estructura 
\begin_inset Formula $(A,i)$
\end_inset

 de tipo 
\begin_inset Formula $\tau$
\end_inset

 y ademas asignarles valores concretos de 
\begin_inset Formula $A$
\end_inset

 a las variables libres y a los nombres de elementos fijos que figuran en
 dicha formula.
 Cuando la formula no tiene variables libres diremos que es una 
\shape italic
sentencia elemental de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

.
 Notese que en tal caso sera verdadera o falsa en una estructura dada dependiend
o solo de los valores que tomen los nombres para elementos fijos que ocurren
 en ella.
 Tambien cabe destacar que los cuantificadores siempre ranguean sobre 
\begin_inset Formula $A$
\end_inset

, es decir 
\begin_inset Formula $\forall x$
\end_inset

 se interpretara como 
\begin_inset Formula $\forall x\in A$
\end_inset

 y 
\begin_inset Formula $\exists x$
\end_inset

 se interpretara como 
\begin_inset Formula $\exists x\in A$
\end_inset

.
 La diferencia entre las variables y los nombres de elementos fijos es que
 si bien ambos pueden variar su valor los nombres de elementos fijos suelen
 denotar un valor fijo de la estructura durante todo un desarrollo o demostracio
n.
 Tampoco se cuantificaran los nombres de elementos fijos, es decir solo
 cuantificamos variables (por ejemplo, 
\begin_inset Formula $\forall a(a=x)$
\end_inset

 no es una formula elemental de tipo 
\begin_inset Formula $\tau$
\end_inset

, cualquiera sea el tipo 
\begin_inset Formula $\tau$
\end_inset

).
\end_layout

\begin_layout Standard
Daremos algunos ejemplos para reafirmar la idea intuitiva de cuando una
 formula elemental es verdadera en una estructura dada para una asignacion
 de valores de sus variables libres y de sus nombres de elementos fijos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 el tipo
\begin_inset Formula 
\[
(\{\mathrm{un},0\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her},\mathrm{Verde}\},\{(\mathrm{MAS},4),(\mathrm{P},1),(\mathrm{Her},3),(\mathrm{Verde},1)\})
\]

\end_inset

y sea 
\begin_inset Formula $(A,i)$
\end_inset

 la estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 dada por:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $A=\mathbf{R}$
\end_inset

, 
\begin_inset Formula $i(\mathrm{un})=\pi$
\end_inset

, 
\begin_inset Formula $i(0)=0$
\end_inset

 (ojo que aqui el primer cero es un simbolo y el segundo un numero real!)
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \begin{array}[t]{rcl}
i(\mathrm{MAS}):\mathbf{R}^{4} & \rightarrow & \mathbf{R}\\
(x,y,z,w) & \rightarrow & x.y
\end{array}\\
 & \begin{array}[t]{rcl}
i(\mathrm{P}):\mathbf{R} & \rightarrow & \mathbf{R}\\
x & \rightarrow & x^{2}
\end{array}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
i(\mathrm{Her}) & =\{(x,y,z)\in\mathbf{R}^{3}:x.y.z=9\}\\
i(\mathrm{Verde}) & =\mathbf{Q}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Entonces:
\end_layout

\begin_layout Enumerate
la formula 
\begin_inset Formula $\mathrm{Her}(x,y,z)$
\end_inset

 es verdadera en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 
\begin_inset Formula $9$
\end_inset

, a 
\begin_inset Formula $y$
\end_inset

 el valor 
\begin_inset Formula $1$
\end_inset

 y a 
\begin_inset Formula $z$
\end_inset

 el valor 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{Verde}(x)$
\end_inset

 es falsa en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 
\begin_inset Formula $\sqrt{2}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{Verde}(\mathrm{MAS}(a,b,\mathrm{un},z))$
\end_inset

 es verdadera en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando le asignamos a 
\begin_inset Formula $a$
\end_inset

 el valor 
\begin_inset Formula $\sqrt{2}$
\end_inset

, a 
\begin_inset Formula $b$
\end_inset

 el valor 
\begin_inset Formula $\sqrt{2}$
\end_inset

 y a 
\begin_inset Formula $z$
\end_inset

 el valor 
\begin_inset Formula $16$
\end_inset

 (o cualquier otro valor)
\end_layout

\begin_layout Enumerate
la formula 
\begin_inset Formula $\exists y\exists z\ \mathrm{Her}(a,y,z))$
\end_inset

 es una sentencia ya que no tiene variables libres y es veradera en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando a 
\begin_inset Formula $a$
\end_inset

 le asignamos un valor no nulo
\end_layout

\begin_layout Enumerate
la formula 
\begin_inset Formula $\exists y\exists z\ \mathrm{Her}(x,y,z))$
\end_inset

 es una formula y es veradera en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando a 
\begin_inset Formula $x$
\end_inset

 le asignamos un valor no nulo
\end_layout

\begin_layout Enumerate
la formula 
\begin_inset Formula $\forall x\ (\lnot(x=0)\rightarrow\exists y\exists z\ \mathrm{Her}(x,y,z))$
\end_inset

 es una sentencia ya que no tiene variables libres y es veradera en 
\begin_inset Formula $(A,i)$
\end_inset


\end_layout

\begin_layout Enumerate
la formula 
\begin_inset Formula $\forall x\forall y\ ((\mathrm{Verde}(x)\wedge\mathrm{Verde}(y))\rightarrow\mathrm{Verde}(\mathrm{MAS}(x,y,\mathrm{un},z)))$
\end_inset

 es verdadera en 
\begin_inset Formula $(A,i)$
\end_inset

 independientemente de que valor le asignemos a 
\begin_inset Formula $z$
\end_inset

, ya que el producto de racionales es racional
\end_layout

\begin_layout Enumerate
la formula 
\begin_inset Formula $\exists y(\mathrm{MAS}(z,z,y,\mathrm{un})=\mathrm{P}(z))$
\end_inset

 es veradera en 
\begin_inset Formula $(A,i)$
\end_inset

 cualquiera sea el valor que le asignemos a 
\begin_inset Formula $z$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Error frecuente:
\series default
 En la estructura anterior hay varios elementos que tienen su notacion clasica
 en la matematica, por ejemplo, con la letra griega 
\begin_inset Formula $\pi$
\end_inset

 denotamos la cantidad de veces que entra el diametro en la circunferencia
 o con el numeral 
\begin_inset Formula $3$
\end_inset

 denotamos al numero entero tres.
 Esto no debe confundirnos y pensar que por ejemplo las palabras
\begin_inset Formula 
\[
\lnot\mathrm{Verde}(\pi)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists y\mathrm{Her}(3,3,y)
\]

\end_inset

son formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

 (aunque es claro que son verdaderas en la estructura 
\begin_inset Formula $(A,i)$
\end_inset

) 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 el tipo
\begin_inset Formula 
\[
(\{\mathrm{er}\},\{+\},\{\leq\},\{(+,4),(\leq,5)\})
\]

\end_inset

y sea 
\begin_inset Formula $(A,i)$
\end_inset

 la estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 dada por:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $A=\{1,2,3,4,5\}$
\end_inset

, 
\begin_inset Formula $i(\mathrm{er})=4$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula 
\[
\begin{array}[t]{rcl}
i(+):A^{4} & \rightarrow & A\\
(x,y,z,w) & \rightarrow & \max\{x,y,z,w\}
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
i(\leq)=\{(x,y,z,u,v)\in A^{5}:x+y+z+u+v\geq17\}
\]

\end_inset


\end_layout

\begin_layout Standard
Entonces:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{\leq}(\mathrm{er},\mathrm{er},\mathrm{er},\mathrm{er},\mathrm{er})$
\end_inset

 es una sentencia verdadera en 
\begin_inset Formula $(A,i)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{\leq}(x,y,\mathrm{er},\mathrm{er},\mathrm{er})$
\end_inset

 es verdadera en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando le asignamos a las variables 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 valores que sumados den al menos 
\begin_inset Formula $5$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\exists y\ \mathrm{\leq}(x,x,x,x,y)$
\end_inset

 es una sentencia la cual es falsa en 
\begin_inset Formula $(A,i)$
\end_inset

, ya que la formula 
\begin_inset Formula $\exists y\ \mathrm{\leq}(x,x,x,x,y)$
\end_inset

 es falsa en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Enumerate
la sentencia 
\begin_inset Formula $\forall x\exists z\ \mathrm{\leq}(x,x,x,x,+(x,x,x,z))$
\end_inset

 es falsa en 
\begin_inset Formula $(A,i)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 el tipo
\begin_inset Formula 
\[
(\{\mathrm{epa}\},\{\leq,r\},\emptyset,\{(\leq,1),(r,1)\})
\]

\end_inset

y sea 
\begin_inset Formula $(A,i)$
\end_inset

 la estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 dada por:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $A=\omega$
\end_inset

, 
\begin_inset Formula $i(\mathrm{epa})=71$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
 & \begin{array}[t]{rcl}
i(\mathrm{\leq}):\omega & \rightarrow & \omega\\
x & \rightarrow & x^{2}
\end{array}\\
 & \begin{array}[t]{rcl}
i(r):\omega & \rightarrow & \omega\\
x & \rightarrow & \left\lfloor \sqrt{x}\right\rfloor 
\end{array}
\end{align*}

\end_inset

(Notese que aqui contrario al uso estandard en la matematica, el simbolo
 
\begin_inset Formula $\leq$
\end_inset

 se interpreta como una funcion.) Entonces:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathrm{\leq}(\mathrm{epa})=x)$
\end_inset

 es veradera en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando le asignamos a la variable 
\begin_inset Formula $x$
\end_inset

 el valor 
\begin_inset Formula $71^{2}$
\end_inset

 y falsa en caso contrario
\end_layout

\begin_layout Enumerate
la sentencia 
\begin_inset Formula $\exists z(\mathrm{\leq}(z)=x)$
\end_inset

 es verdadera en 
\begin_inset Formula $(A,i)$
\end_inset

 cuando le asignamos a 
\begin_inset Formula $x$
\end_inset

 el valor 
\begin_inset Formula $16$
\end_inset


\end_layout

\begin_layout Enumerate
la sentencia 
\begin_inset Formula $\forall x\ (r(\mathrm{\leq}(x))=x)$
\end_inset

 es verdadera en 
\begin_inset Formula $(A,i)$
\end_inset


\end_layout

\begin_layout Enumerate
la sentencia 
\begin_inset Formula $\exists x\ \lnot(\mathrm{\leq}(r(x))=x)$
\end_inset

 es verdadera en 
\begin_inset Formula $(A,i)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "Teorias elementales y pruebas elementales"

\end_inset

Teorias elementales y pruebas elementales
\end_layout

\begin_layout Standard
Tal como vimos en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

, el concepto de prueba elemental dependia del tipo de estructura en cuestion
 y ademas de tener fijado un conjunto de sentencas elementales que llamabamos
 axiomas y eran el punto de partida de dichas pruebas.
 Cabe destacar que dichos axiomas eran sentencias elementales sin nombres
 de elementos fijos ya que estos se usaban solo en las pruebas elementales
 para denotar hipoteticos elementos dentro del argumento de la prueba misma.
 Ademas cuando haciamos una prueba elemental teniamos en mente una estructura
 generica de la cual solo sabiamos que satisfacia los axiomas, es decir
 solo podiamos usar la informacion particular que dichos axiomas nos proveian
 y pasos elementales obvios de los cuales nadie dudaria.
 Esto nos inspira a hacer las siguientes dos definiciones.
\end_layout

\begin_layout Standard
Una 
\shape italic
teoria elemental
\shape default
 sera un par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 tal que 
\begin_inset Formula $\tau$
\end_inset

 es un tipo cualquiera y 
\begin_inset Formula $\Sigma$
\end_inset

 es un conjunto de sentencias elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

, las cuales no tienen nombres de elementos fijos.
 Un 
\shape italic
modelo de
\shape default
 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 la cual haga verdaderos a todos los elementos de 
\begin_inset Formula $\Sigma$
\end_inset

.
 Veamos algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

La 
\shape italic
teoria elemental de los posets
\shape default
 es el par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau=(\emptyset,\emptyset,\{\leq\},\{(\leq,2)\})$
\end_inset

 y 
\begin_inset Formula $\Sigma$
\end_inset

 es el conjunto formado por las siguientes tres sentencias elementales de
 tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall x\ \mathrm{\leq}(x,x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\;((\mathrm{\leq}(x,y)\wedge\mathrm{\leq}(y,z))\rightarrow\mathrm{\leq}(x,z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y((\mathrm{\leq}(x,y)\wedge\mathrm{\leq}(y,x))\rightarrow x=y)$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que los modelos de esta teoria elemental son exactamente aquellas
 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 las cuales son 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 posets.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

La 
\shape italic
teoria elemental de los reticulados terna
\shape default
 es el par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau=(\emptyset,\{\mathsf{s},\mathsf{i}\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2)\})$
\end_inset

 y 
\begin_inset Formula $\Sigma$
\end_inset

 es el conjunto formado por las siguientes sentencias elementales de tipo
 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\ (\mathsf{s}(x,x)=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\ (\mathsf{i}(x,x)=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\ (\mathsf{s}(x,y)=\mathsf{s}(y,x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\ (\mathsf{i}(x,y)=\mathsf{i}(y,x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\ (\mathsf{s}(\mathsf{s}(x,y),z)=\mathsf{s}(x,\mathsf{s}(y,z)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\ (\mathsf{i}(\mathsf{i}(x,y),z)=\mathsf{i}(x,\mathsf{i}(y,z)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\ \mathsf{s}(x,\mathsf{i}(x,y))=x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\ \mathsf{i}(x,\mathsf{s}(x,y))=x)$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que los modelos de esta teoria elemental son exactamente aquellas
 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 las cuales son 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 reticulados terna.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

La 
\shape italic
teoria elemental de los reticulados cuaterna
\shape default
 es el par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau=(\emptyset,\{\mathsf{s},\mathsf{i}\},\{\leq\},\{(\mathsf{s},2),(\mathsf{i},2),(\leq,2)\})$
\end_inset

 y 
\begin_inset Formula $\Sigma$
\end_inset

 es el conjunto formado por las siguientes sentencias elementales de tipo
 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathrm{A}_{\leq R}=\forall x\ \mathrm{\leq}(x,x)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{A}_{\leq T}=\forall x\forall y\forall z\;((\mathrm{\leq}(x,y)\wedge\mathrm{\leq}(y,z))\rightarrow\mathrm{\leq}(x,z))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{A}_{\leq A}=\forall x\forall y\ ((\mathrm{\leq}(x,y)\wedge\mathrm{\leq}(y,x))\rightarrow x=y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{A}_{\mathsf{s}esC}=\forall x\forall y\;(\mathrm{\leq}(x,\mathsf{s}(x,y))\wedge\mathrm{\leq}(y,\mathsf{s}(x,y)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{A}_{\mathsf{s}\leq C}=\forall x\forall y\forall z\;\left((\mathrm{\leq}(x,z)\wedge\mathrm{\leq}(y,z))\rightarrow\mathrm{\leq}(\mathsf{s}(x,y),z\right))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{A}_{\mathsf{i}esC}=\forall x\forall y\;(\mathrm{\leq}(\mathsf{i}(x,y),x)\wedge\mathrm{\leq}(\mathsf{i}(x,y),y))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{A}_{\mathsf{i}\geq C}=\forall x\forall y\forall z\;\left((\mathrm{\leq}(z,x)\wedge\mathrm{\leq}(z,y))\rightarrow\mathrm{\leq}(z,\mathsf{i}(x,y))\right)$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que los modelos de esta teoria elemental son exactamente aquellas
 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 las cuales son 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 reticulados cuaterna.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset

La 
\shape italic
teoria elemental de los grafos
\shape default
 es el par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau=(\emptyset,\emptyset,\{r\},\{(r,2)\})$
\end_inset

 y 
\begin_inset Formula $\Sigma$
\end_inset

 es el conjunto formado por la siguiente sentencia elemental de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow r(y,x))$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que los modelos de esta teoria elemental son exactamente aquellas
 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 las cuales son 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 grafos.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E5)
\end_layout

\end_inset

La 
\shape italic
teoria elemental de los grafos bicoloreados
\shape default
 es el par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau=(\emptyset,\emptyset,\{r,R\},\{(r,2),(R,1)\})$
\end_inset

 y 
\begin_inset Formula $\Sigma$
\end_inset

 es el conjunto formado por las siguientes sentencias elementales de tipo
 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow r(y,x))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y(r(x,y)\rightarrow(R(x)\leftrightarrow\lnot R(y)))$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que los modelos de esta teoria elemental son exactamente aquellas
 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 las cuales son 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 grafos bicoloreados.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Es muy importante notar que una teoria elemental 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es en algun sentido un objeto esencialmente sintactico ya que 
\begin_inset Formula $\Sigma$
\end_inset

, 
\begin_inset Formula $\mathcal{C}$
\end_inset

, 
\begin_inset Formula $\mathcal{F}$
\end_inset

 y 
\begin_inset Formula $\mathcal{R}$
\end_inset

 son conjuntos de palabras.
 Los modelos de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 constituyen la semantica de la teoria.
\end_layout

\begin_layout Standard
Las anteriores son las teorias elementales que se corresponden con los tipos
 de estructuras consideradas en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

 pero nuestra definicion de teoria elemental es muy general y nos permite
 considerar una gran diversidad de teorias.
 Veamos algunos ejemplos de teorias elementales interesantes y no consideradas
 en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E6)
\end_layout

\end_inset

Consideremos la teoria elemental 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau=(\{\mathrm{ex}\},\{\mathrm{F}\},\emptyset,\{(\mathrm{F},1)\})$
\end_inset

 y 
\begin_inset Formula $\Sigma$
\end_inset

 es el conjunto formado por las siguientes dos sentencias elementales:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\ (\lnot(x=y)\rightarrow\lnot(\mathrm{F}(x)=\mathrm{F}(y)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\ \lnot(\mathrm{F}(x)=\mathrm{ex})$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que una estructura 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

 de tipo 
\begin_inset Formula $\tau$
\end_inset

 es un modelo de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 si y solo si 
\begin_inset Formula $i(\mathrm{F})$
\end_inset

 es inyectiva y 
\begin_inset Formula $i(\mathrm{ex})\notin\operatorname{Im}(i(\mathrm{F}))$
\end_inset

.
 Esto obviamente nos dice que el universo de cada modelo de esta teoria
 es infinito.
 Un modelo de la teoria es por ejemplo 
\begin_inset Formula $(\omega,\{(\mathrm{ex},0),(\mathrm{F},Suc)\})$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E7)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau=(\emptyset,\{\times\},\{\mathrm{Com}\},\{(\times,2),(\mathrm{Com},1)\})$
\end_inset

 y sea 
\begin_inset Formula $\Sigma$
\end_inset

 el conjunto formado por las siguientes sentencias elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\ (\times(\times(x,y),z)=\times(x,\times(y,z)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall z\ (\mathrm{Com}(z)\rightarrow\forall x\ (\times(x,z)=\times(z,x)))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x\exists z\ (x=\times(z,z)\wedge\mathrm{Com}(z))$
\end_inset

 
\end_layout

\begin_layout Standard
Supongamos 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

 es un modelo de la teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Notese que el primer axioma nos dice que 
\begin_inset Formula $i(\times)$
\end_inset

 es una operacion binaria asociativa, esto se ve mas facilmente si escribimos
 dicho axioma con la notacion mas usual para operaciones:
\begin_inset Formula 
\[
\forall x\forall y\forall z\ (x\times y)\times z=x\times(y\times z)
\]

\end_inset


\end_layout

\begin_layout Standard
El segundo axioma nos dice que si 
\begin_inset Formula $a\in i(\mathrm{Com})$
\end_inset

, entonces 
\begin_inset Formula $a\ i(\times)\ b=b\ i(\times)\ a$
\end_inset

, cualesquiera sea 
\begin_inset Formula $b\in A$
\end_inset

.
 O sea nos dice que los elementos de 
\begin_inset Formula $i(\mathrm{Com})$
\end_inset

 conmutan con todos los otros elementos relativo a la operacion 
\begin_inset Formula $i(\times)$
\end_inset

.
 El tercer axioma nos dice que cualquiera sea 
\begin_inset Formula $a\in A$
\end_inset

, debe haber un 
\begin_inset Formula $b\in i(\mathrm{Com})$
\end_inset

 tal que 
\begin_inset Formula $b\ i(\times)\ b=a$
\end_inset

.
 En algun sentido nos dice que todo elemento de 
\begin_inset Formula $A$
\end_inset

 tiene en el conjunto 
\begin_inset Formula $i(\mathrm{Com})$
\end_inset

 una 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

raiz cuadrada
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 relativo a la operacion 
\begin_inset Formula $i(\times)$
\end_inset

.
 Ejemplos de modelos de esta teoria son:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\{r\in\mathbf{R}:r\geq0\},i)$
\end_inset

, con 
\begin_inset Formula $i(\times)=$
\end_inset

 operacion producto usual de 
\begin_inset Formula $\mathbf{R}$
\end_inset

 restringida a 
\begin_inset Formula $\{r\in\mathbf{R}:r\geq0\}^{2}$
\end_inset

 y 
\begin_inset Formula $i(\mathrm{Com})=\{r\in\mathbf{R}:r\geq0\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathbf{R},i)$
\end_inset

, con 
\begin_inset Formula $i(\times)=\max$
\end_inset

 y 
\begin_inset Formula $i(\mathrm{Com})=\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathbf{R},i)$
\end_inset

, con 
\begin_inset Formula $i(\times)=\min$
\end_inset

 y 
\begin_inset Formula $i(\mathrm{Com})=\mathbf{R}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\mathcal{P}(\{1,2,3\}),i)$
\end_inset

, con 
\begin_inset Formula $i(\times)=\cup$
\end_inset

 y 
\begin_inset Formula $i(\mathrm{Com})=\mathcal{P}(\{1,2,3\})$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E8)
\end_layout

\end_inset

La 
\shape italic
teoria elemental de los reticulados cuaterna distributivos
\shape default
 es el par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau=(\emptyset,\{\mathsf{s},\mathsf{i}\},\{\leq\},\{(\mathsf{s},2),(\mathsf{i},2),(\leq,2)\})$
\end_inset

 y 
\begin_inset Formula $\Sigma$
\end_inset

 es el conjunto formado por los axiomas de la teoria elemental de los reticulado
s cuaterna junto con el axioma
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\ (\mathsf{i}(x,\mathsf{s}(y,z))=\mathsf{s}(\mathsf{i}(x,y),\mathsf{i}(x,z)))$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que los modelos de esta teoria elemental son exactamente aquellas
 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 las cuales son 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 reticulados cuaterna distributivos
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E9)
\end_layout

\end_inset

La 
\shape italic
teoria elemental de los reticulados terna distributivos
\shape default
 es el par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau=(\emptyset,\{\mathsf{s},\mathsf{i}\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2)\})$
\end_inset

 y 
\begin_inset Formula $\Sigma$
\end_inset

 es el conjunto formado por los axiomas de la teoria elemental de los reticulado
s terna junto con el axioma
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall x\forall y\forall z\ (\mathsf{i}(x,\mathsf{s}(y,z))=\mathsf{s}(\mathsf{i}(x,y),\mathsf{i}(x,z)))$
\end_inset

 
\end_layout

\begin_layout Standard
Notese que los modelos de esta teoria elemental son exactamente aquellas
 estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 las cuales son 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

esencialmente
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 reticulados terna distributivos 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Pruebas elementales
\end_layout

\begin_layout Standard
Podemos generalizar el concepto de prueba elemental, introducido en la Seccion
 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

, a cualquier teoria elemental.
 Dada una teoria elemental 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 y una sentencia elemental 
\begin_inset Formula $\varphi$
\end_inset

 la cual no posea nombres de constantes auxiliares, una 
\shape italic
prueba elemental de 
\shape default

\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
en 
\shape default

\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera una prueba de 
\begin_inset Formula $\varphi$
\end_inset

 que posea las siguientes caracteristicas:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

salvo por ciertas aclaraciones simples y concretas en castellano la prueba
 se escribe usando solo sentencias elementales de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cada paso de la demostracion debe ser obvio y solido
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

cuando el matematico comiensa la prueba tiene en mente una estructura generica
 de tipo 
\begin_inset Formula $\tau$
\end_inset

 que satisface los axiomas de la teoria (i.e.
 es un modelo de la teoria) y esa es la unica particularidad que supone
 de dicho modelo generico al comensar la prueba.
 Es decir las pruebas elementales siempre son formas solidas de justificar
 que 
\shape italic
cualquier
\shape default
 estructura que satisfaga los axiomas tambien satisfacera la sentencia probada
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Por supuesto el concepto de prueba elemental en una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 no es un concepto definido en forma precisa sino mas bien una idea basada
 en ciertos ejemplos de la vida real de los matematicos.
\end_layout

\begin_layout Standard
Veamos algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E10)
\end_layout

\end_inset

Consideremos la teoria elemental del ejemplo (E6).
 Sea
\begin_inset Formula 
\[
\varphi=\exists x\exists y\exists z\ (\lnot(x=y)\wedge\lnot(x=z)\wedge\lnot(y=z))
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
(
\begin_inset Formula $\varphi$
\end_inset

 dice que el universo tiene al menos tres elementos.) Tenemos la siguiente:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Prueba elemental de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

:
\end_layout

\end_inset

Por el segundo axioma tenemos que 
\begin_inset Formula $\lnot(\mathrm{F}(\mathrm{ex})=\mathrm{ex})$
\end_inset

.
 Obviamente entonces tenemos que
\end_layout

\begin_deeper
\begin_layout Standard
(1) 
\begin_inset Formula $\lnot(\mathrm{ex}=\mathrm{F}(\mathrm{ex}))$
\end_inset


\end_layout

\begin_layout Standard
Por el segundo axioma tambien tenemos que 
\begin_inset Formula $\lnot(\mathrm{F}(\mathrm{F}(\mathrm{ex}))=\mathrm{ex})$
\end_inset

 por lo que
\end_layout

\begin_layout Standard
(2) 
\begin_inset Formula $\lnot(\mathrm{ex}=\mathrm{F}(\mathrm{F}(\mathrm{ex})))$
\end_inset


\end_layout

\begin_layout Standard
Ya que se da (2), el primer axioma nos dice que
\end_layout

\begin_layout Standard
(3) 
\begin_inset Formula $\lnot(\mathrm{F}(\mathrm{ex})=\mathrm{F}(\mathrm{F}(\mathrm{ex})))$
\end_inset


\end_layout

\begin_layout Standard
Poniendo (1), (2) y (3) juntos tenemos que
\begin_inset Formula 
\[
\lnot(\mathrm{ex}=\mathrm{F}(\mathrm{ex}))\wedge\lnot(\mathrm{ex}=\mathrm{F}(\mathrm{F}(\mathrm{ex})))\wedge\lnot(\mathrm{F}(\mathrm{ex})=\mathrm{F}(\mathrm{F}(\mathrm{ex})))
\]

\end_inset

de lo cual es obvio que vale 
\begin_inset Formula $\varphi$
\end_inset

.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E11)
\end_layout

\end_inset

Consideremos la teoria elemental del ejemplo (E7).
 A continuacion daremos una prueba elemental de 
\begin_inset Formula $\varphi=\forall x\forall y\ (\times(x,y)=\times(y,x))$
\end_inset

 en la teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Para facilitar la lectura usaremos la notacion clasica para operaciones
 binarias, es decir escribiremos 
\begin_inset Formula $x\times y$
\end_inset

 en lugar de 
\begin_inset Formula $\times(y,x)$
\end_inset

, etc.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Prueba elemental de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

:
\end_layout

\end_inset

Sean 
\begin_inset Formula $a,b\in A$
\end_inset

, fijos pero arbitrarios.
 Por el tercer axioma tenemos que
\end_layout

\begin_deeper
\begin_layout Standard
1.
 
\begin_inset Formula $\exists z\ (a=z\times z\wedge\mathrm{Com}(z))$
\end_inset


\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $c$
\end_inset

 tal que
\end_layout

\begin_layout Standard
2.
 
\begin_inset Formula $a=c\times c\wedge\mathrm{Com}(c)$
\end_inset


\end_layout

\begin_layout Standard
Nuevamente, por el tercer axioma tenemos que
\end_layout

\begin_layout Standard
3.
 
\begin_inset Formula $\exists z\ (b=z\times z\wedge\mathrm{Com}(z))$
\end_inset


\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $d$
\end_inset

 tal que
\end_layout

\begin_layout Standard
4.
 
\begin_inset Formula $b=d\times d\wedge\mathrm{Com}(d)$
\end_inset


\end_layout

\begin_layout Standard
Ya que vale 
\begin_inset Formula $\mathrm{Com}(c)$
\end_inset

, el segundo axioma nos dice que
\end_layout

\begin_layout Standard
5.
 
\begin_inset Formula $\forall x\ (x\times c=c\times x)$
\end_inset


\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $a=c\times c$
\end_inset

 y 
\begin_inset Formula $b=d\times d$
\end_inset

, tenemos que
\end_layout

\begin_layout Standard
6.
 
\begin_inset Formula $a\times b=(c\times c)\times(d\times d)$
\end_inset


\end_layout

\begin_layout Standard
Pero por el primer axioma (asociatividad) tenemos que
\end_layout

\begin_layout Standard
7.
 
\begin_inset Formula $(c\times c)\times(d\times d)=c\times(c\times(d\times d))$
\end_inset


\end_layout

\begin_layout Standard
Pero por 5.
 tenemos que
\end_layout

\begin_layout Standard
8.
 
\begin_inset Formula $c\times(c\times(d\times d))=c\times((d\times d)\times c)$
\end_inset


\end_layout

\begin_layout Standard
Por asociatividad
\end_layout

\begin_layout Standard
9.
 
\begin_inset Formula $c\times((d\times d)\times c)=(c\times(d\times d))\times c$
\end_inset


\end_layout

\begin_layout Standard
Por 5.
 tenemos que
\end_layout

\begin_layout Standard
10.
 
\begin_inset Formula $(c\times(d\times d))\times c=((d\times d)\times c)\times c$
\end_inset


\end_layout

\begin_layout Standard
Por asociatividad tenemos que
\end_layout

\begin_layout Standard
11.
 
\begin_inset Formula $((d\times d)\times c)\times c=(d\times d)\times(c\times c)$
\end_inset


\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $a=c\times c$
\end_inset

 y 
\begin_inset Formula $b=d\times d$
\end_inset

, tenemos que
\end_layout

\begin_layout Standard
12.
 
\begin_inset Formula $(d\times d)\times(c\times c)=b\times a$
\end_inset

.
\end_layout

\begin_layout Standard
Siguiendo la cadena de igualdades desde 6.
 hasta 12.
 tenemos que
\end_layout

\begin_layout Standard
13.
 
\begin_inset Formula $a\times b=b\times a$
\end_inset

.
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

 eran elementos arbitrarios, hemos probado que 
\begin_inset Formula $\forall x\forall y\ x\times y=y\times x$
\end_inset

 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "programa"

\end_inset

Programa
\end_layout

\begin_layout Standard
Ahora que hemos generalizado los conceptos de estructura, formula elemental
 y prueba elemental via el concepto de tipo, podemos enunciar en forma mucho
 mas general el programa de logica para reticulados cuaterna dado al principio
 de la seccion.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Programa de logica matematica
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Dar un modelo matematico del concepto de formula elemental de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Dar una definicion matematica de cuando una formula elemental de tipo 
\begin_inset Formula $\tau$
\end_inset

 es verdadera en una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 para una asignacion dada de valores a las variables libres y a los nombres
 de constantes fijas de la formula
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

(Plato gordo) Dar un modelo matematico del concepto de prueba elemental
 en una teoria elemental de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 A estos objetos matematicos los llamaremos pruebas formales de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

(Sublime) Intentar probar matematicamente que nuestro concepto de prueba
 formal de tipo 
\begin_inset Formula $\tau$
\end_inset

 es una correcta modelizacion matematica de la idea intuitiva de prueba
 elemental en una teoria elemental de tipo 
\begin_inset Formula $\tau$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como veremos, los cuatro puntos anteriores pueden ser hechos satisfactoriamente
 y constituyen el comienzo de la logica matematica con cuantificadores.
 Cabe aclarar que la realizacion del cuarto punto es realmente sorprendente
 ya que es un caso de una prueba matematica rigurosa de un hecho que involucra
 un concepto intuitivo como lo es el de prueba elemental.
\end_layout

\begin_layout Standard
El punto (1) se resuelve en la seccion siguiente y si bien produce interesantes
 conceptos y resultados matematicos su resolucion es rutinaria.
 El punto (2) es resuelto por Tarski.
 El punto (3) por Fregue.
 El (4) es una concecuencia de dos importantes teoremas, el Teorema de Correccio
n y el Teorema de Completitud de Godel.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Modelo matematico de la sintaxis elemental
\end_layout

\begin_layout Standard
En esta seccion daremos un modelo matematico del concepto de formula elemental
 de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Esto coresponde al punto (1) del programa de logica enunciado anteriormente.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Variables
\end_layout

\begin_layout Standard
Las variables usadas en las formulas elementales no estaban del todo especificad
as.
 Para hacer bien preciso este concepto definiremos un conjunto concreto
 de variables.
 Sea 
\begin_inset Formula $Var$
\end_inset

 el siguiente conjunto de palabras del alfabeto 
\begin_inset Formula $\{\mathsf{X},\mathit{0},\mathit{1},...,\mathit{9},\mathbf{0},\mathbf{1},...,\mathbf{9}\}$
\end_inset

:
\begin_inset Formula 
\[
Var=\{\mathsf{X}\mathbf{1},\mathsf{X}\mathbf{2},...,\mathsf{X}\mathbf{9},\mathsf{X}\mathit{1}\mathbf{0},\mathsf{X}\mathit{1}\mathbf{1},...,\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathit{2}\mathbf{0},\mathsf{X}\mathit{2}\mathbf{1},...\}
\]

\end_inset

Es decir el elemento 
\begin_inset Formula $n$
\end_inset

-esimo de 
\begin_inset Formula $Var$
\end_inset

 es la palabra de la forma 
\begin_inset Formula $\mathsf{X}\alpha$
\end_inset

 donde 
\begin_inset Formula $\alpha$
\end_inset

 es el resultado de reemplazar en la palabra que denota 
\begin_inset Formula $n$
\end_inset

 en notacion decimal, el ultimo numeral por su correspondiente numeral bold
 y los otros por sus correspondientes italicos.
 A los elementos de 
\begin_inset Formula $Var$
\end_inset

 los llamaremos 
\shape italic
variables.

\shape default
 La razon por la cual usamos numerales italicos y bold es que a los numerales
 normales los usamos habitualmente en los tipos y sera conveniente que entonces
 no ocurran en las variables.
 Ademas tomamos el ultimo simbolo de cada variable en bold para que de esta
 manera nunca una variable sea una subpalabra de otra variable distinta
 a ella, lo cual contribuye a simplificar los resultados.
\end_layout

\begin_layout Standard
Denotaremos con 
\begin_inset Formula $x_{i}$
\end_inset

 al 
\begin_inset Formula $i$
\end_inset

-esimo elemento de 
\begin_inset Formula $Var$
\end_inset

, para cada 
\begin_inset Formula $i\in\mathbf{N}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Terminos
\end_layout

\begin_layout Standard
Dado un tipo 
\begin_inset Formula $\tau$
\end_inset

, definamos recursivamente los conjuntos de palabras 
\begin_inset Formula $T_{k}^{\tau}$
\end_inset

, con 
\begin_inset Formula $k\geq0$
\end_inset

, de la siguiente manera:
\begin_inset Formula 
\begin{align*}
T_{0}^{\tau} & =Var\cup\mathcal{C}\\
T_{k+1}^{\tau} & =T_{k}^{\tau}\cup\{f(t_{1},...,t_{n}):f\in\mathcal{F}_{n}\text{, }n\geq1\text{ y }t_{1},...,t_{n}\in T_{k}^{\tau}\}.
\end{align*}

\end_inset

Sea
\begin_inset Formula 
\[
T^{\tau}=\bigcup_{k\geq0}T_{k}^{\tau}
\]

\end_inset

Los elementos de 
\begin_inset Formula $T^{\tau}$
\end_inset

 seran llamados 
\shape italic
terminos de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

.
 Un termino 
\begin_inset Formula $t$
\end_inset

 es llamado 
\shape italic
cerrado
\shape default
 si 
\begin_inset Formula $x_{i}$
\end_inset

 no es subpalabra de 
\begin_inset Formula $t$
\end_inset

, para cada 
\begin_inset Formula $i\in\mathbf{N}$
\end_inset

.
 Definamos
\begin_inset Formula 
\[
T_{c}^{\tau}=\{t\in T^{\tau}:t\text{ es cerrado}\}
\]

\end_inset


\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau=(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(\mathrm{MAS})=4$
\end_inset

, 
\begin_inset Formula $a(\mathrm{P})=1$
\end_inset

 y 
\begin_inset Formula $a(\mathrm{Her})=3$
\end_inset

.
 Entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
Las palabras 
\begin_inset Formula $\mathrm{uno}$
\end_inset

, 
\begin_inset Formula $\mathrm{doli}$
\end_inset

 y 
\begin_inset Formula $\mathsf{X}\mathit{15666}\mathbf{9}$
\end_inset

 son terminos de tipo 
\begin_inset Formula $\tau$
\end_inset

 ya que pertenecen a 
\begin_inset Formula $T_{0}^{\tau}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{MAS}(\mathrm{uno},\mathrm{doli},\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathbf{5})$
\end_inset

 y 
\begin_inset Formula $\mathrm{P}(\mathrm{uno})\ $
\end_inset

son terminos de tipo 
\begin_inset Formula $\tau$
\end_inset

 ya que pertenecen a 
\begin_inset Formula $T_{1}^{\tau}$
\end_inset

 (por que?)
\end_layout

\begin_layout Enumerate
Las palabras
\begin_inset Formula 
\[
\mathrm{P}(\mathrm{P}(\mathrm{uno}))\ \ \ \ \ \mathrm{MAS}(\mathrm{P}(\mathsf{X}\mathbf{4}),\mathrm{doli},\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathbf{5})
\]

\end_inset

son terminos de tipo 
\begin_inset Formula $\tau$
\end_inset

 ya que pertenecen a 
\begin_inset Formula $T_{2}^{\tau}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{P}(\mathrm{MAS}(\mathrm{P}(\mathsf{X}\mathbf{4}),\mathrm{MAS}(\mathsf{X}\mathbf{1},\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{3},\mathsf{X}\mathbf{4}),\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathbf{5}))$
\end_inset

 es un termino ya que pertenece a 
\begin_inset Formula $T_{3}^{\tau}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{uno}$
\end_inset

, 
\begin_inset Formula $\mathrm{doli}$
\end_inset

, 
\begin_inset Formula $\mathrm{P}(\mathrm{uno})$
\end_inset

 y 
\begin_inset Formula $\mathrm{MAS}(\mathrm{uno},\mathrm{doli},\mathrm{doli},\mathrm{doli})$
\end_inset

 son terminos cerrados de tipo 
\begin_inset Formula $\tau$
\end_inset

 
\end_layout

\begin_layout Standard
Lo que debe quedar claro es que como objetos matematicos los terminos son
 meras palabras, por ejemplo 
\begin_inset Formula $\mathrm{MAS}(\mathrm{uno},\mathrm{doli},\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathbf{5})$
\end_inset

 es una palabra (de longitud 20)
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau=(\{0,1\},\{+,\times,\uparrow\},\emptyset,a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(+)=2$
\end_inset

, 
\begin_inset Formula $a(\times)=3$
\end_inset

 y 
\begin_inset Formula $a(\uparrow)=1$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
\mathsf{X}\mathit{111}\mathbf{9}\ \ \ \ \ \ \ \ 0\ \ \ \ \ \ \ \ 1\ \ \ \ \ \ \ \ +(+(\mathrm{\uparrow}(\mathsf{X}\mathbf{4}),\times(\mathsf{X}\mathbf{2},1,0)),\times(1,\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{3}))
\]

\end_inset

son terminos de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Tambien 
\begin_inset Formula $\mathrm{\uparrow}(+(\mathrm{\uparrow}(0),\times(0,1,0)))$
\end_inset

 es un termino cerrado de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau=(\emptyset,\{\mathsf{s},\mathsf{i}\},\emptyset,\{(\mathsf{s},2),(\mathsf{i},2)\})$
\end_inset

 el tipo de los reticulados terna.
 Entonces
\begin_inset Formula 
\[
\mathsf{s}(\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{3})\ \ \ \ \ \ \ \ \ \mathsf{s}(\mathsf{s}(\mathsf{X}\mathbf{4},\mathsf{X}\mathit{1}\mathbf{4}),\mathsf{i}(\mathsf{X}\mathbf{2},\mathsf{X}\mathit{111}\mathbf{9}))
\]

\end_inset

son terminos de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 No hay terminos cerrados de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Cabe destacar que 
\begin_inset Formula $\mathsf{X}\mathbf{2\ }\mathsf{s\ X}\mathbf{3}$
\end_inset

 no es un termino de tipo 
\begin_inset Formula $\tau$
\end_inset

 aunque, como veremos en los ejercicios esto no es trivial de la definicion
 de termino y requiere de una demostracion.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente lema es la herramienta basica para probar propiedades de los
 terminos.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Menu para terminos
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "basic0"

\end_inset

Supongamos 
\begin_inset Formula $t\in T_{k}^{\tau}$
\end_inset

, con 
\begin_inset Formula $k\geq1$
\end_inset

.
 Entonces se da alguna de las siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $t\in Var\cup\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $t=f(t_{1},...,t_{n})$
\end_inset

, con 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $n\geq1$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{n}\in T_{k-1}^{\tau}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por induccion en 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $k=1$
\end_inset

: Es directo ya que por definicion
\begin_inset Formula 
\[
T_{1}^{\tau}=Var\cup\mathcal{C}\cup\{f(t_{1},...,t_{n}):f\in\mathcal{F}_{n}\text{, }n\geq1\text{ y }t_{1},...,t_{n}\in T_{0}^{\tau}\}.
\]

\end_inset


\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $k\Rightarrow k+1$
\end_inset

: Sea 
\begin_inset Formula $t\in T_{k+1}^{\tau}$
\end_inset

.
 Por definicion de 
\begin_inset Formula $T_{k+1}^{\tau}$
\end_inset

 tenemos que 
\begin_inset Formula $t\in T_{k}^{\tau}$
\end_inset

 o 
\begin_inset Formula $t=f(t_{1},...,t_{n})$
\end_inset

 con 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $n\geq1$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{n}\in T_{k}^{\tau}$
\end_inset

.
 Si se da que 
\begin_inset Formula $t\in T_{k}^{\tau}$
\end_inset

, entonces podemos aplicar hipotesis inductiva y usar que 
\begin_inset Formula $T_{k-1}^{\tau}\subseteq T_{k}^{\tau}$
\end_inset

.
 Esto completa el caso.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Algunos ejemplos de propiedades de los terminos las cuales se pueden probar
 facilmente usando el lema anterior son
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

 es tal que en 
\begin_inset Formula $t$
\end_inset

 ocurre el simbolo 
\begin_inset Formula $)$
\end_inset

, entonces 
\begin_inset Formula $t=f(t_{1},...,t_{n})$
\end_inset

 con 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $n\geq1$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Ningun termino comienza con un simbolo del alfabeto 
\begin_inset Formula $\{\mathit{0},\mathit{1},...,\mathit{9}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

 comienza con 
\begin_inset Formula $\mathsf{X}$
\end_inset

 entonces 
\begin_inset Formula $t\in Var$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

 y 
\begin_inset Formula $\left[t\right]_{i}=)$
\end_inset

, con 
\begin_inset Formula $i<\left\vert t\right\vert $
\end_inset

, entonces 
\begin_inset Formula $\left[t\right]_{i+1}=$
\end_inset

 
\begin_inset Formula $,$
\end_inset

 o 
\begin_inset Formula $\left[t\right]_{i+1}=$
\end_inset

 
\begin_inset Formula $)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

, entonces 
\begin_inset Formula $\left\vert t\right\vert _{(}=\left\vert t\right\vert _{)}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Una posible forma de probar que una palabra dada no es un termino es encontrar
 una propiedad que posean todos los terminos la cual no cumpla dicha palabra.
 Por ejemplo si 
\begin_inset Formula $\tau=(\emptyset,\{glp\},\emptyset,a)$
\end_inset

, con 
\begin_inset Formula $a(glp)=1$
\end_inset

, la palabra 
\begin_inset Formula $\alpha=glp((\mathsf{X}\mathit{13}\mathbf{3})$
\end_inset

 no es un termino ya que 
\begin_inset Formula $\left\vert \alpha\right\vert _{(}\neq\left\vert \alpha\right\vert _{)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Unicidad de la lectura de terminos
\end_layout

\begin_layout Standard
Definamos conjuntos 
\begin_inset Formula $Bal_{k}$
\end_inset

, con 
\begin_inset Formula $k\geq1$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\begin{align*}
Bal_{1} & =\{()\}\\
Bal_{k+1} & =Bal_{k}\cup\{(b_{1}...b_{n}):b_{1},...,b_{n}\in Bal_{k},n\geq1\}.
\end{align*}

\end_inset

Sea
\begin_inset Formula 
\[
Bal=\bigcup_{k\geq1}Bal_{k}
\]

\end_inset

Recordemos que 
\begin_inset Formula $\beta$
\end_inset

 es un 
\shape italic
tramo inicial (propio) 
\shape default
de 
\begin_inset Formula $\alpha$
\end_inset

 si hay una palabra 
\begin_inset Formula $\gamma$
\end_inset

 tal que 
\begin_inset Formula $\alpha=\beta\gamma$
\end_inset

 (y 
\begin_inset Formula $\beta\notin\{\varepsilon,\alpha\}$
\end_inset

).
 En forma similar se define 
\shape italic
tramo final (propio).
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basicas de balanceadas"

\end_inset

Sea 
\begin_inset Formula $b\in Bal$
\end_inset

.
 Se tiene:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\left\vert b\right\vert _{(}-\left\vert b\right\vert _{)}=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $x$
\end_inset

 es tramo inicial propio de 
\begin_inset Formula $b$
\end_inset

, entonces 
\begin_inset Formula $\left\vert x\right\vert _{(}-\left\vert x\right\vert _{)}>0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $x$
\end_inset

 es tramo final propio de 
\begin_inset Formula $b$
\end_inset

, entonces 
\begin_inset Formula $\left\vert x\right\vert _{(}-\left\vert x\right\vert _{)}<0$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Probaremos por induccion en 
\begin_inset Formula $k$
\end_inset

, que valen (1), (2) y (3) para cada 
\begin_inset Formula $b\in Bal_{k}$
\end_inset

.
 El caso 
\begin_inset Formula $k=1$
\end_inset

 es trivial.
 Supongamos 
\begin_inset Formula $b\in Bal_{k+1}$
\end_inset

.
 Si 
\begin_inset Formula $b\in Bal_{k}$
\end_inset

, se aplica directamente HI.
 Supongamos entonces que 
\begin_inset Formula $b=(b_{1}...b_{n})$
\end_inset

, con 
\begin_inset Formula $b_{1},...,b_{n}\in Bal_{k}$
\end_inset

, 
\begin_inset Formula $n\geq1$
\end_inset

.
 Por HI, 
\begin_inset Formula $b_{1},...,b_{n}$
\end_inset

 cumplen (1) por lo cual 
\begin_inset Formula $b$
\end_inset

 cumple (1).
 Veamos que 
\begin_inset Formula $b$
\end_inset

 cumple (2).
 Sea 
\begin_inset Formula $x$
\end_inset

 un tramo inicial propio de 
\begin_inset Formula $b$
\end_inset

.
 Notese que 
\begin_inset Formula $x$
\end_inset

 es de la forma 
\begin_inset Formula $x=(b_{1}...b_{i}x_{1}$
\end_inset

 con 
\begin_inset Formula $0\leq i\leq n-1$
\end_inset

 y 
\begin_inset Formula $x_{1}$
\end_inset

 un tramo inicial de 
\begin_inset Formula $b_{i+1}$
\end_inset

 (en el caso 
\begin_inset Formula $i=0$
\end_inset

 interpretamos 
\begin_inset Formula $b_{1}...b_{i}=\varepsilon)$
\end_inset

.
 Pero entonces ya que
\begin_inset Formula 
\[
\left\vert x\right\vert _{(}-\left\vert x\right\vert _{)}=1+\left(\sum_{j=1}^{i}\left\vert b_{j}\right\vert _{(}-\left\vert b_{j}\right\vert _{)}\right)+\left\vert x_{1}\right\vert _{(}-\left\vert x_{1}\right\vert _{)}
\]

\end_inset

tenemos que por HI, se da que 
\begin_inset Formula $\left\vert x\right\vert _{(}-\left\vert x\right\vert _{)}>0$
\end_inset

.
 En forma analoga se puede ver que 
\begin_inset Formula $b$
\end_inset

 cumple (3).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dado un alfabeto 
\begin_inset Formula $\Sigma$
\end_inset

 tal que 
\begin_inset Formula $($
\end_inset

 y 
\begin_inset Formula $)$
\end_inset

 pertenecen a 
\begin_inset Formula $\Sigma$
\end_inset

, definamos 
\begin_inset Formula $del:\Sigma^{\ast}\rightarrow\Sigma^{\ast}$
\end_inset

, de la siguiente manera
\begin_inset Formula 
\begin{align*}
del(\varepsilon) & =\varepsilon\\
del(\alpha a) & =del(\alpha)a\text{, si }a\in\{(,)\}\\
del(\alpha a) & =del(\alpha)\text{, si }a\in\Sigma-\{(,)\}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $del(xy)=del(x)del(y)$
\end_inset

, para todo 
\begin_inset Formula $x,y\in\Sigma^{\ast}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos que 
\begin_inset Formula $\Sigma$
\end_inset

 es tal que 
\begin_inset Formula $T^{\tau}\subseteq\Sigma^{\ast}$
\end_inset

.
 Entonces 
\begin_inset Formula $del(t)\in Bal$
\end_inset

, para cada 
\begin_inset Formula $t\in T^{\tau}-(Var\cup\mathcal{C})$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que en la definicion de tipo se exige que nunca un nombre de cte
 sea subpalabra de otro nombre de cte, lo cual garantiza que nunca puede
 ser un nombre de cte un tramo inicial o final propio de otro nombre de
 cte.
 Lo que si puede suceder es que un tramo final propio de un nombre de cte
 
\begin_inset Formula $c$
\end_inset

 sea un tramo inicial propio de otro nombre de cte 
\begin_inset Formula $d$
\end_inset

.
 Mas formalmente puede suceder que haya palabras 
\begin_inset Formula $x,y,z$
\end_inset

, las tres distintas de 
\begin_inset Formula $\varepsilon$
\end_inset

 tales que 
\begin_inset Formula $c=xy$
\end_inset

 y 
\begin_inset Formula $d=yz$
\end_inset

.
 En tal caso solemos decir que las palabras 
\begin_inset Formula $c$
\end_inset

 y 
\begin_inset Formula $d$
\end_inset

 se 
\shape italic
mordizquean
\shape default
.
 Por ejemplo si 
\begin_inset Formula $\tau=(\{\mathrm{uno}$
\end_inset

,
\begin_inset Formula $\mathrm{noli}\},\emptyset,\emptyset,\emptyset)$
\end_inset

, es facil ver que 
\begin_inset Formula $\tau$
\end_inset

 es un tipo y que 
\begin_inset Formula $\mathrm{uno}$
\end_inset

 y 
\begin_inset Formula $\mathrm{noli}$
\end_inset

 se mordizquean.
 El lema siguiente nos dice que este es el unico caso de mordizqueo de terminos.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Mordizqueo de Terminos
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "superposicion"

\end_inset

Sean 
\begin_inset Formula $s,t\in T^{\tau}$
\end_inset

 y supongamos que hay palabras 
\begin_inset Formula $x,y,z$
\end_inset

, con 
\begin_inset Formula $y\neq\varepsilon$
\end_inset

 tales que 
\begin_inset Formula $s=xy$
\end_inset

 y 
\begin_inset Formula $t=yz$
\end_inset

 .
 Entonces 
\begin_inset Formula $x=z=\varepsilon$
\end_inset

 o 
\begin_inset Formula $s,t\in\mathcal{C}$
\end_inset

.
 En particular si un termino es tramo inicial o final de otro termino, entonces
 dichos terminos son iguales.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $s\in\mathcal{C}$
\end_inset

.
 Ya que 
\begin_inset Formula $y\neq\varepsilon$
\end_inset

 tenemos que 
\begin_inset Formula $t$
\end_inset

 debe comenzar con un simbolo que ocurre en un nombre de cte, lo cual dice
 que 
\begin_inset Formula $t$
\end_inset

 no puede ser ni una variable ni de la forma 
\begin_inset Formula $g(t_{1},...,t_{m})$
\end_inset

, es decir 
\begin_inset Formula $t\in\mathcal{C}$
\end_inset

.
 Supongamos 
\begin_inset Formula $s\in Var$
\end_inset

.
 Si 
\begin_inset Formula $x\neq\varepsilon$
\end_inset

 tenemos que 
\begin_inset Formula $t$
\end_inset

 debe comenzar con alguno de los siguientes simbolos
\begin_inset Formula 
\[
\mathit{0}\;\mathit{1\;}...\;\mathit{9}\;\mathbf{0}\;\mathbf{1}\ ...\;\mathbf{9}
\]

\end_inset

lo cual es absurdo.
 O sea que 
\begin_inset Formula $x=\varepsilon$
\end_inset

 y por lo tanto 
\begin_inset Formula $t$
\end_inset

 debe comenzar con 
\begin_inset Formula $\mathsf{X}$
\end_inset

.
 Pero esto dice que 
\begin_inset Formula $t\in Var$
\end_inset

 de lo que sigue facilmente que 
\begin_inset Formula $z=\varepsilon$
\end_inset

.
 Supongamos entonces que 
\begin_inset Formula $s$
\end_inset

 es de la forma 
\begin_inset Formula $f(s_{1},...,s_{n})$
\end_inset

.
 Ya que 
\begin_inset Formula $)$
\end_inset

 debe ocurrir en 
\begin_inset Formula $t$
\end_inset

, tenemos que 
\begin_inset Formula $t$
\end_inset

 es de la forma 
\begin_inset Formula $g(t_{1},...,t_{m})$
\end_inset

.
 O sea que 
\begin_inset Formula $del(s),del(t)\in Bal$
\end_inset

.
 Ya que 
\begin_inset Formula $)$
\end_inset

 ocurre en 
\begin_inset Formula $y$
\end_inset

, 
\begin_inset Formula $del(y)\neq\varepsilon$
\end_inset

.
 Tenemos tambien que
\begin_inset Formula 
\begin{align*}
del(s) & =del(x)del(y)\\
del(t) & =del(y)del(z)
\end{align*}

\end_inset

La primera igualdad, por (1) y (3) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicas de balanceadas"
plural "false"
caps "false"
noprefix "false"

\end_inset

, nos dice que
\begin_inset Formula 
\[
\left\vert del(y)\right\vert _{(}-\left\vert del(y)\right\vert _{)}\leq0,
\]

\end_inset

y la segunda que
\begin_inset Formula 
\[
\left\vert del(y)\right\vert _{(}-\left\vert del(y)\right\vert _{)}\geq0,
\]

\end_inset

por lo cual
\begin_inset Formula 
\[
\left\vert del(y)\right\vert _{(}-\left\vert del(y)\right\vert _{)}=0
\]

\end_inset

Pero entonces (3) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicas de balanceadas"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $del(y)$
\end_inset

 no puede ser tramo final propio de 
\begin_inset Formula $del(s)$
\end_inset

, por lo cual debe suceder que 
\begin_inset Formula $del(y)=del(s)$
\end_inset

, ya que 
\begin_inset Formula $del(y)\neq\varepsilon$
\end_inset

.
 Claramente entonces obtenemos que 
\begin_inset Formula $del(x)=\varepsilon$
\end_inset

.
 Similarmente se puede ver que 
\begin_inset Formula $del(z)=\varepsilon$
\end_inset

.
 Ya que que 
\begin_inset Formula $t$
\end_inset

 termina con 
\begin_inset Formula $)$
\end_inset

 tenemos que 
\begin_inset Formula $z=\varepsilon$
\end_inset

.
 O sea que 
\begin_inset Formula $f(s_{1},...,s_{n})=xg(t_{1},...,t_{m})$
\end_inset

 con 
\begin_inset Formula $del(x)=\varepsilon$
\end_inset

, de lo que se saca que 
\begin_inset Formula $f=xg$
\end_inset

 ya que 
\begin_inset Formula $($
\end_inset

 no ocurre en 
\begin_inset Formula $x$
\end_inset

.
 De la definicion de tipo se desprende que 
\begin_inset Formula $x=\varepsilon$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem

\shape italic
\begin_inset CommandInset label
LatexCommand label
name "le-un-de-te"

\end_inset

Dado 
\shape default

\begin_inset Formula $t\in T^{\tau}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

se da una de las siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $t\in Var\cup\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\shape italic
Hay unicos 
\shape default

\begin_inset Formula $n\geq1$
\end_inset

,
\begin_inset Formula $\;f\in\mathcal{F}_{n}$
\end_inset

,
\begin_inset Formula $\;t_{1},...,t_{n}\in T^{\tau}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

tales que 
\shape default

\begin_inset Formula $t=f(t_{1},...,t_{n})$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 En virtud del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "basic0"
plural "false"
caps "false"
noprefix "false"

\end_inset

 solo nos falta probar la unicidad en el punto (2).
 Supongamos que
\begin_inset Formula 
\[
t=f(t_{1},...,t_{n})=g(s_{1},...,s_{m})
\]

\end_inset

con 
\begin_inset Formula $n,m\geq1,\;f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $g\in\mathcal{F}_{m}$
\end_inset

, 
\begin_inset Formula $t_{1},...,t_{n},s_{1},...,s_{m}\in T^{\tau}$
\end_inset

.
 Notese que 
\begin_inset Formula $f=g$
\end_inset

.
 O sea que 
\begin_inset Formula $n=m=a(f)$
\end_inset

.
 Notese que 
\begin_inset Formula $t_{1}$
\end_inset

 es tramo inicial de 
\begin_inset Formula $s_{1}$
\end_inset

 o 
\begin_inset Formula $s_{1}$
\end_inset

 es tramo inicial de 
\begin_inset Formula $t_{1}$
\end_inset

, lo cual por el lema anterior nos dice que 
\begin_inset Formula $t_{1}=s_{1}$
\end_inset

.
 Con el mismo razonamiento podemos probar que debera suceder 
\begin_inset Formula $t_{2}=s_{2},...,t_{n}=s_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
El teorema anterior es importante ya que nos permite definir recursivamente
 funciones con dominio contenido en 
\begin_inset Formula $T^{\tau}$
\end_inset

.
 Por ejemplo podemos definir una funcion 
\begin_inset Formula $F:T^{\tau}\rightarrow T^{\tau}$
\end_inset

, de la siguiente manera:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $F(c)=c$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $F(v)=v$
\end_inset

, para cada 
\begin_inset Formula $v\in Var$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $F(f(t_{1},...,t_{n}))=f(F(t_{1}),...,F(t_{n}))$
\end_inset

, si 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, con 
\begin_inset Formula $n\neq2$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $F(f(t_{1},t_{2}))=f(t_{2},t_{1})$
\end_inset

, si 
\begin_inset Formula $f\in\mathcal{F}_{2}.$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Notese que si la unicidad de la lectura no fuera cierta, entonces las ecuaciones
 anteriores no estarian definiendo en forma correcta una funcion ya que
 el valor de la imagen de un termino 
\begin_inset Formula $t$
\end_inset

 estaria dependiendo de cual descomposicion tomemos para 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Subterminos
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $s,t\in T^{\tau}$
\end_inset

.
 Diremos que 
\begin_inset Formula $s$
\end_inset

 es 
\shape italic
subtermino 
\shape default
(
\shape italic
propio
\shape default
)
\shape italic

\begin_inset space \space{}
\end_inset


\shape default
de 
\begin_inset Formula $t$
\end_inset

 si (no es igual a 
\begin_inset Formula $t$
\end_inset

 y) 
\begin_inset Formula $s$
\end_inset

 es subpalabra de 
\begin_inset Formula $t$
\end_inset

.
 A continuacion veremos de que manera ocurren los subterminos de un termino.
 Para esto recordemos un poco el concepto de ocurrencia.
\end_layout

\begin_layout Standard
Dadas palabras 
\begin_inset Formula $\alpha,\beta\in\Sigma^{\ast}$
\end_inset

, con 
\begin_inset Formula $\left\vert \alpha\right\vert ,\left\vert \beta\right\vert \geq1$
\end_inset

, y un natural 
\begin_inset Formula $i\in\{1,...,\left\vert \beta\right\vert \}$
\end_inset

, se dice que 
\begin_inset Formula $\alpha$
\end_inset

 
\shape italic
ocurre a partir de 
\shape default

\begin_inset Formula $i$
\end_inset

 
\shape italic
en 
\shape default

\begin_inset Formula $\beta$
\end_inset

 cuando se de que existan palabras 
\begin_inset Formula $\delta,\gamma$
\end_inset

 tales que 
\begin_inset Formula $\beta=\delta\alpha\gamma$
\end_inset

 y 
\begin_inset Formula $\left\vert \delta\right\vert =i-1$
\end_inset

.
 Intuitivamente hablando 
\begin_inset Formula $\alpha$
\end_inset

 ocurre a partir de 
\begin_inset Formula $i$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

 cuando se de que si comensamos a leer desde el lugar 
\begin_inset Formula $i$
\end_inset

-esimo de 
\begin_inset Formula $\beta$
\end_inset

 en adelante, leeremos la palabra 
\begin_inset Formula $\alpha$
\end_inset

 completa y luego posiblemente seguiran otros simbolos.
\end_layout

\begin_layout Standard
Notese que una palabra 
\begin_inset Formula $\alpha$
\end_inset

 puede ocurrir en 
\begin_inset Formula $\beta$
\end_inset

, a partir de 
\begin_inset Formula $i$
\end_inset

, y tambien a partir de 
\begin_inset Formula $j$
\end_inset

, con 
\begin_inset Formula $i\neq j$
\end_inset

.
 En virtud de esto, hablaremos de las distintas ocurrencias de 
\begin_inset Formula $\alpha$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

.
 Por ejemplo hay dos ocurrencias de la palabra 
\begin_inset Formula $aba$
\end_inset


\begin_inset space \space{}
\end_inset

en la palabra
\begin_inset Formula 
\[
cccccccabaccccabaccccc
\]

\end_inset

y tambien hay dos ocurrencias de la palabra 
\begin_inset Formula $aba$
\end_inset


\begin_inset space \space{}
\end_inset

en la palabra
\begin_inset Formula 
\[
cccccccababacccccccccc
\]

\end_inset

En el primer caso diremos que dichas ocurrencias de 
\begin_inset Formula $aba$
\end_inset

 son 
\shape italic
disjuntas
\shape default
, en cambio en el segundo caso puede apreciarse que las dos ocurrencias
 se superponen en una posicion.
 No definiremos en forma matematica precisa el concepto de ocurrencia pero
 lo describiremos con ejemplos de manera que el lector no tendra problemas
 en comprenderlo y manejarlo en forma correcta.
\end_layout

\begin_layout Standard
A veces diremos que una ocurrencia esta 
\shape italic
contenida
\shape default
 o 
\shape italic
sucede
\shape default
 dentro de otra.
 Por ejemplo la segunda ocurrencia de 
\begin_inset Formula $ab$
\end_inset

 en 
\begin_inset Formula $babbbfabcccfabccc$
\end_inset

 esta contenida en la primer ocurrencia de 
\begin_inset Formula $fabc$
\end_inset

 en 
\begin_inset Formula $babbbfabcccfabccc$
\end_inset

.
 Tambien haremos 
\shape italic
reemplazos
\shape default
 de ocurrencias por palabras.
 Por ejemplo el resultado de reemplazar la primer ocurrencia de 
\begin_inset Formula $abb$
\end_inset

 en 
\begin_inset Formula $ccabbgfgabbgg$
\end_inset

 por 
\begin_inset Formula $oolala$
\end_inset

 es la palabra 
\begin_inset Formula $ccoolalagfgabbgg$
\end_inset

.
 El resultado de reemplazar todas las ocurrencias de 
\begin_inset Formula $aba$
\end_inset

 en 
\begin_inset Formula $ccabagfgabaggaba$
\end_inset

 por 
\begin_inset Formula $\$\$$
\end_inset

 es la palabra 
\begin_inset Formula $cc\$\$gfg\$\$gg\$\$$
\end_inset

.
 En algunos casos deberemos especificar que los reemplazos se hagan 
\shape italic
simultaneamente
\shape default
.
 Por ejemplo hablaremos del resultado de reemplazar en 
\begin_inset Formula $\gamma$
\end_inset

, simultaneamente, todas las ocurrencias de 
\begin_inset Formula $\alpha_{1}$
\end_inset

 por 
\begin_inset Formula $\beta_{1}$
\end_inset

 y todas las de 
\begin_inset Formula $\alpha_{2}$
\end_inset

 por 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Aqui la aclaracion de simultaneidad es importante ya que si primero reemplazara
mos las ocurrencias de 
\begin_inset Formula $\alpha_{1}$
\end_inset

 por 
\begin_inset Formula $\beta_{1}$
\end_inset

 y despues las de 
\begin_inset Formula $\alpha_{2}$
\end_inset

 por 
\begin_inset Formula $\beta_{2}$
\end_inset

, el resultado puede cambiar porque en 
\begin_inset Formula $\beta_{1}$
\end_inset

 puede haber ocurrencias de 
\begin_inset Formula $\alpha_{2}$
\end_inset

.
 Dejamos al lector dar un ejemplo en el cual el reemplazo secuencial y el
 simultaneo dan distintos resultados.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Ocurrencias de terminos en terminos
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "reemp-ter-en-ter"

\end_inset

Sean 
\begin_inset Formula $r,s,t\in T^{\tau}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Si 
\begin_inset Formula $s\neq t=f(t_{1},...,t_{n})$
\end_inset

 y 
\begin_inset Formula $s$
\end_inset

 ocurre en 
\begin_inset Formula $t$
\end_inset

, entonces dicha ocurrencia sucede dentro de algun 
\begin_inset Formula $t_{j}$
\end_inset

, 
\begin_inset Formula $j=1,...,n$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si 
\begin_inset Formula $r,s$
\end_inset


\begin_inset space \space{}
\end_inset

ocurren en 
\begin_inset Formula $t$
\end_inset

, entonces dichas ocurrencias son disjuntas o una ocurre dentro de otra.
 En particular, las distintas ocurrencias de 
\begin_inset Formula $r$
\end_inset

 en 
\begin_inset Formula $t$
\end_inset

 son disjuntas.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset

Si 
\begin_inset Formula $t^{\prime}$
\end_inset


\begin_inset space \space{}
\end_inset

es el resultado de reemplazar una ocurrencia de 
\begin_inset Formula $s$
\end_inset


\begin_inset space \space{}
\end_inset

en 
\begin_inset Formula $t$
\end_inset


\begin_inset space \space{}
\end_inset

por 
\begin_inset Formula $r$
\end_inset

, entonces 
\begin_inset Formula $t^{\prime}\in T^{\tau}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Supongamos la ocurrencia de 
\begin_inset Formula $s$
\end_inset

 comienza en algun 
\begin_inset Formula $t_{j}$
\end_inset

.
 Entonces el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "superposicion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos conduce a que dicha ocurrencia debera estar contenida en 
\begin_inset Formula $t_{j}$
\end_inset

.
 Veamos que la ocurrencia de 
\begin_inset Formula $s$
\end_inset

 no puede ser a partir de un 
\begin_inset Formula $i\in\{1,...,\left\vert f\right\vert \}$
\end_inset

.
 Supongamos lo contrario.
 Tenemos entonces que 
\begin_inset Formula $s$
\end_inset

 debe ser de la forma 
\begin_inset Formula $g(s_{1},...,s_{m})$
\end_inset

 ya que no puede estar en 
\begin_inset Formula $Var\cup\mathcal{C}$
\end_inset

.
 Notese que 
\begin_inset Formula $i\neq1$
\end_inset

 ya que en caso contrario 
\begin_inset Formula $s$
\end_inset

 seria un tramo inicial propio de 
\begin_inset Formula $t$
\end_inset

.
 Pero entonces 
\begin_inset Formula $g$
\end_inset

 debe ser un tramo final propio de 
\begin_inset Formula $f$
\end_inset

, lo cual es absurdo.
 Ya que 
\begin_inset Formula $s$
\end_inset

 no puede comenzar con parentesis o coma, hemos contemplado todos los posibles
 casos de comienzo de la ocurrencia de 
\begin_inset Formula $s$
\end_inset

 en 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard
(b) y (c) pueden probarse por induccion, usando (a).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Nota:
\series default
 Es importante notar que si bien no hemos definido en forma presisa el concepto
 de ocurrencia o de reemplazo de ocurrencias, la prueba del lema anterior
 es rigurosa en el sentido de que solo usa propiedades del concepto de ocurrenci
a y reemplazo de ocurrencias las cuales deberan ser comunes a cualquier
 definicion o formulacion matematica que se hiciera de aquellos conceptos.
 En este caso, es posible dar una defincion presisa y satisfactoria de dichos
 conceptos aunque para otros conceptos tales como el de prueba absoluta
 de consistencia, aun no se ha encontrado una formulacion matematica adecuada.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Formulas
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo.
 Las palabras de alguna de las siguientes dos formas
\begin_inset Formula 
\[
\begin{array}{l}
(t\equiv s),\;\text{con }t,s\in T^{\tau}\\
r(t_{1},...,t_{n})\text{, con }r\in\mathcal{R}_{n}\text{,}\ n\geq1\text{ y }t_{1},...,t_{n}\in T^{\tau}
\end{array}
\]

\end_inset

seran llamadas 
\shape italic
formulas atomicas de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

.
 Por ejemplo si 
\begin_inset Formula $\tau=(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(\mathrm{MAS})=4$
\end_inset

, 
\begin_inset Formula $a(\mathrm{P})=1$
\end_inset

 y 
\begin_inset Formula $a(\mathrm{Her})=3$
\end_inset

, entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\mathrm{uno}\equiv\mathrm{doli})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\mathsf{X}\mathit{15666}\mathbf{9}\equiv\mathrm{doli})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{Her}(\mathrm{uno},\mathsf{X}\mathbf{4},\mathrm{doli})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\mathrm{MAS}(\mathrm{uno},\mathrm{doli},\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathbf{5})\equiv\mathrm{uno})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{Her}(\mathrm{P}(\mathrm{P}(\mathrm{uno})),\mathrm{MAS}(\mathrm{P}(\mathsf{X}\mathbf{4}),\mathrm{doli},\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathbf{5}),\mathsf{X}\mathit{1}\mathbf{9})$
\end_inset

 
\end_layout

\begin_layout Standard
son formulas atomicas de tipo 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dado un tipo 
\begin_inset Formula $\tau$
\end_inset

, definamos recursivamente los conjuntos de palabras 
\begin_inset Formula $F_{k}^{\tau}$
\end_inset

, con 
\begin_inset Formula $k\geq0$
\end_inset

, de la siguiente manera:
\begin_inset Formula 
\[
\begin{array}{ccl}
F_{0}^{\tau} & = & \{\text{formulas atomicas de tipo }\tau\}\\
F_{k+1}^{\tau} & = & F_{k}^{\tau}\cup\{\lnot\varphi:\varphi\in F_{k}^{\tau}\}\cup\{(\varphi\vee\psi):\varphi,\psi\in F_{k}^{\tau}\}\cup\\
 &  & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{(\varphi\wedge\psi):\varphi,\psi\in F_{k}^{\tau}\}\cup\{(\varphi\rightarrow\psi):\varphi,\psi\in F_{k}^{\tau}\}\cup\\
 &  & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{(\varphi\leftrightarrow\psi):\varphi,\psi\in F_{k}^{\tau}\}\cup\{\forall v\varphi:\varphi\in F_{k}^{\tau}\text{ y }v\in Var\}\cup\\
 &  & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\exists v\varphi:\varphi\in F_{k}^{\tau}\text{ y }v\in Var\}
\end{array}
\]

\end_inset

Sea
\begin_inset Formula 
\[
F^{\tau}=\bigcup_{k\geq0}F_{k}^{\tau}
\]

\end_inset

Los elementos de 
\begin_inset Formula $F^{\tau}$
\end_inset

 seran llamados 
\shape italic
formulas de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau=(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(\mathrm{MAS})=4$
\end_inset

, 
\begin_inset Formula $a(\mathrm{P})=1$
\end_inset

 y 
\begin_inset Formula $a(\mathrm{Her})=3$
\end_inset

.
 Entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\lnot((\mathsf{X}\mathbf{1}\equiv\mathsf{X}\mathbf{2})\wedge\mathrm{Her}(\mathrm{P}(\mathrm{doli}),\mathrm{doli},\mathsf{X}\mathit{1}\mathbf{9}))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\exists\mathsf{X}\mathbf{9}\mathrm{Her}(\mathrm{doli},\mathrm{doli},\mathsf{X}\mathbf{9})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\exists\mathsf{X}\mathbf{9}\lnot(\mathrm{uno}\equiv\mathrm{doli})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\lnot\exists\mathsf{X}\mathbf{9}\forall\mathsf{X}\mathbf{7(}\mathrm{Her}(\mathsf{X}\mathbf{9},\mathrm{doli},\mathsf{X}\mathbf{7})\rightarrow(\mathrm{P}(\mathrm{doli})\equiv\mathsf{X}\mathbf{7}))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall\mathsf{X}\mathit{555}\mathbf{9}\forall\mathsf{X}\mathbf{7}\exists\mathsf{X}\mathit{5}\mathbf{1}(\mathrm{MAS}(\mathrm{uno},\mathrm{doli},\mathsf{X}\mathit{1}\mathbf{9},\mathsf{X}\mathbf{5})\equiv\mathrm{uno})\rightarrow\mathrm{Her}(\mathrm{doli},\mathrm{doli},\mathrm{doli}))$
\end_inset

 
\end_layout

\begin_layout Standard
son formulas de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau=(\{0,1\},\{\mathsf{s},\mathsf{i}\},\{\leq\},\{(\mathsf{s},2),(\mathsf{i},2),(\leq,2)\})$
\end_inset

 el tipo de los reticulados cuaterna.
 Entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathrm{\leq}(1,0)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{\leq}(\mathsf{X}\mathbf{1},\mathsf{X}\mathbf{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\lnot(\mathsf{s}(\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{1})\equiv\mathsf{X}\mathbf{2}))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall\mathsf{X}\mathbf{2}\forall\mathsf{X}\mathbf{1}\mathrm{\leq}(\mathsf{X}\mathbf{2},\mathsf{s}(\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{1}))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $((\mathsf{i}(\mathsf{X}\mathbf{1},\mathsf{X}\mathbf{2})\equiv0)\wedge(\mathsf{s}(\mathsf{X}\mathbf{1},\mathsf{X}\mathbf{2})\equiv1))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall\mathsf{X}\mathbf{9}\exists\mathsf{X}\mathbf{1}((0\equiv\mathsf{X}\mathbf{1})\rightarrow\exists\mathsf{X}\mathbf{1}\lnot\mathrm{\leq}(\mathsf{X}\mathbf{2},\mathsf{s}(\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{1})))$
\end_inset

 
\end_layout

\begin_layout Standard
son formulas de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Cabe destacar que 
\begin_inset Formula $(\mathsf{X}\mathbf{1}\leq\mathsf{X}\mathbf{2})$
\end_inset

 no es una formula de tipo 
\begin_inset Formula $\tau$
\end_inset

 aunque, como veremos en los ejercicios esto no es trivial de la definicion
 de formula y requiere de una demostracion.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente lema es la herramienta basica que usaremos para probar propiedades
 acerca de los elementos de 
\begin_inset Formula $F^{\tau}$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Menu para formulas
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "basic2"

\end_inset

Supongamos 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

, con 
\begin_inset Formula $k\geq1$
\end_inset

.
 Entonces 
\begin_inset Formula $\varphi$
\end_inset

 es de alguna de las siguientes formas
\end_layout

\begin_layout Standard
\begin_inset Formula $\varphi=(t\equiv s),$
\end_inset

 con 
\begin_inset Formula $t,s\in T^{\tau}$
\end_inset


\shape italic
.
\end_layout

\begin_layout Standard
\begin_inset Formula $\varphi=r(t_{1},...,t_{n}),$
\end_inset

 con 
\begin_inset Formula $r\in\mathcal{R}_{n}$
\end_inset


\shape italic
, 
\shape default

\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\varphi=(\varphi_{1}\eta\varphi_{2}),$
\end_inset

 con 
\begin_inset Formula $\eta\in\{\wedge,\vee,\rightarrow,\leftrightarrow\},\;\varphi_{1},\varphi_{2}\in F_{k-1}^{\tau}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\varphi=\lnot\varphi_{1},$
\end_inset

 con 
\begin_inset Formula $\varphi_{1}\in F_{k-1}^{\tau}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\varphi=Qv\varphi_{1},$
\end_inset

 con 
\begin_inset Formula $Q\in\{\forall,\exists\},\;v\in Var$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}\in F_{k-1}^{\tau}.$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Induccion en 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Unicidad de la lectura de formulas
\end_layout

\begin_layout Standard
Tal como para el caso de terminos veremos que las formulas tambien tienen
 su unicidad de lectura.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "basic3"

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Supongamos que 
\begin_inset Formula $\Sigma$
\end_inset

 es tal que 
\begin_inset Formula $F^{\tau}\subseteq\Sigma^{\ast}$
\end_inset

.
 Entonces 
\begin_inset Formula $del(\varphi)\in Bal$
\end_inset

, para cada 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Sea 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

, con 
\begin_inset Formula $k\geq0$
\end_inset

.
 Existen 
\begin_inset Formula $x\in(\{\lnot\}\cup\{Qv:Q\in\{\forall,\exists\}$
\end_inset

 y 
\begin_inset Formula $v\in Var\})^{\ast}$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}\in F^{\tau}$
\end_inset

 tales que 
\begin_inset Formula $\varphi=x\varphi_{1}$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}$
\end_inset

 es de la forma 
\begin_inset Formula $(\psi_{1}\eta\psi_{2})$
\end_inset

 o atomica.
 En particular toda formula termina con el simbolo 
\begin_inset Formula $)$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (b) Induccion en 
\begin_inset Formula $k$
\end_inset

.
 El caso 
\begin_inset Formula $k=0$
\end_inset

 es trivial.
 Supongamos (b) vale para cada 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

 y sea 
\begin_inset Formula $\varphi\in F_{k+1}^{\tau}$
\end_inset

.
 Hay varios casos de los cuales haremos solo dos
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=(\psi_{1}\eta\psi_{2})$
\end_inset

, con 
\begin_inset Formula $\psi_{1},\psi_{2}\in F_{k}^{\tau}$
\end_inset

 y 
\begin_inset Formula $\eta\in\{\vee,\wedge,\rightarrow,\leftrightarrow\}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Podemos tomar 
\begin_inset Formula $x=\varepsilon$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}=\varphi$
\end_inset

.
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=Qx_{i}\psi$
\end_inset

, con 
\begin_inset Formula $\psi\in F_{k}^{\tau}$
\end_inset

, 
\begin_inset Formula $i\geq1$
\end_inset

 y 
\begin_inset Formula $Q\in\{\forall,\exists\}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Por HI hay 
\begin_inset Formula $\bar{x}\in(\{\lnot\}\cup\{Qv:Q\in\{\forall,\exists\}$
\end_inset

 y 
\begin_inset Formula $v\in Var\})^{\ast}$
\end_inset

 y 
\begin_inset Formula $\psi_{1}\in F^{\tau}$
\end_inset

 tales que 
\begin_inset Formula $\psi=\bar{x}\psi_{1}$
\end_inset

 y 
\begin_inset Formula $\psi_{1}$
\end_inset

 es de la forma 
\begin_inset Formula $(\gamma_{1}\eta\gamma_{2})$
\end_inset

 o atomica.
 Entonces es claro que 
\begin_inset Formula $x=Qx_{i}\bar{x}$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}=\psi_{1}$
\end_inset

 cumplen (b).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Ninguna formula es tramo final propio de una formula atomica, es decir,
 si 
\begin_inset Formula $\varphi=x\psi$
\end_inset

, con 
\begin_inset Formula $\varphi\in F_{0}^{\tau}$
\end_inset

 y 
\begin_inset Formula $\psi\in F^{\tau}$
\end_inset

, entonces 
\begin_inset Formula $x=\varepsilon$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Si 
\begin_inset Formula $\varphi$
\end_inset

 es de la forma 
\begin_inset Formula $(t\equiv s)$
\end_inset

, entonces 
\begin_inset Formula $\left\vert del(y)\right\vert _{(}-\left\vert del(y)\right\vert _{)}<0$
\end_inset

 para cada tramo final propio 
\begin_inset Formula $y$
\end_inset

 de 
\begin_inset Formula $\varphi$
\end_inset

, lo cual termina el caso ya que 
\begin_inset Formula $del(\psi)$
\end_inset

 es balanceada.
 Supongamos entonces 
\begin_inset Formula $\varphi=r(t_{1},...,t_{n})$
\end_inset

.
 Notese que 
\begin_inset Formula $\psi$
\end_inset

 no puede ser tramo final de 
\begin_inset Formula $t_{1},...,t_{n})$
\end_inset

 ya que 
\begin_inset Formula $del(\psi)$
\end_inset

 es balanceada y 
\begin_inset Formula $\left\vert del(y)\right\vert _{(}-\left\vert del(y)\right\vert _{)}<0$
\end_inset

 para cada tramo final 
\begin_inset Formula $y$
\end_inset

 de 
\begin_inset Formula $t_{1},...,t_{n})$
\end_inset

.
 Es decir que 
\begin_inset Formula $\psi=y(t_{1},...,t_{n})$
\end_inset

, para algun tramo final 
\begin_inset Formula $y$
\end_inset

 de 
\begin_inset Formula $r$
\end_inset

.
 Ya que en 
\begin_inset Formula $\psi$
\end_inset

 no ocurren cuantificadores ni nexos ni el simbolo 
\begin_inset Formula $\equiv$
\end_inset

 el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "basic2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice 
\begin_inset Formula $\psi=\tilde{r}(s_{1},...,s_{m})$
\end_inset

, con 
\begin_inset Formula $\tilde{r}\in\mathcal{R}_{m}$
\end_inset


\shape italic
, 
\shape default

\begin_inset Formula $m\geq1$
\end_inset

 y 
\begin_inset Formula $s_{1},...,s_{m}\in T^{\tau}$
\end_inset

.
 Ahora es facil usando un argumento paresido al usado en la prueba del Teorema
 
\begin_inset CommandInset ref
LatexCommand ref
reference "le-un-de-te"
plural "false"
caps "false"
noprefix "false"

\end_inset

 concluir que 
\begin_inset Formula $m=n$
\end_inset

, 
\begin_inset Formula $s_{i}=t_{i}$
\end_inset

, 
\begin_inset Formula $i=1,...,n$
\end_inset

 y 
\begin_inset Formula $\tilde{r}$
\end_inset

 es tramo final de 
\begin_inset Formula $r$
\end_inset

.
 Por (3) de la definicion de tipo tenemos que 
\begin_inset Formula $\tilde{r}=r$
\end_inset

 lo cual nos dice que 
\begin_inset Formula $\varphi=\psi$
\end_inset

 y 
\begin_inset Formula $x=\varepsilon$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\shape italic
Si 
\shape default

\begin_inset Formula $\varphi=x\psi$
\end_inset

, con 
\begin_inset Formula $\varphi,\psi\in F^{\tau}$
\end_inset

 y 
\begin_inset Formula $x$
\end_inset

 sin parentesis, entonces 
\begin_inset Formula $x\in(\{\lnot\}\cup\{Qv:Q\in\{\forall,\exists\}$
\end_inset

 y 
\begin_inset Formula $v\in Var\})^{\ast}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por induccion en el 
\begin_inset Formula $k$
\end_inset

 tal que 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

.
 El caso 
\begin_inset Formula $k=0$
\end_inset

 es probado en el lema anterior.
 Asumamos que el resultado vale cuando 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

 y veamos que vale cuando 
\begin_inset Formula $\varphi\in F_{k+1}^{\tau}$
\end_inset

.
 Mas aun supongamos 
\begin_inset Formula $\varphi\in F_{k+1}^{\tau}-F_{k}^{\tau}$
\end_inset

.
 Primero haremos el caso en que 
\begin_inset Formula $\varphi=Qv\varphi_{1},$
\end_inset

 con 
\begin_inset Formula $Q\in\{\forall,\exists\},\;v\in Var$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}\in F_{k}^{\tau}$
\end_inset

.
 Supongamos 
\begin_inset Formula $x\neq\varepsilon$
\end_inset

.
 Ya que 
\begin_inset Formula $\psi$
\end_inset

 no comienza con simbolos de 
\begin_inset Formula $v$
\end_inset

, tenemos que 
\begin_inset Formula $\psi$
\end_inset

 debe ser tramo final de 
\begin_inset Formula $\varphi_{1}$
\end_inset

 lo cual nos dice que hay una palabra 
\begin_inset Formula $x_{1}$
\end_inset

 tal que 
\begin_inset Formula $x=Qvx_{1}$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}=x_{1}\psi$
\end_inset

.
 Por HI tenemos que 
\begin_inset Formula $x_{1}\in(\{\lnot\}\cup\{Qv:Q\in\{\forall,\exists\}$
\end_inset

 y 
\begin_inset Formula $v\in Var\})^{\ast}$
\end_inset

 con lo cual 
\begin_inset Formula $x\in(\{\lnot\}\cup\{Qv:Q\in\{\forall,\exists\}$
\end_inset

 y 
\begin_inset Formula $v\in Var\})^{\ast}$
\end_inset

.
 El caso en el que 
\begin_inset Formula $\varphi=\lnot\varphi_{1}$
\end_inset

 con 
\begin_inset Formula $\varphi_{1}\in F_{k}^{\tau}$
\end_inset

, es similar.
 Note que no hay mas casos posibles ya que 
\begin_inset Formula $\varphi$
\end_inset

 no puede comenzar con 
\begin_inset Formula $($
\end_inset

 porque en 
\begin_inset Formula $x$
\end_inset

 no ocurren parentesis por hipotesis 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Mordisqueo de formulas
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mordisqueo"

\end_inset


\shape italic
Si 
\shape default

\begin_inset Formula $\varphi,\psi\in F^{\tau}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

y 
\shape default

\begin_inset Formula $x,y,z$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

son tales que 
\shape default

\begin_inset Formula $\varphi=xy,$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $\psi=yz$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

y 
\shape default

\begin_inset Formula $y\neq\varepsilon,$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

entonces 
\shape default

\begin_inset Formula $z=\varepsilon$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

y 
\shape default

\begin_inset Formula $x\in(\{\lnot\}\cup\{Qv:Q\in\{\forall,\exists\}$
\end_inset

 y 
\begin_inset Formula $v\in Var\})^{\ast}$
\end_inset

.
\shape italic

\begin_inset space \space{}
\end_inset

En particular ningun tramo inicial propio de una formula es una formula.

\shape default
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $\varphi$
\end_inset

 termina con 
\begin_inset Formula $)$
\end_inset

 tenemos que 
\begin_inset Formula $del(y)\neq\varepsilon.$
\end_inset

 Por un lema anterior tenemos que 
\begin_inset Formula $del(\varphi),del(\psi)\in Bal$
\end_inset

.
 Ademas
\begin_inset Formula 
\begin{align*}
del(\varphi) & =del(x)del(y)\\
del(\psi) & =del(y)del(z)
\end{align*}

\end_inset

La primera igualdad, por (1) y (3) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicas de balanceadas"
plural "false"
caps "false"
noprefix "false"

\end_inset

, nos dice que
\begin_inset Formula 
\[
\left\vert del(y)\right\vert _{(}-\left\vert del(y)\right\vert _{)}\leq0,
\]

\end_inset

y la segunda que
\begin_inset Formula 
\[
\left\vert del(y)\right\vert _{(}-\left\vert del(y)\right\vert _{)}\geq0,
\]

\end_inset

por lo cual
\begin_inset Formula 
\[
\left\vert del(y)\right\vert _{(}-\left\vert del(y)\right\vert _{)}=0
\]

\end_inset

Pero entonces (3) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "basicas de balanceadas"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $del(y)$
\end_inset

 no puede ser tramo final propio de 
\begin_inset Formula $del(\varphi)$
\end_inset

, por lo cual debe suceder que 
\begin_inset Formula $del(y)=del(\varphi)$
\end_inset

, ya que 
\begin_inset Formula $del(y)\neq\varepsilon$
\end_inset

.
 Claramente entonces obtenemos que 
\begin_inset Formula $del(x)=\varepsilon$
\end_inset

.
 Similarmente se puede ver que 
\begin_inset Formula $del(z)=\varepsilon$
\end_inset

.
 Pero 
\begin_inset Formula $\psi$
\end_inset

 termina con 
\begin_inset Formula $)$
\end_inset

 lo cual nos dice que 
\begin_inset Formula $z=\varepsilon$
\end_inset

.
 Es decir que 
\begin_inset Formula $\varphi=x\psi$
\end_inset

.
 Por el lema anterior tenemos que 
\begin_inset Formula $x\in(\{\lnot\}\cup\{Qv:Q\in\{\forall,\exists\}$
\end_inset

 y 
\begin_inset Formula $v\in Var\})^{\ast}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
Dada 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset


\begin_inset space \space{}
\end_inset

se da una y solo una de las siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\varphi=(t\equiv s),$
\end_inset

 con 
\begin_inset Formula $t,s\in T^{\tau}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\varphi=r(t_{1},...,t_{n}),$
\end_inset

 con 
\begin_inset Formula $r\in\mathcal{R}_{n}$
\end_inset


\shape italic
, 
\shape default

\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $\varphi=(\varphi_{1}\eta\varphi_{2}),$
\end_inset

 con 
\begin_inset Formula $\eta\in\{\wedge,\vee,\rightarrow,\leftrightarrow\},\;\varphi_{1},\varphi_{2}\in F^{\tau}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $\varphi=\lnot\varphi_{1},$
\end_inset

 con 
\begin_inset Formula $\varphi_{1}\in F^{\tau}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
(5)
\end_layout

\end_inset


\begin_inset Formula $\varphi=Qv\varphi_{1},$
\end_inset

 con 
\begin_inset Formula $Q\in\{\forall,\exists\},\;\varphi_{1}\in F^{\tau}$
\end_inset

 y 
\begin_inset Formula $v\in Var.$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Mas aun, en los puntos (1), (2), (3), (4) y (5) tales descomposiciones son
 unicas.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Si una formula 
\begin_inset Formula $\varphi$
\end_inset

 satisface (1), entonces 
\begin_inset Formula $\varphi$
\end_inset

 no puede contener simbolos del alfabeto 
\begin_inset Formula $\{\wedge,\vee,\rightarrow,\leftrightarrow\}$
\end_inset

 lo cual garantiza que 
\begin_inset Formula $\varphi$
\end_inset

 no puede satisfacer (3).
 Ademas 
\begin_inset Formula $\varphi$
\end_inset

 no puede satisfacer (2) o (4) o (5) ya que 
\begin_inset Formula $\varphi$
\end_inset

 comienza con 
\begin_inset Formula $($
\end_inset

.
 En forma analoga se puede terminar de ver que las propiedades (1),...,(5)
 son excluyentes.
\end_layout

\begin_layout Standard
La unicidad en las descomposiciones de (4) y (5) es obvia.
 La de (3) se desprende facilmente del lema anterior y la de los puntos
 (1) y (2) del lema analogo para terminos.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Subformulas
\end_layout

\begin_layout Standard
Una formula 
\begin_inset Formula $\varphi$
\end_inset

 sera llamada una 
\shape italic
subformula 
\shape default
(
\shape italic
propia
\shape default
)
\shape italic

\begin_inset space \space{}
\end_inset


\shape default
de una formula 
\begin_inset Formula $\psi$
\end_inset

, cuando 
\begin_inset Formula $\varphi$
\end_inset

 (sea no igual a 
\begin_inset Formula $\psi$
\end_inset

 y) sea subpalabra de 
\begin_inset Formula $\psi$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Ocurrencias de formulas en formulas
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "ocurrencias"

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Las formulas atomicas no tienen subformulas propias.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi$
\end_inset


\begin_inset space \space{}
\end_inset

ocurre propiamente en 
\begin_inset Formula $(\psi\eta\gamma),$
\end_inset


\begin_inset space \space{}
\end_inset

entonces tal ocurrencia es en 
\begin_inset Formula $\psi$
\end_inset


\begin_inset space \space{}
\end_inset

o en 
\begin_inset Formula $\gamma.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi$
\end_inset


\begin_inset space \space{}
\end_inset

ocurre propiamente en 
\begin_inset Formula $\lnot\psi$
\end_inset

,
\begin_inset space \space{}
\end_inset

entonces tal ocurrencia es en 
\begin_inset Formula $\psi.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(d)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi$
\end_inset


\begin_inset space \space{}
\end_inset

ocurre propiamente en 
\begin_inset Formula $Qx_{k}\psi,$
\end_inset


\begin_inset space \space{}
\end_inset

entonces tal ocurrencia es en 
\begin_inset Formula $\psi.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(e)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi_{1},\varphi_{2}$
\end_inset


\begin_inset space \space{}
\end_inset

ocurren en 
\begin_inset Formula $\varphi,$
\end_inset


\begin_inset space \space{}
\end_inset

entonces dichas ocurrencias son disjuntas o una contiene a la otra.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(f)
\end_layout

\end_inset

Si 
\begin_inset Formula $\lambda^{\prime}$
\end_inset


\begin_inset space \space{}
\end_inset

es el resultado de reemplazar alguna ocurrencia de 
\begin_inset Formula $\varphi$
\end_inset


\begin_inset space \space{}
\end_inset

en 
\begin_inset Formula $\lambda$
\end_inset


\begin_inset space \space{}
\end_inset

por 
\begin_inset Formula $\psi$
\end_inset

, entonces 
\begin_inset Formula $\lambda^{\prime}\in F^{\tau}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ejercicio.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "VariablesLibres"

\end_inset

Variables libres
\end_layout

\begin_layout Standard
Recordemos que dadas palabras 
\begin_inset Formula $\alpha,\beta\in\Sigma^{\ast}$
\end_inset

, con 
\begin_inset Formula $\left\vert \alpha\right\vert ,\left\vert \beta\right\vert \geq1$
\end_inset

, y un natural 
\begin_inset Formula $i\in\{1,...,\left\vert \beta\right\vert \}$
\end_inset

, se dice que 
\begin_inset Formula $\alpha$
\end_inset

 
\shape italic
ocurre a partir de 
\shape default

\begin_inset Formula $i$
\end_inset

 
\shape italic
en 
\shape default

\begin_inset Formula $\beta$
\end_inset

 cuando se de que existan palabras 
\begin_inset Formula $\delta,\gamma$
\end_inset

 tales que 
\begin_inset Formula $\beta=\delta\alpha\gamma$
\end_inset

 y 
\begin_inset Formula $\left\vert \delta\right\vert =i-1$
\end_inset

.
 Intuitivamente hablando 
\begin_inset Formula $\alpha$
\end_inset

 ocurre a partir de 
\begin_inset Formula $i$
\end_inset

 en 
\begin_inset Formula $\beta$
\end_inset

 cuando se de que si comensamos a leer desde el lugar 
\begin_inset Formula $i$
\end_inset

-esimo de 
\begin_inset Formula $\beta$
\end_inset

, en adelante, entonces leeremos la palabra 
\begin_inset Formula $\alpha$
\end_inset

 completa y luego posiblemente seguiran otros simbolos.
\end_layout

\begin_layout Standard
Definamos recursivamente la relacion 
\begin_inset Formula $"v\mathit{\ ocurre\ libremente\ en\ }\varphi\mathit{\ a\ partir\ de\ }i"$
\end_inset

, donde 
\begin_inset Formula $v\in Var$
\end_inset

, 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

 y 
\begin_inset Formula $i\in\{1,...,\left\vert \varphi\right\vert \}$
\end_inset

, de la siguiente manera:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi$
\end_inset

 es atomica, entonces 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

 sii 
\begin_inset Formula $v$
\end_inset

 ocurre en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\eta\varphi_{2})$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

 sii se da alguna de las siguientes
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi_{1}$
\end_inset

 a partir de 
\begin_inset Formula $i-1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi_{2}$
\end_inset

 a partir de 
\begin_inset Formula $i-\left\vert (\varphi_{1}\eta\right\vert $
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\lnot\varphi_{1}$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

 sii 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi_{1}$
\end_inset

 a partir de 
\begin_inset Formula $i-1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=Qw\varphi_{1}$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

 sii 
\begin_inset Formula $v\neq w$
\end_inset

 y 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi_{1}$
\end_inset

 a partir de 
\begin_inset Formula $i-\left\vert Qw\right\vert $
\end_inset

 
\end_layout

\begin_layout Standard
Dados 
\begin_inset Formula $v\in Var$
\end_inset

, 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

 y 
\begin_inset Formula $i\in\{1,...,\left\vert \varphi\right\vert \}$
\end_inset

, diremos que 
\begin_inset Formula $"v$
\end_inset

 
\shape italic
ocurre acotadamente en
\shape default
 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
a partir de
\shape default
 
\begin_inset Formula $i"$
\end_inset

 cuando 
\begin_inset Formula $v$
\end_inset

 ocurre en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $v$
\end_inset

 no ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Algunos ejemplos:
\end_layout

\begin_layout Enumerate
Sea 
\begin_inset Formula $\tau=(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},a)$
\end_inset

, con 
\begin_inset Formula $a$
\end_inset

 dado por 
\begin_inset Formula $a(\mathrm{MAS})=4$
\end_inset

, 
\begin_inset Formula $a(\mathrm{P})=1$
\end_inset

 y 
\begin_inset Formula $a(\mathrm{Her})=3$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathsf{X}\mathbf{9}$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\mathrm{Her}(\mathrm{doli},\mathrm{doli},\mathsf{X}\mathbf{9})$
\end_inset

 a partir de 
\begin_inset Formula $15$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathsf{X}\mathbf{9}$
\end_inset

 ocurre acotadamente en 
\begin_inset Formula $\exists\mathsf{X}\mathbf{9}\mathrm{Her}(\mathrm{doli},\mathrm{doli},\mathsf{X}\mathbf{9})$
\end_inset

 a partir de 
\begin_inset Formula $2$
\end_inset

 y de 
\begin_inset Formula $18$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathsf{X}\mathbf{2}$
\end_inset

 ocurre libremente en 
\begin_inset Formula $(\exists\mathsf{X}\mathbf{2}\mathrm{Her}(\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{7},\mathrm{uno})\rightarrow\mathrm{Her}(\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{7},\mathrm{uno}))$
\end_inset

 a partir de 
\begin_inset Formula $16$
\end_inset

 y acotadamente a partir de 
\begin_inset Formula $3$
\end_inset

 y 
\begin_inset Formula $7$
\end_inset

.
\end_layout

\begin_layout Enumerate
Sea 
\begin_inset Formula $\varphi=((\mathsf{X}\mathbf{1}\equiv\mathsf{X}\mathbf{2})\wedge\exists\mathsf{X}\mathbf{2}\mathrm{Her}(\mathrm{P}(\mathrm{doli}),\mathrm{doli},\mathsf{X}\mathbf{2}))$
\end_inset

.
 La variable 
\begin_inset Formula $\mathsf{X}\mathbf{2}$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $6$
\end_inset

 y ocurre acotadamente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $11$
\end_inset

 y de 
\begin_inset Formula $30$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dada una formula 
\begin_inset Formula $\varphi$
\end_inset

, sea
\begin_inset Formula 
\[
Li(\varphi)=\{v\in Var:\text{hay un }i\text{ tal que }v\text{ ocurre libremente en }\varphi\text{ a partir de }i\}\text{.}
\]

\end_inset

Los elementos de 
\begin_inset Formula $Li(\varphi)$
\end_inset

 seran llamados 
\shape italic
variables libres de 
\shape default

\begin_inset Formula $\varphi$
\end_inset

.
 Por ejemplo, si 
\begin_inset Formula $\varphi$
\end_inset

 es la formula
\begin_inset Formula 
\[
(\exists\mathsf{X}\mathbf{7}(\mathsf{X}\mathbf{7}\equiv\mathsf{X}\mathbf{6})\rightarrow((\mathsf{X}\mathbf{1}\equiv\mathsf{X}\mathbf{2})\wedge\exists\mathsf{X}\mathbf{2}\mathrm{Her}(\mathrm{doli},\mathrm{doli},\mathsf{X}\mathbf{2})))
\]

\end_inset

tenemos que 
\begin_inset Formula $Li(\varphi)=\{\mathsf{X}\mathbf{1},\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{6}\}$
\end_inset

 (justifique).
 Tambien si
\begin_inset Formula 
\[
\varphi=(\exists\mathsf{X}\mathbf{2}\mathrm{Her}(\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{7},\mathrm{uno})\rightarrow\mathrm{Her}(\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{7},\mathrm{uno}))
\]

\end_inset

entonces 
\begin_inset Formula $Li(\varphi)=\{\mathsf{X}\mathbf{2},\mathsf{X}\mathbf{7}\}$
\end_inset

.
\end_layout

\begin_layout Standard
Una 
\shape italic
sentencia 
\shape default
sera una formula 
\begin_inset Formula $\varphi$
\end_inset

 tal que 
\begin_inset Formula $Li(\varphi)=\emptyset$
\end_inset

.
 Usaremos 
\begin_inset Formula $S^{\tau}$
\end_inset

 para denotar el conjunto de las sentencias de tipo 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $Li((t\equiv s))=\{v\in Var:v$
\end_inset

 ocurre en 
\begin_inset Formula $t$
\end_inset

 o 
\begin_inset Formula $v$
\end_inset

 ocurre en 
\begin_inset Formula $s\}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $Li(r(t_{1},...,t_{n}))=\{v\in Var:v$
\end_inset

 ocurre en algun 
\begin_inset Formula $t_{i}\}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset


\begin_inset Formula $Li(\lnot\varphi)=Li(\varphi)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(d)
\end_layout

\end_inset


\begin_inset Formula $Li((\varphi\eta\psi))=Li(\varphi)\cup Li(\psi).$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(e)
\end_layout

\end_inset


\begin_inset Formula $Li(Qx_{j}\varphi)=Li(\varphi)-\{x_{j}\}.$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) y (b) son triviales de las definiciones y dejadas al lector
\end_layout

\begin_layout Standard
(d) Supongamos 
\begin_inset Formula $v\in Li((\varphi\eta\psi))$
\end_inset

, entonces hay un 
\begin_inset Formula $i$
\end_inset

 tal que 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $(\varphi\eta\psi)$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

.
 Por definicion tenemos que ya sea 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i-1$
\end_inset

 o 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\psi$
\end_inset

 a partir de 
\begin_inset Formula $i-\left\vert (\varphi\eta\right\vert $
\end_inset

, con lo cual 
\begin_inset Formula $v\in Li(\varphi)\cup Li(\psi)$
\end_inset


\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $v\in Li(\varphi)\cup Li(\psi)$
\end_inset

.
 S.p.d.g.
 supongamos 
\begin_inset Formula $v\in Li(\psi)$
\end_inset

.
 Por definicion tenemos que hay un 
\begin_inset Formula $i$
\end_inset

 tal que 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\psi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

.
 Pero notese que esto nos dice por definicion que 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $(\varphi\eta\psi)$
\end_inset

 a partir de 
\begin_inset Formula $i+\left\vert (\varphi\eta\right\vert $
\end_inset

 con lo cual 
\begin_inset Formula $v\in Li((\varphi\eta\psi))$
\end_inset

.
\end_layout

\begin_layout Standard
(c) es similar a (d)
\end_layout

\begin_layout Standard
(e) Supongamos 
\begin_inset Formula $v\in Li(Qx_{j}\varphi)$
\end_inset

, entonces hay un 
\begin_inset Formula $i$
\end_inset

 tal que 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $Qx_{j}\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

.
 Por definicion tenemos que 
\begin_inset Formula $v\neq x_{j}$
\end_inset

 y 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i-\left\vert Qx_{j}\right\vert $
\end_inset

, con lo cual 
\begin_inset Formula $v\in Li(\varphi)-\{x_{j}\}$
\end_inset


\end_layout

\begin_layout Standard
Supongamos ahora que 
\begin_inset Formula $v\in Li(\varphi)-\{x_{j}\}$
\end_inset

.
 Por definicion tenemos que hay un 
\begin_inset Formula $i$
\end_inset

 tal que 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

.
 Ya que 
\begin_inset Formula $v\neq x_{j}$
\end_inset

 esto nos dice por definicion que 
\begin_inset Formula $v$
\end_inset

 ocurre libremente en 
\begin_inset Formula $Qx_{j}\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i+\left\vert Qx_{j}\right\vert $
\end_inset

, con lo cual 
\begin_inset Formula $v\in Li(Qx_{j}\varphi)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Modelo matematico de las formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\tau=(\mathcal{C},\mathcal{F},\mathcal{R},a)$
\end_inset

 es un tipo, diremos que 
\begin_inset Formula $\tau^{\prime}$
\end_inset

 es una 
\shape italic
extension de 
\shape default

\begin_inset Formula $\tau$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

por nombres de constante
\shape default
 si 
\begin_inset Formula $\tau^{\prime}$
\end_inset

 es de la forma 
\begin_inset Formula $(\mathcal{C}^{\prime},\mathcal{F},\mathcal{R},a)$
\end_inset

 con 
\begin_inset Formula $\mathcal{C}^{\prime}$
\end_inset

 tal que 
\begin_inset Formula $\mathcal{C}\subseteq\mathcal{C}^{\prime}$
\end_inset

.
\end_layout

\begin_layout Standard
Hemos definido las formulas de tipo 
\begin_inset Formula $\tau$
\end_inset

 con la intencion de dar un modelo matematico del concepto de formula elemental
 de tipo 
\begin_inset Formula $\tau$
\end_inset

 pero deberiamos notar que en las formulas de tipo 
\begin_inset Formula $\tau$
\end_inset

 no hay nombres de elementos fijos por lo cual dichas formulas son un modelo
 matematico solo de ciertas formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

, a saber aquellas en las cuales no hay nombres de elementos fijos.
 Recordemos que estos nombres se usaban en las pruebas elementales para
 denotar elementos fijos (a veces arbitrarios y otras veces que cumplian
 alguna propiedad).
\end_layout

\begin_layout Standard
Cuando un matematico realiza una prueba elemental en una teoria elemental
 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 comienza la misma imaginando una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 de la cual lo unico que sabe es que cumple las sentencias de 
\begin_inset Formula $\Sigma$
\end_inset

.
 Luego cuando fija un elemento y le pone nombre, digamos 
\begin_inset Formula $b$
\end_inset

, podemos pensar que expandio su estructura imaginaria a una de tipo 
\begin_inset Formula $(\mathcal{C}\cup\{b\},\mathcal{F},\mathcal{R},a)$
\end_inset

 y continua su razonamiento.
 Esto lo puede hacer muchas veces a lo largo de una prueba por lo cual su
 estructura imaginaria va cambiando de tipo.
 Esta mecanica de prueba del matematico nos deja ver que es natural modelizar
 las formulas elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

 con formulas de tipo 
\begin_inset Formula $\tau_{1}$
\end_inset

, donde 
\begin_inset Formula $\tau_{1}$
\end_inset

 es alguna extension de 
\begin_inset Formula $\tau$
\end_inset

 por constantes.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Modelo matematico del valor de verdad de una formula
\end_layout

\begin_layout Standard
En esta seccion daremos una definicion matematica que modeliza la idea intuitiva
 de cuando una formula de tipo 
\begin_inset Formula $\tau$
\end_inset

 es verdadera en una estructura dada para una asignacion de elementos a
 las variables libres de dicha formula.
 Esto corresponde al punto (2) del programa de logica enunciado en la Seccion
 
\begin_inset CommandInset ref
LatexCommand ref
reference "programa"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
El valor de un termino en una estructura
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

 una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Una 
\shape italic
asignacion de 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset


\shape default
sera un elemento de 
\begin_inset Formula $A^{\mathbf{N}}=\{$
\end_inset

infinituplas de elementos de 
\begin_inset Formula $A\}$
\end_inset

.
 Si 
\begin_inset Formula $\vec{a}=(a_{1},a_{2},...)$
\end_inset

 es una asignacion, entonces diremos que 
\begin_inset Formula $a_{j}$
\end_inset

 
\shape italic
es el valor que 
\shape default

\begin_inset Formula $\vec{a}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

le asigna a la variable 
\shape default

\begin_inset Formula $x_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
Dada una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de tipo 
\begin_inset Formula $\tau$
\end_inset

, un termino 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

 y una asignacion 
\begin_inset Formula $\vec{a}=(a_{1},a_{2},...)\in A^{\mathbf{N}}$
\end_inset

 definamos recursivamente 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]$
\end_inset

 de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $t=x_{i}\in Var$
\end_inset

, entonces 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=a_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $t=c\in\mathcal{C}$
\end_inset

, entonces 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=i(c)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $t=f(t_{1},...,t_{n})$
\end_inset

, con 
\begin_inset Formula $f\in\mathcal{F}_{n},\;n\geq1$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset

, entonces 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=i(f)(t_{1}^{\mathbf{A}}[\vec{a}],...,t_{n}^{\mathbf{A}}[\vec{a}])$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
El elemento 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]$
\end_inset

 sera llamado el 
\shape italic
valor de 
\shape default

\begin_inset Formula $t$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

en la estructura 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

para la asignacion 
\shape default

\begin_inset Formula $\vec{a}$
\end_inset

.
\end_layout

\begin_layout Standard
Veamos un ejemplo.
 Sea 
\begin_inset Formula $\tau$
\end_inset

 el tipo
\begin_inset Formula 
\[
(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},\{(\mathrm{MAS},4),(\mathrm{P},1),(\mathrm{Her},3)\})
\]

\end_inset

y sea 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

 la estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 con universo 
\begin_inset Formula $A=\mathbf{R}$
\end_inset

 y
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{uno})=9$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{doli})=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{MAS})$
\end_inset

 igual a la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{R}^{4} & \rightarrow & \mathbf{R}\\
(x,y,z,w) & \rightarrow & 2x+4y
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{P})$
\end_inset

 igual a la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{R} & \rightarrow & \mathbf{R}\\
x & \rightarrow & 5^{x}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{Her})=\{(x,y,z)\in\mathbf{R}^{3}:x.y.z=9\}$
\end_inset

 
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\vec{a}=(1,2,3,4,5,...)$
\end_inset

.
 Claramente 
\begin_inset Formula $\vec{a}$
\end_inset

 es una asignacion de 
\begin_inset Formula $\mathbf{A}$
\end_inset

.
 Se tiene que:
\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $t=\mathsf{X}\mathit{55}\mathbf{4}$
\end_inset

, entonces 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=\mathsf{X}\mathit{55}\mathbf{4}^{\mathbf{A}}[\vec{a}]=554$
\end_inset

 (por (1) de la definicion recursiva de 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]$
\end_inset

)
\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $t=\mathrm{uno}$
\end_inset

, entonces 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=\mathrm{uno}^{\mathbf{A}}[\vec{a}]=9$
\end_inset

 (por (2) de la definicion recursiva de 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]$
\end_inset

)
\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $t=\mathrm{P}(\mathsf{X}\mathbf{3})$
\end_inset

, entonces
\begin_inset Formula 
\begin{align*}
t^{\mathbf{A}}[\vec{a}] & =\mathrm{P}(\mathsf{X}\mathbf{3})^{\mathbf{A}}[\vec{a}]\\
 & =i(\mathrm{P})(\mathsf{X}\mathbf{3}^{\mathbf{A}}[\vec{a}])\text{ (por (3) de la definicion de }t^{\mathbf{A}}[\vec{a}]\text{)}\\
 & =i(\mathrm{P})(3)\\
 & =5^{3}=125
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $t=\mathrm{MAS}(\mathsf{X}\mathbf{1},\mathrm{uno},\mathsf{X}\mathbf{3},\mathsf{X}\mathit{55}\mathbf{4})$
\end_inset

, entonces
\begin_inset Formula 
\begin{align*}
t^{\mathbf{A}}[\vec{a}] & =\mathrm{MAS}(\mathsf{X}\mathbf{1},\mathrm{uno},\mathsf{X}\mathbf{3},\mathsf{X}\mathit{55}\mathbf{4})^{\mathbf{A}}[\vec{a}]\\
 & =i(\mathrm{MAS})(\mathsf{X}\mathbf{1}^{\mathbf{A}}[\vec{a}],\mathrm{uno}^{\mathbf{A}}[\vec{a}],\mathsf{X}\mathbf{3}^{\mathbf{A}}[\vec{a}],\mathsf{X}\mathit{55}\mathbf{4}^{\mathbf{A}}[\vec{a}])\\
 & =i(\mathrm{MAS})(1,9,3,554)\\
 & =2.1+4.9=38
\end{align*}

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "independencia del valor"

\end_inset

Sea 
\begin_inset Formula $\mathbf{A}$
\end_inset

 una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 y sea 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

.
 Supongamos que 
\begin_inset Formula $\vec{a},\vec{b}$
\end_inset

 son asignaciones tales que 
\begin_inset Formula $a_{i}=b_{i},$
\end_inset

 cada vez que 
\begin_inset Formula $x_{i}$
\end_inset

 ocurra en 
\begin_inset Formula $t$
\end_inset

.
 Entonces 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=t^{\mathbf{A}}[\vec{b}]$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Teo
\begin_inset Formula $_{k}$
\end_inset

: El lema vale para 
\begin_inset Formula $t\in T_{k}^{\tau}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Teo
\begin_inset Formula $_{0}$
\end_inset

 es facil de probar.
 Veamos Teo
\begin_inset Formula $_{k}\Rightarrow$
\end_inset

Teo
\begin_inset Formula $_{k+1}$
\end_inset

.
 Supongamos 
\begin_inset Formula $t\in T_{k+1}^{\tau}-T_{k}^{\tau}$
\end_inset

 y sean 
\begin_inset Formula $\vec{a},\vec{b}$
\end_inset

 asignaciones tales que 
\begin_inset Formula $a_{i}=b_{i}$
\end_inset

, cada vez que 
\begin_inset Formula $x_{i}$
\end_inset

 ocurra en 
\begin_inset Formula $t$
\end_inset

.
 Notese que 
\begin_inset Formula $t=f(t_{1},...,t_{n})$
\end_inset

, con 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

,
\begin_inset Formula $\;n\geq1$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{n}\in T_{k}^{\tau}$
\end_inset

.
 Notese que para cada 
\begin_inset Formula $j=1,...,n$
\end_inset

, tenemos que 
\begin_inset Formula $a_{i}=b_{i},$
\end_inset

 cada vez que 
\begin_inset Formula $x_{i}$
\end_inset

 ocurra en 
\begin_inset Formula $t_{j}$
\end_inset

, lo cual por Teo
\begin_inset Formula $_{k}$
\end_inset

 nos dice que
\begin_inset Formula 
\[
t_{j}^{\mathbf{A}}[\vec{a}]=t_{j}^{\mathbf{A}}[\vec{b}]\text{, }j=1,...,n
\]

\end_inset

Se tiene entonces que
\begin_inset Formula 
\[
\begin{array}{ccl}
t^{\mathbf{A}}[\vec{a}] & = & i(f)(t_{1}^{\mathbf{A}}[\vec{a}],...,t_{n}^{\mathbf{A}}[\vec{a}])\text{ (por def de }t^{\mathbf{A}}[\vec{a}]\text{)}\\
 & = & i(f)(t_{1}^{\mathbf{A}}[\vec{b}],...,t_{n}^{\mathbf{A}}[\vec{b}])\\
 & = & t^{\mathbf{A}}[\vec{b}]\text{ (por def de }t^{\mathbf{A}}[\vec{b}]\text{)}
\end{array}
\]

\end_inset


\begin_inset space \space{}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
La relacion 
\begin_inset Formula $\models$
\end_inset


\end_layout

\begin_layout Standard
Dada una asignacion 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

 y 
\begin_inset Formula $a\in A$
\end_inset

, con 
\begin_inset Formula $\downarrow_{i}^{a}(\vec{a})$
\end_inset

 denotaremos la asignacion que resulta de reemplazar en 
\begin_inset Formula $\vec{a}$
\end_inset

 el 
\begin_inset Formula $i$
\end_inset

-esimo elemento por 
\begin_inset Formula $a$
\end_inset

.
 A continuacion definiremos recursivamente la relacion 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

, donde 
\begin_inset Formula $\mathbf{A}$
\end_inset

 es una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

, 
\begin_inset Formula $\vec{a}$
\end_inset

 es una asignacion y 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

.
 Escribiremos 
\begin_inset Formula $\mathbf{A}\not\models\varphi[\vec{a}]$
\end_inset

 para expresar que no se da 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(t\equiv s),$
\end_inset

 entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=s^{\mathbf{A}}[\vec{a}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=r(t_{1},...,t_{m})$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $(t_{1}^{\mathbf{A}}[\vec{a}],...,t_{m}^{\mathbf{A}}[\vec{a}])\in i(r)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\wedge\varphi_{2})$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[\vec{a}]$
\end_inset

 y 
\begin_inset Formula $\mathbf{A}\models\varphi_{2}[\vec{a}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\vee\varphi_{2})$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[\vec{a}]$
\end_inset

 o 
\begin_inset Formula $\mathbf{A}\models\varphi_{2}[\vec{a}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\rightarrow\varphi_{2})$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\not\models\varphi_{1}[\vec{a}]$
\end_inset

 o 
\begin_inset Formula $\mathbf{A}\models\varphi_{2}[\vec{a}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\leftrightarrow\varphi_{2})$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si ya sea se dan 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[\vec{a}]$
\end_inset

 y 
\begin_inset Formula $\mathbf{A}\models\varphi_{2}[\vec{a}]$
\end_inset

 o se dan 
\begin_inset Formula $\mathbf{A}\not\models\varphi_{1}[\vec{a}]$
\end_inset

 y 
\begin_inset Formula $\mathbf{A}\not\models\varphi_{2}[\vec{a}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(7)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\lnot\varphi_{1},$
\end_inset

 entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\not\models\varphi_{1}[\vec{a}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(8)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\forall x_{i}\varphi_{1}$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si para cada 
\begin_inset Formula $a\in A$
\end_inset

, se da que 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[\downarrow_{i}^{a}(\vec{a})]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(9)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\exists x_{i}\varphi_{1}$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si hay un 
\begin_inset Formula $a\in A$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[\downarrow_{i}^{a}(\vec{a})]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Cuando se de 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 diremos que 
\shape italic
la estructura 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

satisface 
\shape default

\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
en la asignacion 
\shape default

\begin_inset Formula $\vec{a}$
\end_inset

 y en tal caso diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
es verdadera en 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

para la asignacion 
\shape default

\begin_inset Formula $\vec{a}$
\end_inset

.
 Cuando no se de 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 diremos que 
\shape italic
la estructura 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

no satisface 
\shape default

\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
en la asignacion 
\shape default

\begin_inset Formula $\vec{a}$
\end_inset

 y en tal caso diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
es falsa en 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

para la asignacion 
\shape default

\begin_inset Formula $\vec{a}$
\end_inset

.
 Tambien hablaremos del 
\shape italic
valor de verdad de 
\shape default

\begin_inset Formula $\varphi$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

en 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

para la asignacion 
\shape default

\begin_inset Formula $\vec{a}$
\end_inset

 el cual sera igual a 
\begin_inset Formula $1$
\end_inset

 si se da 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 y 
\begin_inset Formula $0$
\end_inset

 en caso contrario.
\end_layout

\begin_layout Standard
Veamos algunos ejemplos.
 Sea 
\begin_inset Formula $\tau$
\end_inset

 el tipo
\begin_inset Formula 
\[
(\{\mathrm{uno},\mathrm{doli}\},\{\mathrm{MAS},\mathrm{P}\},\{\mathrm{Her}\},\{(\mathrm{MAS},4),(\mathrm{P},1),(\mathrm{Her},3)\})
\]

\end_inset

y sea 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

 la estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 con universo 
\begin_inset Formula $A=\mathbf{R}$
\end_inset

 y
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{uno})=9$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{doli})=0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{MAS})$
\end_inset

 igual a la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{R}^{4} & \rightarrow & \mathbf{R}\\
(x,y,z,w) & \rightarrow & 2x+4y
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{P})$
\end_inset

 igual a la operacion
\begin_inset Formula 
\[
\begin{array}{rcl}
\mathbf{R} & \rightarrow & \mathbf{R}\\
x & \rightarrow & 5^{x}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $i(\mathrm{Her})=\{(x,y,z)\in\mathbf{R}^{3}:x.y.z=9\}$
\end_inset

 
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\vec{a}=(1,2,3,4,5,...)$
\end_inset

.
 Claramente 
\begin_inset Formula $\vec{a}$
\end_inset

 es una asignacion de 
\begin_inset Formula $\mathbf{A}$
\end_inset

.
 Consideremos los siguientes ejemplos:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E1)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\mathrm{MAS}(\mathsf{X}\mathbf{1},\mathrm{uno},\mathsf{X}\mathbf{3},\mathsf{X}\mathit{55}\mathbf{4})\equiv\mathrm{P}(\mathsf{X}\mathbf{3}))$
\end_inset

, entonces ya que
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathrm{MAS}(\mathsf{X}\mathbf{1},\mathrm{uno},\mathsf{X}\mathbf{3},\mathsf{X}\mathit{55}\mathbf{4})^{\mathbf{A}}[\vec{a}]=38$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathrm{P}(\mathsf{X}\mathbf{3})^{\mathbf{A}}[\vec{a}]=125$
\end_inset

 
\end_layout

\begin_layout Standard
tenemos que (1) de la definicion nos dice que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $38=125$
\end_inset

 por lo cual se saca que 
\begin_inset Formula $\mathbf{A}\not\models\varphi[\vec{a}]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\lnot\mathrm{Her}(\mathrm{P}(\mathrm{P}(\mathsf{X}\mathbf{6})),\mathsf{X}\mathbf{3},\mathrm{doli})$
\end_inset

, entonces ya que
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{P}(\mathrm{P}(\mathsf{X}\mathbf{6}))^{\mathbf{A}}[\vec{a}]=5^{(5^{6})}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathsf{X}\mathbf{3}^{\mathbf{A}}[\vec{a}]=3$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathrm{doli}^{\mathbf{A}}[\vec{a}]=0$
\end_inset

 
\end_layout

\begin_layout Standard
tenemos que (7) de la definicion nos dice que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\not\models\mathrm{Her}(\mathrm{P}(\mathrm{P}(\mathsf{X}\mathbf{6})),\mathsf{X}\mathbf{3},\mathrm{doli})[\vec{a}]$
\end_inset

.
 Pero (2) de la definicion nos dice que 
\begin_inset Formula $\mathbf{A}\models\mathrm{Her}(\mathrm{P}(\mathrm{P}(\mathsf{X}\mathbf{6})),\mathsf{X}\mathbf{3},\mathrm{doli})[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $(5^{(5^{6})},3,0)\in i(\mathrm{Her})$
\end_inset

 ya que no se da que 
\begin_inset Formula $(5^{(5^{6})},3,0)\in i(\mathrm{Her})$
\end_inset

, tenemos que 
\begin_inset Formula $\mathbf{A}\not\models\mathrm{Her}(\mathrm{P}(\mathrm{P}(\mathsf{X}\mathbf{6})),\mathsf{X}\mathbf{3},\mathrm{doli})[\vec{a}]$
\end_inset

 lo cual nos dice que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E3)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\exists\mathsf{X}\mathbf{3}\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno})$
\end_inset

, entonces por (9) de la definicion tenemos que
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii hay un 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{A}\models\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno})[\downarrow_{3}^{r}(\vec{a})]$
\end_inset

 
\end_layout

\begin_layout Standard
es decir que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii hay un 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{A}\models\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno})[(1,2,r,4,5,6,...)]$
\end_inset

 
\end_layout

\begin_layout Standard
Pero (2) de la definicion nos dice que cualquiera sea 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 se tiene que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno})[(1,2,r,4,5,6,...)]$
\end_inset

 sii 
\begin_inset Formula $(6,r,9)\in i(\mathrm{Her})$
\end_inset

 
\end_layout

\begin_layout Standard
O sea que obtenemos finalmente que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii hay un 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 tal que 
\begin_inset Formula $6.r.9=9$
\end_inset

 
\end_layout

\begin_layout Standard
Lo cual claramente implica que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 ya que podemos tomar 
\begin_inset Formula $r=1/6$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(E4)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\forall\mathsf{X}\mathbf{3(}(\mathsf{X}\mathbf{4}\equiv\mathsf{X}\mathbf{3})\rightarrow\exists\mathsf{X}\mathbf{6}\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno}))$
\end_inset

, entonces por (8) de la definicion tenemos que
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii para cada 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 se da que
\begin_inset Formula 
\[
\mathbf{A}\models\mathbf{(}(\mathsf{X}\mathbf{4}\equiv\mathsf{X}\mathbf{3})\rightarrow\exists\mathsf{X}\mathbf{6}\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno}))[\downarrow_{3}^{r}(\vec{a})]
\]

\end_inset


\end_layout

\begin_layout Standard
es decir que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii para cada 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 se da que
\begin_inset Formula 
\[
\mathbf{A}\models\mathbf{(}(\mathsf{X}\mathbf{4}\equiv\mathsf{X}\mathbf{3})\rightarrow\exists\mathsf{X}\mathbf{6}\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno}))[(1,2,r,4,5,6,...)]
\]

\end_inset


\end_layout

\begin_layout Standard
Pero entonces (5) de la definicion nos dice que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii para cada 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 se da que
\begin_inset Formula 
\[
\mathbf{A}\not\models(\mathsf{X}\mathbf{4}\equiv\mathsf{X}\mathbf{3})[(1,2,r,4,5,6,...)]\text{ o }\mathbf{A}\models\exists\mathsf{X}\mathbf{6}\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno}))[(1,2,r,4,5,6,...)]
\]

\end_inset

O sea que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii para cada 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 se da que
\begin_inset Formula 
\[
r\neq4\text{ o }\mathbf{A}\models\exists\mathsf{X}\mathbf{6}\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno}))[(1,2,r,4,5,6,...)]
\]

\end_inset

Es decir que debemos ver cuando se da que 
\begin_inset Formula $\mathbf{A}\models\exists\mathsf{X}\mathbf{6}\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno}))[(1,2,r,4,5,6,...)]$
\end_inset

.
 Por (9) y (2) de la definicion tenemos que cualquiera sea el 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 se da que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\exists\mathsf{X}\mathbf{6}\mathrm{Her}(\mathsf{X}\mathbf{6},\mathsf{X}\mathbf{3},\mathrm{uno}))[(1,2,r,4,5,6,...)]$
\end_inset

 sii hay un 
\begin_inset Formula $s\in\mathbf{R}$
\end_inset

 tal que 
\begin_inset Formula $s.r.9=9$
\end_inset

.
 
\end_layout

\begin_layout Standard
Esto nos dice finalmente que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii para cada 
\begin_inset Formula $r\in\mathbf{R}$
\end_inset

 se da que
\begin_inset Formula 
\[
r\neq4\text{ o hay un }s\in\mathbf{R}\text{ tal que }s.r.9=9
\]

\end_inset


\end_layout

\begin_layout Standard
Pensando un poco esto nos dice que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 (separar los casos 
\begin_inset Formula $r=4$
\end_inset

 y 
\begin_inset Formula $r\neq4$
\end_inset

) 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "independencia1"

\end_inset

Supongamos que 
\begin_inset Formula $\vec{a},\vec{b}$
\end_inset

 son asignaciones tales que si 
\begin_inset Formula $x_{i}\in Li(\varphi),$
\end_inset

 entonces 
\begin_inset Formula $a_{i}=b_{i}.$
\end_inset

 Entonces 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{b}]$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Probaremos por induccion en 
\begin_inset Formula $k$
\end_inset

 que el lema vale para cada 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

.
 El caso 
\begin_inset Formula $k=0$
\end_inset

 se desprende del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia del valor"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Veamos que Teo
\begin_inset Formula $_{k}$
\end_inset

 implica Teo
\begin_inset Formula $_{k+1}.$
\end_inset

 Sea 
\begin_inset Formula $\varphi\in F_{k+1}^{\tau}-F_{k}^{\tau}.$
\end_inset

 Hay varios casos:
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=(\varphi_{1}\wedge\varphi_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Ya que 
\begin_inset Formula $Li(\varphi_{i})\subseteq Li(\varphi)$
\end_inset

, 
\begin_inset Formula $i=1,2$
\end_inset

, Teo
\begin_inset Formula $_{k}$
\end_inset

 nos dice que 
\begin_inset Formula $\mathbf{A}\models\varphi_{i}[\vec{a}]$
\end_inset

 sii 
\begin_inset Formula $\mathbf{A}\models\varphi_{i}[\vec{b}]$
\end_inset

, para 
\begin_inset Formula $i=1,2$
\end_inset

.
 Se tiene entonces que
\begin_inset Formula 
\[
\begin{array}{l}
\mathbf{A}\models\varphi[\vec{a}]\\
\ \ \Updownarrow\text{ (por (3) en la def de }\mathbf{A}\models\varphi[\vec{a}]\text{)}\\
\mathbf{A}\models\varphi_{1}[\vec{a}]\text{ y }\mathbf{A}\models\varphi_{2}[\vec{a}]\\
\ \ \Updownarrow\text{ (por Teo}_{k}\text{)}\\
\mathbf{A}\models\varphi_{1}[\vec{b}]\text{ y }\mathbf{A}\models\varphi_{2}[\vec{b}]\\
\ \ \Updownarrow\text{(por (3) en la def de }\mathbf{A}\models\varphi[\vec{a}]\text{)}\\
\mathbf{A}\models\varphi[\vec{b}]
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=(\varphi_{1}\vee\varphi_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Es completamente similar al anterior.
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=(\varphi_{1}\rightarrow\varphi_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Es completamente similar al anterior.
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=(\varphi_{1}\leftrightarrow\varphi_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Es completamente similar al anterior.
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=\lnot\varphi_{1}.$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Es completamente similar al anterior.
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=\forall x_{j}\varphi_{1}.$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Supongamos 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

.
 Entonces por (8) en la def de 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 se tiene que 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[\downarrow_{j}^{a}(\vec{a})]$
\end_inset

, para todo 
\begin_inset Formula $a\in A$
\end_inset

.
 Notese que 
\begin_inset Formula $\downarrow_{j}^{a}(\vec{a})$
\end_inset

 y 
\begin_inset Formula $\downarrow_{j}^{a}(\vec{b})$
\end_inset

 coinciden en toda 
\begin_inset Formula $x_{i}\in Li(\varphi_{1})$
\end_inset

 ya que 
\begin_inset Formula $Li(\varphi_{1})\subseteq Li(\varphi)\cup\{x_{j}\}$
\end_inset

.
 O sea que por Teo
\begin_inset Formula $_{k}$
\end_inset

 se tiene que 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[\downarrow_{j}^{a}(\vec{b})]$
\end_inset

, para todo 
\begin_inset Formula $a\in A$
\end_inset

, lo cual por (8) en la def de 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 nos dice que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{b}]$
\end_inset

.
 La prueba de que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{b}]$
\end_inset

 implica que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 es similar.
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=\exists x_{j}\varphi_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Es similar al anterior.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Si 
\begin_inset Formula $\varphi$
\end_inset

 es una sentencia, entonces 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 sii 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{b}]$
\end_inset

, cualesquiera sean las asignaciones 
\begin_inset Formula $\vec{a},\vec{b}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
En virtud del corolario anterior tenemos que el valor de verdad de una sentencia
 
\begin_inset Formula $\varphi$
\end_inset

 en una estructura dada 
\begin_inset Formula $\mathbf{A}$
\end_inset

 para una asignacion 
\begin_inset Formula $\vec{a}$
\end_inset

 no depende de 
\begin_inset Formula $\vec{a}$
\end_inset

, es decir este valor es ya sea 
\begin_inset Formula $1$
\end_inset

 para todas las asignaciones o 
\begin_inset Formula $0$
\end_inset

 para todas las asignaciones.
 En el primer caso diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
es verdadera en 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset

 (y escribiremos 
\begin_inset Formula $\mathbf{A}\models\varphi$
\end_inset

) y en el segundo caso diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
es falsa en 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset

 (y escribiremos 
\begin_inset Formula $\mathbf{A}\not\models\varphi$
\end_inset

)
\end_layout

\begin_layout Standard
Una sentencia de tipo 
\begin_inset Formula $\tau$
\end_inset

 sera llamada 
\shape italic
universalmente valida
\shape default
 si es verdadera en cada modelo de tipo 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Subsection
Equivalencia de formulas
\end_layout

\begin_layout Standard
Dadas 
\begin_inset Formula $\varphi,\psi\in F^{\tau}$
\end_inset

 diremos que 
\begin_inset Formula $\varphi$
\end_inset

 y 
\begin_inset Formula $\psi$
\end_inset

 son 
\shape italic
equivalentes
\shape default
 cuando se de la siguiente condicion
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[\vec{a}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\psi[\vec{a}]$
\end_inset

, para cada modelo de tipo 
\begin_inset Formula $\tau$
\end_inset

, 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y cada 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Escribiremos 
\begin_inset Formula $\varphi\thicksim\psi$
\end_inset

 cuando 
\begin_inset Formula $\varphi$
\end_inset

 y 
\begin_inset Formula $\psi$
\end_inset

 sean equivalentes.
 Notese que
\begin_inset Formula 
\[
\{(\varphi,\psi)\in F^{\tau}:\varphi\thicksim\psi\}
\]

\end_inset

es una relacion de equivalencia sobre 
\begin_inset Formula $F^{\tau}$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma

\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Si 
\begin_inset Formula $Li(\phi)\cup Li(\psi)\subseteq\{x_{i_{1}},...,x_{i_{n}}\},$
\end_inset

 entonces 
\begin_inset Formula $\phi\thicksim\psi$
\end_inset

 si y solo si la sentencia 
\begin_inset Formula $\forall x_{i_{1}}...\forall x_{i_{n}}(\phi\leftrightarrow\psi)$
\end_inset

 es universalmente valida.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si 
\begin_inset Formula $\phi_{i}\thicksim\psi_{i},$
\end_inset

 
\begin_inset Formula $i=1,2,$
\end_inset

 entonces 
\begin_inset Formula $\lnot\phi_{1}\thicksim\lnot\psi_{1},$
\end_inset

 
\begin_inset Formula $(\phi_{1}\eta\phi_{2})\thicksim(\psi_{1}\eta\psi_{2})$
\end_inset

 y 
\begin_inset Formula $Qv\phi_{1}\thicksim Qv\psi_{1}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset

Si 
\begin_inset Formula $\phi\thicksim\psi$
\end_inset

 y 
\begin_inset Formula $\alpha^{\prime}$
\end_inset

 es el resultado de reemplazar en una formula 
\begin_inset Formula $\alpha$
\end_inset

 algunas (posiblemente 
\begin_inset Formula $0$
\end_inset

) ocurrencias de 
\begin_inset Formula $\phi$
\end_inset

 por 
\begin_inset Formula $\psi$
\end_inset

, entonces 
\begin_inset Formula $\alpha\thicksim\alpha^{\prime}.$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Tenemos que
\begin_inset Formula 
\[
\begin{array}{l}
\gamma\thicksim\psi\\
\ \ \Updownarrow\text{ (por (6) de la def de}\models\text{)}\\
\mathbf{A}\models(\gamma\leftrightarrow\psi)[\vec{a}]\text{, para todo }\mathbf{A}\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\
\ \ \Updownarrow\\
\mathbf{A}\models(\gamma\leftrightarrow\psi)[\downarrow_{i_{n}}^{a}(\vec{a})]\text{, para todo }\mathbf{A}\text{, }a\in A\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\
\ \ \Updownarrow(\text{por (8) de la def de}\models)\\
\mathbf{A}\models\forall x_{i_{n}}(\gamma\leftrightarrow\psi)[\vec{a}]\text{, para todo }\mathbf{A}\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\
\ \ \Updownarrow\\
\mathbf{A}\models\forall x_{i_{n}}(\gamma\leftrightarrow\psi)[\downarrow_{i_{n-1}}^{a}(\vec{a})]\text{, para todo }\mathbf{A}\text{, }a\in A\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\
\ \ \Updownarrow\text{ (por (8) de la def de}\models\text{)}\\
\mathbf{A}\models\forall x_{i_{n-1}}\forall x_{i_{n}}(\gamma\leftrightarrow\psi)[\vec{a}]\text{, para todo }\mathbf{A}\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\
\ \ \Updownarrow\\
\ \ \ \ \vdots\\
\ \ \Updownarrow\\
\mathbf{A}\models\forall x_{i_{1}}...\forall x_{i_{n}}(\gamma\leftrightarrow\psi)[\vec{a}]\text{, para todo }\mathbf{A}\text{ y toda }\vec{a}\in A^{\mathbf{N}}\\
\ \ \Updownarrow\\
\forall x_{i_{1}}...\forall x_{i_{n}}(\gamma\leftrightarrow\psi)\text{ es universalmente valida}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
(b) Es dejado al lector.
\end_layout

\begin_layout Standard
(c) Por induccion en el 
\begin_inset Formula $k$
\end_inset

 tal que 
\begin_inset Formula $\alpha\in F_{k}^{\tau}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Un poco de semantica
\end_layout

\begin_layout Standard
Dado que las estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 constituyen los 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

mundos posibles
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 donde las formulas de tipo 
\begin_inset Formula $\tau$
\end_inset

 se 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

interpretan
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 se suele llamar semantica al estudio general de las estructuras y su vinculacio
n con el lenguaje.
 Aqui daremos algunas nociones basicas de semantica.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Homomorfismos
\end_layout

\begin_layout Standard
La nocion de homomorfismo estaba restringida a unos pocos casos particulares
 de estructuras estudiadas pero ahora con nuestra definicion general de
 estructura podemos generalizarla en forma natural.
 Antes una notacion muy util.
 Dado un modelo de tipo 
\begin_inset Formula $\tau$
\end_inset

, 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

, para cada 
\begin_inset Formula $s\in\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}$
\end_inset

, usaremos 
\begin_inset Formula $s^{\mathbf{A}}$
\end_inset

 para denotar a 
\begin_inset Formula $i(s)$
\end_inset

.
\end_layout

\begin_layout Standard
Sean 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\mathbf{B}$
\end_inset

 modelos de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Una funcion 
\begin_inset Formula $F:A\rightarrow B$
\end_inset

 sera un 
\shape italic
homomorfismo de 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $\mathbf{B}$
\end_inset

 si se cumplen las siguientes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $F(c^{\mathbf{A}})=c^{\mathbf{B}}$
\end_inset

, para todo 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

,
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $F(f^{\mathbf{A}}(a_{1},...,a_{n}))=f^{\mathbf{B}}(F(a_{1}),...,F(a_{n}))$
\end_inset

, para cada 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $(a_{1},...,a_{n})\in r^{\mathbf{A}}$
\end_inset

 implica 
\begin_inset Formula $(F(a_{1}),...,F(a_{n}))\in r^{\mathbf{B}}$
\end_inset

, para todo 
\begin_inset Formula $r\in\mathcal{R}_{n}$
\end_inset

, 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
Un 
\shape italic
isomorfismo de 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $\mathbf{B}$
\end_inset

 sera un un homomorfismo de 
\begin_inset Formula $\mathbf{A}$
\end_inset

 en 
\begin_inset Formula $\mathbf{B}$
\end_inset

 el cual sea biyectivo y cuya inversa sea un homomorfismo de 
\begin_inset Formula $\mathbf{B}$
\end_inset

 en 
\begin_inset Formula $\mathbf{A}$
\end_inset

.
 Diremos que los modelos 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\mathbf{B}$
\end_inset

 son 
\shape italic
isomorfos
\shape default
 (en simbolos: 
\begin_inset Formula $\mathbf{A}\cong\mathbf{B}$
\end_inset

), cuando haya un isomorfismo 
\begin_inset Formula $F$
\end_inset

 de 
\begin_inset Formula $\mathbf{A}$
\end_inset

 en 
\begin_inset Formula $\mathbf{B}$
\end_inset

.
 Diremos que 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 
\shape italic
es un homomorfismo
\shape default
 para expresar que 
\begin_inset Formula $F$
\end_inset

 es un homomorfismo de 
\begin_inset Formula $\mathbf{A}$
\end_inset

 en 
\begin_inset Formula $\mathbf{B}$
\end_inset

.
 Analogamente diremos que 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 
\shape italic
es un isomorfismo
\shape default
 para expresar que 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo de 
\begin_inset Formula $\mathbf{A}$
\end_inset

 en 
\begin_inset Formula $\mathbf{B}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
Ejercicio:
\series default
 Pruebe que la relacion 
\begin_inset Formula $\cong$
\end_inset

 es reflexiva, transitiva y simetrica.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "F-respeta-term"

\end_inset

Sea 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 un homomorfismo.
 Entonces
\begin_inset Formula 
\[
F(t^{\mathbf{A}}[(a_{1},a_{2},...)]=t^{\mathbf{B}}[(F(a_{1}),F(a_{2}),...)]
\]

\end_inset

para cada 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

, 
\begin_inset Formula $(a_{1},a_{2},...)\in A^{\mathbf{N}}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por induccion.
 Sea
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Teo
\begin_inset Formula $_{k}$
\end_inset

: Si 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 es un homomorfismo, entonces
\begin_inset Formula 
\[
F(t^{\mathbf{A}}[(a_{1},a_{2},...)]=t^{\mathbf{B}}[(F(a_{1}),F(a_{2}),...)]
\]

\end_inset

para cada 
\begin_inset Formula $t\in T_{k}^{\tau}$
\end_inset

, 
\begin_inset Formula $(a_{1},a_{2},...)\in A^{\mathbf{N}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Teo
\begin_inset Formula $_{0}$
\end_inset

 es trivial.
 Veamos que Teo
\begin_inset Formula $_{k}$
\end_inset

 implica Teo
\begin_inset Formula $_{k+1}$
\end_inset

.
 Supongamos que vale Teo
\begin_inset Formula $_{k}$
\end_inset

 y supongamos 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 es un homomorfismo, 
\begin_inset Formula $t\in T_{k+1}^{\tau}-T_{k}^{\tau}$
\end_inset

 y 
\begin_inset Formula $\vec{a}=(a_{1},a_{2},...)\in A^{\mathbf{N}}$
\end_inset

.
 Denotemos 
\begin_inset Formula $(F(a_{1}),F(a_{2}),...)$
\end_inset

 con 
\begin_inset Formula $F(\vec{a})$
\end_inset

.
 Por Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "basic0"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $t=f(t_{1},...,t_{n})$
\end_inset

, con 
\begin_inset Formula $n\geq1$
\end_inset

,
\begin_inset Formula $\;f\in\mathcal{F}_{n}$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{n}\in T_{k}^{\tau}$
\end_inset

.
 Tenemos entonces
\begin_inset Formula 
\[
\begin{array}{ccl}
F(t^{\mathbf{A}}[\vec{a}]) & = & F(f(t_{1},...,t_{n})^{\mathbf{A}}[\vec{a}])\\
 & = & F(f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[\vec{a}],...,t_{n}^{\mathbf{A}}[\vec{a}]))\\
 & = & f^{\mathbf{B}}(F(t_{1}^{\mathbf{A}}[\vec{a}]),...,F(t_{n}^{\mathbf{A}}[\vec{a}]))\\
 & = & f^{\mathbf{B}}(t_{1}^{\mathbf{B}}[F(\vec{a})],...,t_{n}^{\mathbf{B}}[F(\vec{a})]))\\
 & = & f(t_{1},...,t_{n})^{\mathbf{B}}[F(\vec{a})]\\
 & = & t^{\mathbf{B}}[F(\vec{a})]
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos que 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 es un isomorfismo.
 Sea 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
\mathbf{A}\models\varphi[(a_{1},a_{2},...)]\text{ sii }\mathbf{B}\models\varphi[(F(a_{1}),F(a_{2}),...)]
\]

\end_inset

para cada 
\begin_inset Formula $(a_{1},a_{2},...)\in A^{\mathbf{N}}$
\end_inset

.
 En particular 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\mathbf{B}$
\end_inset

 satisfacen las mismas sentencias de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por induccion.
 Sea
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Teo
\begin_inset Formula $_{k}$
\end_inset

: Supongamos que 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 es un isomorfismo.
 Sea 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

.
 Entonces
\begin_inset Formula 
\[
\mathbf{A}\models\varphi[(a_{1},a_{2},...)]\text{ sii }\mathbf{B}\models\varphi[(F(a_{1}),F(a_{2}),...)]
\]

\end_inset

para cada 
\begin_inset Formula $(a_{1},a_{2},...)\in A^{\mathbf{N}}$
\end_inset

 
\end_layout

\begin_layout Standard
Prueba de Teo
\begin_inset Formula $_{0}$
\end_inset

.
 Supongamos que 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 es un isomorfismo, 
\begin_inset Formula $\varphi\in F_{0}^{\tau}$
\end_inset

 y 
\begin_inset Formula $(a_{1},a_{2},...)\in A^{\mathbf{N}}$
\end_inset

.
 Probaremos que
\begin_inset Formula 
\[
\mathbf{A}\models\varphi[(a_{1},a_{2},...)]\text{ sii }\mathbf{B}\models\varphi[(F(a_{1}),F(a_{2}),...)]
\]

\end_inset

Hay dos casos.
 Caso 
\begin_inset Formula $\varphi=r(t_{1},...,t_{n})$
\end_inset

, con 
\begin_inset Formula $n\geq1$
\end_inset

,
\begin_inset Formula $\;r\in\mathcal{R}_{n}$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset

.
 Denotemos con 
\begin_inset Formula $\vec{a}$
\end_inset

 a 
\begin_inset Formula $(a_{1},a_{2},...)$
\end_inset

 y con 
\begin_inset Formula $F(\vec{a})$
\end_inset

 a 
\begin_inset Formula $(F(a_{1}),F(a_{2}),...)$
\end_inset

.
 Tenemos entonces
\begin_inset Formula 
\[
\begin{array}{ccl}
\mathbf{A}\models\varphi[\vec{a}] & \text{sii} & (t_{1}^{\mathbf{A}}[\vec{a}],...,t_{m}^{\mathbf{A}}[\vec{a}])\in r^{\mathbf{A}}\text{ (def de }\models\text{)}\\
 & \text{sii} & (F(t_{1}^{\mathbf{A}}[\vec{a}]),...,F(t_{n}^{\mathbf{A}}[\vec{a}]))\in r^{\mathbf{B}}\text{ (}F\text{ es iso)}\\
 & \text{sii} & (t_{1}^{\mathbf{B}}[F(\vec{a})]),...,t_{n}^{\mathbf{B}}[F(\vec{a})])\in r^{\mathbf{B}}\text{ (Lema \ref{F-respeta-term})}\\
 & \text{sii} & \mathbf{B}\models\varphi[F(\vec{a})]
\end{array}
\]

\end_inset

Dejamos al lector completar la prueba de que Teo
\begin_inset Formula $_{k}$
\end_inset

 implica Teo
\begin_inset Formula $_{k+1}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Algebras
\end_layout

\begin_layout Standard
Un tipo 
\begin_inset Formula $\tau$
\end_inset

 sera llamado 
\shape italic
algebraico
\shape default
 si no contiene nombres de relacion (i.e.
 
\begin_inset Formula $\mathcal{R}=\emptyset$
\end_inset

).
 Un modelo de un tipo algebraico 
\begin_inset Formula $\tau$
\end_inset

 sera llamado una 
\begin_inset Formula $\tau$
\end_inset

-
\shape italic
algebra
\shape default
.
 Ejemplos clasicos de 
\begin_inset Formula $\tau$
\end_inset

-algebras son los grupos (
\begin_inset Formula $\tau=(\{e\},\{.^{2}\},\emptyset,a)$
\end_inset

), los reticulados, los reticulados acotados, las algebras de Boole, etc.
 Muchos de los resultados y definiciones dados en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Seccion estructuras algebraicas ordenadas"
plural "false"
caps "false"
noprefix "false"

\end_inset

 para reticulados terna, reticulados acotados y reticulados complementados
 pueden ahora ser generalizados naturalmente para 
\begin_inset Formula $\tau$
\end_inset

-algebras.
 Desarrollaremos un poco esta linea de 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

algebra general
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 la cual ha tenido un furte impacto en el area de las especificaciones algebraic
as de tipos de datos.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "homobiyectivo"

\end_inset

Supongamos 
\begin_inset Formula $\tau$
\end_inset

 es algebraico.
 Si 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 es un homomorfismo biyectivo, entonces 
\begin_inset Formula $F$
\end_inset

 es un isomorfismo.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Solo falta probar que 
\begin_inset Formula $F^{-1}$
\end_inset

 es un homomorfismo.
 Supongamos que 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

.
 Ya que 
\begin_inset Formula $F(c^{\mathbf{A}})=c^{\mathbf{B}}$
\end_inset

, tenemos que 
\begin_inset Formula $F^{-1}(c^{\mathbf{B}})=c^{\mathbf{A}}$
\end_inset

, por lo cual 
\begin_inset Formula $F^{-1}$
\end_inset

 cumple (1) de la definicion de homomorfismo.
 Supongamos ahora que 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

 y sean 
\begin_inset Formula $b_{1},...,b_{n}\in B$
\end_inset

.
 Sean 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

 tales que 
\begin_inset Formula $F(a_{i})=b_{i}$
\end_inset

, 
\begin_inset Formula $i=1,...,n$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\begin{array}{ccl}
F^{-1}(f^{\mathbf{B}}(b_{1},...,b_{n})) & = & F^{-1}(f^{\mathbf{B}}(F(a_{1}),...,F(a_{n})))\\
 & = & F^{-1}(F(f^{\mathbf{A}}(a_{1},...,a_{n})))\\
 & = & f^{\mathbf{A}}(a_{1},...,a_{n})\\
 & = & f^{\mathbf{A}}(F^{-1}(b_{1}),...,F^{-1}(b_{n}))
\end{array}
\]

\end_inset

por lo cual 
\begin_inset Formula $F^{-1}$
\end_inset

 satisface (2) de la definicion de homomorfismo 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Subalgebras
\end_layout

\begin_layout Standard
Dadas 
\begin_inset Formula $\tau$
\end_inset

-algebras 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\mathbf{B}$
\end_inset

, diremos que 
\begin_inset Formula $\mathbf{A}$
\end_inset

 es una 
\shape italic
subalgebra de
\shape default
 
\begin_inset Formula $\mathbf{B}$
\end_inset

 cuando se den las siguientes condiciones
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $A\subseteq B$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{A}}=c^{\mathbf{B}}$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{A}}=f^{\mathbf{B}}|_{A^{n}}$
\end_inset

, para cada 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $n\geq1$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\mathbf{B}$
\end_inset

 es una 
\begin_inset Formula $\tau$
\end_inset

-algebra, entonces un 
\shape italic
subuniverso de 
\shape default

\begin_inset Formula $\mathbf{B}$
\end_inset

 es un conjunto 
\begin_inset Formula $A$
\end_inset

 el cual cumple las siguientes condiciones:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\emptyset\neq A\subseteq B$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{B}}\in A,$
\end_inset

 para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{B}}(a_{1},...,a_{n})\in A$
\end_inset

, para cada 
\begin_inset Formula $(a_{1},...,a_{n})\in A^{n},$
\end_inset

 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Es importante notar que si bien los conceptos de subalgebra y subuniverso
 estan muy relacionados, se trata de objetos diferentes ya que las subalgebras
 de un algebra dada son estructuras de tipo 
\begin_inset Formula $\tau$
\end_inset

 y por lo tanto son pares ordenados y los subuniversos de un algebra dada
 son ciertos subconjuntos por lo cual no son pares ordenados.
 A continuacion presisaremos la relacion que hay entre estos dos conceptos.
 Notese que dado un subuniverso 
\begin_inset Formula $A$
\end_inset

 de una 
\begin_inset Formula $\tau$
\end_inset

-algebra 
\begin_inset Formula $\mathbf{B}$
\end_inset

 podemos definir en forma natural una 
\begin_inset Formula $\tau$
\end_inset

-algebra 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de la siguiente manera:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Universo de 
\begin_inset Formula $\mathbf{A}=A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{A}}=c^{\mathbf{B}},$
\end_inset

 para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{A}}=f^{\mathbf{B}}|_{A^{n}},$
\end_inset

 para cada 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
Es facil chequear que el algebra 
\begin_inset Formula $\mathbf{A}$
\end_inset

 asi definida es una subalgebra de 
\begin_inset Formula $\mathbf{B}$
\end_inset

.
 Lo anterior nos muestra que los subuniversos de un algebra dada son precisament
e los universos de las distintas subalgebras de dicha algebra.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $\tau$
\end_inset

 es algebraico.
 Si 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 es un homomorfismo, entonces 
\begin_inset Formula $I_{F}$
\end_inset

 es un subuniverso de 
\begin_inset Formula $\mathbf{B}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $A\neq\emptyset,$
\end_inset

 tenemos que 
\begin_inset Formula $I_{F}\neq\emptyset.$
\end_inset

 Es claro que 
\begin_inset Formula $c^{\mathbf{B}}=F(c^{\mathbf{A}})\in I_{F},$
\end_inset

 para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

.
 Sea 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

 y sean 
\begin_inset Formula $b_{1},...,b_{n}\in I_{F}$
\end_inset

 Sean 
\begin_inset Formula $a_{1},...,a_{n}$
\end_inset

 tales que 
\begin_inset Formula $F(a_{i})=b_{i},$
\end_inset

 
\begin_inset Formula $i=1,...,n$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
f^{\mathbf{B}}(b_{1},...,b_{n})=f^{\mathbf{B}}(F(a_{1}),...,F(a_{n}))=F(f^{\mathbf{A}}(a_{1},...,a_{n}))\in I_{F}
\]

\end_inset

por lo cual 
\begin_inset Formula $I_{F}$
\end_inset

 es cerrada bajo 
\begin_inset Formula $f^{\mathbf{B}}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Congruencias
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\mathbf{A}$
\end_inset

 una 
\begin_inset Formula $\tau$
\end_inset

-algebra.
 Una 
\shape italic
congruencia
\shape default
 
\shape italic
sobre
\shape default
 
\begin_inset Formula $\mathbf{A}$
\end_inset

 es una relacion de equivalencia 
\begin_inset Formula $\theta$
\end_inset

 sobre 
\begin_inset Formula $A$
\end_inset

 la cual cumple que
\begin_inset Formula 
\[
a_{1}\theta b_{1},...,a_{n}\theta b_{n}\text{ implica }f^{\mathbf{A}}(a_{1},...,a_{n})\theta f^{\mathbf{A}}(b_{1},...,b_{n})
\]

\end_inset

cualesquiera sean 
\begin_inset Formula $a_{1},...,a_{n},b_{1},...,b_{n}\in A$
\end_inset

 y
\begin_inset Formula $\;f\in\mathcal{F}_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
Dada una congruencia 
\begin_inset Formula $\theta$
\end_inset

 sobre 
\begin_inset Formula $\mathbf{A}$
\end_inset

 se puede formar una nueva algebra 
\begin_inset Formula $\mathbf{A}/\theta$
\end_inset

 de la siguiente manera:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Universo de 
\begin_inset Formula $\mathbf{A}/\theta=A/\theta=\{a/\theta:a\in A\}=\{$
\end_inset

clases de equivalencia de 
\begin_inset Formula $\theta\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{A}/\theta}(a_{1}/\theta,...,a_{n}/\theta)=f^{\mathbf{A}}(a_{1},...,a_{n})/\theta,$
\end_inset

 para cada 
\begin_inset Formula $f\in\mathcal{F}_{n}.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{A}/\theta}=c^{\mathbf{A}}/\theta,$
\end_inset

 para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula $\mathbf{A}/\theta$
\end_inset

 sera llamada el 
\shape italic
algebra cociente de 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset

 
\shape italic
por
\shape default
 
\begin_inset Formula $\theta$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Supongamos 
\begin_inset Formula $\tau$
\end_inset

 es algebraico.
 Si 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 es un homomorfismo, entonces 
\begin_inset Formula $\ker F$
\end_inset

 es una congruencia sobre 
\begin_inset Formula $\mathbf{A}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

.
 Supongamos que 
\begin_inset Formula $a_{1},...,a_{n},b_{1},...,b_{n}\in A$
\end_inset

 son tales que 
\begin_inset Formula $a_{1}\ker Fb_{1},...,a_{n}\ker Fb_{n}$
\end_inset

.
 Tenemos entonces que
\begin_inset Formula 
\[
\begin{array}{ccl}
F(f^{\mathbf{A}}(a_{1},...,a_{n})) & = & f^{\mathbf{B}}(F(a_{1}),...,F(a_{n}))\\
 & = & f^{\mathbf{B}}(F(b_{1}),...,F(b_{n}))\\
 & = & F(f^{\mathbf{A}}(b_{1},...,b_{n}))
\end{array}
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $f^{\mathbf{A}}(a_{1},...,a_{n})\ker Ff^{\mathbf{A}}(b_{1},...,b_{n})$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Al mapeo
\begin_inset Formula 
\[
\begin{array}{lll}
A & \rightarrow & A/\theta\\
a & \rightarrow & a/\theta
\end{array}
\]

\end_inset

lo llamaremos la 
\shape italic
proyeccion canonica
\shape default
 y lo denotaremos con 
\begin_inset Formula $\pi_{\theta}$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $\pi_{\theta}:\mathbf{A}\rightarrow\mathbf{A}/\theta$
\end_inset

 es un homomorfismo cuyo nucleo es 
\begin_inset Formula $\theta$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\pi_{\theta}(c^{\mathbf{A}})=c^{\mathbf{A}}/\theta=c^{\mathbf{A}/\theta}
\]

\end_inset

Sea 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, con 
\begin_inset Formula $n\geq1$
\end_inset

 y sean 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\begin{array}{ccl}
\pi_{\theta}(f^{\mathbf{A}}(a_{1},...,a_{n})) & = & f^{\mathbf{A}}(a_{1},...,a_{n})/\theta\\
 & = & f^{\mathbf{A}/\theta}(a_{1}/\theta,...,a_{n}/\theta)\\
 & = & f^{\mathbf{A}/\theta}(\pi_{\theta}(a_{1}),...,\pi_{\theta}(a_{n}))
\end{array}
\]

\end_inset

con lo cual 
\begin_inset Formula $\pi_{\theta}$
\end_inset

 es un homomorfismo.
 Es trivial que 
\begin_inset Formula $\ker\pi_{\theta}=\theta$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 
\begin_inset CommandInset label
LatexCommand label
name "v(t,a1,...)/tita"

\end_inset

Para cada 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

, 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}},$
\end_inset

 se tiene que 
\begin_inset Formula $t^{\mathbf{A}/\theta}[(a_{1}/\theta,a_{2}/\theta,...)]=t^{\mathbf{A}}[(a_{1},a_{2},...)]/\theta.$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $\pi_{\theta}$
\end_inset

 es un homomorfismo, se puede aplicar el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "F-respeta-term"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $F:\mathbf{A}\rightarrow\mathbf{B}$
\end_inset

 un homomorfismo sobreyectivo.
 Entonces
\begin_inset Formula 
\[
\begin{array}{lll}
A/\ker F & \rightarrow & B\\
a/\ker F & \rightarrow & F(a)
\end{array}
\]

\end_inset

define sin ambiguedad una funcion 
\begin_inset Formula $\bar{F}$
\end_inset

 la cual es un isomorfismo de 
\begin_inset Formula $\mathbf{A}/\ker F$
\end_inset

 en 
\begin_inset Formula $\mathbf{B}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que la definicion de 
\begin_inset Formula $\bar{F}$
\end_inset

 es inambigua ya que si 
\begin_inset Formula $a/\ker F=a^{\prime}/\ker F$
\end_inset

, entonces 
\begin_inset Formula $F(a)=F(a^{\prime}).$
\end_inset

 Ya que 
\begin_inset Formula $F$
\end_inset

 es sobre, tenemos que 
\begin_inset Formula $\bar{F}$
\end_inset

 lo es.
 Supongamos que 
\begin_inset Formula $\bar{F}(a/\ker F)=\bar{F}(a^{\prime}/\ker F).$
\end_inset

 Claramente entonces tenemos que 
\begin_inset Formula $F(a)=F(a^{\prime})$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $a/\ker F=a^{\prime}/\ker F$
\end_inset

.
 Esto prueba que 
\begin_inset Formula $\bar{F}$
\end_inset

 es inyectiva.
 Para ver que 
\begin_inset Formula $\bar{F}$
\end_inset

 es un isomorfismo, por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "homobiyectivo"
plural "false"
caps "false"
noprefix "false"

\end_inset

, basta con ver que 
\begin_inset Formula $\bar{F}$
\end_inset

 es un homomorfismo.
 Sea 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\bar{F}(c^{\mathbf{A}/\ker F})=\bar{F}(c^{\mathbf{A}}/\ker F)=F(c^{\mathbf{A}})=c^{\mathbf{B}}
\]

\end_inset

Sea 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

.
 Sean 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\begin{array}{ccl}
\bar{F}(f^{\mathbf{A}/\ker F}(a_{1}/\ker F,...,a_{n}/\ker F)) & = & \bar{F}(f^{\mathbf{A}}(a_{1},...,a_{n})/\ker F)\\
 & = & F(f^{\mathbf{A}}(a_{1},...,a_{n}))\\
 & = & f^{\mathbf{B}}(F(a_{1}),...,F(a_{n}))\\
 & = & f^{\mathbf{B}}(\bar{F}(a_{1}/\ker F),...,\bar{F}(a_{n}/\ker F))
\end{array}
\]

\end_inset

con lo cual 
\begin_inset Formula $\bar{F}$
\end_inset

 cunple (2) de la definicion de homomorfismo 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Producto directo de algebras
\end_layout

\begin_layout Standard
Dadas 
\begin_inset Formula $\tau$
\end_inset

-algebras 
\begin_inset Formula $\mathbf{A},\mathbf{B},$
\end_inset

 definamos una nueva 
\begin_inset Formula $\tau$
\end_inset

-algebra 
\begin_inset Formula $\mathbf{A}\times\mathbf{B},$
\end_inset

 de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Universo de 
\begin_inset Formula $\mathbf{A}\times\mathbf{B}=A\times B$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{A}\times\mathbf{B}}=(c^{\mathbf{A}},c^{\mathbf{B}})$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{A}\times\mathbf{B}}((a_{1},b_{1}),...,(a_{n},b_{n}))=(f^{\mathbf{A}}(a_{1},...,a_{n}),f^{\mathbf{B}}(b_{1},...,b_{n}))$
\end_inset

, para cada 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Llamaremos a 
\begin_inset Formula $\mathbf{A}\times\mathbf{B}$
\end_inset

 el 
\shape italic
producto directo
\shape default
 de 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\mathbf{B}.$
\end_inset


\end_layout

\begin_layout Standard
Los mapeos
\begin_inset Formula 
\[
\begin{array}{lll}
\pi_{1}:A\times B & \rightarrow & A\\
\;\;\;\;\;(a,b) & \rightarrow & a
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{lll}
\pi_{2}:A\times B & \rightarrow & B\\
\;\;\;\;\;(a,b) & \rightarrow & b
\end{array}
\]

\end_inset

seran llamados las 
\shape italic
proyecciones canonicas
\shape default
 asociadas al producto 
\begin_inset Formula $A\times B$
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Los mapeos 
\begin_inset Formula $\pi_{1}:\mathbf{A}\times\mathbf{B}\rightarrow\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\pi_{2}:\mathbf{A}\times\mathbf{B}\rightarrow\mathbf{B}$
\end_inset

 son homomorfismos 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Veamos que 
\begin_inset Formula $\pi_{1}$
\end_inset

 es un homomorfismo.
 Primero notese que si 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

, entonces
\begin_inset Formula 
\[
\pi_{1}(c^{\mathbf{A}\times\mathbf{B}})=\pi_{1}((c^{\mathbf{A}},c^{\mathbf{B}}))=c^{\mathbf{A}}
\]

\end_inset

Sea 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, con 
\begin_inset Formula $n\geq1$
\end_inset

 y sean 
\begin_inset Formula $(a_{1},b_{1}),...,(a_{n},b_{n})\in A\times B$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\begin{array}{ccl}
\pi_{1}(f^{\mathbf{A}\times\mathbf{B}}((a_{1},b_{1}),...,(a_{n},b_{n})) & = & \pi_{1}((f^{\mathbf{A}}(a_{1},...,a_{n}),f^{\mathbf{B}}(b_{1},...,b_{n}))\\
 & = & f^{\mathbf{A}}(a_{1},...,a_{n})\\
 & = & f^{\mathbf{A}}(\pi_{1}(a_{1},b_{1}),...,\pi_{1}(a_{n},b_{n}))
\end{array}
\]

\end_inset

con lo cual hemos probado que 
\begin_inset Formula $\pi_{1}$
\end_inset

 cumple (2) de la definicion de homomorfismo 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Para cada 
\begin_inset Formula $t\in T^{\tau},$
\end_inset

 
\begin_inset Formula $((a_{1},b_{1}),(a_{2},b_{2}),...)\in(A\times B)^{\mathbf{N}},$
\end_inset

 se tiene que 
\begin_inset Formula $t^{\mathbf{A}\times\mathbf{B}}[((a_{1},b_{1}),(a_{2},b_{2}),...)]=(t^{\mathbf{A}}[(a_{1},a_{2},...)],t^{\mathbf{B}}[(b_{1},b_{2},...)])$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Dos teoremas de reemplazo
\end_layout

\begin_layout Standard
Probaremos dos teoremas muy importantes que en algun sentido nos dicen que
 el reemplazo sintactico se lleva bien con la semantica.
 Antes nos dedicaremos a desarrollar la notacion declaratoria la cual hace
 mas intuitivos los resultados y ademas permite manejar las cosas con mas
 naturalidad y practicidad.
\end_layout

\begin_layout Subsection
Notacion declaratoria para terminos
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $t$
\end_inset

 es un termino de tipo 
\begin_inset Formula $\tau$
\end_inset

, entonces escribiremos 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})$
\end_inset

 para declarar que 
\begin_inset Formula $v_{1},...,v_{n}$
\end_inset

 son variables distintas (con 
\begin_inset Formula $n\geq1$
\end_inset

) y tales que toda variable que ocurre en 
\begin_inset Formula $t$
\end_inset

 pertenece a 
\begin_inset Formula $\{v_{1},...,v_{n}\}$
\end_inset

 (no necesariamente toda 
\begin_inset Formula $v_{j}$
\end_inset

 debe ocurrir en 
\begin_inset Formula $t$
\end_inset

).
\end_layout

\begin_layout Standard
El uso de declaraciones de la forma 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})$
\end_inset

 sera muy util cuando se lo convina con ciertas convenciones notacionales
 que describiremos a continuacion.
\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Convencion Notacional 1:
\end_layout

\end_inset

 Cuando hayamos hecho la declaracion 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})$
\end_inset

, si 
\begin_inset Formula $P_{1},...,P_{n}$
\end_inset

 son palabras cualesquiera (no necesariamente terminos), entonces 
\begin_inset Formula $t(P_{1},...,P_{n})$
\end_inset

 denotara la palabra que resulta de reemplazar (simultaneamente) cada ocurrencia
 de 
\begin_inset Formula $v_{1}$
\end_inset

 en 
\begin_inset Formula $t$
\end_inset

, por 
\begin_inset Formula $P_{1}$
\end_inset

, cada ocurrencia de 
\begin_inset Formula $v_{2}$
\end_inset

 en 
\begin_inset Formula $t$
\end_inset

, por 
\begin_inset Formula $P_{2}$
\end_inset

, etc.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que cuando las palabras 
\begin_inset Formula $P_{i}^{\prime}s$
\end_inset

 son terminos, 
\begin_inset Formula $t(P_{1},...,P_{n})$
\end_inset

 es un termino (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "reemp-ter-en-ter"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Ademas notese que en esta convencion notacional, el orden de las variables
 
\begin_inset Formula $v_{1},...,v_{n}$
\end_inset

 es clave.
 Por ejemplo si 
\begin_inset Formula $\tau=(\emptyset,\{\mathrm{FU}\},\emptyset,\{(\mathrm{FU},2)\})$
\end_inset

 y 
\begin_inset Formula $t=\mathrm{FU}(\mathrm{FU}(x_{2},x_{16}),x_{3})$
\end_inset

 y declaramos 
\begin_inset Formula $t=_{d}t(x_{3},x_{2},x_{16})$
\end_inset

, entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si declaramos 
\begin_inset Formula $t=_{d}t(x_{3},x_{2},x_{16})$
\end_inset

, entonces 
\begin_inset Formula $t(\#\#,\blacktriangle\#\blacktriangle,@@)$
\end_inset

 denotara la palabra 
\begin_inset Formula $\mathrm{FU}(\mathrm{FU}(\blacktriangle\#\blacktriangle,@@),\#\#)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si declaramos 
\begin_inset Formula $t=_{d}t(x_{16},x_{3},x_{2})$
\end_inset

, entonces 
\begin_inset Formula $t(\#\#,\blacktriangle\#\blacktriangle,@@)$
\end_inset

 denotara la palabra 
\begin_inset Formula $\mathrm{FU}(\mathrm{FU}(@@,\#\#),\blacktriangle\#\blacktriangle)$
\end_inset

 
\end_layout

\begin_layout Standard
Tambien podriamos haber declarado 
\begin_inset Formula $t=_{d}t(x_{3},x_{200},x_{2},x_{16},x_{100})$
\end_inset

 y en tal caso 
\begin_inset Formula $t(\#\#,!!!!,\blacktriangle\#\blacktriangle,@@,!!)$
\end_inset

 denotara la palabra 
\begin_inset Formula $\mathrm{FU}(\mathrm{FU}(\blacktriangle\#\blacktriangle,@@),\#\#)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Convencion Notacional 2:
\end_layout

\end_inset

 Cuando hayamos declarado 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})$
\end_inset

, si 
\begin_inset Formula $\mathbf{A}$
\end_inset

 es un modelo de tipo 
\begin_inset Formula $\tau$
\end_inset

 y 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

, entonces con 
\begin_inset Formula $t^{\mathbf{A}}[a_{1}...,a_{n}]$
\end_inset

 denotaremos al elemento 
\begin_inset Formula $t^{\mathbf{A}}[\vec{b}]$
\end_inset

, donde 
\begin_inset Formula $\vec{b}$
\end_inset

 es una asignacion tal que a cada 
\begin_inset Formula $v_{i}$
\end_inset

 le asigna el valor 
\begin_inset Formula $a_{i}$
\end_inset

.
 (Notese que esta notacion es inhambigua gracias al Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia del valor"
plural "false"
caps "false"
noprefix "false"

\end_inset

.) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Nuevamente cabe destacar que en esta convencion notacional, el orden de
 las variables 
\begin_inset Formula $v_{1},...,v_{n}$
\end_inset

 es clave.
 Por ejemplo si 
\begin_inset Formula $\tau$
\end_inset

 y 
\begin_inset Formula $t$
\end_inset

 son los dados en el ejemplo anterior y 
\begin_inset Formula $\mathbf{A}$
\end_inset

 es dado por 
\begin_inset Formula $A=\{1,2,3\}$
\end_inset

 y 
\begin_inset Formula $\mathrm{FU}^{\mathbf{A}}(i,j)=j$
\end_inset

, para cada 
\begin_inset Formula $i,j\in A$
\end_inset

, tenemos que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si declaramos 
\begin_inset Formula $t=_{d}t(x_{3},x_{2},x_{16})$
\end_inset

, entonces 
\begin_inset Formula $t^{\mathbf{A}}[2,1,3]=\mathrm{FU}(\mathrm{FU}(x_{2},x_{16}),x_{3})^{\mathbf{A}}[2,1,3]=\mathrm{FU^{\mathbf{A}}}(\mathrm{FU^{\mathbf{A}}}(1,3),2)=2$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si declaramos 
\begin_inset Formula $t=_{d}t(x_{16},x_{3},x_{2})$
\end_inset

, entonces 
\begin_inset Formula $t^{\mathbf{A}}[2,1,3]=\mathrm{FU}(\mathrm{FU}(x_{2},x_{16}),x_{3})^{\mathbf{A}}[2,1,3]=\mathrm{FU^{\mathbf{A}}}(\mathrm{FU^{\mathbf{A}}}(3,2),1)=1$
\end_inset


\end_layout

\begin_layout Standard
Tambien podriamos haber declarado 
\begin_inset Formula $t=_{d}t(x_{3},x_{200},x_{2},x_{16},x_{100})$
\end_inset

 y en tal caso 
\begin_inset Formula $t^{\mathbf{A}}[2,10,1,3,1000]=2$
\end_inset

.
\end_layout

\begin_layout Standard
Para establecer nuestra Convencion Notacional 3, debemos antes enunciar
 un lema de 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

lectura de terminos una ves declarados
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 el cual el lector no tendra inconvenientes en probar.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Lectura unica de terminos declarados
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "si t = t(v1,...,vn) ..."

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo cualquiera y supongamos 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

.
 Si 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})$
\end_inset

, entonces se da alguna de las siguientes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $t=c,$
\end_inset

 para algun 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $t=v_{j},$
\end_inset

 para algun 
\begin_inset Formula $j$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $t=f(t_{1},...,t_{m})$
\end_inset

, con 
\begin_inset Formula $f\in\mathcal{F}_{m}$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{m}\in T^{\tau}$
\end_inset

 tales que las variables que ocurren en cada uno de ellos estan en 
\begin_inset Formula $\{v_{1},...,v_{n}\}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Rutina 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Convencion Notacional 3:
\end_layout

\end_inset

 Cuando hayamos declarado 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})$
\end_inset

 y se el caso (3) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "si t = t(v1,...,vn) ..."
plural "false"
caps "false"
noprefix "false"

\end_inset

 supondremos tacitamente que tambien hemos hecho las declaraciones 
\begin_inset Formula $t_{1}=_{d}t_{1}(v_{1},...,v_{n}),...,t_{m}=_{d}t_{m}(v_{1},...,v_{n})$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Cabe destacar que esta ultima convencion notacional junto con la Convencion
 Notacional 1, nos dice que cuando se de el caso (3) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "si t = t(v1,...,vn) ..."
plural "false"
caps "false"
noprefix "false"

\end_inset

, si 
\begin_inset Formula $P_{1},...,P_{n}$
\end_inset

 son palabras cualesquiera, entonces
\begin_inset Formula 
\[
t(P_{1},...,P_{n})=f(t_{1}(P_{1},...,P_{n}),...,t_{m}(P_{1},...,P_{n}))
\]

\end_inset

El siguiente lema se basa en la Convencion Notacional 3 y nos permite darle
 caracter recursivo a la notacion 
\begin_inset Formula $t^{\mathbf{A}}[a_{1},....,a_{n}]$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Caracter recursivo de la notacion 
\begin_inset Formula $t^{\mathbf{A}}[a_{1},....,a_{n}]$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo cualquiera y 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

.
 Supongamos 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbf{A}$
\end_inset

 un modelo de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Sean 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

.
 Se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $t=c,$
\end_inset

 entonces 
\begin_inset Formula $t^{\mathbf{A}}[a_{1},....,a_{n}]=c^{\mathbf{A}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $t=v_{j},$
\end_inset

 entonces 
\begin_inset Formula $t^{\mathbf{A}}[a_{1},....,a_{n}]=a_{j}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $t=f(t_{1},...,t_{m})$
\end_inset

, con 
\begin_inset Formula $f\in\mathcal{F}_{m}$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{m}\in T^{\tau}$
\end_inset

, entonces
\begin_inset Formula 
\[
t^{\mathbf{A}}[a_{1},....,a_{n}]=f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[a_{1},....,a_{n}],...,t_{m}^{\mathbf{A}}[a_{1},....,a_{n}])
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) y (2) son triviales.
\end_layout

\begin_layout Standard
(3) Sea 
\begin_inset Formula $\vec{b}$
\end_inset

 una asignacion tal que a cada 
\begin_inset Formula $v_{i}$
\end_inset

 le asigna el valor 
\begin_inset Formula $a_{i}$
\end_inset

.
\begin_inset space \space{}
\end_inset

Tenemos que
\begin_inset Formula 
\begin{align*}
t^{\mathbf{A}}[a_{1},....,a_{n}] & =t^{\mathbf{A}}[\vec{b}]\text{ (por def. de }t^{\mathbf{A}}[a_{1},....,a_{n}]\text{)}\\
 & =f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[\vec{b}],...,t_{m}^{\mathbf{A}}[\vec{b}])\text{ (por def. de }t^{\mathbf{A}}[\vec{b}]\text{)}\\
 & =f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[a_{1},....,a_{n}],...,t_{m}^{\mathbf{A}}[a_{1},....,a_{n}])\text{ (por def. de cada }t_{i}^{\mathbf{A}}[a_{1},....,a_{n}]\text{)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Teorema de reemplazo para terminos
\end_layout

\begin_layout Standard
Ahora si podemos enunciar y probar el primero de nuestros teoremas de reemplazo
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "reemp-term"

\end_inset

Supongamos 
\begin_inset Formula $t=_{d}t(w_{1},...,w_{k}),$
\end_inset

 
\begin_inset Formula $s_{1}=_{d}s_{1}(v_{1},...,v_{n}),...,s_{k}=_{d}s_{k}(v_{1},...,v_{n})$
\end_inset

.
 Todas las variables de 
\begin_inset Formula $t(s_{1},...,s_{k})$
\end_inset

 estan en 
\begin_inset Formula $\{v_{1},...,v_{n}\}$
\end_inset

 y si declaramos 
\begin_inset Formula $t(s_{1},...,s_{k})=_{d}t(s_{1},...,s_{k})(v_{1},...,v_{n})$
\end_inset

, entonces para cada estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $a_{1},....,a_{n}\in A,$
\end_inset

 se tiene que
\begin_inset Formula 
\[
t(s_{1},...,s_{k})^{\mathbf{A}}[a_{1},....,a_{n}]=t^{\mathbf{A}}[s_{1}^{\mathbf{A}}[a_{1},....,a_{n}],...,s_{k}^{\mathbf{A}}[a_{1},....,a_{n}]].
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por induccion en el 
\begin_inset Formula $l$
\end_inset

 tal que 
\begin_inset Formula $t\in T_{l}^{\tau}$
\end_inset

.
 El caso 
\begin_inset Formula $l=0$
\end_inset

 es dejado al lector.
 Supongamos entonces que el teorema vale siempre que 
\begin_inset Formula $t\in T_{l}^{\tau}$
\end_inset

 y veamos que entonces vale cuando 
\begin_inset Formula $t\in T_{l+1}^{\tau}-T_{l}^{\tau}$
\end_inset

.
 Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "si t = t(v1,...,vn) ..."
plural "false"
caps "false"
noprefix "false"

\end_inset

 hay 
\begin_inset Formula $f\in\mathcal{F}_{m}$
\end_inset

 y 
\begin_inset Formula $t_{1},...,t_{m}$
\end_inset

 terminos tales 
\begin_inset Formula $t=f(t_{1},...,t_{m})$
\end_inset

 y las variables que ocurren en cada 
\begin_inset Formula $t_{i}$
\end_inset

 estan en 
\begin_inset Formula $\{w_{1},...,w_{k}\}$
\end_inset

.
 Por la unicidad de la lectura de terminos tenemos que 
\begin_inset Formula $t_{1},...,t_{m}\in T_{l}^{\tau}$
\end_inset

 (por que?).
 Notese que por nuestra Convencion Notacional 3 asumimos ya hechas las declaraci
ones
\begin_inset Formula 
\[
t_{1}=_{d}t_{1}(w_{1},...,w_{k}),...,t_{m}=_{d}t_{m}(w_{1},...,w_{k})
\]

\end_inset

Por HI tenemos que las variables de cada 
\begin_inset Formula $t_{i}(s_{1},...,s_{k})$
\end_inset

 estan en 
\begin_inset Formula $\{v_{1},...,v_{n}\}$
\end_inset

, lo cual nos permite hacer las siguientes declaraciones:
\begin_inset Formula 
\[
t_{i}(s_{1},...,s_{k})=_{d}t_{i}(s_{1},...,s_{k})(v_{1},...,v_{n}),\text{ }i=1,...,m
\]

\end_inset

Por HI tenemos entonces que
\begin_inset Formula 
\[
t_{i}(s_{1},...,s_{k})^{\mathbf{A}}[\vec{a}]=t_{i}^{\mathbf{A}}[s_{1}^{\mathbf{A}}[\vec{a}],...,s_{k}^{\mathbf{A}}[\vec{a}]],\text{ }i=1,...,m
\]

\end_inset

Ya que las variables de cada 
\begin_inset Formula $t_{i}(s_{1},...,s_{k})$
\end_inset

 estan en 
\begin_inset Formula $\{v_{1},...,v_{n}\}$
\end_inset

, tenemos que las variables de 
\begin_inset Formula $t(s_{1},...,s_{k})=f(t_{1}(s_{1},...,s_{k}),...,t_{m}(s_{1},...,s_{k}))$
\end_inset

 estan en 
\begin_inset Formula $\{v_{1},...,v_{n}\}$
\end_inset

.
 Declaremos entonces 
\begin_inset Formula $t(s_{1},...,s_{k})=_{d}t(s_{1},...,s_{k})(v_{1},...,v_{n})$
\end_inset

.
 Solo nos falta probar que
\begin_inset Formula 
\[
t(s_{1},...,s_{k})^{\mathbf{A}}[a_{1},....,a_{n}]=t^{\mathbf{A}}[s_{1}^{\mathbf{A}}[a_{1},....,a_{n}],...,s_{k}^{\mathbf{A}}[a_{1},....,a_{n}]].
\]

\end_inset

lo cual se detalla a continuacion
\begin_inset Formula 
\[
\begin{array}{ccl}
t(s_{1},...,s_{k})^{\mathbf{A}}[\vec{a}] & = & f(t_{1}(s_{1},...,s_{k}),...,t_{m}(s_{1},...,s_{k}))^{\mathbf{A}}[\vec{a}]\\
 & = & f^{\mathbf{A}}(t_{1}(s_{1},...,s_{k})^{\mathbf{A}}[\vec{a}],...,t_{m}(s_{1},...,s_{k})^{\mathbf{A}}[\vec{a}])\\
 & = & f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[s_{1}^{\mathbf{A}}[\vec{a}],...,s_{k}^{\mathbf{A}}[\vec{a}]],...,t_{m}^{\mathbf{A}}[s_{1}^{\mathbf{A}}[\vec{a}],...,s_{k}^{\mathbf{A}}[\vec{a}]])\\
 & = & t^{\mathbf{A}}[s_{1}^{\mathbf{A}}[\vec{a}],...,s_{k}^{\mathbf{A}}[\vec{a}]]
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Notacion declaratoria para formulas
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $\varphi$
\end_inset

 es una formula de tipo 
\begin_inset Formula $\tau$
\end_inset

, entonces escribiremos 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})$
\end_inset

 para declarar que 
\begin_inset Formula $v_{1},...,v_{n}$
\end_inset

 son variables distintas (con 
\begin_inset Formula $n\geq1$
\end_inset

) tales que 
\begin_inset Formula $Li(\varphi)\subseteq\{v_{1},...,v_{n}\}$
\end_inset

.
 Tal como para el caso de terminos, el uso de declaraciones de la forma
 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})$
\end_inset

 sera muy util cuando se convina con ciertas convenciones notacionales que
 describiremos a continuacion.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Convencion Notacional 4:
\end_layout

\end_inset

 Cuando hayamos hecho la declaracion 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})$
\end_inset

, si 
\begin_inset Formula $P_{1},...,P_{n}$
\end_inset

 son palabras cualesquiera, entonces 
\begin_inset Formula $\varphi(P_{1},...,P_{n})$
\end_inset

 denotara la palabra que resulta de reemplazar (simultaneamente) cada ocurrencia
 libre de 
\begin_inset Formula $v_{1}$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

, por 
\begin_inset Formula $P_{1}$
\end_inset

, cada ocurrencia libre de 
\begin_inset Formula $v_{2}$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

, por 
\begin_inset Formula $P_{2}$
\end_inset

, etc.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que cuando las palabras 
\begin_inset Formula $P_{i}^{\prime}s$
\end_inset

 son terminos, 
\begin_inset Formula $\varphi(P_{1},...,P_{n})$
\end_inset

 es una formula.
 Ademas notese que tal como para el caso de terminos, en esta convencion
 notacional, el orden de las variables 
\begin_inset Formula $v_{1},...,v_{n}$
\end_inset

 es clave.
 Es facil dar el ejemplo analogo al dado para terminos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Convencion Notacional 5:
\end_layout

\end_inset

 Cuando hayamos declarado 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})$
\end_inset

, si 
\begin_inset Formula $\mathbf{A}$
\end_inset

 es un modelo de tipo 
\begin_inset Formula $\tau$
\end_inset

 y 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

, entonces 
\begin_inset Formula $\mathbf{A}\models\varphi[a_{1}...,a_{n}]$
\end_inset

 significara que 
\begin_inset Formula $\mathbf{A}\models\varphi[\vec{b}],$
\end_inset

 donde 
\begin_inset Formula $\vec{b}$
\end_inset

 es una asignacion tal que a cada 
\begin_inset Formula $v_{i}$
\end_inset

 le asigna el valor 
\begin_inset Formula $a_{i}$
\end_inset

.
\begin_inset space \space{}
\end_inset

(Notese que esta definicion es inambigua gracias al Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "independencia1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 En gral 
\begin_inset Formula $\mathbf{A}\not\models\varphi[a_{1},....,a_{n}]$
\end_inset

 significara que no sucede 
\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Nuevamente cabe destacar que en esta convencion notacional, el orden de
 las variables 
\begin_inset Formula $v_{1},...,v_{n}$
\end_inset

 es clave y dejamos al lector encontrar un ejemplo donde esto se vea claramente.
 Para establecer nuestra Convencion Notacional 6, debemos antes enunciar
 un 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

lema de lectura unica de formulas declaradas
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 el cual el lector no tendra inconvenientes en probar.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Lectura unica de formulas declaradas
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "si fi = fi(v1,...,vn)"

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo cualquiera y 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

.
 Supongamos 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})$
\end_inset

.
 Entonces se una y solo una de las siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\varphi=(t\equiv s)$
\end_inset

, con 
\begin_inset Formula $t,s\in T^{\tau}$
\end_inset


\shape italic
, unicos y tales que las variables que ocurren en 
\shape default

\begin_inset Formula $t$
\end_inset

 o en 
\begin_inset Formula $s$
\end_inset

 estan todas en 
\begin_inset Formula $\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\varphi=r(t_{1},...,t_{m})$
\end_inset

, con 
\begin_inset Formula $r\in\mathcal{R}_{m}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

y 
\shape default

\begin_inset Formula $t_{1},...,t_{m}\in T^{\tau}$
\end_inset


\shape italic
, unicos y tales que las variables que ocurren en cada 
\shape default

\begin_inset Formula $t_{i}$
\end_inset

 estan todas en 
\begin_inset Formula $\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $\varphi=(\varphi_{1}\wedge\varphi_{2})$
\end_inset

, con 
\begin_inset Formula $\varphi_{1},\varphi_{2}\in F^{\tau}$
\end_inset


\shape italic
, unicas y
\shape default
 tales que 
\begin_inset Formula $Li(\varphi_{1})\cup Li(\varphi_{2})\subseteq\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $\varphi=(\varphi_{1}\vee\varphi_{2})$
\end_inset

, con 
\begin_inset Formula $\varphi_{1},\varphi_{2}\in F^{\tau}$
\end_inset


\shape italic
, unicas y
\shape default
 tales que 
\begin_inset Formula $Li(\varphi_{1})\cup Li(\varphi_{2})\subseteq\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset


\begin_inset Formula $\varphi=(\varphi_{1}\rightarrow\varphi_{2})$
\end_inset

, con 
\begin_inset Formula $\varphi_{1},\varphi_{2}\in F^{\tau}$
\end_inset


\shape italic
, unicas y
\shape default
 tales que 
\begin_inset Formula $Li(\varphi_{1})\cup Li(\varphi_{2})\subseteq\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset


\begin_inset Formula $\varphi=(\varphi_{1}\leftrightarrow\varphi_{2})$
\end_inset

, con 
\begin_inset Formula $\varphi_{1},\varphi_{2}\in F^{\tau}$
\end_inset


\shape italic
, unicas y
\shape default
 tales que 
\begin_inset Formula $Li(\varphi_{1})\cup Li(\varphi_{2})\subseteq\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(7)
\end_layout

\end_inset


\begin_inset Formula $\varphi=\lnot\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $\varphi_{1}\in F^{\tau}$
\end_inset

, unica y tal que 
\begin_inset Formula $Li(\varphi_{1})\subseteq\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(8)
\end_layout

\end_inset


\begin_inset Formula $\varphi=\forall v_{j}\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $v_{j}\in\{v_{1},...,v_{n}\}$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}\in F^{\tau}$
\end_inset

, unicas y tales que 
\begin_inset Formula $Li(\varphi_{1})\subseteq\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(9)
\end_layout

\end_inset


\begin_inset Formula $\varphi=\forall v\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $v\in Var-\{v_{1},...,v_{n}\}$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}\in F^{\tau}$
\end_inset

, unicas y tales que 
\begin_inset Formula $Li(\varphi_{1})\subseteq\{v_{1},...,v_{n},v\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(10)
\end_layout

\end_inset


\begin_inset Formula $\varphi=\exists v_{j}\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $v_{j}\in\{v_{1},...,v_{n}\}$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}\in F^{\tau}$
\end_inset

, unicas y tales que 
\begin_inset Formula $Li(\varphi_{1})\subseteq\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(11)
\end_layout

\end_inset


\begin_inset Formula $\varphi=\exists v\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $v\in Var-\{v_{1},...,v_{n}\}$
\end_inset

 y 
\begin_inset Formula $\varphi_{1}\in F^{\tau}$
\end_inset

, unicas y tales que 
\begin_inset Formula $Li(\varphi_{1})\subseteq\{v_{1},...,v_{n},v\}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Induccion en el 
\begin_inset Formula $k$
\end_inset

 tal que 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Convencion Notacional 6:
\end_layout

\end_inset

 Cuando hayamos declarado 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})$
\end_inset

, entonces:
\end_layout

\begin_layout Description
- si se da el caso (1) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "si fi = fi(v1,...,vn)"
plural "false"
caps "false"
noprefix "false"

\end_inset

, supondremos tacitamente que tambien hemos hecho las declaraciones 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})$
\end_inset

 y 
\begin_inset Formula $s=_{d}s(v_{1},...,v_{n})$
\end_inset

.
\end_layout

\begin_layout Description
- si se da el caso (2) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "si fi = fi(v1,...,vn)"
plural "false"
caps "false"
noprefix "false"

\end_inset

, supondremos tacitamente que tambien hemos hecho las declaraciones 
\begin_inset Formula $t_{1}=_{d}t_{1}(v_{1},...,v_{n}),...,t_{m}=_{d}t_{m}(v_{1},...,v_{n})$
\end_inset

.
\end_layout

\begin_layout Description
- si se da cualquiera de los casos (3), (4), (5) o (6) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "si fi = fi(v1,...,vn)"
plural "false"
caps "false"
noprefix "false"

\end_inset

, supondremos tacitamente que tambien hemos hecho las declaraciones 
\begin_inset Formula $\varphi_{1}=_{d}\varphi_{1}(v_{1},...,v_{n})$
\end_inset

 y 
\begin_inset Formula $\varphi_{2}=_{d}\varphi_{2}(v_{1},...,v_{n})$
\end_inset

.
\end_layout

\begin_layout Description
- si se da cualquiera de los casos (7), (8) o (10) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "si fi = fi(v1,...,vn)"
plural "false"
caps "false"
noprefix "false"

\end_inset

, supondremos tacitamente que tambien hemos hecho la declaracion 
\begin_inset Formula $\varphi_{1}=_{d}\varphi_{1}(v_{1},...,v_{n})$
\end_inset

.
\end_layout

\begin_layout Description
- si se da el caso (9) o el caso (11) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "si fi = fi(v1,...,vn)"
plural "false"
caps "false"
noprefix "false"

\end_inset

, supondremos tacitamente que tambien hemos hecho la declaracion 
\begin_inset Formula $\varphi_{1}=_{d}\varphi_{1}(v_{1},...,v_{n},v)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente lema se basa en la Convencion Notacional 6 y nos permite darle
 caracter recursivo a la notacion 
\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

Caracter recursivo de la notacion 
\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}$
\end_inset

]
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset

) Supongamos 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

 un modelo de tipo 
\begin_inset Formula $\tau$
\end_inset

 y sean 
\begin_inset Formula $a_{1},...,a_{n}\in A$
\end_inset

.
 Entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(t\equiv s)$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $t^{\mathbf{A}}[a_{1},...,a_{n}]=s^{\mathbf{A}}[a_{1},...,a_{n}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=r(t_{1},...,t_{m})$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $(t_{1}^{\mathbf{A}}[a_{1},...,a_{n}],...,t_{m}^{\mathbf{A}}[a_{1},...,a_{n}])\in r^{\mathbf{A}}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\wedge\varphi_{2}),$
\end_inset

 entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[a_{1},....,a_{n}]$
\end_inset

 y 
\begin_inset Formula $\mathbf{A}\models\varphi_{2}[a_{1},....,a_{n}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\vee\varphi_{2}),$
\end_inset

 entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[a_{1},....,a_{n}]$
\end_inset

 o 
\begin_inset Formula $\mathbf{A}\models\varphi_{2}[a_{1},....,a_{n}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\rightarrow\varphi_{2}),$
\end_inset

 entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{2}[a_{1},....,a_{n}]$
\end_inset

 o 
\begin_inset Formula $\mathbf{A}\not\models\varphi_{1}[a_{1},....,a_{n}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\leftrightarrow\varphi_{2}),$
\end_inset

 entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si ya sea 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[a_{1},....,a_{n}]$
\end_inset

 y 
\begin_inset Formula $\mathbf{A}\models\varphi_{2}[a_{1},....,a_{n}]$
\end_inset

 o 
\begin_inset Formula $\mathbf{A}\not\models\varphi_{1}[a_{1},....,a_{n}]$
\end_inset

 y 
\begin_inset Formula $\mathbf{A}\not\models\varphi_{2}[a_{1},....,a_{n}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(7)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\lnot\varphi_{1},$
\end_inset

 entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\not\models\varphi_{1}[a_{1},....,a_{n}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(8)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\forall v_{j}\varphi_{1},$
\end_inset

 entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[a_{1},....,a,...,a_{n}],$
\end_inset

 para todo 
\begin_inset Formula $a\in A.$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(9)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\forall v\varphi_{1},$
\end_inset

 con 
\begin_inset Formula $v\not\in\{v_{1},...,v_{n}\}$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[a_{1},....,a_{n},a]$
\end_inset

, para todo 
\begin_inset Formula $a\in A.$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(10)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\exists v_{j}\varphi_{1}$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[a_{1},....,a,...,a_{n}]$
\end_inset

, para algun 
\begin_inset Formula $a\in A.$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(11)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\exists v\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $v\not\in\{v_{1},...,v_{n}\}$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi[a_{1},....,a_{n}]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\varphi_{1}[a_{1},....,a_{n},a]$
\end_inset

, para algun 
\begin_inset Formula $a\in A.$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Rutina.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Alcance de la ocurrencia de un cuantificador en una formula
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $Qv$
\end_inset

 ocurre en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

, entonces hay una unica formula 
\begin_inset Formula $\psi$
\end_inset

 tal que 
\begin_inset Formula $Qv\psi$
\end_inset

 ocurre en 
\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por induccion en el 
\begin_inset Formula $k$
\end_inset

 tal que 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dada una ocurrencia de 
\begin_inset Formula $Qv$
\end_inset

 en una formula 
\begin_inset Formula $\varphi$
\end_inset

, la formula 
\begin_inset Formula $\psi$
\end_inset

 del lema anterior sera llamada el 
\shape italic
alcance 
\shape default
de dicha ocurrencia en 
\begin_inset Formula $\varphi$
\end_inset

.
 Notese que dos ocurrencias distintas de 
\begin_inset Formula $Qv$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 pueden tener alcances distintos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Sustitucion de variables libres
\end_layout

\begin_layout Standard
Diremos que 
\begin_inset Formula $v$
\end_inset

 
\shape italic
es sustituible por 
\shape default

\begin_inset Formula $w$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

en
\shape default
 
\begin_inset Formula $\varphi$
\end_inset

 cuando ninguna ocurrencia libre de 
\begin_inset Formula $v$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 sucede dentro de una ocurrencia de una subformula de la forma 
\begin_inset Formula $Qw\psi$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

.
 En otras palabras 
\begin_inset Formula $v$
\end_inset

 no sera sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 cuando alguna ocurrencia libre de 
\begin_inset Formula $v$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 suceda dentro de una ocurrencia en 
\begin_inset Formula $\varphi$
\end_inset

 de una formula de la forma 
\begin_inset Formula $Qw\psi$
\end_inset

.
 Notese que puede suceder que 
\begin_inset Formula $v$
\end_inset

 sea sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 y que sin envargo haya una subformula de la forma 
\begin_inset Formula $Qw\psi$
\end_inset

 para la cual 
\begin_inset Formula $v\in Li(Qw\psi)$
\end_inset

.
 Dejamos como ejercicio encontrar un ejemplo de esta situacion.
\end_layout

\begin_layout Standard
Usando lemas anteriores podemos ver que se dan las siguientes propiedades
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi$
\end_inset

 es atomica, entonces 
\begin_inset Formula $v$
\end_inset

 es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=(\varphi_{1}\eta\varphi_{2})$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 sii 
\begin_inset Formula $v$
\end_inset

 es substituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi_{1}$
\end_inset

 y 
\begin_inset Formula $v$
\end_inset

 es
\end_layout

\begin_deeper
\begin_layout Standard
substituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi_{2}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=\lnot\varphi_{1}$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 sii 
\begin_inset Formula $v$
\end_inset

 es substituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=Qv\varphi_{1}$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=Qw\varphi_{1}$
\end_inset

 y 
\begin_inset Formula $v\in Li(\varphi_{1})$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 no es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=Qw\varphi_{1}$
\end_inset

 y 
\begin_inset Formula $v\not\in Li(\varphi_{1})$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(7)
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi=Qu\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $u\neq v,w$
\end_inset

, entonces 
\begin_inset Formula $v$
\end_inset

 es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 sii 
\begin_inset Formula $v$
\end_inset

 es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi_{1}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Notese que las propiedades (1),...,(7) pueden usarse para dar una definicion
 recursiva de la relacion 
\begin_inset Formula $"v$
\end_inset

 
\begin_inset Formula $\mathit{es\ sustituible\ por\ }w\mathit{\ en}$
\end_inset

 
\begin_inset Formula $\varphi"$
\end_inset

.
\end_layout

\begin_layout Subsection
Teorema de reemplazo para formulas
\end_layout

\begin_layout Standard
Ahora si podemos enunciar y probar el primero de nuestros teoremas de reemplazo.
 Antes una definicion.
 Dado un termino 
\begin_inset Formula $t$
\end_inset

, diremos que una variable 
\begin_inset Formula $v$
\end_inset

 
\shape italic
es sustituible por 
\shape default

\begin_inset Formula $t$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $\varphi$
\end_inset

 cuando 
\begin_inset Formula $v$
\end_inset

 sea sustituible en 
\begin_inset Formula $\varphi$
\end_inset

 por cada variable que ocurre en 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "reemp-term1"

\end_inset

Supongamos 
\begin_inset Formula $\varphi=_{d}\varphi(w_{1},...,w_{k})$
\end_inset

, 
\begin_inset Formula $t_{1}=_{d}t_{1}(v_{1},...,v_{n}),...,t_{k}=_{d}t_{k}(v_{1},...,v_{n})$
\end_inset

 y supongamos ademas que cada 
\begin_inset Formula $w_{j}$
\end_inset

 es sustituible por 
\begin_inset Formula $t_{j}$
\end_inset

 en 
\begin_inset Formula $\varphi.$
\end_inset

 Entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $Li(\varphi(t_{1},...,t_{k}))\subseteq\{v_{1},...,v_{n}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si declaramos 
\begin_inset Formula $\varphi(t_{1},...,t_{k})=_{d}\varphi(t_{1},...,t_{k})(v_{1},...,v_{n})$
\end_inset

, entonces para cada estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\vec{a}\in A^{n}$
\end_inset

 se tiene
\begin_inset Formula 
\[
\mathbf{A}\models\varphi(t_{1},...,t_{k})[\vec{a}]\text{ si y solo si }\mathbf{A}\models\varphi[t_{1}^{\mathbf{A}}[\vec{a}],...,t_{k}^{\mathbf{A}}[\vec{a}]]
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Probaremos que se dan (a) y (b), por induccion en el 
\begin_inset Formula $l$
\end_inset

 tal que 
\begin_inset Formula $\varphi\in F_{l}^{\tau}.$
\end_inset

 El caso 
\begin_inset Formula $l=0$
\end_inset

 es una consecuencia directa del Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "reemp-term"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Supongamos (a) y (b) valen para cada 
\begin_inset Formula $\varphi\in F_{l}^{\tau}$
\end_inset

 y sea 
\begin_inset Formula $\varphi\in F_{l+1}^{\tau}-F_{l}^{\tau}.$
\end_inset

 Notese que se puede suponer que cada 
\begin_inset Formula $v_{i}$
\end_inset

 ocurre en algun 
\begin_inset Formula $t_{i}$
\end_inset

, y que cada 
\begin_inset Formula $w_{i}\in Li(\varphi)$
\end_inset

, ya que para cada 
\begin_inset Formula $\varphi$
\end_inset

, el caso general se desprende del caso con estas restricciones.
 Hay varios casos
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=\forall w\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $w\not\in\{w_{1},...,w_{k}\}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Notese que cada 
\begin_inset Formula $w_{j}\in Li(\varphi_{1})$
\end_inset

.
 Ademas notese que 
\begin_inset Formula $w\not\in\{v_{1},...,v_{n}\}$
\end_inset

 ya que de lo contrario 
\begin_inset Formula $w$
\end_inset

 ocurriria en algun 
\begin_inset Formula $t_{j}$
\end_inset

, y entonces 
\begin_inset Formula $w_{j}$
\end_inset

 no seria sustituible por 
\begin_inset Formula $t_{j}$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

.
 Sean
\begin_inset Formula 
\[
\begin{array}{ccc}
\tilde{t}_{1} & = & t_{1}\\
 & \vdots\\
\tilde{t}_{k} & = & t_{k}\\
\tilde{t}_{k+1} & = & w
\end{array}
\]

\end_inset

Declaremos
\begin_inset Formula 
\[
\tilde{t}_{j}=_{d}\tilde{t}_{j}(v_{1},...,v_{n},w)
\]

\end_inset

Notese que nuestra Convencion Notacional 6 nos dice que tenemos implicitamente
 hecha la declaracion 
\begin_inset Formula $\varphi_{1}=_{d}\varphi_{1}(w_{1},...,w_{k},w)$
\end_inset

.
 Por (a) de la hipotesis inductiva tenemos que
\begin_inset Formula 
\[
Li(\varphi_{1}(t_{1},...,t_{k},w))=Li(\varphi_{1}(\tilde{t}_{1},...,\tilde{t}_{k},\tilde{t}_{k+1}))\subseteq\{v_{1},...,v_{n},w\}
\]

\end_inset

y por lo tanto
\begin_inset Formula 
\[
Li(\varphi(t_{1},...,t_{k}))\subseteq\{v_{1},...,v_{n}\}
\]

\end_inset

lo cual prueba (a).
 Finalmente para probar (b) declaremos 
\begin_inset Formula $\varphi(t_{1},...,t_{k})=_{d}\varphi(t_{1},...,t_{k})(v_{1},...,v_{n})$
\end_inset

.
 Se tiene que
\begin_inset Formula 
\[
\begin{array}{c}
\mathbf{A}\models\varphi(t_{1},...,t_{k})\mathbf{[}\vec{a}]\\
\Updownarrow\\
\mathbf{A}\models\varphi_{1}(\tilde{t}_{1},...,\tilde{t}_{k},\tilde{t}_{k+1})[\vec{a},a]\text{, para todo }a\in A\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \Updownarrow\ \text{(por HI)}\\
\mathbf{A}\models\varphi_{1}[\tilde{t}_{1}^{\mathbf{A}}[\vec{a},a],...,\tilde{t}_{k}^{\mathbf{A}}[\vec{a},a],\tilde{t}_{k+1}^{\mathbf{A}}[\vec{a},a]]\text{, para todo }a\in A\\
\Updownarrow\\
\mathbf{A}\models\varphi_{1}[t_{1}^{\mathbf{A}}[\vec{a}],...,t_{k}^{\mathbf{A}}[\vec{a}],a]\text{, para todo }a\in A\\
\Updownarrow\\
\mathbf{A}\models\varphi[t_{1}^{\mathbf{A}}[\vec{a}],...,t_{k}^{\mathbf{A}}[\vec{a}]]
\end{array}
\]

\end_inset

lo cual pueba (b).
 Dejamos al lector los casos restantes.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejemplo:
\end_layout

\end_inset

Sea 
\begin_inset Formula $\tau=(\emptyset,\{f\},\emptyset,\{(f,1)\})$
\end_inset

.
 Sean 
\begin_inset Formula $\varphi=\exists v_{1}(f(v_{1})\equiv w_{1})$
\end_inset

 y 
\begin_inset Formula $t=v_{1}$
\end_inset

, donde 
\begin_inset Formula $v_{1}$
\end_inset

 y 
\begin_inset Formula $w_{1}$
\end_inset

 son variables distintas.
 Declaremos 
\begin_inset Formula $\varphi=_{d}\varphi(w_{1})$
\end_inset

 y 
\begin_inset Formula $t=_{d}t(v_{1})$
\end_inset

.
 Notese que 
\begin_inset Formula $w_{1}$
\end_inset

 no es sustituible en 
\begin_inset Formula $\varphi$
\end_inset

 por 
\begin_inset Formula $t$
\end_inset

, por lo cual el teorema anterior no se puede aplicar.
 De hecho la conclusion del teorema no se da en este caso ya que puede verse
 facilmente que, cualesquiera sea la estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

, 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $a_{1}\in A$
\end_inset

, tenemos que:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathbf{A}\models\varphi(t)[a_{1}]$
\end_inset

 si y solo si 
\begin_inset Formula $f^{\mathbf{A}}$
\end_inset

 tiene un pto fijo, es decir, 
\begin_inset Formula $f^{\mathbf{A}}(a)=a$
\end_inset

, para algun 
\begin_inset Formula $a\in A$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{A}\models\varphi[t^{\mathbf{A}}[a_{1}]]$
\end_inset

 si y solo si 
\begin_inset Formula $a_{1}$
\end_inset

 esta en la imagen de 
\begin_inset Formula $f^{\mathbf{A}}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
las cuales son condiciones claramente no equivalentes.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Teorias de primer orden
\end_layout

\begin_layout Standard
En esta seccion nos avocaremos a dar una solucion al punto (3) de nuestro
 programa de logica dado en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "programa"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 O sea nos abocaremos al siguiente problema:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Dar un modelo matematico del concepto de prueba elemental en una teoria
 elemental de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 
\end_layout

\begin_layout Standard
Este problema involucra el concepto de teoria elemental definido en la Seccion
 
\begin_inset CommandInset ref
LatexCommand ref
reference "Teorias elementales y pruebas elementales"
plural "false"
caps "false"
noprefix "false"

\end_inset

, el cual es intuitivo, por lo cual un primer paso en la resolucion de (3)
 sera dar un modelo matematico de este concepto.
 Recordemos que una teoria elemental es un par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 tal que 
\begin_inset Formula $\tau$
\end_inset

 es un tipo cualquiera y 
\begin_inset Formula $\Sigma$
\end_inset

 es un conjunto de sentencias elementales de tipo 
\begin_inset Formula $\tau$
\end_inset

, las cuales no tienen nombres de elementos fijos.
 Dado que ya tenemos nuestro modelo matematico para las sentencias elementales
 de tipo 
\begin_inset Formula $\tau$
\end_inset

, las cuales no tienen nombres de elementos fijos (i.e.
 las sentencias de tipo 
\begin_inset Formula $\tau$
\end_inset

), podemos dar el siguiente modelo matematico del concepto de teoria elemental:
\end_layout

\begin_layout Standard
Una 
\shape italic
teoria de primer orden
\shape default
 sera un par 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, donde 
\begin_inset Formula $\tau$
\end_inset

 es un tipo y 
\begin_inset Formula $\Sigma$
\end_inset

 es un conjunto de sentencias de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Esto ya es un buen comienzo en la resolucion del punto (3) pero aun nos
 queda por hacer lo mas complicado.
\end_layout

\begin_layout Standard
Dada una teoria de primer orden 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, los elementos de 
\begin_inset Formula $\Sigma$
\end_inset

 seran llamados 
\shape italic
axiomas propios
\shape default
 de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Un 
\shape italic
modelo de 
\shape default

\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 la cual satisfaga todos los axiomas propios de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
\end_layout

\begin_layout Standard
Algunos ejemplos de teorias de primer orden:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
La teoria
\series default
 
\begin_inset Formula $Po$
\end_inset

.
 Sea
\begin_inset Formula 
\[
Po=(\{\mathrm{A}_{\leq R},\mathrm{A}_{\leq T},\mathrm{A}_{\leq A}\},\tau_{Po})
\]

\end_inset

donde 
\begin_inset Formula $\tau_{Po}$
\end_inset

 es el tipo de los posets, es decir 
\begin_inset Formula $(\emptyset,\emptyset,\{\leq\},\{(\leq,2)\})$
\end_inset

 y
\begin_inset Formula 
\begin{align*}
\mathrm{A}_{\leq R} & =\forall x_{1}\;\mathrm{\leq}(x_{1},x_{1})\\
\mathrm{A}_{\leq T} & =\forall x_{1}\forall x_{2}\forall x_{3}\;((\mathrm{\leq}(x_{1},x_{2})\wedge\mathrm{\leq}(x_{2},x_{3}))\rightarrow\mathrm{\leq}(x_{1},x_{3}))\\
\mathrm{A}_{\leq A} & =\forall x_{1}\forall x_{2}\;((\mathrm{\leq}(x_{1},x_{2})\wedge\mathrm{\leq}(x_{2},x_{1}))\rightarrow(x_{1}\equiv x_{2}))
\end{align*}

\end_inset

Notese que una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de tipo 
\begin_inset Formula $\tau_{Po}$
\end_inset

 es un modelo de 
\begin_inset Formula $Po$
\end_inset

 si y solo si 
\begin_inset Formula $\leq^{\mathbf{A}}$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $A$
\end_inset

.
 Estrictamente hablando un modelo de 
\begin_inset Formula $Po$
\end_inset

 no es un poset ya que es un par 
\begin_inset Formula $(A,i)$
\end_inset

 donde 
\begin_inset Formula $A$
\end_inset

 es un conjunto no vacio e 
\begin_inset Formula $i$
\end_inset

 es una funcion con dominio 
\begin_inset Formula $\{\leq\}$
\end_inset

 tal que 
\begin_inset Formula $i(\leq)$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $A$
\end_inset

.
 Es decir, un modelo de 
\begin_inset Formula $Po$
\end_inset

 es un par 
\begin_inset Formula $(A,\{(\leq,R)\})$
\end_inset

 donde 
\begin_inset Formula $A$
\end_inset

 es un conjunto no vacio y 
\begin_inset Formula $R$
\end_inset

 es un orden parcial sobre 
\begin_inset Formula $A$
\end_inset

.
 De todas maneras deberia quedar claro que en esencia un poset y un modelo
 de 
\begin_inset Formula $Po$
\end_inset

 son la misma cosa por lo cual llamaremos a 
\begin_inset Formula $Po$
\end_inset

 la 
\shape italic
teoria de los posets
\shape default
 y muchas veces nos referiremos a los modelos de 
\begin_inset Formula $Po$
\end_inset

 como si fueran posets.
 Dejamos al lector el ejercicio de encontrar una biyeccion natural entre
 la clase de los modelos de 
\begin_inset Formula $Po$
\end_inset

 y la clase de los posets.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
La teoria 
\series default

\begin_inset Formula $RetCua$
\end_inset

.
 Sea 
\begin_inset Formula $\tau_{RetCua}=(\emptyset,\{\mathsf{s}^{2},\mathsf{i}^{2}\},\{\leq^{2}\},a)$
\end_inset

 y sea 
\begin_inset Formula $\Sigma_{RetCua}$
\end_inset

 el siguiente conjunto de sentencias:
\begin_inset Formula 
\begin{align*}
\mathrm{A}_{\leq R} & =\forall x_{1}\;\mathrm{\leq}(x_{1},x_{1})\\
\mathrm{A}_{\leq T} & =\forall x_{1}\forall x_{2}\forall x_{3}\;((\mathrm{\leq}(x_{1},x_{2})\wedge\mathrm{\leq}(x_{2},x_{3}))\rightarrow\mathrm{\leq}(x_{1},x_{3}))\\
\mathrm{A}_{\leq A} & =\forall x_{1}\forall x_{2}\;((\mathrm{\leq}(x_{1},x_{2})\wedge\mathrm{\leq}(x_{2},x_{1}))\rightarrow(x_{1}\equiv x_{2}))\\
\mathrm{A}_{\mathsf{s}esC} & =\forall x_{1}\forall x_{2}\;(\mathrm{\leq}(x_{1},\mathsf{s}(x_{1},x_{2}))\wedge\mathrm{\leq}(x_{2},\mathsf{s}(x_{1},x_{2})))\\
\mathrm{A}_{\mathsf{s}\leq C} & =\forall x_{1}\forall x_{2}\forall x_{3}\;\left((\mathrm{\leq}(x_{1},x_{3})\wedge\mathrm{\leq}(x_{2},x_{3}))\rightarrow\mathrm{\leq}(\mathsf{s}(x_{1},x_{2}),x_{3}\right))\\
\mathrm{A}_{\mathsf{i}esC} & =\forall x_{1}\forall x_{2}\;(\mathrm{\leq}(\mathsf{i}(x_{1},x_{2}),x_{1})\wedge\mathrm{\leq}(\mathsf{i}(x_{1},x_{2}),x_{2}))\\
\mathrm{A}_{\mathsf{i}\geq C} & =\forall x_{1}\forall x_{2}\forall x_{3}\;\left((\mathrm{\leq}(x_{3},x_{1})\wedge\mathrm{\leq}(x_{3},x_{2}))\rightarrow\mathrm{\leq}(x_{3},\mathsf{i}(x_{1},x_{2}))\right)
\end{align*}

\end_inset

Definamos 
\begin_inset Formula $RetCua=(\Sigma_{RetCua},\tau_{RetCua})$
\end_inset

.
 Como pueden notarse los axiomas de 
\begin_inset Formula $RetCua$
\end_inset

 son justamente los axiomas con los que definimos el concepto de reticulado
 cuaterna en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Es decir una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de tipo 
\begin_inset Formula $\tau_{RetCua}$
\end_inset

 es modelo de 
\begin_inset Formula $RetCua$
\end_inset

 sii 
\begin_inset Formula $(A,\mathsf{s}^{\mathbf{A}},\mathsf{i}^{\mathbf{A}},\leq^{\mathbf{A}})$
\end_inset

 es un reticulado cuaterna.
 Vayamos mas despacio:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de tipo 
\begin_inset Formula $\tau_{RetCua}$
\end_inset

 satisface los 3 primeros axiomas de 
\begin_inset Formula $RetCua$
\end_inset

 si y solo si el par 
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset

 es un poset.
 Aqui es muy importante notar que una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de tipo 
\begin_inset Formula $\tau_{RetCua}$
\end_inset

 puede satisfacer los 3 axiomas mencionados antes pero esto no implica que
 las operaciones 
\begin_inset Formula $\mathsf{s}^{\mathbf{A}}$
\end_inset

 e 
\begin_inset Formula $\mathsf{i}^{\mathbf{A}}$
\end_inset

 deban ser las operaciones infimo y supremo respecto al orden 
\begin_inset Formula $\leq^{\mathbf{A}}$
\end_inset

.
 De hecho el poset 
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset

 podria no tener supremo para algun subconjunto 
\begin_inset Formula $\{a,b\}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 que satisfaga los 3 primeros axiomas satisfacera el axioma 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}esC}$
\end_inset

 si y solo si cualesquiera sean los elementos 
\begin_inset Formula $a,b\in A$
\end_inset

, se tiene que 
\begin_inset Formula $a\;\mathsf{s}^{\mathbf{A}}\;b$
\end_inset

 es cota superior del conjunto 
\begin_inset Formula $\{a,b\}$
\end_inset

 en el poset 
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset

.
 Por supuesto esto no garaniza que 
\begin_inset Formula $a\;\mathsf{s}^{\mathbf{A}}\;b$
\end_inset

 sea el supremo de 
\begin_inset Formula $\{a,b\}$
\end_inset

 en 
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset

, solo nos dice que debe ser una cota superior
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 que satisfaga los 3 primeros axiomas cumplir 
\begin_inset Formula $\mathrm{A}_{\mathsf{s}\leq C}$
\end_inset

 si y solo si cualesquiera sean los elementos 
\begin_inset Formula $a,b\in A$
\end_inset

, se tiene que 
\begin_inset Formula $a\;\mathsf{s}^{\mathbf{A}}\;b$
\end_inset

 es menor o igual que toda cota superior de 
\begin_inset Formula $\{a,b\}$
\end_inset

 en 
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset

.
 Por supuesto esto tampoco garaniza que 
\begin_inset Formula $a\;\mathsf{s}^{\mathbf{A}}\;b$
\end_inset

 sea el supremo de 
\begin_inset Formula $\{a,b\}$
\end_inset

 en 
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset

 
\end_layout

\begin_layout Standard
De las observaciones anteriores el lector ya se habra dado cuenta que dada
 una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset


\begin_inset space \space{}
\end_inset

de tipo 
\begin_inset Formula $\tau_{RetCua}$
\end_inset

 son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{A}$
\end_inset

 es modelo de 
\begin_inset Formula $RetCua$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset

 es un poset y cualesquiera sean 
\begin_inset Formula $a,b\in A$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $a\;\mathsf{s}^{\mathbf{A}}\;b=$
\end_inset

 supremo de 
\begin_inset Formula $\{a,b\}$
\end_inset

 en 
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $a\;\mathsf{i}^{\mathbf{A}}\;b=$
\end_inset

 infimo de 
\begin_inset Formula $\{a,b\}$
\end_inset

 en 
\begin_inset Formula $(A,\leq^{\mathbf{A}})$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Definicion del concepto de prueba formal
\end_layout

\begin_layout Standard
Recomendamos al lector repasar el concepto de prueba elemental en una teoria
 elemental, dado en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Aqui daremos un modelo matematico del concepto de prueba elemental en una
 teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Tal como lo hemos visto en numerosos ejemplos, una prueba es una sucecion
 de sentencias junto con una sucesion de 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

justificaciones
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 las cuales van explicando o justificando por que es licito que cada una
 de dichas sentencias aparezca en la sucesion.
 Por supuesto nuestra definicion sera precisa y matematica por lo que deberemos
 trabajar bastante para poder escribirla correctamente.
 Como objeto matematico una prueba resultara ser un par ordenado de palabras
 cuya primera coordenada codificara en forma natural la sucesion de sentencias
 y su segunda coordenada codificara la sucesion de justificaciones.
\end_layout

\begin_layout Standard
La formalizacion matematica del concepto de prueba elemental es uno de los
 grandes logros de la ciencia moderna y este hecho se debe en gran medida
 a que si elejimos bien la teoria, las pruebas elementales no son ni mas
 ni menos que las pruebas de la matematica misma por lo cual se tiene una
 definicion matematica de la deduccion matematica!
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Reglas
\end_layout

\begin_layout Standard
Definiremos una serie de conjuntos los cuales poseen informacion deductiva
 basica, es decir representan las reglas usuales con las que los matematicos
 dan pasos dentro de una demostracion (aunque muchas veces ellos lo hacen
 sin avisar debido a la obviedad de dichas reglas).
\end_layout

\begin_layout Standard
Recordemos que si 
\begin_inset Formula $\tau$
\end_inset

 es un tipo cualquiera, un termino 
\begin_inset Formula $t\in T^{\tau}$
\end_inset

 es llamado 
\shape italic
cerrado
\shape default

\begin_inset space \space{}
\end_inset

si ninguna variable es subtermino de 
\begin_inset Formula $t$
\end_inset

.
 Con 
\begin_inset Formula $T_{c}^{\tau}$
\end_inset

 denotamos el conjunto formado por todos los terminos cerrados.
\end_layout

\begin_layout Standard
Sean
\begin_inset Formula 
\begin{align*}
Partic^{\tau} & =\{(\forall v\varphi(v),\varphi(t)):\varphi=_{d}\varphi(v)\in F^{\tau}\ \mathrm{y\ }t\in T_{c}^{\tau}\}\\
Exist^{\tau} & =\{(\varphi(t),\exists v\varphi(v)):\varphi=_{d}\varphi(v)\in F^{\tau}\ \mathrm{y\ }t\in T_{c}^{\tau}\}\\
Evoc^{\tau} & =\{(\varphi,\varphi):\varphi\in S^{\tau}\}\\
Absur^{\tau} & =\{((\lnot\varphi\rightarrow(\psi\wedge\lnot\psi)),\varphi):\varphi,\psi\in S^{\tau}\}\cup\{((\varphi\rightarrow(\psi\wedge\lnot\psi)),\lnot\varphi):\varphi,\psi\in S^{\tau}\}\\
ConjElim^{\tau} & =\{((\varphi\wedge\psi),\varphi):\varphi,\psi\in S^{\tau}\}\cup\{((\varphi\wedge\psi),\psi):\varphi,\psi\in S^{\tau}\}\\
EquivElim^{\tau} & =\{((\varphi\leftrightarrow\psi),(\varphi\rightarrow\psi)):\varphi,\psi\in S^{\tau}\}\cup\{((\varphi\leftrightarrow\psi),(\psi\rightarrow\varphi)):\varphi,\psi\in S^{\tau}\}\\
DisjInt^{\tau} & =\{(\varphi,(\varphi\vee\psi)):\varphi,\psi\in S^{\tau}\}\cup\{(\psi,(\varphi\vee\psi)):\varphi,\psi\in S^{\tau}\}\cup\{((\lnot\varphi\rightarrow\psi),(\varphi\vee\psi)):\varphi,\psi\in S^{\tau}\}
\end{align*}

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi$
\end_inset

 
\shape italic
por la regla de particularizacion
\shape default
 (resp.
 
\shape italic
existencia, evocacion, absurdo, conjuncion-eliminacion, equivalencia-eliminacion
, disjuncion-introduccion
\shape default
), 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi,\varphi)\in Partic^{\tau}$
\end_inset

 (resp.
 
\begin_inset Formula $(\psi,\varphi)\in Exist^{\tau}$
\end_inset

, 
\begin_inset Formula $(\psi,\varphi)\in Evoc^{\tau}$
\end_inset

, 
\begin_inset Formula $(\psi,\varphi)\in Absur^{\tau}$
\end_inset

, 
\begin_inset Formula $(\psi,\varphi)\in ConjElim^{\tau}$
\end_inset

, 
\begin_inset Formula $(\psi,\varphi)\in EquivElim^{\tau}$
\end_inset

, 
\begin_inset Formula $(\psi,\varphi)\in DisjInt^{\tau}$
\end_inset

).
\end_layout

\begin_layout Standard
Sea
\begin_inset Formula 
\[
Commut^{\tau}=Commut1^{\tau}\cup Commut2^{\tau}
\]

\end_inset

donde
\begin_inset Formula 
\begin{align*}
Commut1^{\tau} & =\{((t\equiv s),(s\equiv t)):s,t\in T_{c}^{\tau}\}\\
Commut2^{\tau} & =\{((\varphi\leftrightarrow\psi),(\psi\leftrightarrow\varphi)):\varphi,\psi\in S^{\tau}\}
\end{align*}

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi$
\end_inset

 
\shape italic
por la regla de commutatividad
\shape default
, 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi,\varphi)\in Commut^{\tau}$
\end_inset

.
\end_layout

\begin_layout Standard
Sean
\begin_inset Formula 
\begin{align*}
ModPon^{\tau} & =\{(\varphi,(\varphi\rightarrow\psi),\psi):\varphi,\psi\in S^{\tau}\}\\
ConjInt^{\tau} & =\{(\varphi,\psi,(\varphi\wedge\psi)):\varphi,\psi\in S^{\tau}\}\\
EquivInt^{\tau} & =\{((\varphi\rightarrow\psi),(\psi\rightarrow\varphi),(\varphi\leftrightarrow\psi)):\varphi,\psi\in S^{\tau}\}\\
DisjElim^{\tau} & =\{(\lnot\varphi,(\varphi\vee\psi),\psi):\varphi,\psi\in S^{\tau}\}\cup\{(\lnot\psi,(\varphi\vee\psi),\varphi):\varphi,\psi\in S^{\tau}\}
\end{align*}

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi_{1}$
\end_inset

 y 
\begin_inset Formula $\psi_{2}$
\end_inset

 
\shape italic
por la regla de Modus Ponens
\shape default
 (resp.
 
\shape italic
conjuncion-introduccion, equivalencia-introduccion, disjuncion-eliminacion
\shape default
), 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in ModPon^{\tau}$
\end_inset

 (resp.
 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in ConjInt^{\tau}$
\end_inset

, 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in EquivInt^{\tau}$
\end_inset

, 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in DisjElim^{\tau}$
\end_inset

).
 Sea
\begin_inset Formula 
\[
DivPorCas^{\tau}=\{((\varphi_{1}\vee\varphi_{2}),(\varphi_{1}\rightarrow\psi),(\varphi_{2}\rightarrow\psi),\psi):\varphi_{1},\varphi_{2},\psi\in S^{\tau}\}
\]

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi_{1}$
\end_inset

, 
\begin_inset Formula $\psi_{2}$
\end_inset

 y 
\begin_inset Formula $\psi_{3}$
\end_inset

 
\shape italic
por la regla de division por casos,
\shape default
 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi_{1},\psi_{2},\psi_{3},\varphi)\in DivPorCas^{\tau}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
Reemp^{\tau}=Reemp1^{\tau}\cup Reemp2^{\tau}
\]

\end_inset

donde
\end_layout

\begin_layout Standard
\begin_inset Formula $Reemp1^{\tau}=\{((t\equiv s),\gamma,\tilde{\gamma}):s,t\in T_{c}^{\tau},$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \gamma\in S^{\tau}\ \mathrm{y\ }\tilde{\gamma}=\mathrm{resultado\ de\ reemplazar\ en\ }\gamma\ \mathrm{una\ ocurrencia\ de\ }t\ \mathrm{por\ }s\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Reemp2^{\tau}=\{(\forall v_{1}...\forall v_{n}(\varphi\leftrightarrow\psi),\gamma,\tilde{\gamma}):\varphi,\psi\in F^{\tau}$
\end_inset

, 
\begin_inset Formula $Li(\varphi)=Li(\psi)=\{v_{1},...,v_{n}\}$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ n\geq0,$
\end_inset

 
\begin_inset Formula $\gamma\in S^{\tau}\ \mathrm{y\ }\tilde{\gamma}=\mathrm{resultado\ de\ reemplazar\ en\ }\gamma\ \mathrm{una\ ocurrencia\ de\ }\varphi\ \mathrm{por\ }\psi\}$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi_{1}$
\end_inset

y 
\begin_inset Formula $\psi_{2}$
\end_inset

 
\shape italic
por la regla de reemplazo,
\shape default
 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

, para expresar que 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in Reemp^{\tau}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
Trans^{\tau}=Trans1^{\tau}\cup Trans2^{\tau}\cup Trans3^{\tau}
\]

\end_inset

donde
\begin_inset Formula 
\begin{align*}
Trans1^{\tau} & =\{((t\equiv s),(s\equiv u),(t\equiv u)):t,s,u\in T_{c}^{\tau}\}\\
Trans2^{\tau} & =\{((\varphi\rightarrow\psi),(\psi\rightarrow\Phi),(\varphi\rightarrow\Phi)):\varphi,\psi,\Phi\in S^{\tau}\}\\
Trans3^{\tau} & =\{((\varphi\leftrightarrow\psi),(\psi\leftrightarrow\Phi),(\varphi\leftrightarrow\Phi)):\varphi,\psi,\Phi\in S^{\tau}\}
\end{align*}

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi_{1}$
\end_inset

y 
\begin_inset Formula $\psi_{2}$
\end_inset

 
\shape italic
por la regla de transitividad,
\shape default
 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in Trans^{\tau}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
Generaliz^{\tau}=\{(\varphi(c),\forall v\varphi(v)):\varphi=_{d}\varphi(v)\in F^{\tau},\ Li(\varphi)=\{v\}\ \mathrm{y\ }c\in\mathcal{C}\ \mathrm{no\ ocurre\ en}\ \varphi\}
\]

\end_inset

Es importante el siguiente
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $(\varphi_{1},\varphi_{2})\in Generaliz^{\tau}$
\end_inset

, entonces el nombre de constante 
\begin_inset Formula $c$
\end_inset

 del cual habla la definicion de 
\begin_inset Formula $Generaliz^{\tau}$
\end_inset

 esta univocamente determinado por el par 
\begin_inset Formula $(\varphi_{1},\varphi_{2})$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que 
\begin_inset Formula $c$
\end_inset

 es el unico nombre de constante que ocurre en 
\begin_inset Formula $\varphi_{1}$
\end_inset

 y no ocurre en 
\begin_inset Formula $\varphi_{2}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Escribiremos 
\begin_inset Formula $(\varphi_{1},\varphi_{2})\in Generaliz^{\tau}$
\end_inset

 
\shape italic
via
\shape default
 
\begin_inset Formula $c$
\end_inset

 para expresar que 
\begin_inset Formula $(\varphi_{1},\varphi_{2})\in Generaliz^{\tau}$
\end_inset

 y que 
\begin_inset Formula $c$
\end_inset

 es el unico nombre de constante que ocurre en 
\begin_inset Formula $\varphi_{1}$
\end_inset

 y no ocurre en 
\begin_inset Formula $\varphi_{2}$
\end_inset

.
 Diremos que 
\begin_inset Formula $\varphi_{2}$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\varphi_{1}$
\end_inset

 
\shape italic
por la regla de generalizacion con nombre de constante 
\shape default

\begin_inset Formula $c$
\end_inset

, 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

, para expresar que 
\begin_inset Formula $(\varphi_{1},\varphi_{2})\in Generaliz^{\tau}$
\end_inset

 
\shape italic
via
\shape default
 
\begin_inset Formula $c$
\end_inset


\end_layout

\begin_layout Standard
Sea
\begin_inset Formula 
\[
Elec^{\tau}=\{(\exists v\varphi(v),\varphi(e)):\varphi=_{d}\varphi(v)\in F^{\tau},\ Li(\varphi)=\{v\}\ \mathrm{y\ }e\in\mathcal{C}\ \mathrm{no\ ocurre\ en}\ \varphi\}
\]

\end_inset

Es importante el siguiente
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $(\varphi_{1},\varphi_{2})\in Elec^{\tau}$
\end_inset

, entonces el nombre de constante 
\begin_inset Formula $e$
\end_inset

 del cual habla la definicion de 
\begin_inset Formula $Elec^{\tau}$
\end_inset

 esta univocamente determinado por el par 
\begin_inset Formula $(\varphi_{1},\varphi_{2})$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que 
\begin_inset Formula $e$
\end_inset

 es el unico nombre de constante que ocurre en 
\begin_inset Formula $\varphi_{2}$
\end_inset

 y no ocurre en 
\begin_inset Formula $\varphi_{1}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\bigskip$
\end_inset


\end_layout

\begin_layout Standard
Escribiremos 
\begin_inset Formula $(\varphi_{1},\varphi_{2})\in Elec^{\tau}$
\end_inset

 
\shape italic
via
\shape default
 
\begin_inset Formula $e$
\end_inset

 para expresar que 
\begin_inset Formula $(\varphi_{1},\varphi_{2})\in Elec^{\tau}$
\end_inset

 y que 
\begin_inset Formula $e$
\end_inset

 es el unico nombre de constante que ocurre en 
\begin_inset Formula $\varphi_{2}$
\end_inset

 y no ocurre en 
\begin_inset Formula $\varphi_{1}$
\end_inset

.
 Diremos que 
\begin_inset Formula $\varphi_{2}$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\varphi_{1}$
\end_inset

 
\shape italic
por la regla de eleccion con nombre de constante 
\shape default

\begin_inset Formula $e$
\end_inset

, 
\shape italic
con respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\varphi_{1},\varphi_{2})\in Elec^{\tau}$
\end_inset

 
\shape italic
via
\shape default
 
\begin_inset Formula $e$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Como se puede notar hay muchas reglas y todas modelizan en forma muy natural
 fragmentos deductivos usuales de las pruebas elementales.
 Una regla 
\begin_inset Formula $R$
\end_inset

 sera llamada 
\shape italic
universal
\shape default
 cuando se de que si 
\begin_inset Formula $\varphi$
\end_inset

 se deduce de 
\begin_inset Formula $\psi_{1},...,\psi_{k}$
\end_inset

 por 
\begin_inset Formula $R$
\end_inset

, entonces 
\begin_inset Formula $\left((\psi_{1}\wedge...\wedge\psi_{k})\rightarrow\varphi\right)$
\end_inset

 es una sentencia universalmente valida.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "reglas universales"

\end_inset

Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo.
 Todas las reglas exepto las reglas de eleccion y generalizacion son universales.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Veamos que la regla de existencia es universal.
 Por definicion, un par de 
\begin_inset Formula $Exist^{\tau}$
\end_inset

 es siempre de la forma 
\begin_inset Formula $(\varphi(t),\exists v\varphi(v))$
\end_inset

, con 
\begin_inset Formula $\varphi=_{d}\varphi(v)$
\end_inset

 y 
\begin_inset Formula $t\in T_{c}^{\tau}$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbf{A}$
\end_inset

 una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{A}\models\varphi(t)$
\end_inset

.
 Sea 
\begin_inset Formula $t^{\mathbf{A}}$
\end_inset

 el valor que toma 
\begin_inset Formula $t$
\end_inset

 en 
\begin_inset Formula $\mathbf{A}$
\end_inset

.
 Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "reemp-term1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $\mathbf{A}\models\varphi\left[t^{\mathbf{A}}\right]$
\end_inset

, por lo cual tenemos que 
\begin_inset Formula $\mathbf{A}\models\exists v\varphi(v)$
\end_inset

.
\end_layout

\begin_layout Standard
Veamos que la regla de reemplazo es universal.
 Debemos probar que si 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in Reemp^{\tau}=Reemp1^{\tau}\cup Reemp2^{\tau}$
\end_inset

, entonces 
\begin_inset Formula $\left((\psi_{1}\wedge\psi_{2})\rightarrow\varphi\right)$
\end_inset

 es una sentencia universalmente valida.
 El caso en el que 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in Reemp1^{\tau}$
\end_inset

 es facil y lo dejaremos al lector.
 Para el caso en el que 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in Reemp2^{\tau}$
\end_inset

 nos hara falta un resultado un poco mas general.
 Veamos por induccion en 
\begin_inset Formula $k$
\end_inset

 que si se dan las siguientes condiciones
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\alpha\in F_{k}^{\tau}$
\end_inset

 y 
\begin_inset Formula $\varphi,\psi\in F^{\tau}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}$
\end_inset

 es una estructura de tipo 
\begin_inset Formula $\tau$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\overline{\alpha}=$
\end_inset

 resultado de reemplazar en 
\begin_inset Formula $\alpha$
\end_inset

 una ocurrencia de 
\begin_inset Formula $\varphi$
\end_inset

 por 
\begin_inset Formula $\psi$
\end_inset

,
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\varphi\left[\vec{a}\right]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\psi\left[\vec{a}\right]$
\end_inset

, para cada 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
entonces se da que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathbf{A}\models\alpha\left[\vec{a}\right]$
\end_inset

 si y solo si 
\begin_inset Formula $\mathbf{A}\models\overline{\alpha}\left[\vec{a}\right]$
\end_inset

, para cada 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $k=0.$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Entonces 
\begin_inset Formula $\alpha$
\end_inset

 es atomica y por lo tanto ya que 
\begin_inset Formula $\alpha$
\end_inset

 es la unica subformula de 
\begin_inset Formula $\alpha$
\end_inset

, la situacion es facil de probar.
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\alpha=\forall x_{i}\alpha_{1}.$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $\varphi=\alpha$
\end_inset

, entonces la situacion es facil de probar.
 Si 
\begin_inset Formula $\varphi\neq\alpha$
\end_inset

, entonces la ocurrencia de 
\begin_inset Formula $\varphi$
\end_inset

 a reemplazar sucede en 
\begin_inset Formula $\alpha_{1}$
\end_inset

 y por lo tanto 
\begin_inset Formula $\overline{\alpha}=\forall x_{i}\overline{\alpha_{1}}.$
\end_inset

 Se tiene entonces que para un 
\begin_inset Formula $\vec{a}$
\end_inset

 dado,
\begin_inset Formula 
\[
\begin{array}{c}
\mathbf{A}\models\alpha\left[\vec{a}\right]\\
\Updownarrow\\
\mathbf{A}\models\alpha_{1}\left[\downarrow_{i}^{a}\vec{a}\right],\text{ para cada }a\in A\\
\Updownarrow\\
\mathbf{A}\models\overline{\alpha_{1}}\left[\downarrow_{i}^{a}\vec{a}\right],\text{ para cada }a\in A\\
\Updownarrow\\
\mathbf{A}\models\overline{\alpha}\left[\vec{a}\right]
\end{array}
\]

\end_inset

CASO 
\begin_inset Formula $\alpha=(\alpha_{1}\vee\alpha_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $\varphi=\alpha$
\end_inset

, entonces la situacion es facil de probar.
 Supongamos 
\begin_inset Formula $\varphi\neq\alpha$
\end_inset

 y supongamos que la ocurrencia de 
\begin_inset Formula $\varphi$
\end_inset

 a reemplazar sucede en 
\begin_inset Formula $\alpha_{1}$
\end_inset

.
 Entonces 
\begin_inset Formula $\overline{\alpha}=(\overline{\alpha_{1}}\vee\alpha_{2})$
\end_inset

 y tenemos que
\begin_inset Formula 
\[
\begin{array}{c}
\mathbf{A}\models\alpha\left[\vec{a}\right]\\
\Updownarrow\\
\mathbf{A}\models\alpha_{1}\left[\vec{a}\right]\text{ o }\mathbf{A}\models\alpha_{2}\left[\vec{a}\right]\\
\Updownarrow\\
\mathbf{A}\models\overline{\alpha_{1}}\left[\vec{a}\right]\text{ o }\mathbf{A}\models\alpha_{2}\left[\vec{a}\right]\\
\Updownarrow\\
\mathbf{A}\models\overline{\alpha}\left[\vec{a}\right]
\end{array}
\]

\end_inset

Los demas casos son dejados al lector.
\end_layout

\begin_layout Standard
Dejamos al lector el chequeo de la universalidad del resto de las reglas.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Axiomas logicos
\end_layout

\begin_layout Standard
Recordemos que dada una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, los elementos de 
\begin_inset Formula $\Sigma$
\end_inset

 son llamados axiomas propios y en general no son sentencias universalmente
 validas.
\end_layout

\begin_layout Standard
En las pruebas formales sera necesario usar ciertas verdades universales
 y obvias las cuales llamaremos 
\shape italic
axiomas logicos
\shape default
.
 Mas concretamente, llamaremos 
\shape italic
axiomas logicos de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

 a todas las sentencias de alguna de las siguientes formas.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\varphi\leftrightarrow\varphi)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(t\equiv t)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\varphi\vee\lnot\varphi)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\varphi\leftrightarrow\lnot\lnot\varphi)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\lnot\forall v\psi\leftrightarrow\exists v\lnot\psi)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\lnot\exists v\psi\leftrightarrow\forall v\lnot\psi)$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
donde 
\begin_inset Formula $t\in T_{c}^{\tau}$
\end_inset

, 
\begin_inset Formula $\varphi\in S^{\tau}$
\end_inset

, 
\begin_inset Formula $\psi\in F^{\tau}$
\end_inset

, 
\begin_inset Formula $v\in Var$
\end_inset

 y 
\begin_inset Formula $Li(\psi)\subseteq\{v\}$
\end_inset

.
 Con 
\begin_inset Formula $AxLog^{\tau}$
\end_inset

 denotaremos el conjunto
\begin_inset Formula 
\[
\{\varphi\in S^{\tau}:\varphi\ \mathrm{es\ un\ axioma\ logico\ de\ tipo\ }\tau\}
\]

\end_inset

Notese que hay infinitos axiomas logicos de tipo 
\begin_inset Formula $\tau$
\end_inset

, es decir el conjunto 
\begin_inset Formula $AxLog^{\tau}$
\end_inset

 es un conjunto infinito de palabras.
 Por ejemplo, el formato dado en 1.
 produce una cantidad infinita de axiomas logicos, a saber todas las sentencias
 de la forma 
\begin_inset Formula $(\varphi\leftrightarrow\varphi)$
\end_inset

, donde 
\begin_inset Formula $\varphi$
\end_inset

 es cualquier sentencia de tipo 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejercicio:
\end_layout

\end_inset

Pruebe que cada sentencia de 
\begin_inset Formula $AxLog^{\tau}$
\end_inset


\begin_inset space \space{}
\end_inset

es universalmente valida 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Justificaciones
\end_layout

\begin_layout Standard
Remitimos a la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "SintaxisDeSsigma"
plural "false"
caps "false"
noprefix "false"

\end_inset

 por la definicion del alfabeto 
\begin_inset Formula $Num$
\end_inset

 y la funcion 
\begin_inset Formula $Dec:\omega\rightarrow Num^{\ast}$
\end_inset

.
 Recordemos que para 
\begin_inset Formula $n\in\mathbf{N}$
\end_inset

, la palabra 
\begin_inset Formula $Dec(n)$
\end_inset

 es la notacion usual decimal de 
\begin_inset Formula $n$
\end_inset

 y que para hacer mas agil la notacion escribimos 
\begin_inset Formula $\bar{n}$
\end_inset

 en lugar de 
\begin_inset Formula $Dec(n)$
\end_inset

.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $Nombres_{1}$
\end_inset

 el conjunto formado por las siguientes palabras
\begin_inset Formula 
\begin{align*}
 & \text{EXISTENCIA}\\
 & \text{COMMUTATIVIDAD}\\
 & \text{PARTICULARIZACION}\\
 & \text{ABSURDO}\\
 & \text{EVOCACION}\\
 & \text{CONJUNCIONELIMINACION}\\
 & \text{EQUIVALENCIAELIMINACION}\\
 & \text{DISJUNCIONINTRODUCCION}\\
 & \text{ELECCION}\\
 & \text{GENERALIZACION}
\end{align*}

\end_inset

Sea 
\begin_inset Formula $Nombres_{2}$
\end_inset

 el conjunto formado por las siguientes palabras
\begin_inset Formula 
\begin{align*}
 & \text{MODUSPONENS}\\
 & \text{TRANSITIVIDAD}\\
 & \text{CONJUNCIONINTRODUCCION}\\
 & \text{EQUIVALENCIAINTRODUCCION}\\
 & \text{DISJUNCIONELIMINACION}\\
 & \text{REEMPLAZO}
\end{align*}

\end_inset

Una 
\shape italic
justificacion basica
\shape default
 es una palabra perteneciente a la union de los siguientes conjuntos de
 palabras
\begin_inset Formula 
\[
\{\text{CONCLUSION},\text{AXIOMAPROPIO},\text{AXIOMALOGICO}\}
\]

\end_inset


\begin_inset Formula 
\[
\{\alpha(\bar{k}):k\in\mathbf{N}\text{ y }\alpha\in Nombres_{1}\}
\]

\end_inset


\begin_inset Formula 
\[
\{\alpha(\bar{j},\bar{k}):j,k\in\mathbf{N}\text{ y }\alpha\in Nombres_{2}\}
\]

\end_inset


\begin_inset Formula 
\[
\{\text{DIVISIONPORCASOS}(\bar{j},\bar{k},\bar{l}):j,k,l\in\mathbf{N}\}
\]

\end_inset

Usaremos 
\begin_inset Formula $JustBas$
\end_inset

 para denotar el conjunto formado por todas las justificaciones basicas.
 Una 
\shape italic
justificacion 
\shape default
es una palabra que ya sea es una justificacion basica o pertenece a la union
 de los siguientes conjuntos de palabras
\begin_inset Formula 
\[
\{\text{HIPOTESIS}\bar{k}:k\in\mathbf{N}\}
\]

\end_inset


\begin_inset Formula 
\[
\{\text{TESIS}\bar{j}\alpha:j\in\mathbf{N}\text{ y }\alpha\in JustBas\}
\]

\end_inset

Usaremos 
\begin_inset Formula $Just$
\end_inset

 para denotar el conjunto formado por todas las justificaciones.
 Cabe destacar que los elementos de 
\begin_inset Formula $Just$
\end_inset

 son palabras del alfabeto formado por los siguientes simbolos
\begin_inset Formula 
\[
(\ )\ ,\ 0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ \text{A\ B\ C\ D\ E\ G\ H\ I\ J\ L\ M\ N\ O\ P\ Q\ R\ S\ T\ U\ V\ X Z}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Concatenaciones balanceadas de justificaciones
\end_layout

\begin_layout Standard
Para construir el concepto de prueba elemental deberiamos trabajar con sucesione
s finitas de justificaciones pero el siguiente lema nos dice que podemos
 reemplazarlas por ciertas palabras, i.e.
 sus concatenaciones, sin perder informacion.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "secuencia de justificaciones"

\end_inset

Sea 
\begin_inset Formula $\mathbf{J}\in Just^{+}$
\end_inset

.
 Hay unicos 
\begin_inset Formula $n\geq1$
\end_inset

 y 
\begin_inset Formula $J_{1},...,J_{n}\in Just$
\end_inset

 tales que 
\begin_inset Formula $\mathbf{J}=J_{1}...J_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $J_{1},...,J_{n}$
\end_inset

, 
\begin_inset Formula $J_{1}^{\prime},...,J_{m}^{\prime}$
\end_inset

, con 
\begin_inset Formula $n,m\geq1$
\end_inset

, son justificaciones tales que 
\begin_inset Formula $J_{1}...J_{n}=J_{1}^{\prime}...J_{m}^{\prime}$
\end_inset

.
 Es facil ver que entonces tenemos 
\begin_inset Formula $J_{1}=J_{1}^{\prime}$
\end_inset

, por lo cual 
\begin_inset Formula $J_{2}...J_{n}=J_{2}^{\prime}...J_{m}^{\prime}$
\end_inset

.
 Un argumento inductivo nos dice que entonces 
\begin_inset Formula $n=m$
\end_inset

 y 
\begin_inset Formula $J_{i}=J_{i}^{\prime}$
\end_inset

, 
\begin_inset Formula $i=1,...,n$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Es decir el lema anterior nos dice que la sucesion 
\begin_inset Formula $J_{1},...,J_{n}$
\end_inset

 se puede codificar con la palabra 
\begin_inset Formula $J_{1}...J_{n}$
\end_inset

 sin perder informacion.
 Dada 
\begin_inset Formula $\mathbf{J}\in Just^{+}$
\end_inset

, usaremos 
\begin_inset Formula $n(\mathbf{J})$
\end_inset

 y 
\begin_inset Formula $\mathbf{J}_{1},...,\mathbf{J}_{n(\mathbf{J})}$
\end_inset

 para denotar los unicos 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $J_{1},...,J_{n}$
\end_inset

 cuya existencia garantiza el lema anterior.
\end_layout

\begin_layout Standard
Dados 
\begin_inset Formula $i,j\in\omega$
\end_inset

, usaremos 
\begin_inset Formula $\left\langle i,j\right\rangle $
\end_inset

 para denotar el conjunto 
\begin_inset Formula $\{l\in\omega:i\leq l\leq j\}$
\end_inset

.
 A los conjuntos de la forma 
\begin_inset Formula $\left\langle i,j\right\rangle $
\end_inset

 los llamaremos 
\shape italic
bloques
\shape default
.
\end_layout

\begin_layout Standard
Dada 
\begin_inset Formula $\mathbf{J}\in Just^{+}$
\end_inset

 definamos
\begin_inset Formula 
\begin{gather*}
\mathcal{B}^{\mathbf{J}}=\{\left\langle i,j\right\rangle :1\leq i\leq j\leq n(\mathbf{J})\text{ y \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\\
\exists k\ \mathbf{J}_{i}=\text{HIPOTESIS}\bar{k}\text{ y}\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mathbf{J}_{j}=\text{TESIS}\bar{k}\alpha\text{ para algun }\alpha\in JustBas\}
\end{gather*}

\end_inset

Diremos que 
\begin_inset Formula $\mathbf{J}\in Just^{+}$
\end_inset

 es 
\shape italic
balanceada
\shape default
 si se dan las siguientes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Por cada 
\begin_inset Formula $k\in\mathbf{N}$
\end_inset

 a lo sumo hay un 
\begin_inset Formula $i$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{J}_{i}=$
\end_inset

 
\begin_inset Formula $\mathrm{HIPOTESIS}\bar{k}$
\end_inset

 y a lo sumo hay un 
\begin_inset Formula $i$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{J}_{i}=$
\end_inset

 
\begin_inset Formula $\mathrm{TESIS}\bar{k}\alpha$
\end_inset

, con 
\begin_inset Formula $\alpha\in JustBas$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\mathbf{J}_{i}=\mathrm{HIPOTESIS}\bar{k}$
\end_inset

 entonces hay un 
\begin_inset Formula $l>i$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{J}_{l}=\mathrm{TESIS}\bar{k}\alpha$
\end_inset

, con 
\begin_inset Formula $\alpha\in JustBas$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $\mathbf{J}_{i}=\mathrm{TESIS}\bar{k}\alpha$
\end_inset

, con 
\begin_inset Formula $\alpha\in JustBas$
\end_inset

, entonces hay un 
\begin_inset Formula $l<i$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{J}_{l}=\mathrm{HIPOTESIS}\bar{k}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Si 
\begin_inset Formula $B_{1},B_{2}\in\mathcal{B}^{\mathbf{J}}$
\end_inset

, entonces 
\begin_inset Formula $B_{1}\cap B_{2}=\emptyset$
\end_inset

 o 
\begin_inset Formula $B_{1}\subseteq B_{2}$
\end_inset

 o 
\begin_inset Formula $B_{2}\subseteq B_{1}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejercicio:
\end_layout

\end_inset

Supongamos 
\begin_inset Formula $\mathbf{J}\in Just^{+}$
\end_inset

 es balanceada.
 Entonces
\end_layout

\begin_deeper
\begin_layout Enumerate
Si 
\begin_inset Formula $\left\langle i,j\right\rangle \in\mathcal{B}^{\mathbf{J}}$
\end_inset

, entonces 
\begin_inset Formula $i<j$
\end_inset


\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $\left\langle i,j\right\rangle ,\left\langle i^{\prime},j^{\prime}\right\rangle \in\mathcal{B}^{\mathbf{J}}$
\end_inset

 y 
\begin_inset Formula $i=i^{\prime}$
\end_inset

, entonces 
\begin_inset Formula $j=j^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
Si 
\begin_inset Formula $\left\langle i,j\right\rangle ,\left\langle i^{\prime},j^{\prime}\right\rangle \in\mathcal{B}^{\mathbf{J}}$
\end_inset

 y 
\begin_inset Formula $j=j^{\prime}$
\end_inset

, entonces 
\begin_inset Formula $i=i^{\prime}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Pares adecuados
\end_layout

\begin_layout Standard
Para construir el concepto de prueba elemental deberiamos trabajar con sucesione
s finitas de sentencias pero el siguiente lema nos dice que podemos reemplazarla
s por ciertas palabras, i.e.
 sus concatenaciones, sin perder informacion.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "secuencia de sentencias"

\end_inset

Sea 
\begin_inset Formula $\mathbf{\varphi}\in S^{\tau+}$
\end_inset

.
 Hay unicos 
\begin_inset Formula $n\geq1$
\end_inset

 y 
\begin_inset Formula $\varphi_{1},...,\varphi_{n}\in S^{\tau}$
\end_inset

 tales que 
\begin_inset Formula $\mathbf{\varphi}=\varphi_{1}...\varphi_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Solo hay que probar la unicidad la cual sigue de la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "mordisqueo"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Es decir el lema anterior nos dice que la sucesion 
\begin_inset Formula $\varphi_{1},...,\varphi_{n}$
\end_inset

 se puede codificar con la palabra 
\begin_inset Formula $\varphi_{1}...\varphi_{n}$
\end_inset

 sin perder informacion.
 Dada 
\begin_inset Formula $\mathbf{\varphi}\in S^{\tau+}$
\end_inset

, usaremos 
\begin_inset Formula $n(\mathbf{\varphi})$
\end_inset

 y 
\begin_inset Formula $\mathbf{\varphi}_{1},...,\mathbf{\varphi}_{n(\mathbf{\varphi})}$
\end_inset

 para denotar los unicos 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $\varphi_{1},...,\varphi_{n}$
\end_inset

 cuya existencia garantiza el lema anterior.
\end_layout

\begin_layout Standard
Un 
\shape italic
par adecuado de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

 es un par 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})\in S^{\tau+}\times Just^{+}$
\end_inset

 tal que 
\begin_inset Formula $n(\mathbf{\varphi})=n(\mathbf{J})$
\end_inset

 y 
\begin_inset Formula $\mathbf{J}$
\end_inset

 es balanceada.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 un par adecuado de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Si 
\begin_inset Formula $\left\langle i,j\right\rangle \in\mathcal{B}^{\mathbf{J}}$
\end_inset

, entonces 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 sera la 
\shape italic
hipotesis 
\shape default
del bloque 
\begin_inset Formula $\left\langle i,j\right\rangle $
\end_inset

 en 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 y 
\begin_inset Formula $\mathbf{\varphi}_{j}$
\end_inset

 sera la 
\shape italic
tesis
\shape default
 del bloque 
\begin_inset Formula $\left\langle i,j\right\rangle $
\end_inset

 en 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

.
 Diremos que 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 
\shape italic
esta bajo la hipotesis
\shape default
 
\begin_inset Formula $\mathbf{\varphi}_{l}$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 o que 
\begin_inset Formula $\mathbf{\varphi}_{l}$
\end_inset

 
\shape italic
es una hipotesis de
\shape default
 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 cuando haya en 
\begin_inset Formula $\mathcal{B}^{\mathbf{J}}$
\end_inset

 un bloque de la forma 
\begin_inset Formula $\left\langle l,j\right\rangle $
\end_inset

 el cual contenga a 
\begin_inset Formula $i$
\end_inset

.
 Sean 
\begin_inset Formula $i,j\in\left\langle 1,n(\mathbf{\varphi})\right\rangle .$
\end_inset

 Diremos que 
\begin_inset Formula $i$
\end_inset

 es 
\shape italic
anterior
\shape default
 a 
\begin_inset Formula $j$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 si 
\begin_inset Formula $i<j$
\end_inset

 y ademas para todo 
\begin_inset Formula $B\in\mathcal{B}^{\mathbf{J}}$
\end_inset

 se tiene que 
\begin_inset Formula $i\in B\Rightarrow j\in B$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Paragraph
Dependencia de constantes en pares adecuados
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 un par adecuado de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Dadas 
\begin_inset Formula $e,d\in\mathcal{C}$
\end_inset

, diremos que 
\begin_inset Formula $e$
\end_inset

 
\shape italic
depende directamente de 
\shape default

\begin_inset Formula $d$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 si hay numeros 
\begin_inset Formula $1\leq l<j\leq n(\mathbf{\varphi})$
\end_inset

 tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $l$
\end_inset

 es anterior a 
\begin_inset Formula $j$
\end_inset

 en 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{j}=\alpha\mathrm{ELECCION}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{j})\in Elec^{\tau}$
\end_inset

 via 
\begin_inset Formula $e$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $d$
\end_inset

 ocurre en 
\begin_inset Formula $\mathbf{\varphi}_{l}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dados 
\begin_inset Formula $e,d\in\mathcal{C}$
\end_inset

, diremos que 
\begin_inset Formula $e$
\end_inset

 
\shape italic
depende de 
\shape default

\begin_inset Formula $d$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 si existen 
\begin_inset Formula $e_{0},...,e_{k+1}\in\mathcal{C}$
\end_inset

, con 
\begin_inset Formula $k\geq0$
\end_inset

, tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $e_{0}=e$
\end_inset

 y 
\begin_inset Formula $e_{k+1}=d$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $e_{i}$
\end_inset

 
\shape italic
depende directamente de 
\shape default

\begin_inset Formula $e_{i+1}$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

, para 
\begin_inset Formula $i=0,...,k$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Definicion de prueba formal
\end_layout

\begin_layout Standard
Ahora si estamos en condiciones de definir el concepto de prueba formal
 en una teoria de primer orden.
 Sea 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 una teoria de primer orden.
 Sea 
\begin_inset Formula $\varphi$
\end_inset

 una sentencia de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Una 
\shape italic
prueba formal de 
\shape default

\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera un par adecuado 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 de algun tipo 
\begin_inset Formula $\tau_{1}=(\mathcal{C}\cup\mathcal{C}_{1},\mathcal{F},\mathcal{R},a)$
\end_inset

, con 
\begin_inset Formula $\mathcal{C}_{1}$
\end_inset

 finito y disjunto con 
\begin_inset Formula $\mathcal{C}$
\end_inset

, tal que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Cada 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 es una sentencia de tipo 
\begin_inset Formula $\tau_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{\varphi}_{n(\mathbf{\varphi})}=\varphi$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $\left\langle i,j\right\rangle \in\mathcal{B}^{\mathbf{J}}$
\end_inset

, entonces 
\begin_inset Formula $\mathbf{\varphi}_{j+1}=(\mathbf{\varphi}_{i}\rightarrow\mathbf{\varphi}_{j})$
\end_inset

 y 
\begin_inset Formula $\mathbf{J}_{j+1}=\alpha\mathrm{CONCLUSION}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $i=1,...,n(\mathbf{\varphi})$
\end_inset

, se da una de las siguientes
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\mathrm{HIPOTESIS}\bar{k}$
\end_inset

 para algun 
\begin_inset Formula $k\in\mathbf{N}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{CONCLUSION}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

 y hay un 
\begin_inset Formula $j$
\end_inset

 tal que 
\begin_inset Formula $\left\langle j,i-1\right\rangle \in\mathcal{B}^{\mathbf{J}}$
\end_inset

 y 
\begin_inset Formula $\mathbf{\varphi}_{i}=(\mathbf{\varphi}_{j}\rightarrow\mathbf{\varphi}_{i-1})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{AXIOMALOGICO}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

 y 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 es un axioma logico de tipo 
\begin_inset Formula $\tau_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(d)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{AXIOMAPROPIO}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

 y 
\begin_inset Formula $\mathbf{\varphi}_{i}\in\Sigma$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(e)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{PARTICULARIZACION}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in Partic^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(f)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{COMMUTATIVIDAD}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in Commut^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(g)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{ABSURDO}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in Absur^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(h)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{EVOCACION}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in Evoc^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(i)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{EXISTENCIA}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in Exist^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(j)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{CONJUNCIONELIMINACION}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in ConjElim^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(k)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{DISJUNCIONINTRODUCCION}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in DisjInt^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(l)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{EQUIVALENCIAELIMINACION}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in EquivElim^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(m)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{MODUSPONENS}(\overline{l_{1}},\overline{l_{2}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l_{1}$
\end_inset

 y 
\begin_inset Formula $l_{2}$
\end_inset

 anteriores a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l_{1}},\mathbf{\varphi}_{l_{2}},\mathbf{\varphi}_{i})\in ModPon^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(n)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{CONJUNCIONINTRODUCCION}(\overline{l_{1}},\overline{l_{2}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l_{1}$
\end_inset

 y 
\begin_inset Formula $l_{2}$
\end_inset

 anteriores a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l_{1}},\mathbf{\varphi}_{l_{2}},\mathbf{\varphi}_{i})\in ConjInt^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(o)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{EQUIVALENCIAINTRODUCCION}(\overline{l_{1}},\overline{l_{2}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l_{1}$
\end_inset

 y 
\begin_inset Formula $l_{2}$
\end_inset

 anteriores a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l_{1}},\mathbf{\varphi}_{l_{2}},\mathbf{\varphi}_{i})\in EquivInt^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(p)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{DISJUNCIONELIMINACION}(\overline{l_{1}},\overline{l_{2}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l_{1}$
\end_inset

 y 
\begin_inset Formula $l_{2}$
\end_inset

 anteriores a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l_{1}},\mathbf{\varphi}_{l_{2}},\mathbf{\varphi}_{i})\in DisjElim^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(q)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{REEMPLAZO}(\overline{l_{1}},\overline{l_{2}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l_{1}$
\end_inset

 y 
\begin_inset Formula $l_{2}$
\end_inset

 anteriores a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l_{1}},\mathbf{\varphi}_{l_{2}},\mathbf{\varphi}_{i})\in Reemp^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(r)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{TRANSITIVIDAD}(\overline{l_{1}},\overline{l_{2}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l_{1}$
\end_inset

 y 
\begin_inset Formula $l_{2}$
\end_inset

 anteriores a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l_{1}},\mathbf{\varphi}_{l_{2}},\mathbf{\varphi}_{i})\in Trans^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(s)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{DIVISIONPORCASOS}(\overline{l_{1}},\overline{l_{2}},\overline{l_{3}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l_{1},l_{2}$
\end_inset

 y 
\begin_inset Formula $l_{3}$
\end_inset

 anteriores a 
\begin_inset Formula $i$
\end_inset

 y y 
\begin_inset Formula $(\mathbf{\varphi}_{l_{1}},\mathbf{\varphi}_{l_{2}},\mathbf{\varphi}_{l_{3}},\mathbf{\varphi}_{i})\in DivPorCas^{\tau_{1}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(t)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{ELECCION}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in Elec^{\tau_{1}}$
\end_inset

 via un nombre de cte 
\begin_inset Formula $e$
\end_inset

, el cual no pertenece a 
\begin_inset Formula $\mathcal{C}$
\end_inset

 y no ocurre en 
\begin_inset Formula $\mathbf{\varphi}_{1},...,\mathbf{\varphi}_{i-1}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(u)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{J}_{i}=\alpha\mathrm{GENERALIZACION}(\bar{l})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 anterior a 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $(\mathbf{\varphi}_{l},\mathbf{\varphi}_{i})\in Generaliz^{\tau_{1}}$
\end_inset

 via un nombre de cte 
\begin_inset Formula $c$
\end_inset

 el cual cumple:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(i)
\end_layout

\end_inset


\begin_inset Formula $c\not\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(ii)
\end_layout

\end_inset


\begin_inset Formula $c$
\end_inset

 no es un nombre de cte que ocurra en 
\begin_inset Formula $\mathbf{\varphi}$
\end_inset

 el cual sea introducido por la aplicacion de la regla de eleccion; es decir
 para cada 
\begin_inset Formula $u\in\{1,...,n(\mathbf{\varphi})\}$
\end_inset

, si 
\begin_inset Formula $\mathbf{J}_{u}=\alpha\mathrm{ELECCION}(\bar{v})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces no se da que 
\begin_inset Formula $(\mathbf{\varphi}_{v},\mathbf{\varphi}_{u})\in Elec^{\tau_{1}}$
\end_inset

 via 
\begin_inset Formula $c$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(iii)
\end_layout

\end_inset


\begin_inset Formula $c$
\end_inset

 no ocurre en ninguna hipotesis de 
\begin_inset Formula $\mathbf{\varphi}_{l}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(iv)
\end_layout

\end_inset

Ningun nombre de constante que ocurra en 
\begin_inset Formula $\mathbf{\varphi}_{l}$
\end_inset

 o en sus hipotesis, depende de 
\begin_inset Formula $c.$
\end_inset

 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Las pruebas formales modelizan nuestras pruebas elementales y en la mayoria
 de los casos la modelizacion es tan natural que el pasaje de la prueba
 elemental a la formal es rutinario y obvio.
 Sin envargo hay ciertos casos en los que la modelizacion es un poco mas
 burocratica y puede suceder que a uno no se le ocurra como 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

formalizar
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 (i.e.
 ir haciendo la prueba formal) cierta parte de una prueba elemental.
 Un ejemplo es cuando en una prueba elemental se va a probar una sentencia
 de la forma 
\begin_inset Formula $(\varphi\vee\psi)$
\end_inset

.
 En estos casos es muy comun que el matematico pruebe directamente que vale
 
\begin_inset Formula $(\lnot\varphi\rightarrow\psi)$
\end_inset

 (de lo cual es obvio que sigue 
\begin_inset Formula $(\varphi\vee\psi)$
\end_inset

).
 Este razonamiento podriamos simularlo en nuestra prueba formal de la siguiente
 manera: Primero suponemos el axioma logico 
\begin_inset Formula $(\varphi\vee\lnot\varphi)$
\end_inset

.
 Luego probamos 
\begin_inset Formula $(\varphi\rightarrow(\varphi\vee\psi))$
\end_inset

 (es muy facil).
 Luego hacemos la simulacion formal de la prueba de 
\begin_inset Formula $(\lnot\varphi\rightarrow\psi)$
\end_inset

 dada por el matematico.
 Luego probamos 
\begin_inset Formula $(\psi\rightarrow(\varphi\vee\psi))$
\end_inset

 y por la regla de transitividad obtenemos que 
\begin_inset Formula $(\lnot\varphi\rightarrow(\varphi\vee\psi))$
\end_inset

.
 Finalmente aplicamos la regla de division por casos a 
\begin_inset Formula $(\varphi\vee\lnot\varphi)$
\end_inset

, 
\begin_inset Formula $(\varphi\rightarrow(\varphi\vee\psi))$
\end_inset

 y 
\begin_inset Formula $(\psi\rightarrow(\varphi\vee\psi))$
\end_inset

 para obtener 
\begin_inset Formula $(\varphi\vee\psi)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
A continuacion daremos una prueba formal de 
\begin_inset Formula $\mu=\forall x_{1}\forall x_{2}((\forall x_{3}\ x_{3}\leq x_{1}\wedge\forall x_{3}\ x_{3}\leq x_{2})\rightarrow x_{1}\equiv x_{2})$
\end_inset

 en la teoria 
\begin_inset Formula $Po$
\end_inset

.
 La idea para hacerla es ir copiando la estructura de la prueba elemental
 de 
\begin_inset Formula $\mu$
\end_inset

 dada al comienso de la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "Estructuras y su lenguaje elemental asociado"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Para facilitar la lectura la escribiremos secuencialmente
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & (\forall x_{3}\ x_{3}\leq a\wedge\forall x_{3}\ x_{3}\leq b) &  & \text{\textrm{HIPOTESIS}}1\\
2.\; & \forall x_{3}\ x_{3}\leq a &  & \mathrm{CONJUNCIONELIMINACION}(1)\\
3.\; & b\leq a &  & \mathrm{PARTICULARIZACION}(2)\\
4.\; & \forall x_{3}\ x_{3}\leq b &  & \mathrm{CONJUNCIONELIMINACION}(1)\\
5. & a\leq b &  & \mathrm{PARTICULARIZACION}(4)\\
6. & a\leq b\wedge b\leq a &  & \text{CONJUNCIONINTRODUCCION}(5,3)\\
7. & \forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2}) &  & \text{AXIOMAPROPIO}\\
8. & \forall x_{2}\;((a\leq x_{2}\wedge x_{2}\leq a)\rightarrow a\equiv x_{2}) &  & \text{PARTICULARIZACION}(7)\\
9. & (a\leq b\wedge b\leq a)\rightarrow a\equiv b &  & \text{PARTICULARIZACION}(8)\\
10. & a\equiv b &  & \text{TESIS}1\text{MODUSPONENS}(6,9)\\
11. & (\forall x_{3}\ x_{3}\leq a\wedge\forall x_{3}\ x_{3}\leq b)\rightarrow a\equiv b &  & \text{CONCLUSION}\\
12. & \forall x_{2}((\forall x_{3}\ x_{3}\leq a\wedge\forall x_{3}\ x_{3}\leq x_{2})\rightarrow a\equiv x_{2}) &  & \text{GENERALIZACION}(11)\\
13. & \forall x_{1}\forall x_{2}((\forall x_{3}\ x_{3}\leq x_{1}\wedge\forall x_{3}\ x_{3}\leq x_{2})\rightarrow x_{1}\equiv x_{2}) &  & \text{GENERALIZACION}(12)
\end{array}
\]

\end_inset

pero por supuesto, nuestra prueba formal es en realidad el par 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 donde 
\begin_inset Formula $\mathbf{\varphi}$
\end_inset

 es la concatenacion de la secuencia de sentencias de arriba y 
\begin_inset Formula $\mathbf{J}$
\end_inset

 es la concatenacion de la secuencia de justificaciones de arriba
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
El concepto de teorema
\end_layout

\begin_layout Standard
Cuando haya una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, diremos que 
\begin_inset Formula $\varphi$
\end_inset

 es un 
\shape italic
teorema 
\shape default
de la teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 y escribiremos 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

.
 A continuacion se dan algunos ejemplos de teoremas de la teoria 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\varphi_{1}\vee\varphi_{2})\rightarrow(\varphi_{2}\vee\varphi_{1})$
\end_inset

 es un teorema de 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

.
 Una prueba formal:
\begin_inset Formula 
\[
\begin{array}{llll}
1. & (\varphi_{1}\vee\varphi_{2}) &  & \text{HIPOTESIS}1\\
2. & \varphi_{1} &  & \text{HIPOTESIS}2\\
3. & (\varphi_{2}\vee\varphi_{1}) &  & \text{TESIS}2\text{DISJUNCIONINTRODUCCION}(2)\\
4. & (\varphi_{1}\rightarrow(\varphi_{2}\vee\varphi_{1})) &  & \text{CONCLUSION}\\
5. & \varphi_{2} &  & \text{HIPOTESIS}3\\
6. & (\varphi_{2}\vee\varphi_{1}) &  & \text{TESIS}3\text{DISJUNCIONINTRODUCCION}(5)\\
7. & \varphi_{2}\rightarrow(\varphi_{2}\vee\varphi_{1}) &  & \text{CONCLUSION}\\
8. & (\varphi_{2}\vee\varphi_{1}) &  & \text{TESIS}1\text{DIVISIONPORCASOS}(1,4,7)\\
9. & (\varphi_{1}\vee\varphi_{2})\rightarrow(\varphi_{2}\vee\varphi_{1}) &  & \text{CONCLUSION}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3}))\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3})$
\end_inset

 es un teorema de 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

.
 Una prueba formal:
\begin_inset Formula 
\[
\begin{array}{llll}
1. & (\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3})) &  & \text{HIPOTESIS}1\\
2. & \varphi_{1} &  & \text{HIPOTESIS}2\\
3. & (\varphi_{1}\vee\varphi_{2}) &  & \text{DISJUNCIONINTRODUCCION}(2)\\
4. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}2\text{DISJUNCIONINTRODUCCION}(3)\\
5. & \varphi_{1}\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}\\
6. & (\varphi_{2}\vee\varphi_{3}) &  & \text{HIPOTESIS}3\\
7. & \varphi_{2} &  & \text{HIPOTESIS}4\\
8. & (\varphi_{1}\vee\varphi_{2}) &  & \text{DISJUNCIONINTRODUCCION}(6)\\
9. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}4\text{DISJUNCIONINTRODUCCION}(7)\\
10. & \varphi_{2}\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}\\
11. & \varphi_{3} &  & \text{HIPOTESIS}5\\
12. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}5\text{DISJUNCIONINTRODUCCION}(11)\\
13. & \varphi_{3}\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}\\
14. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}3\text{DIVISIONPORCASOS}(6,10,13)\\
15. & (\varphi_{2}\vee\varphi_{3})\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}\\
16. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}1\text{DIVISIONPORCASOS}(1,5,15)\\
17. & (\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3}))\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}
\end{array}
\]

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $((\varphi\wedge(\varphi\vee\psi))\leftrightarrow\varphi)$
\end_inset

 es un teorema de 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

.
 Una prueba formal:
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & (\varphi\wedge(\varphi\vee\psi)) &  & \text{HIPOTESIS}1\\
2.\; & \varphi &  & \text{TESIS}1\text{CONJUNCIONELIMINACION}(1)\\
3.\; & (\varphi\wedge(\varphi\vee\psi))\rightarrow\varphi &  & \text{CONCLUSION}\\
4.\; & \varphi &  & \text{HIPOTESIS}2\\
5. & (\varphi\vee\psi) &  & \text{DISJUNCIONINTRODUCCION}(4)\\
6. & (\varphi\wedge(\varphi\vee\psi)) &  & \text{TESIS}2\text{CONJUNCIONINTRODUCCION}(4,5)\\
7. & \varphi\rightarrow(\varphi\wedge(\varphi\vee\psi)) &  & \text{CONCLUSION}\\
8. & ((\varphi\wedge(\varphi\vee\psi))\leftrightarrow\varphi) &  & \text{EQUIVALENCIAINTRODUCCION}(3,7)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $((\varphi\vee(\varphi\wedge\psi))\leftrightarrow\varphi)$
\end_inset

 es un teorema de 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

.
 Una prueba formal:
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & (\varphi\vee(\varphi\wedge\psi)) &  & \text{HIPOTESIS}1\\
2.\; & \varphi &  & \text{HIPOTESIS}2\\
3.\; & \varphi &  & \text{TESIS}2\text{EVOCACION}(2)\\
4.\; & \varphi\rightarrow\varphi &  & \text{CONCLUSION}\\
5. & (\varphi\wedge\psi) &  & \text{HIPOTESIS}3\\
6. & \varphi &  & \text{TESIS}3\text{CONJUNCIONELIMINACION}(5)\\
7. & (\varphi\wedge\psi)\rightarrow\varphi &  & \text{CONCLUSION}\\
8. & \varphi &  & \text{TESIS}1\text{DIVISIONPORCASOS}(1,4,7)\\
9. & (\varphi\vee(\varphi\wedge\psi))\rightarrow\varphi &  & \text{CONCLUSION}\\
10. & \varphi &  & \text{HIPOTESIS}4\\
11. & (\varphi\vee(\varphi\wedge\psi)) &  & \text{TESIS}4\text{DISJUNCIONINTRODUCCION}(10)\\
12. & \varphi\rightarrow(\varphi\vee(\varphi\wedge\psi)) &  & \text{CONCLUSION}\\
13. & ((\varphi\vee(\varphi\wedge\psi))\leftrightarrow\varphi) &  & \text{EQUIVALENCIAINTRODUCCION}(9,12)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\varphi\wedge(\varphi_{1}\vee\varphi_{2}))\rightarrow((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2}))$
\end_inset

 es un teorema de 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

.
 Una prueba formal:
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & (\varphi\wedge(\varphi_{1}\vee\varphi_{2})) &  & \text{HIPOTESIS}1\\
2.\; & \varphi &  & \text{CONJUNCIONELIMINACION}(1)\\
3.\; & (\varphi_{1}\vee\varphi_{2}) &  & \text{CONJUNCIONELIMINACION}(1)\\
4.\; & \varphi_{1} &  & \text{HIPOTESIS}2\\
5. & (\varphi\wedge\varphi_{1}) &  & \text{CONJUNCIONINTRODUCCION}(2,4)\\
6. & ((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2})) &  & \text{TESIS}2\text{DISJUNCIONINTRODUCCION}(5)\\
7. & \varphi_{1}\rightarrow((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2})) &  & \text{CONCLUSION}\\
8. & \varphi_{2} &  & \text{HIPOTESIS}3\\
9. & (\varphi\wedge\varphi_{2}) &  & \text{CONJUNCIONINTRODUCCION}(2,8)\\
10. & ((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2})) &  & \text{TESIS}3\text{DISJUNCIONINTRODUCCION}(9)\\
11. & \varphi_{2}\rightarrow((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2})) &  & \text{CONCLUSION}\\
12. & ((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2})) &  & \text{TESIS}1\text{DIVISIONPORCASOS}(3,7,11)\\
13. & (\varphi\wedge(\varphi_{1}\vee\varphi_{2}))\rightarrow((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2})) &  & \text{CONCLUSION}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2}))\rightarrow(\varphi\wedge(\varphi_{1}\vee\varphi_{2}))$
\end_inset

 es un teorema de 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

.
 Una prueba formal:
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & ((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2})) &  & \text{HIPOTESIS}1\\
2.\; & (\varphi\wedge\varphi_{1}) &  & \text{HIPOTESIS}2\\
3.\; & \varphi &  & \text{CONJUNCIONELIMINACION}(2)\\
4.\; & \varphi_{1} &  & \text{CONJUNCIONELIMINACION}(2)\\
5. & (\varphi_{1}\vee\varphi_{2}) &  & \text{DISJUNCIONINTRODUCCION}(4)\\
6. & \varphi\wedge(\varphi_{1}\vee\varphi_{2}) &  & \text{TESIS}2\text{CONJUNCIONINTRODUCCION}(3,5)\\
7. & (\varphi\wedge\varphi_{1})\rightarrow(\varphi\wedge(\varphi_{1}\vee\varphi_{2})) &  & \text{CONCLUSION}\\
8. & (\varphi\wedge\varphi_{2}) &  & \text{HIPOTESIS}3\\
9. & \varphi &  & \text{CONJUNCIONELIMINACION}(8)\\
10. & \varphi_{2} &  & \text{CONJUNCIONELIMINACION}(8)\\
11. & (\varphi_{1}\vee\varphi_{2}) &  & \text{DISJUNCIONINTRODUCCION}(10)\\
12. & \varphi\wedge(\varphi_{1}\vee\varphi_{2}) &  & \text{TESIS}3\text{CONJUNCIONINTRODUCCION}(9,11)\\
13. & (\varphi\wedge\varphi_{2})\rightarrow(\varphi\wedge(\varphi_{1}\vee\varphi_{2})) &  & \text{CONCLUSION}\\
14. & (\varphi\wedge(\varphi_{1}\vee\varphi_{2})) &  & \text{TESIS}1\text{DIVISIONPORCASOS}(1,7,13)\\
15. & ((\varphi\wedge\varphi_{1})\vee(\varphi\wedge\varphi_{2}))\rightarrow(\varphi\wedge(\varphi_{1}\vee\varphi_{2})) &  & \text{CONCLUSION}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo cualquiera y sea 
\begin_inset Formula $\varphi=_{d}\varphi(v)$
\end_inset

 una formula de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Ya que 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

 es un axioma logico, tenemos que
\begin_inset Formula 
\[
((\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi),\text{AXIOMALOGICO})
\]

\end_inset

es una prueba formal de 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

 en la teoria 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

.
 A continuacion se da una prueba formal en la teoria 
\begin_inset Formula $(\emptyset,\tau)$
\end_inset

 de la sentencia 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

 la cual no usa el hecho de que 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

 sea un axioma logico.
 Notar que en las primeras 10 lineas se prueba 
\begin_inset Formula $(\lnot\exists v\lnot\varphi\rightarrow\lnot\lnot\forall v\varphi)$
\end_inset

, es decir el contraresiproco de 
\begin_inset Formula $(\lnot\forall v\varphi\rightarrow\exists v\lnot\varphi)$
\end_inset

.
 De la linea 11 hasta la 17 se prueba 
\begin_inset Formula $(\lnot\forall v\varphi\rightarrow\exists v\lnot\varphi)$
\end_inset

.
 En las lineas restantes se prueba la implicacion reciproca de 
\begin_inset Formula $(\lnot\forall v\varphi\rightarrow\exists v\lnot\varphi)$
\end_inset

, es decir 
\begin_inset Formula $(\exists v\lnot\varphi\rightarrow\lnot\forall v\varphi)$
\end_inset

 y en el ultimo paso se obtiene 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

 por la regla de equivalencia-introduccion.
 Cabe observar que esta prueba formal no es natural u obvia, mas bien es
 dificil de encontrar.
\begin_inset Formula 
\[
\begin{array}{clll}
1. & \lnot\exists v\lnot\varphi &  & \text{HIPOTESIS}1\\
2. & \lnot\varphi(c) &  & \text{HIPOTESIS}2\\
3. & \exists v\lnot\varphi &  & \text{EXISTENCIAL}(2)\\
4. & (\exists v\lnot\varphi\wedge\lnot\exists v\lnot\varphi) &  & \text{TESIS}2\text{CONJUNCIONINTRODUCCION}(3,1)\\
5. & \lnot\varphi(c)\rightarrow(\exists v\lnot\varphi\wedge\lnot\exists v\lnot\varphi) &  & \text{CONCLUSION}\\
6. & \varphi(c) &  & \text{ABSURDO}(5)\\
7. & \forall v\varphi &  & \text{GENERALIZACION}(6)\\
8. & (\forall v\varphi\leftrightarrow\lnot\lnot\forall v\varphi) &  & \text{AXIOMALOGICO}\\
9. & \lnot\lnot\forall v\varphi &  & \text{TESIS}1\text{REEMPLAZO}(7,8)\\
10. & (\lnot\exists v\lnot\varphi\rightarrow\lnot\lnot\forall v\varphi) &  & \text{CONCLUSION}\\
11. & \lnot\forall v\varphi &  & \text{HIPOTESIS}3\\
12. & \lnot\exists v\lnot\varphi &  & \text{HIPOTESIS}4\\
13. & \lnot\lnot\forall v\varphi &  & \text{MODUSPONENS}(12,10)\\
14. & (\lnot\forall v\varphi\wedge\lnot\lnot\forall v\varphi) &  & \text{TESIS}4\text{CONJUNCIONINTRODUCCION}(11,13)\\
15. & \lnot\exists v\lnot\varphi\rightarrow(\lnot\forall v\varphi\wedge\lnot\lnot\forall v\varphi) &  & \text{CONCLUSION}\\
16. & \exists v\lnot\varphi &  & \text{TESIS}3\text{ABSURDO}(15)\\
17. & (\lnot\forall v\varphi\rightarrow\exists v\lnot\varphi) &  & \text{CONCLUSION}\\
18. & \exists v\lnot\varphi &  & \text{HIPOTESIS}5\\
19. & \lnot\varphi(e) &  & \text{ELECCION}(18)\\
20. & \forall v\varphi &  & \text{HIPOTESIS}6\\
21. & \varphi(e) &  & \text{PARTICULARIZACION}(20)\\
22. & (\varphi(e)\wedge\lnot\varphi(e)) &  & \text{TESIS}6\text{CONJUNCIONINTRODUCCION}(21,19)\\
23. & \forall v\varphi\rightarrow(\varphi(e)\wedge\lnot\varphi(e)) &  & \text{CONCLUSION}\\
24. & \lnot\forall v\varphi &  & \text{TESIS}5\text{ABSURDO}(23)\\
25. & (\exists v\lnot\varphi\rightarrow\lnot\forall v\varphi) &  & \text{CONCLUSION}\\
26. & (\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi) &  & \text{EQUIVALENCIAINTRODUCCION}(17,25)
\end{array}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
En virtud de la prueba formal anterior se tiene que si redujeramos la lista
 de axiomas logicos sacando las sentencias de la forma 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

, el concepto de prueba formal resultante seria equivalente al dado.
 La razon por la cual se incluyen las sentencias de la forma 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

 como axiomas logicos es que nuestra definicion de prueba formal en una
 teoria intenta modelizar o describir en forma matematica a las pruebas
 reales de los matematicos y la sentencia 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

 es obviamente cierta para un matematico por lo cual seria un detalle artificios
o de nuestra definicion si dicha sentencia resultara dificil de probar con
 el concepto de prueba formalizado.
 Dicho de otra forma, nuestro concepto de prueba formal no modelizaria en
 forma natural a las pruebas matematicas reales.
 No sucede lo mismo con los axiomas de la forma 
\begin_inset Formula $(\lnot\exists v\varphi\leftrightarrow\forall v\lnot\varphi)$
\end_inset

 los cuales se pueden probar formalmente en forma directa (y sin usar axiomas
 de las ultimas dos formas de axiomas logicos) tal como lo haria un matematico.
 Sin envargo hemos elejido incluir a las sentencias de la forma 
\begin_inset Formula $(\lnot\exists v\varphi\leftrightarrow\forall v\lnot\varphi)$
\end_inset

 como axiomas logicos por una cuestion estetica y mnemotecnica ya que ambos
 axiomas 
\begin_inset Formula $(\lnot\forall v\varphi\leftrightarrow\exists v\lnot\varphi)$
\end_inset

 y 
\begin_inset Formula $(\lnot\exists v\varphi\leftrightarrow\forall v\lnot\varphi)$
\end_inset

 estan muy emparentados ya que nos dicen como 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

eliminar la negacion de un cuantificador
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Formula $\bigskip$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Propiedades basicas de pruebas y teoremas
\end_layout

\begin_layout Standard
Por supuesto los numeros asociados a las hipotesis en una prueba son completamen
te arbitrarios y pueden cambiarse, es decir:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Cambio de indice de hipotesis
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "cambio-indice-hipotesis"

\end_inset

Sea 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Sea 
\begin_inset Formula $m\in\mathbf{N}$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{J}_{i}\neq$
\end_inset

 
\begin_inset Formula $\mathrm{HIPOTESIS}\bar{m}$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n(\mathbf{\varphi})$
\end_inset

.
 Supongamos que 
\begin_inset Formula $\mathbf{J}_{i}=$
\end_inset

 
\begin_inset Formula $\mathrm{HIPOTESIS}\bar{k}$
\end_inset

 y que 
\begin_inset Formula $\mathbf{J}_{j}=$
\end_inset

 
\begin_inset Formula $\mathrm{TESIS}\bar{k}\alpha$
\end_inset

, con 
\begin_inset Formula $[\alpha]_{1}\notin Num$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbf{\tilde{J}}$
\end_inset

 el resultado de reemplazar en 
\begin_inset Formula $\mathbf{J}$
\end_inset

 la justificacion 
\begin_inset Formula $\mathbf{J}_{i}$
\end_inset

 por 
\begin_inset Formula $\mathrm{HIPOTESIS}\bar{m}$
\end_inset

 y reemplazar la justificacion 
\begin_inset Formula $\mathbf{J}_{j}$
\end_inset

 por 
\begin_inset Formula $\mathrm{TESIS}\bar{m}\alpha$
\end_inset

.
 Entonces 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{\tilde{J}})$
\end_inset

 es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Tambien podemos cambiar los nombres de cte auxiliares
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Cambio de ctes auxiliares
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "cambio-ctes"

\end_inset

Sea 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Sea 
\begin_inset Formula $\mathcal{C}_{1}$
\end_inset

 el conjunto de nombres de constante que ocurren en 
\begin_inset Formula $\mathbf{\varphi}$
\end_inset

 y que no pertenecen a 
\begin_inset Formula $\mathcal{C}$
\end_inset

.
 Sea 
\begin_inset Formula $e\in\mathcal{C}_{1}$
\end_inset

.
 Sea 
\begin_inset Formula $\tilde{e}\notin\mathcal{C}\cup\mathcal{C}_{1}$
\end_inset

 tal que 
\begin_inset Formula $(\mathcal{C}\cup(\mathcal{C}_{1}-\{e\})\cup\{\tilde{e}\},\mathcal{F},\mathcal{R},a)$
\end_inset

 es un tipo.
 Sea 
\begin_inset Formula $\mathbf{\tilde{\varphi}}_{i}=$
\end_inset

 resultado de reemplazar en 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 cada ocurrencia de 
\begin_inset Formula $e$
\end_inset

 por 
\begin_inset Formula $\tilde{e}.$
\end_inset

 Entonces 
\begin_inset Formula $(\mathbf{\tilde{\varphi}}_{1}...\mathbf{\tilde{\varphi}}_{n(\mathbf{\varphi})},\mathbf{J})$
\end_inset

 es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sean
\begin_inset Formula 
\begin{align*}
\tau_{1} & =(\mathcal{C}\cup\mathcal{C}_{1},\mathcal{F},\mathcal{R},a)\\
\tau_{2} & =(\mathcal{C}\cup(\mathcal{C}_{1}-\{e\})\cup\{\tilde{e}\},\mathcal{F},\mathcal{R},a)
\end{align*}

\end_inset

Para cada 
\begin_inset Formula $c\in\mathcal{C}\cup(\mathcal{C}_{1}-\{e\})$
\end_inset

 definamos 
\begin_inset Formula $\tilde{c}=c$
\end_inset

.
 Notese que el mapeo 
\begin_inset Formula $c\rightarrow\tilde{c}$
\end_inset

 es una biyeccion entre el conjunto de nombres de constante de 
\begin_inset Formula $\tau_{1}$
\end_inset

 y el conjunto de nombres de cte de 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 Para cada 
\begin_inset Formula $t\in T^{\tau_{1}}$
\end_inset

 sea 
\begin_inset Formula $\tilde{t}=$
\end_inset

 resultado de reemplazar en 
\begin_inset Formula $t$
\end_inset

 cada ocurrencia de 
\begin_inset Formula $c$
\end_inset

 por 
\begin_inset Formula $\tilde{c}$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}\cup\mathcal{C}_{1}$
\end_inset

.
 Analogamente para una formula 
\begin_inset Formula $\psi\in F^{\tau_{1}}$
\end_inset

, sea 
\begin_inset Formula $\tilde{\psi}=$
\end_inset

 resultado de reemplazar en 
\begin_inset Formula $\psi$
\end_inset

 cada ocurrencia de 
\begin_inset Formula $c$
\end_inset

 por 
\begin_inset Formula $\tilde{c}$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}\cup\mathcal{C}_{1}$
\end_inset

.
 Notese que los mapeos 
\begin_inset Formula $t\rightarrow\tilde{t}$
\end_inset

 y 
\begin_inset Formula $\psi\rightarrow\tilde{\psi}$
\end_inset

 son biyecciones naturales entre 
\begin_inset Formula $T^{\tau_{1}}$
\end_inset

 y 
\begin_inset Formula $T^{\tau_{2}}$
\end_inset

 y entre 
\begin_inset Formula $F^{\tau_{1}}$
\end_inset

 y 
\begin_inset Formula $F^{\tau_{2}}$
\end_inset

, respectivamente.
 Notese que cualesquiera sean 
\begin_inset Formula $\psi_{1},\psi_{2}\in F^{\tau_{1}}$
\end_inset

, tenemos que 
\begin_inset Formula $\psi_{1}$
\end_inset

 se deduce de 
\begin_inset Formula $\psi_{2}$
\end_inset

 por la regla de generalizacion con constante 
\begin_inset Formula $c$
\end_inset

 sii 
\begin_inset Formula $\tilde{\psi}_{1}$
\end_inset

 se deduce de 
\begin_inset Formula $\tilde{\psi}_{2}$
\end_inset

 por la regla de generalizacion con constante 
\begin_inset Formula $\tilde{c}$
\end_inset

.
 Para las otras reglas sucede lo mismo.
 Notese tambien que 
\begin_inset Formula $c$
\end_inset

 ocurre en 
\begin_inset Formula $\psi$
\end_inset

 sii 
\begin_inset Formula $\tilde{c}$
\end_inset

 ocurre en 
\begin_inset Formula $\tilde{\psi}.$
\end_inset

 Mas aun notese que 
\begin_inset Formula $c$
\end_inset

 depende de 
\begin_inset Formula $d$
\end_inset

 en 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 sii 
\begin_inset Formula $\tilde{c}$
\end_inset

 depende de 
\begin_inset Formula $\tilde{d}$
\end_inset

 en 
\begin_inset Formula $(\mathbf{\tilde{\varphi}},\mathbf{J})$
\end_inset

, donde 
\begin_inset Formula $\mathbf{\tilde{\varphi}}=\widetilde{\mathbf{\varphi}_{1}}...\widetilde{\mathbf{\varphi}_{n(\mathbf{\varphi})}}$
\end_inset

.
 Ahora es facil chequear que 
\begin_inset Formula $(\mathbf{\tilde{\varphi}},\mathbf{J})$
\end_inset

 es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 basandose en que 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Propiedades basicas de 
\begin_inset Formula $\vdash$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop-bas-prueb"

\end_inset

Sea 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 una teoria.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

(Uso de Teoremas) Si 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi_{1},...,\varphi_{n}$
\end_inset

 y 
\begin_inset Formula $(\Sigma\cup\{\varphi_{1},...,\varphi_{n}\},\tau)\vdash\varphi,$
\end_inset

 entonces 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Supongamos 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi_{1},...,\varphi_{n}$
\end_inset

.
 Si 
\begin_inset Formula $R$
\end_inset

 es una regla distinta de GENERALIZACION y ELECCION y 
\begin_inset Formula $\varphi$
\end_inset

 se deduce de 
\begin_inset Formula $\varphi_{1},...,\varphi_{n}$
\end_inset

 por la regla 
\begin_inset Formula $R$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $(\Sigma,\tau)\vdash(\varphi\rightarrow\psi)$
\end_inset

 si y solo si 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)\vdash\psi$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Notese que basta con hacer el caso 
\begin_inset Formula $n=1$
\end_inset

.
 El caso con 
\begin_inset Formula $n\geq2$
\end_inset

 se obtiene aplicando 
\begin_inset Formula $n$
\end_inset

 veces el caso 
\begin_inset Formula $n=1$
\end_inset

.
 Supongamos entonces que 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi_{1}$
\end_inset

 y 
\begin_inset Formula $(\Sigma\cup\{\varphi_{1}\},\tau)\vdash\varphi$
\end_inset

.
 Sea 
\begin_inset Formula $(\alpha_{1}...\alpha_{h},I_{1}...I_{h})$
\end_inset

 una prueba formal de 
\begin_inset Formula $\varphi_{1}$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Sea 
\begin_inset Formula $(\psi_{1}...\psi_{m},J_{1}...J_{m})$
\end_inset

 una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma\cup\{\varphi_{1}\},\tau)$
\end_inset

.
 Notese que por los Lemas 
\begin_inset CommandInset ref
LatexCommand ref
reference "cambio-indice-hipotesis"
plural "false"
caps "false"
noprefix "false"

\end_inset

 y 
\begin_inset CommandInset ref
LatexCommand ref
reference "cambio-ctes"
plural "false"
caps "false"
noprefix "false"

\end_inset

 podemos suponer que estas dos pruebas no comparten ningun nombre de constante
 auxiliar y que tampoco comparten numeros asociados a hipotesis o tesis.
 Para cada 
\begin_inset Formula $i=1,...,m$
\end_inset

, definamos 
\begin_inset Formula $\widetilde{J_{i}}$
\end_inset

 de la siguiente manera.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\alpha\mathrm{AXIOMAPROPIO}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

 y 
\begin_inset Formula $\psi_{i}=\varphi_{1}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha\mathrm{EVOCACION}(\overline{h})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\alpha\mathrm{AXIOMAPROPIO}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

 y 
\begin_inset Formula $\psi_{i}\notin\{\varphi_{1}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha\mathrm{AXIOMAPROPIO}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\alpha\mathrm{AXIOMALOGICO}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha\mathrm{AXIOMALOGICO}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\alpha\mathrm{CONCLUSION}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha\mathrm{CONCLUSION}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\mathrm{HIPOTESIS}\bar{k}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\mathrm{HIPOTESIS}\bar{k}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\alpha R(\overline{l_{1}},...,\overline{l_{k}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha R(\overline{l_{1}+h},...,\overline{l_{k}+h})$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Es facil chequear que
\begin_inset Formula 
\[
(\alpha_{1}...\alpha_{h}\psi_{1}...\psi_{m},I_{1}...I_{h}\widetilde{J_{1}}...\widetilde{J_{m}})
\]

\end_inset

es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset


\end_layout

\begin_layout Standard
(2) Notese que
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & \varphi_{1} &  & \text{AXIOMAPROPIO}\\
2.\; & \varphi_{2} &  & \text{AXIOMAPROPIO}\\
\vdots & \vdots &  & \vdots\\
n. & \varphi_{n} &  & \text{AXIOMAPROPIO}\\
n+1. & \varphi &  & R(\bar{1},...,\bar{n})
\end{array}
\]

\end_inset

es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma\cup\{\varphi_{1},...,\varphi_{n}\},\tau)$
\end_inset

, lo cual por (1) nos dice que 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

.
\end_layout

\begin_layout Standard
(3) Supongamos 
\begin_inset Formula $(\Sigma,\tau)\vdash(\varphi\rightarrow\psi)$
\end_inset

.
 Entonces tenemos que 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)\vdash(\varphi\rightarrow\psi),\varphi$
\end_inset

, lo cual por (2) nos dice que 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)\vdash\psi$
\end_inset

.
 Supongamos ahora que 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)\vdash\psi$
\end_inset

.
 Sea 
\begin_inset Formula $(\varphi_{1}...\varphi_{n},J_{1}...,J_{n})$
\end_inset

 una prueba formal de 
\begin_inset Formula $\psi$
\end_inset

 en 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)$
\end_inset

.
 Para cada 
\begin_inset Formula $i=1,...,n$
\end_inset

, definamos 
\begin_inset Formula $\widetilde{J_{i}}$
\end_inset

 de la siguiente manera.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi_{i}=\varphi$
\end_inset

 y 
\begin_inset Formula $J_{i}=\alpha\mathrm{AXIOMAPROPIO}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha\mathrm{EVOCACION}(1)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $\varphi_{i}\neq\varphi$
\end_inset

 y 
\begin_inset Formula $J_{i}=\alpha\mathrm{AXIOMAPROPIO}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha\mathrm{AXIOMAPROPIO}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\alpha\mathrm{AXIOMALOGICO}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha\mathrm{AXIOMALOGICO}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\alpha\mathrm{CONCLUSION}$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha\mathrm{CONCLUSION}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\mathrm{HIPOTESIS}\bar{k}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\mathrm{HIPOTESIS}\bar{k}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $J_{i}=\alpha R(\overline{l_{1}},...,\overline{l_{k}})$
\end_inset

, con 
\begin_inset Formula $\alpha\in\{\varepsilon\}\cup\{\mathrm{TESIS}\bar{k}:k\in\mathbf{N}\}$
\end_inset

, entonces 
\begin_inset Formula $\widetilde{J_{i}}=\alpha P(\overline{l_{1}+1},...,\overline{l_{k}+1})$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Sea 
\begin_inset Formula $m$
\end_inset

 tal que ninguna 
\begin_inset Formula $J_{i}$
\end_inset

 es igual a 
\begin_inset Formula $\mathrm{HIPOTESIS}\bar{m}$
\end_inset

.
 Notese que 
\begin_inset Formula $\widetilde{J_{n}}$
\end_inset

 no es de la forma 
\begin_inset Formula $\mathrm{TESIS}\bar{k}\beta$
\end_inset

 ni de la forma 
\begin_inset Formula $\mathrm{HIPOTESIS}\bar{k}$
\end_inset

 (por que?) por lo cual 
\begin_inset Formula $\mathrm{TESIS}\bar{m}\widetilde{J_{n}}$
\end_inset

 es una justificacion.
 Es facil chequear que
\begin_inset Formula 
\[
(\varphi\varphi_{1}...\varphi_{n}(\varphi\rightarrow\psi),\text{HIPOTESIS}\bar{m}\widetilde{J_{1}}...\widetilde{J_{n-1}}\mathrm{TESIS}\bar{m}\widetilde{J_{n}}\text{CONCLUSION})
\]

\end_inset

es una prueba formal de 
\begin_inset Formula $(\varphi\rightarrow\psi)$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Consistencia
\end_layout

\begin_layout Standard
Una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera 
\shape italic
inconsistente
\shape default
 cuando haya una sentencia 
\begin_inset Formula $\varphi$
\end_inset

 tal que 
\begin_inset Formula $(\Sigma,\tau)\vdash(\varphi\wedge\lnot\varphi).$
\end_inset

 Una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera 
\shape italic
consistente
\shape default
 cuando no sea inconsistente.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Propiedades basicas de la consistencia
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop-bas-consistencia"

\end_inset

Sea 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 una teoria.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es inconsistente, entonces 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

, para toda sentencia 
\begin_inset Formula $\varphi.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es consistente y 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)$
\end_inset

 es consistente.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\Sigma,\tau)\not\vdash\lnot\varphi$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)$
\end_inset

 es consistente.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Si 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es inconsistente, entonces por definicion tenemos que 
\begin_inset Formula $(\Sigma,\tau)\vdash\psi\wedge\lnot\psi$
\end_inset

 para alguna sentencia 
\begin_inset Formula $\psi$
\end_inset

.
 Dada una sentencia cualquiera 
\begin_inset Formula $\varphi$
\end_inset

 tenemos que 
\begin_inset Formula $\varphi$
\end_inset

 se deduce por la regla del absurdo a partir de 
\begin_inset Formula $\psi\wedge\lnot\psi$
\end_inset

 con lo cual (2) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop-bas-prueb"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset


\end_layout

\begin_layout Standard
(2) Supongamos 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es consistente y 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

.
 Si 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)$
\end_inset

 fuera inconsistente, entonces 
\begin_inset Formula $(\Sigma\cup\{\varphi\},\tau)\vdash\psi\wedge\lnot\psi$
\end_inset

, para alguna sentencia 
\begin_inset Formula $\psi$
\end_inset

, lo cual por (1) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop-bas-prueb"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos diria que 
\begin_inset Formula $(\Sigma,\tau)\vdash\psi\wedge\lnot\psi$
\end_inset

, es decir nos diria que 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es inconsistente.
\end_layout

\begin_layout Standard
(3) es dejada al lector.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
El teorema de correccion
\end_layout

\begin_layout Standard
Como ya vimos en las secciones anteriores, el concepto matematico de prueba
 formal en una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 fue hecho como un intento de modelizar ciertas pruebas que realizan los
 matematicos profecionales, a las que llamamos pruebas elementales.
 Es claro que cuando un matematico hace una prueba elemental de una setencia
 
\begin_inset Formula $\varphi$
\end_inset

 en una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, comienza imaginando una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de tipo 
\begin_inset Formula $\tau$
\end_inset

 de la cual lo unico que sabe es que ella satisface todas las sentencias
 de 
\begin_inset Formula $\Sigma$
\end_inset

, y luego al finalizar la prueba concluye que dicho modelo imaginario satisface
 la ultima sentencia de la prueba.
 En algun sentido la mision de una prueba es justamente eso: justificar
 con solidez que la sentencia a probar vale en todos los modelos de la teoria.
\end_layout

\begin_layout Standard
O sea que si nuestro concepto de prueba formal permitiera probar sentencias
 que no sean verdaderas en todos los modelos de la teoria, no seria correcto.
 Este no es el caso y el teorema que asegura que las pruebas formales solo
 prueban sentencias verdaderas en todos los modelos de la teoria se llama
 Teorema de Correccion.
 Lo enunciaremos fomalmente a continuacion aunque no daremos la prueba ya
 que es dificultosa.
 Antes una definicion.
 Dada 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 una teoria, escribiremos 
\begin_inset Formula $(\Sigma,\tau)\models\varphi$
\end_inset

 cuando 
\begin_inset Formula $\varphi$
\end_inset

 sea verdadera en todo modelo de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

 implica 
\begin_inset Formula $(\Sigma,\tau)\models\varphi$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Cabe destacar que el teorema de correccion hace parte de la tarea encomendada
 en el punto (4) del programa de logica dado en la Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "programa"
plural "false"
caps "false"
noprefix "false"

\end_inset

 ya que asegura que nuestro concepto de prueba formal no es demaciado permisivo
 como para permitir probar sentencias que son falsas en algun modelo de
 la teoria.
 Pero dicho concepto podria ser incorrecto en el sentido que podria haber
 pruebas elementales dadas por matematicos la cuales no puedan ser simuladas
 por pruebas formales.
 Por ejemplo podria pasar que maana un matematico diera una prueba elemental
 de una sentencia 
\begin_inset Formula $\varphi$
\end_inset

 en una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 pero que no haya una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 En tal caso nuestro modelo de prueba formal seria un modelo erroneo del
 concepto de prueba elemental, por ser incompleto.
 Por supuesto en ese caso podriamos mejorarlo viendo la prueba elemental
 dada por dicho matematico y enrriquesiendo a la luz de dicha prueba nuestra
 definicion de prueba formal.
 De todas maneras nos quedaria la duda de que aun esta nueva definicion
 de prueba sea incompleta ....
 Como veremos el Teorema de Completitud de Godel prueba que este no es el
 caso!
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Un corolario muy importante del Teorema de Correccion es el siguiente.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Si 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 tiene un modelo, entonces 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es consistente.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $\mathbf{A}$
\end_inset

 es un modelo de 
\begin_inset Formula $(\Sigma,\tau).$
\end_inset

 Si 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 fuera inconsistente, tendriamos que hay una 
\begin_inset Formula $\varphi\in S^{t}$
\end_inset

 tal que 
\begin_inset Formula $(\Sigma,\tau)\vdash(\varphi\wedge\lnot\varphi)$
\end_inset

, lo cual por el Teorema de Correccion nos diria que 
\begin_inset Formula $\mathbf{A}\models(\varphi\wedge\lnot\varphi)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Concluimos la subseccion dando algunos ejemplos que muestran que si hacemos
 mas permisiva la definicion de prueba formal, esta ya no resulta correcta.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejemplo 1:
\end_layout

\end_inset

Este ejemplo muestra que en la sentencia a generalizar (dentro de una prueba
 formal) no puede ocurrir un nombre de cte el cual dependa del nombre de
 cte a generalizar.
 Sea 
\begin_inset Formula $\tau=(\emptyset,\{f^{1}\},\emptyset,a)$
\end_inset

 y sea 
\begin_inset Formula $\Sigma=\{\forall y\exists x\;y\equiv f(x)\}$
\end_inset

.
 Sea 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

.
 Notese que una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de tipo 
\begin_inset Formula $\tau$
\end_inset

 es modelo de 
\begin_inset Formula $T$
\end_inset

 sii 
\begin_inset Formula $f^{\mathbf{A}}$
\end_inset

 es una funcion sobre.
 Consideremos
\begin_inset Formula 
\[
\begin{array}{llll}
\ 1. & \forall y\exists x\;y\equiv f(x) &  & \text{AXIOMAPROPIO}\\
\ 2. & \exists x\;y_{0}\equiv f(x) &  & \text{PARTICULARIZACION}(1)\\
\ 3. & y_{0}\equiv f(e) &  & \text{ELECCION}(2)\\
\ 4. & \forall y\;y\equiv f(e) &  & \text{GENERALIZACION}(3)\\
\ 5. & c\equiv f(e) &  & \text{PARTICULARIZACION}(4)\\
\ 6. & d\equiv f(e) &  & \text{PARTICULARIZACION}(4)\\
\ 7. & f(e)\equiv d &  & \text{COMMUTATIVIDAD}(6)\\
\ 8. & c\equiv d &  & \text{TRANSITIVIDAD}(5,7)\\
\ 9. & \forall y\;c\equiv y &  & \text{GENERALIZACION}(8)\\
10. & \forall x\forall y\;x\equiv y &  & \text{GENERALIZACION}(9)
\end{array}
\]

\end_inset

Obviamente, si permitieramos que lo anterior fuera una prueba formal, dejaria
 de valer el teorema de correccion ya que hay muchos modelos de 
\begin_inset Formula $T$
\end_inset

, los cuales no satisfacen 
\begin_inset Formula $\forall x\forall y\;x\equiv y$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejemplo 2:
\end_layout

\end_inset

El siguiente ejemplo muestra que el nombre de cte a generalizar no puede
 ocurrir en hipotesis de la sentencia a la cual se le aplica la generalizacion.
 Sea 
\begin_inset Formula $\tau=(\{1\},\emptyset,\emptyset,\emptyset)$
\end_inset

 y sea 
\begin_inset Formula $T=(\emptyset,\tau)$
\end_inset

.
 Consideremos
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & c\equiv1 &  & \text{HIPOTESIS}1\\
2.\; & \forall x\;x\equiv1 &  & \text{TESIS}1\text{GENERALIZACION}(1)\\
3.\; & (c\equiv1\rightarrow\forall x\;x\equiv1) &  & \text{CONCLUSION}\\
4.\; & \forall y\;\left(y\equiv1\rightarrow\forall x\;x\equiv1\right) &  & \text{GENERALIZACION}(3)\\
5.\; & \left(1\equiv1\rightarrow\forall x\;x\equiv1\right) &  & \text{PARTICULARIZACION}(4)\\
6. & 1\equiv1 &  & \text{AXIOMALOGICO}\\
7. & \forall x\;x\equiv1 &  & \text{MODUSPONENS}(5,6)
\end{array}
\]

\end_inset

Si permitieramos que lo anterior fuera una prueba formal, dejaria de valer
 el teorema de correccion ya que hay muchos modelos de 
\begin_inset Formula $T$
\end_inset

 (toda estructura es un modelo de 
\begin_inset Formula $T$
\end_inset

) los cuales no satisfacen 
\begin_inset Formula $\forall x\;x\equiv1$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejemplo 3:
\end_layout

\end_inset

El siguiente ejemplo muestra que la sentencia a generalizar no puede tener
 una hipotesis en las cual ocurra un nombre de cte que dependa del nombre
 de cte que se generaliza.
 Sea 
\begin_inset Formula $\tau=(\emptyset,\emptyset,\emptyset,\emptyset)$
\end_inset

 y sea 
\begin_inset Formula $T=(\emptyset,\tau)$
\end_inset

.
 Consideremos
\begin_inset Formula 
\[
\begin{array}{llll}
\ 1. & c\equiv c &  & \text{AXIOMALOGICO}\\
\ 2. & \exists z\;z\equiv c &  & \text{EXISTENCIA}(1)\\
\ 3. & e\equiv c &  & \text{ELECCION}(2)\\
\ 4. & d\equiv e &  & \text{HIPOTESIS}1\\
\ 5. & d\equiv c &  & \text{TRANSITIVIDAD}(4,3)\\
\ 6. & \forall y\;d\equiv y &  & \text{TESIS}1\text{GENERALIZACION}(5)\\
\ 7. & d\equiv e\rightarrow\forall y\;d\equiv y &  & \text{CONCLUSION}\\
\ 8. & \forall x(x\equiv e\rightarrow\forall y\;x\equiv y) &  & \text{GENERALIZACION}(7)\\
\ 9. & e\equiv e\rightarrow\forall y\;e\equiv y &  & \text{PARTICULARIZACION}(8)\\
10. & e\equiv e &  & \text{AXIOMALOGICO}\\
11. & \forall y\;e\equiv y &  & \text{MODUSPONENS}(10,9)\\
12. & \forall y\;c\equiv y &  & \text{REEMPLAZO}(3,11)\\
13. & \forall x\forall y\;x\equiv y &  & \text{GENERALIZACION}(12)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "algebra.de.lindenbaum"

\end_inset


\end_layout

\begin_layout Subsection
El algebra de Lindenbaum
\end_layout

\begin_layout Standard
Recordemos que dado un tipo 
\begin_inset Formula $\tau$
\end_inset

, con 
\begin_inset Formula $S^{\tau}$
\end_inset

 denotamos el conjunto de las sentencias de tipo 
\begin_inset Formula $\tau$
\end_inset

, es decir
\begin_inset Formula 
\[
S^{\tau}=\{\varphi\in F^{\tau}:Li(\varphi)=\emptyset\}
\]

\end_inset

Sea 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

 una teoria.
 Podemos definir la siguiente relacion binaria sobre 
\begin_inset Formula $S^{\tau}$
\end_inset

:
\begin_inset Formula 
\[
\varphi\dashv\vdash_{T}\psi\text{ si y solo si }T\vdash\left(\varphi\leftrightarrow\psi\right)
\]

\end_inset

Es decir
\begin_inset Formula 
\[
\dashv\vdash_{T}=\{(\varphi,\psi)\in S^{\tau}:T\vdash\left(\varphi\leftrightarrow\psi\right)\}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $\dashv\vdash_{T}$
\end_inset

 es una relacion de equivalencia.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 La relacion es reflexiva ya que 
\begin_inset Formula $(\varphi\leftrightarrow\varphi)$
\end_inset

 es un axioma logico y por lo tanto 
\begin_inset Formula $((\varphi\leftrightarrow\varphi),$
\end_inset

AXIOMALOGICO
\begin_inset Formula $)$
\end_inset

 es una prueba formal de 
\begin_inset Formula $(\varphi\leftrightarrow\varphi)$
\end_inset

 en 
\begin_inset Formula $T$
\end_inset

.
 Veamos que es simetrica.
 Supongamos que 
\begin_inset Formula $\varphi\dashv\vdash_{T}\psi$
\end_inset

, es decir 
\begin_inset Formula $T\vdash\left(\varphi\leftrightarrow\psi\right)$
\end_inset

.
 Ya que 
\begin_inset Formula $\left(\psi\leftrightarrow\varphi\right)$
\end_inset

 se deduce de 
\begin_inset Formula $(\varphi\leftrightarrow\psi)$
\end_inset

 por la regla de commutatividad, (2) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop-bas-prueb"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $T\vdash\left(\psi\leftrightarrow\varphi\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Analogamente, usando la regla de transitividad se puede probar que 
\begin_inset Formula $\dashv\vdash_{T}$
\end_inset

 es transitiva.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Una sentencia 
\begin_inset Formula $\varphi$
\end_inset

 se dice 
\shape italic
refutable en 
\shape default

\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 si 
\begin_inset Formula $(\Sigma,\tau)\vdash\lnot\varphi$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "0 y 1 del algebra de lindembaum"

\end_inset

Dada una teoria 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

, se tiene que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\{\varphi\in S^{\tau}:\varphi$
\end_inset

 es un teorema de 
\begin_inset Formula $T\}\in S^{\tau}/\mathrm{\dashv\vdash}_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\{\varphi\in S^{\tau}:\varphi$
\end_inset

 es refutable en 
\begin_inset Formula $T\}\in S^{\tau}/\mathrm{\dashv\vdash}_{T}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Haremos la prueba de (2) y dejaremos la prueba de (1) como ejercicio.
 Sean 
\begin_inset Formula $\varphi,\psi$
\end_inset

 refutables en 
\begin_inset Formula $T$
\end_inset

, veremos que 
\begin_inset Formula $\varphi\dashv\vdash_{T}\psi$
\end_inset

.
 Notese que
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & \varphi &  & \text{HIPOTESIS}1\\
2.\; & \lnot\psi &  & \text{HIPOTESIS}2\\
3.\; & \lnot\varphi &  & \text{AXIOMAPROPIO}\\
4.\; & (\varphi\wedge\lnot\varphi) &  & \text{TESIS}2\text{CONJUNCIONINTRODUCCION}(1,3)\\
5. & \lnot\psi\rightarrow(\varphi\wedge\lnot\varphi) &  & \text{CONCLUSION}\\
6. & \psi &  & \text{TESIS}1\text{ABSURDO}(5)\\
7. & (\varphi\rightarrow\psi) &  & \text{CONCLUSION}\\
8. & \psi &  & \text{HIPOTESIS}3\\
9. & \lnot\varphi &  & \text{HIPOTESIS}4\\
10. & \lnot\psi &  & \text{AXIOMAPROPIO}\\
11. & (\psi\wedge\lnot\psi) &  & \text{TESIS}4\text{CONJUNCIONINTRODUCCION}(8,10)\\
12. & \lnot\varphi\rightarrow(\psi\wedge\lnot\psi) &  & \text{CONCLUSION}\\
13. & \varphi &  & \text{TESIS}3\text{ABSURDO}(12)\\
14. & (\psi\rightarrow\varphi) &  & \text{CONCLUSION}\\
15. & (\varphi\leftrightarrow\psi) &  & \text{EQUIVALENCIAINTRODUCCION}(7,14)
\end{array}
\]

\end_inset

justifica que 
\begin_inset Formula $(\Sigma\cup\{\lnot\varphi,\lnot\psi\},\tau)\vdash(\varphi\leftrightarrow\psi)$
\end_inset

 lo cual por (1) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop-bas-prueb"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $(\Sigma,\tau)\vdash(\varphi\leftrightarrow\psi)$
\end_inset

, obteniendo que 
\begin_inset Formula $\varphi\dashv\vdash_{T}\psi$
\end_inset

.
 Para terminar de probar (2) faltaria ver que si 
\begin_inset Formula $\varphi$
\end_inset

 es refutable en 
\begin_inset Formula $T$
\end_inset

 y 
\begin_inset Formula $\varphi\dashv\vdash_{T}\psi$
\end_inset

, entonces 
\begin_inset Formula $\psi$
\end_inset

 es refutable en 
\begin_inset Formula $T$
\end_inset

.
 Dejamos al lector la prueba.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dada una teoria 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

 y 
\begin_inset Formula $\varphi\in S^{\tau}$
\end_inset

, 
\begin_inset Formula $[\varphi]_{T}$
\end_inset

 denotara la clase de 
\begin_inset Formula $\varphi$
\end_inset

 con respecto a la relacion de equivalencia 
\begin_inset Formula $\dashv\vdash_{T}$
\end_inset

.
 Definiremos sobre 
\begin_inset Formula $S^{\tau}/\mathrm{\dashv\vdash}_{T}$
\end_inset

 las siguiente operacion binaria 
\begin_inset Formula $\mathsf{s}^{T}$
\end_inset

:
\begin_inset Formula 
\[
[\varphi]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\psi]_{T}=[(\varphi\vee\psi)]_{T}
\]

\end_inset

Una observacion importante es que para que la definicion anterior de la
 operacion 
\begin_inset Formula $\mathsf{s}^{T}$
\end_inset

 sea inambigua, debemos probar la siguiente propiedad
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $[\varphi]_{T}=[\varphi^{\prime}]_{T}$
\end_inset

 y 
\begin_inset Formula $[\psi]_{T}=[\psi^{\prime}]_{T}$
\end_inset

 entonces 
\begin_inset Formula $[(\varphi\vee\psi)]_{T}=[(\varphi^{\prime}\vee\psi^{\prime})]_{T}$
\end_inset

 
\end_layout

\begin_layout Standard
Es decir debemos probar que si 
\begin_inset Formula $T\vdash\left(\varphi\leftrightarrow\varphi^{\prime}\right)$
\end_inset

 y 
\begin_inset Formula $T\vdash\left(\psi\leftrightarrow\psi^{\prime}\right)$
\end_inset

, entonces 
\begin_inset Formula $T\vdash((\varphi\vee\psi)\leftrightarrow(\varphi^{\prime}\vee\psi^{\prime}))$
\end_inset

.
 Pero esto sigue de (1) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop-bas-prueb"
plural "false"
caps "false"
noprefix "false"

\end_inset

 ya que
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & \left(\varphi\leftrightarrow\varphi^{\prime}\right) &  & \text{AXIOMAPROPIO}\\
2.\; & \left(\psi\leftrightarrow\psi^{\prime}\right) &  & \text{AXIOMAPROPIO}\\
3.\; & ((\varphi\vee\psi)\leftrightarrow(\varphi\vee\psi)) &  & \text{AXIOMALOGICO}\\
4.\; & ((\varphi\vee\psi)\leftrightarrow(\varphi^{\prime}\vee\psi)) &  & \text{REEMPLAZO}(1,3)\\
5.\; & ((\varphi\vee\psi)\leftrightarrow(\varphi^{\prime}\vee\psi^{\prime})) &  & \text{REEMPLAZO}(2,4)
\end{array}
\]

\end_inset

atestigua que 
\begin_inset Formula $(\Sigma\cup\{\left(\varphi\leftrightarrow\varphi^{\prime}\right),\left(\psi\leftrightarrow\psi^{\prime}\right)\},\tau)\vdash((\varphi\vee\psi)\leftrightarrow(\varphi^{\prime}\vee\psi^{\prime}))$
\end_inset

.
 En forma analoga se puede ver que las siguientes igualdades definen en
 forma inambigua una operacion binaria 
\begin_inset Formula $\mathsf{i}^{T}$
\end_inset


\begin_inset space \space{}
\end_inset

sobre 
\begin_inset Formula $S^{\tau}/\mathrm{\dashv\vdash}_{T}$
\end_inset

 y una operacion unaria 
\begin_inset Formula $^{\mathsf{c}^{T}}$
\end_inset

 sobre 
\begin_inset Formula $S^{\tau}/\mathrm{\dashv\vdash}_{T}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
[\varphi]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\psi]_{T} & =[(\varphi\wedge\psi)]_{T}\\
([\varphi]_{T})^{\mathsf{c}^{T}} & =[\lnot\varphi]_{T}
\end{align*}

\end_inset

Dejamos al lector los detalles.
\end_layout

\begin_layout Standard
Dada una teoria 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

, denotemos con 
\begin_inset Formula $1^{T}$
\end_inset

 al conjunto 
\begin_inset Formula $\{\varphi\in S^{\tau}:\varphi$
\end_inset

 es un teorema de 
\begin_inset Formula $T\}$
\end_inset

 y con 
\begin_inset Formula $0^{T}$
\end_inset

 al conjunto 
\begin_inset Formula $\{\varphi\in S^{\tau}:\varphi$
\end_inset

 es refutable en 
\begin_inset Formula $T\}$
\end_inset

.
 Ya vimos en un lema anterior que 
\begin_inset Formula $0^{T}$
\end_inset

 y 
\begin_inset Formula $1^{T}$
\end_inset

 pertenecen a 
\begin_inset Formula $S^{\tau}/\mathrm{\dashv\vdash}_{T}$
\end_inset

.
 Podemos enunciar ahora el siguiente resultado, inspirado en la idea clasica
 de Boole para el calculo proposicional.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 Sea 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

 una teoria.
 Entonces 
\begin_inset Formula $(S^{\tau}/\mathrm{\dashv\vdash}_{T},\mathsf{s}^{T},\mathsf{i}^{T},^{\mathsf{c}^{T}},0^{T},1^{T})$
\end_inset

 es un algebra de Boole.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por definicion de algebra de Boole, debemos probar que cualesquiera sean
 
\begin_inset Formula $\varphi_{1},\varphi_{2},\varphi_{3}\in S^{\tau}$
\end_inset

, se cumplen las siguientes igualdades:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{1}]_{T}=[\varphi_{1}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{1}]_{T}=[\varphi_{1}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{2}]_{T}=[\varphi_{2}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{1}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{2}]_{T}=[\varphi_{2}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{1}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}([\varphi_{2}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{3}]_{T})=([\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{2}]_{T})\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{3}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}([\varphi_{2}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{3}]_{T})=([\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{2}]_{T})\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{3}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(7)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}([\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{2}]_{T})=[\varphi_{1}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(8)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}([\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{2}]_{T})=[\varphi_{1}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(9)
\end_layout

\end_inset


\begin_inset Formula $0^{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{1}]_{T}=[\varphi_{1}]_{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(10)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}1^{T}=1^{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(11)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}([\varphi_{1}]_{T})^{\mathsf{c}^{T}}=1^{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(12)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}([\varphi_{1}]_{T})^{\mathsf{c}^{T}}=0^{T}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(13)
\end_layout

\end_inset


\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}([\varphi_{2}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{3}]_{T})=([\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{2}]_{T})\;\mathsf{s}^{T}\mathsf{\;}([\varphi_{1}]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi_{3}]_{T})$
\end_inset

 
\end_layout

\begin_layout Standard
Veamos por ejemplo que se da (10), es decir probaremos que 
\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}1^{T}=1^{T}$
\end_inset

, cualesquiera sea la sentencia 
\begin_inset Formula $\varphi_{1}$
\end_inset

.
 Ya que 
\begin_inset Formula $\forall x_{1}(x_{1}\equiv x_{1})$
\end_inset

 es un teorema de 
\begin_inset Formula $T$
\end_inset

, atestiguado por la prueba formal
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & c\equiv c &  & \text{AXIOMALOGICO}\\
2.\; & \forall x_{1}(x_{1}\equiv x_{1}) &  & \text{GENERALIZACION}(1)
\end{array}
\]

\end_inset

(
\begin_inset Formula $c$
\end_inset

 es un nombre de cte no perteneciente a 
\begin_inset Formula $\mathcal{C}$
\end_inset

 y tal que 
\begin_inset Formula $(\mathcal{C}\cup\{c\},\mathcal{F},\mathcal{R},a)$
\end_inset

 es un tipo), tenemos que el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "0 y 1 del algebra de lindembaum"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $1^{T}=\{\varphi\in S^{\tau}:\varphi$
\end_inset

 es un teorema de 
\begin_inset Formula $T\}=[\forall x_{1}(x_{1}\equiv x_{1})]_{T}$
\end_inset

.
 Es decir que para probar (10) debemos probar que para cualquier 
\begin_inset Formula $\varphi_{1}\in S^{\tau}$
\end_inset

, se da que
\begin_inset Formula 
\[
[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\forall x_{1}(x_{1}\equiv x_{1})]_{T}=\{\varphi\in S^{\tau}:\varphi\text{ }\mathrm{es\ un\ teorema\ de\ }T\}
\]

\end_inset

Ya que 
\begin_inset Formula $[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\forall x_{1}(x_{1}\equiv x_{1})]_{T}=[\varphi_{1}\vee\forall x_{1}(x_{1}\equiv x_{1})]_{T}$
\end_inset

, debemos probar que 
\begin_inset Formula $\varphi_{1}\vee\forall x_{1}(x_{1}\equiv x_{1})$
\end_inset

 es un teorema de 
\begin_inset Formula $T$
\end_inset

, lo cual es atestiguado por la siguiente prueba formal
\begin_inset Formula 
\[
\begin{array}{llll}
1.\; & c\equiv c &  & \text{AXIOMALOGICO}\\
2.\; & \forall x_{1}(x_{1}\equiv x_{1}) &  & \text{GENERALIZACION}(1)\\
3. & (\varphi_{1}\vee\forall x_{1}(x_{1}\equiv x_{1})) &  & \text{DISJUNCIONINTRODUCCION}(2)
\end{array}
\]

\end_inset

Veamos ahora que se da (6), es decir veamos que
\begin_inset Formula 
\[
[\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}([\varphi_{2}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{3}]_{T})=([\varphi_{1}]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{2}]_{T})\;\mathsf{s}^{T}\mathsf{\;}[\varphi_{3}]_{T}
\]

\end_inset

cualesquiera sean 
\begin_inset Formula $\varphi_{1},\varphi_{2},\varphi_{3}\in S^{\tau}$
\end_inset

.
 Sean 
\begin_inset Formula $\varphi_{1},\varphi_{2},\varphi_{3}\in S^{\tau}$
\end_inset

 fijas.
 Por la definicion de la operacion 
\begin_inset Formula $\mathsf{s}^{T}$
\end_inset

 debemos probar que
\begin_inset Formula 
\[
[(\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3}))]_{T}=[((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3})]_{T}
\]

\end_inset

es decir, debemos probar que
\begin_inset Formula 
\[
T\vdash((\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3}))\leftrightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}))
\]

\end_inset

Notese que por (2) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop-bas-prueb"
plural "false"
caps "false"
noprefix "false"

\end_inset

, basta con probar que
\begin_inset Formula 
\begin{align*}
T & \vdash((\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3}))\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}))\\
T & \vdash(((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3})\rightarrow(\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3})))
\end{align*}

\end_inset

La siguiente es una prueba formal de 
\begin_inset Formula $((\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3}))\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}))$
\end_inset

 en 
\begin_inset Formula $T$
\end_inset

 y dejamos al lector la otra prueba formal.
\begin_inset Formula 
\[
\begin{array}{llll}
1. & (\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3})) &  & \text{HIPOTESIS}1\\
2. & \varphi_{1} &  & \text{HIPOTESIS}2\\
3. & (\varphi_{1}\vee\varphi_{2}) &  & \text{DISJUNCIONINTRODUCCION}(2)\\
4. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}2\text{DISJUNCIONINTRODUCCION}(3)\\
5. & \varphi_{1}\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}\\
6. & (\varphi_{2}\vee\varphi_{3}) &  & \text{HIPOTESIS}3\\
7. & \varphi_{2} &  & \text{HIPOTESIS}4\\
8. & (\varphi_{1}\vee\varphi_{2}) &  & \text{DISJUNCIONINTRODUCCION}(6)\\
9. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}4\text{DISJUNCIONINTRODUCCION}(7)\\
10. & \varphi_{2}\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}\\
11. & \varphi_{3} &  & \text{HIPOTESIS}5\\
12. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}5\text{DISJUNCIONINTRODUCCION}(11)\\
13. & \varphi_{3}\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}\\
14. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}3\text{DIVISIONPORCASOS}(6,10,13)\\
15. & (\varphi_{2}\vee\varphi_{3})\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}\\
16. & ((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{TESIS}1\text{DIVISIONPORCASOS}(1,5,15)\\
17. & (\varphi_{1}\vee(\varphi_{2}\vee\varphi_{3}))\rightarrow((\varphi_{1}\vee\varphi_{2})\vee\varphi_{3}) &  & \text{CONCLUSION}
\end{array}
\]

\end_inset

El resto de las propiedades pueden ser probadas en forma similar, algunas
 de las pruebas formales necesarias han sido dadas en los ejemplos que siguen
 a la definicion de prueba formal 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dada una teoria 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

, denotaremos con 
\begin_inset Formula $\mathcal{A}_{T}$
\end_inset

 al algebra de Boole 
\begin_inset Formula $(S^{\tau}/\mathrm{\dashv\vdash}_{T},\mathsf{s}^{T},\mathsf{i}^{T},^{\mathsf{c}^{T}},0^{T},1^{T})$
\end_inset

.
 El algebra 
\begin_inset Formula $\mathcal{A}_{T}$
\end_inset

 sera llamada el 
\shape italic
algebra de Lindenbaum de la teoria 
\shape default

\begin_inset Formula $T$
\end_inset

.
 Denotaremos con 
\begin_inset Formula $\leq^{T}$
\end_inset

 al orden parcial asociado al algebra de Boole 
\begin_inset Formula $\mathcal{A}_{T}$
\end_inset

 (es decir 
\begin_inset Formula $[\varphi]_{T}\leq^{T}[\psi]_{T}$
\end_inset

 si y solo si 
\begin_inset Formula $[\varphi]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\psi]_{T}=[\psi]_{T}$
\end_inset

).
 El siguiente lema nos da una descripcion agradable de 
\begin_inset Formula $\leq^{T}$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $T$
\end_inset

 una teoria.
 Se tiene que
\begin_inset Formula 
\[
[\varphi]_{T}\leq^{T}[\psi]_{T}\text{ si y solo si }T\vdash\left(\varphi\rightarrow\psi\right)
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos que 
\begin_inset Formula $[\varphi]_{T}\leq^{T}[\psi]_{T}$
\end_inset

, es decir supongamos que 
\begin_inset Formula $[\varphi]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\psi]_{T}=[\psi]_{T}$
\end_inset

.
 Por la definicion de 
\begin_inset Formula $\mathsf{s}^{T}$
\end_inset

 tenemos que 
\begin_inset Formula $[(\varphi\vee\psi)]_{T}=[\psi]_{T}$
\end_inset

, es decir 
\begin_inset Formula $T\vdash((\varphi\vee\psi)\leftrightarrow\psi)$
\end_inset

.
 Es facil ver entonces que 
\begin_inset Formula $T\vdash\left(\varphi\rightarrow\psi\right)$
\end_inset

.
 Reciprocamente si 
\begin_inset Formula $T\vdash\left(\varphi\rightarrow\psi\right)$
\end_inset

, entonces facilmente podemos probar que 
\begin_inset Formula $T\vdash((\varphi\vee\psi)\leftrightarrow\psi)$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $[(\varphi\vee\psi)]_{T}=[\psi]_{T}$
\end_inset

.
 Por la definicion de
\begin_inset Formula $\ \mathsf{s}^{T}$
\end_inset

 tenemos que 
\begin_inset Formula $[\varphi]_{T}\;\mathsf{s}^{T}\mathsf{\;}[\psi]_{T}=[\psi]_{T}$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $[\varphi]_{T}\leq^{T}[\psi]_{T}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Teorema de completitud
\end_layout

\begin_layout Standard
Hasta el momento tenemos una definicion matematica de prueba formal que
 modeliza el concepto intuitivo de prueba elemental, el cual corresponde
 al mundo real de los matematicos profecionales.
 Ahora bien, nada nos asegura que no aparesca un matematico que realize
 una prueba elemental de una sentencia 
\begin_inset Formula $\varphi$
\end_inset

 en una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, y que no haya una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 En tal caso nuestro concepto de prueba seria incompleto (como modelo) aunque,
 como ya se vio, el mismo es correcto.
 Esto podria pasar por ejemplo si nos hubiesemos olvidado de incluir en
 nuestra definicion de prueba formal alguna regla o accion que el matematico
 usara para probar dicha 
\begin_inset Formula $\varphi$
\end_inset

, es decir nos podria pasar que no podamos 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

traducir
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 dicha prueba elemental a una prueba formal.
 Parese dificil poder asegurar o probar que nuestro concepto de prueba formal
 sea completo en el sentido antes descripto ya que el concepto de prueba
 elemental es empirico puesto que depende de las acciones de la comunidad
 matematica profecional y ademas no tiene una formulacion precisa.
 Por otra parte nada nos asegura que los matematicos profecionales no vayan
 a descubrir en el futuro algun nuevo 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

truco
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 elemental y que nuestro concepto que era completo pase a ser incompleto.
\end_layout

\begin_layout Standard
Fue un verdadero desafio cientifico (de los aos cercanos a 1900) lidiar
 con estos problemas, y el teorema de completitud de Godel resuelve todo
 de una manera limpia y asombrosa.
 La razon es muy simple: Godel prueba que si una sentencia 
\begin_inset Formula $\varphi$
\end_inset

 es verdadera en todos los modelos de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, entonces hay una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Ya que toda prueba elemental que haga un matematico (ahora o en el futuro)
 siempre probara una sentencia que es verdadera en cada modelo de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

, el teorema de Godel nos garantiza que para cada prueba elemental (de ahora
 y del futuro) habra una prueba formal que pruebe la misma sentencia!
\end_layout

\begin_layout Standard
Por supuesto queda la posibilidad de que una prueba elemental dada por algun
 matematico no sea traducible en forma natural a una prueba formal que pruebe
 lo mismo (mas alla de que sepamos que hay una gracias a Godel).
 Sin envargo el lector se ira convenciendo que esto es improbable que suceda,
 a medida que vaya formalizando distintas pruebas elementales clasicas dadas
 por los matematicos a lo largo de la historia.
\end_layout

\begin_layout Standard
Cabe destacar que entonces el Teorema de Correccion junto con el Teorema
 de Completitud resuelven el punto (4) del programa de logica dado en la
 Seccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "programa"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Para probar el teorema de completitud necesitaremos algunos resultados.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "tipos-parecidos"

\end_inset

Sean 
\begin_inset Formula $\tau=(\mathcal{C},\mathcal{F},\mathcal{R},a)$
\end_inset

 y 
\begin_inset Formula $\tau^{\prime}=(\mathcal{C}^{\prime},\mathcal{F}^{\prime},\mathcal{R}^{\prime},a^{\prime})$
\end_inset

 tipos.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Si 
\begin_inset Formula $\mathcal{C}\subseteq\mathcal{C}^{\prime}$
\end_inset

, 
\begin_inset Formula $\mathcal{F}\subseteq\mathcal{F}^{\prime}$
\end_inset

, 
\begin_inset Formula $\mathcal{R}\subseteq\mathcal{R}^{\prime}$
\end_inset

 y 
\begin_inset Formula $a^{\prime}|_{\mathcal{F}\cup\mathcal{R}}=a$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

 implica 
\begin_inset Formula $(\Sigma,\tau^{\prime})\vdash\varphi$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\mathcal{C}\subseteq\mathcal{C}^{\prime}$
\end_inset

, 
\begin_inset Formula $\mathcal{F}=\mathcal{F}^{\prime}$
\end_inset

, 
\begin_inset Formula $\mathcal{R}=\mathcal{R}^{\prime}$
\end_inset

 y 
\begin_inset Formula $a^{\prime}=a$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma,\tau^{\prime})\vdash\varphi$
\end_inset

 implica 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

, cada vez que 
\begin_inset Formula $\Sigma\cup\{\varphi\}\subseteq S^{\tau}.$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Supongamos 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

.
 Entonces hay una prueba formal 
\begin_inset Formula $(\varphi_{1}...\varphi_{n},J_{1}...J_{n})$
\end_inset

 de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Notese que aplicando varias veces el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "cambio-ctes"
plural "false"
caps "false"
noprefix "false"

\end_inset

 podemos obtener una prueba formal 
\begin_inset Formula $(\tilde{\varphi}_{1}...\tilde{\varphi}_{n},J_{1}...J_{n})$
\end_inset

 de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 la cual cumple que si 
\begin_inset Formula $\mathcal{C}_{2}$
\end_inset

 es el conjunto de nombres de constante que ocurren en 
\begin_inset Formula $\tilde{\varphi}_{1}...\tilde{\varphi}_{n}$
\end_inset

 y que no pertenecen a 
\begin_inset Formula $\mathcal{C}$
\end_inset

, entonces:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\mathcal{C}_{2}\cap\mathcal{C}^{\prime}=\emptyset$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\mathcal{C}^{\prime}\cup\mathcal{C}_{2},\mathcal{F}^{\prime},\mathcal{R}^{\prime},a^{\prime})$
\end_inset

 es un tipo 
\end_layout

\begin_layout Standard
\noindent
Pero entonces 
\begin_inset Formula $(\tilde{\varphi}_{1}...\tilde{\varphi}_{n},J_{1}...J_{n})$
\end_inset

 es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau^{\prime})$
\end_inset

, con lo cual 
\begin_inset Formula $(\Sigma,\tau^{\prime})\vdash\varphi$
\end_inset


\end_layout

\begin_layout Standard
(2) Supongamos 
\begin_inset Formula $(\Sigma,\tau^{\prime})\vdash\varphi$
\end_inset

.
 Entonces hay una prueba formal 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau^{\prime})$
\end_inset

.
 Veremos que 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Ya que 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 es una prueba formal de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau^{\prime})$
\end_inset

 hay un conjunto finito 
\begin_inset Formula $\mathcal{C}_{1}$
\end_inset

, disjunto con 
\begin_inset Formula $\mathcal{C}^{\prime}$
\end_inset

, tal que 
\begin_inset Formula $(\mathcal{C}^{\prime}\cup\mathcal{C}_{1},\mathcal{F},\mathcal{R},a)$
\end_inset

 es un tipo y cada 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 es una sentencia de tipo 
\begin_inset Formula $(\mathcal{C}^{\prime}\cup\mathcal{C}_{1},\mathcal{F},\mathcal{R},a)$
\end_inset

.
 Sea 
\begin_inset Formula $\widetilde{\mathcal{C}_{1}}=\mathcal{C}_{1}\cup(\mathcal{C}^{\prime}-\mathcal{C})$
\end_inset

.
 Notese que 
\begin_inset Formula $\mathcal{C}\cup\widetilde{\mathcal{C}_{1}}=\mathcal{C}^{\prime}\cup\mathcal{C}_{1}$
\end_inset

 por lo cual 
\begin_inset Formula $(\mathcal{C}\cup\widetilde{\mathcal{C}_{1}},\mathcal{F},\mathcal{R},a)$
\end_inset

 es un tipo y cada 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 es una sentencia de tipo 
\begin_inset Formula $(\mathcal{C}\cup\widetilde{\mathcal{C}_{1}},\mathcal{F},\mathcal{R},a)$
\end_inset

.
 Esto nos dice que 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 cumple (1) de la definicion de prueba formal en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Todos los otros puntos se cumplen en forma directa, exepto los puntos (4)(t)
 y (4)(u)(i) para los cuales es necesario notar que 
\begin_inset Formula $\mathcal{C}\subseteq\mathcal{C}^{\prime}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Lema del infimo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lema-del-infimo"

\end_inset

Sea 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

 una teoria y supongamos que 
\begin_inset Formula $\tau$
\end_inset

 tiene una cantidad infinita de nombres de cte que no ocurren en las sentencias
 de 
\begin_inset Formula $\Sigma$
\end_inset

.
 Entonces para cada formula 
\begin_inset Formula $\varphi=_{d}\varphi(v)$
\end_inset

, se tiene que en el algebra de Lindembaum 
\begin_inset Formula $\mathcal{A}_{T}$
\end_inset

:
\begin_inset Formula 
\[
[\forall v\varphi(v)]_{T}=\inf(\{[\varphi(t)]_{T}:t\in T_{c}^{\tau}\}).
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Haremos primero el caso en que 
\begin_inset Formula $v$
\end_inset

 no ocurre acotadamente en 
\begin_inset Formula $\varphi$
\end_inset

.
 Primero notese que 
\begin_inset Formula $[\forall v\varphi(v)]_{T}\leq^{T}[\varphi(t)]_{T}$
\end_inset

, para todo termino cerrado 
\begin_inset Formula $t$
\end_inset

, ya que podemos dar la siguiente prueba formal:
\begin_inset Formula 
\[
\begin{array}{cllll}
1. & \forall v\varphi(v) &  &  & \text{HIPOTESIS}1\\
2. & \varphi(t) &  &  & \text{TESIS}1\text{PARTICULARIZACION}(1)\\
3. & (\forall v\varphi(v)\rightarrow\varphi(t)) &  &  & \text{CONCLUSION}
\end{array}
\]

\end_inset

Supongamos ahora que 
\begin_inset Formula $[\psi]_{T}\leq^{T}[\varphi(t)]_{T}$
\end_inset

, para todo termino cerrado 
\begin_inset Formula $t.$
\end_inset

 Por hipotesis hay un nombre de cte 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

 el cual no ocurre en los elementos de 
\begin_inset Formula $\Sigma\cup\{\psi,\varphi(v)\}$
\end_inset

.
 Ya que 
\begin_inset Formula $[\psi]_{T}\leq^{T}[\varphi(c)]_{T}$
\end_inset

, hay una prueba formal 
\begin_inset Formula $(\varphi_{1}...\varphi_{n},J_{1}...J_{n})$
\end_inset

 de 
\begin_inset Formula $\left(\psi\rightarrow\varphi(c)\right)$
\end_inset

 en 
\begin_inset Formula $T$
\end_inset

.
 Pero entonces es facil de chequear que la siguiente es una prueba formal
 en 
\begin_inset Formula $(\Sigma,(\mathcal{C}-\{c\},\mathcal{F},\mathcal{R},a))$
\end_inset

 de 
\begin_inset Formula $\left(\psi\rightarrow\forall v\varphi(v)\right)$
\end_inset

:
\begin_inset Formula 
\[
\begin{array}{rlcl}
1. & \varphi_{1} &  & J_{1}\\
2. & \varphi_{2} &  & J_{2}\\
\vdots & \vdots &  & \vdots\\
n. & \varphi_{n}=\left(\psi\rightarrow\varphi(c)\right) &  & J_{n}\\
n+1. & \psi &  & \text{HIPOTESIS}\bar{m}\\
n+2. & \varphi(c) &  & \text{MODUSPONENS}(\overline{n+1},\bar{n})\\
n+3. & \forall v\varphi(v) &  & \text{TESIS}\bar{m}\text{GENERALIZACION}(\overline{n+2})\\
n+4. & \left(\psi\rightarrow\forall v\varphi(v)\right) &  & \text{CONCLUSION}
\end{array}
\]

\end_inset

(con 
\begin_inset Formula $m$
\end_inset

 elejido suficientemente grande y 
\begin_inset Formula $\tau_{1}=\tau$
\end_inset

 en la definicion de prueba, es decir con 
\begin_inset Formula $c$
\end_inset

 como el unico nombre de cte auxiliar de la prueba).
 Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "tipos-parecidos"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos entonces que 
\begin_inset Formula $T\vdash\left(\psi\rightarrow\forall v\varphi(v)\right)$
\end_inset

.
 Cabe destacar que es necesaria la asumsion de que 
\begin_inset Formula $v$
\end_inset

 no ocurra acotadamente en 
\begin_inset Formula $\varphi$
\end_inset

 para que 
\begin_inset Formula $(\varphi(c),\forall v\varphi(v))\in Generaliz^{\tau}$
\end_inset

 (por que?).
\end_layout

\begin_layout Standard
Ahora supongamos el caso mas general donde 
\begin_inset Formula $v$
\end_inset

 puede ocurrir acotadamente en 
\begin_inset Formula $\varphi$
\end_inset

.
 Sea 
\begin_inset Formula $\gamma=\varphi(w)$
\end_inset

, donde 
\begin_inset Formula $w$
\end_inset

 es una variable que no ocurre en 
\begin_inset Formula $\varphi$
\end_inset

.
 Claramente 
\begin_inset Formula $Li(\gamma)\subseteq\{w\}$
\end_inset

.
 Declaremos 
\begin_inset Formula $\gamma=_{d}\gamma(w)$
\end_inset

.
 Notese que 
\begin_inset Formula $w$
\end_inset

 no ocurre acotadamente en 
\begin_inset Formula $\gamma$
\end_inset

.
 Por lo ya probado tenemos que
\begin_inset Formula 
\[
[\forall w\gamma(w)]_{T}=\inf(\{[\gamma(t)]_{T}:t\in T_{c}^{\tau}\})
\]

\end_inset

Pero 
\begin_inset Formula $[\forall v\varphi(v)]_{T}=[\forall w\gamma(w)]_{T}$
\end_inset

 ya que
\begin_inset Formula 
\[
\begin{array}{rlcl}
1. & \forall v\varphi(v) &  & \text{HIPOTESIS}1\\
2. & \varphi(c)\text{ (es igual a }\gamma(c)\text{)} &  & \text{PARTICULARIZACION}(1)\\
3. & \forall w\gamma(w) &  & \text{TESIS}1\text{GENERALIZACION}(2)\\
4. & (\forall v\varphi(v)\rightarrow\forall w\gamma(w)) &  & \text{CONCLUSION}
\end{array}
\]

\end_inset

y
\begin_inset Formula 
\[
\begin{array}{rlcl}
1. & \forall w\gamma(w) &  & \text{HIPOTESIS}1\\
2. & \varphi(c)\text{ (es igual a }\gamma(c)\text{)} &  & \text{PARTICULARIZACION}(1)\\
3. &  &  & \text{TESIS}1\text{GENERALIZACION}(2)\\
4. & (\forall v\varphi(v)\rightarrow\forall w\gamma(w)) &  & \text{CONCLUSION}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
es claro que
\begin_inset Formula 
\begin{align*}
[\forall v\varphi(v)]_{T} & =[\forall w\gamma(w)]_{T}\\{}
[\varphi(t)]_{T} & =[\gamma(t)]_{T}\text{ para cada }t\in T_{c}^{\tau}\})
\end{align*}

\end_inset

por lo cual obtenemos que
\begin_inset Formula 
\[
[\forall v\varphi(v)]_{T}=\inf(\{[\varphi(t)]_{T}:t\in T_{c}^{\tau}\}).
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Lema de Coincidencia
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset

Sean 
\begin_inset Formula $\tau$
\end_inset

 y 
\begin_inset Formula $\tau^{\prime}$
\end_inset

 dos tipos cualesquiera y sea 
\begin_inset Formula $\tau_{\cap}=(\mathcal{C}_{\cap},\mathcal{F}_{\cap},\mathcal{R}_{\cap},a_{\cap})$
\end_inset

, donde
\begin_inset Formula 
\begin{align*}
\mathcal{C}_{\cap} & =\mathcal{C}\cap\mathcal{C}^{\prime}\\
\mathcal{F}_{\cap} & =\{f\in\mathcal{F}\cap\mathcal{F}^{\prime}:a(f)=a^{\prime}(f)\}\\
\mathcal{R}_{\cap} & =\{r\in\mathcal{R}\cap\mathcal{R}^{\prime}:a(r)=a^{\prime}(r)\}\\
a_{\cap} & =a|_{\mathcal{F}_{\cap}\cup\mathcal{R}_{\cap}}
\end{align*}

\end_inset

Entonces 
\begin_inset Formula $\tau_{\cap}$
\end_inset

 es un tipo tal que 
\begin_inset Formula $T^{\tau_{\cap}}=T^{\tau}\cap T^{\tau^{\prime}}$
\end_inset

 y 
\begin_inset Formula $F^{\tau_{\cap}}=F^{\tau}\cap F^{\tau^{\prime}}$
\end_inset

.
 Sean 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\mathbf{A}^{\prime}$
\end_inset

 modelos de tipo 
\begin_inset Formula $\tau$
\end_inset

 y 
\begin_inset Formula $\tau^{\prime}$
\end_inset

 respectivamente.
 Supongamos que 
\begin_inset Formula $A=A^{\prime}$
\end_inset

 y que 
\begin_inset Formula $c^{\mathbf{A}}=c^{\mathbf{A}^{\prime}}$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}_{\cap}$
\end_inset

, 
\begin_inset Formula $f^{\mathbf{A}}=f^{\mathbf{A}^{\prime}}$
\end_inset

, para cada 
\begin_inset Formula $f\in\mathcal{F}_{\cap}$
\end_inset

 y 
\begin_inset Formula $r^{\mathbf{A}}=r^{\mathbf{A}^{\prime}}$
\end_inset

, para cada 
\begin_inset Formula $r\in\mathcal{R}_{\cap}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $t=_{d}t(\vec{v})\in T^{\tau_{\cap}}$
\end_inset

 se tiene que 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=t^{\mathbf{A}^{\prime}}[\vec{a}]$
\end_inset

, para cada 
\begin_inset Formula $\vec{a}\in A^{n}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $\varphi=_{d}\varphi(\vec{v})\in F^{\tau_{\cap}}$
\end_inset

 se tiene que
\begin_inset Formula 
\[
\mathbf{A}\models\varphi[\vec{a}]\text{ si y solo si }\mathbf{A}^{\prime}\models\varphi[\vec{a}]\text{.}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset

Si 
\begin_inset Formula $\Sigma\cup\{\varphi\}\subseteq S^{\tau_{\cap}}$
\end_inset

, entonces
\begin_inset Formula 
\[
(\Sigma,\tau)\models\varphi\text{ sii }(\Sigma,\tau^{\prime})\models\varphi\text{.}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dejamos al lector probar que 
\begin_inset Formula $\tau_{\cap}$
\end_inset

 es un tipo, 
\begin_inset Formula $T^{\tau_{\cap}}=T^{\tau}\cap T^{\tau^{\prime}}$
\end_inset

 y 
\begin_inset Formula $F^{\tau_{\cap}}=F^{\tau}\cap F^{\tau^{\prime}}$
\end_inset

.
\end_layout

\begin_layout Standard
(a) y (b) son directos por induccion.
\end_layout

\begin_layout Standard
(c) Supongamos que 
\begin_inset Formula $(\Sigma,\tau)\models\varphi$
\end_inset

.
 Sea 
\begin_inset Formula $\mathbf{A}^{\prime}$
\end_inset

 un modelo de 
\begin_inset Formula $\tau^{\prime}$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{A}^{\prime}\models\Sigma$
\end_inset

.
 Sea 
\begin_inset Formula $a\in A^{\prime}$
\end_inset

 un elemento fijo.
 Sea 
\begin_inset Formula $\mathbf{A}$
\end_inset

 el modelo de tipo 
\begin_inset Formula $\tau$
\end_inset

 definido de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

universo de 
\begin_inset Formula $\mathbf{A}=$
\end_inset

 
\begin_inset Formula $A^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{A}}=c^{\mathbf{A}^{\prime}}$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}_{\cap}$
\end_inset

,
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{A}}=f^{\mathbf{A}^{\prime}}$
\end_inset

, para cada 
\begin_inset Formula $f\in\mathcal{F}_{\cap}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r^{\mathbf{A}}=r^{\mathbf{A}^{\prime}}$
\end_inset

, para cada 
\begin_inset Formula $r\in\mathcal{R}_{\cap}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{A}}=a$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}-\mathcal{C}_{\cap}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{A}}(a_{1},...,a_{a(f)})=a$
\end_inset

, para cada 
\begin_inset Formula $f\in\mathcal{F}-\mathcal{F}_{\cap}$
\end_inset

, 
\begin_inset Formula $a_{1},...,a_{a(f)}\in A^{\prime}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r^{\mathbf{A}}=\emptyset$
\end_inset

, para cada 
\begin_inset Formula $r\in\mathcal{R-R}_{\cap}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Ya que 
\begin_inset Formula $\mathbf{A}^{\prime}\models\Sigma$
\end_inset

, (b) nos dice que 
\begin_inset Formula $\mathbf{A}\models\Sigma$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $\mathbf{A}\models\varphi$
\end_inset

.
 Nuevamente por (b) tenemos que 
\begin_inset Formula $\mathbf{A}^{\prime}\models\varphi$
\end_inset

, con lo cual hemos probado que 
\begin_inset Formula $(\Sigma,\tau^{\prime})\models\varphi$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\tau$
\end_inset

 un tipo.
 Hay una infinitupla 
\begin_inset Formula $(\gamma_{1},\gamma_{2},...)\in F^{\tau\mathbf{N}}$
\end_inset

 tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\left\vert Li(\gamma_{j})\right\vert \leq1$
\end_inset

, para cada 
\begin_inset Formula $j=1,2,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Si 
\begin_inset Formula $\left\vert Li(\gamma)\right\vert \leq1$
\end_inset

, entonces 
\begin_inset Formula $\gamma=\gamma_{j}$
\end_inset

, para algun 
\begin_inset Formula $j\in\mathbf{N}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que las formulas de tipo 
\begin_inset Formula $\tau$
\end_inset

 son palabras de algun alfabeto finito 
\begin_inset Formula $A$
\end_inset

.
 Dado un orden total 
\begin_inset Formula $\leq$
\end_inset

 para 
\begin_inset Formula $A$
\end_inset

, podemos definir
\begin_inset Formula 
\begin{align*}
\gamma_{1} & =\min\nolimits _{\alpha}^{\leq}\left(\alpha\in F^{\tau}\wedge\left\vert Li(\alpha)\right\vert \leq1\right)\\
\gamma_{t+1} & =\min\nolimits _{\alpha}^{\leq}\left(\alpha\in F^{\tau}\wedge\left\vert Li(\alpha)\right\vert \leq1\wedge(\forall i\in\omega)_{i\leq t}\alpha\neq\gamma_{i}\right)
\end{align*}

\end_inset

Notese que para 
\begin_inset Formula $t\in\mathbf{N}$
\end_inset

, tenemos que 
\begin_inset Formula $\gamma_{t}=t$
\end_inset

-esimo elemento de 
\begin_inset Formula $\{\alpha\in F^{\tau}:\left\vert Li(\alpha)\right\vert \leq1\}$
\end_inset

, con respecto al orden total de 
\begin_inset Formula $A^{\ast}$
\end_inset

 inducido por 
\begin_inset Formula $\leq$
\end_inset

.
 Claramente entonces la infinitupla 
\begin_inset Formula $(\gamma_{1},\gamma_{2},...)$
\end_inset

 cumple (1) y (2).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora si, el famoso resultado de Godel.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
Sea 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

 una teoria de primer orden.
 Si 
\begin_inset Formula $T\models\varphi$
\end_inset

, entonces 
\begin_inset Formula $T\vdash\varphi$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Primero probaremos completitud para el caso en que 
\begin_inset Formula $\tau$
\end_inset

 tiene una cantidad infinita de nombres de cte que no ocurren en las sentencias
 de 
\begin_inset Formula $\Sigma$
\end_inset

.
 Lo probaremos por el absurdo, es decir supongamos que hay una sentencia
 
\begin_inset Formula $\varphi_{0}$
\end_inset

 tal que 
\begin_inset Formula $T\models\varphi_{0}$
\end_inset

 y 
\begin_inset Formula $T\not\vdash\varphi_{0}$
\end_inset

.
 Notese que ya que 
\begin_inset Formula $T\not\vdash\varphi_{0}$
\end_inset

, tenemos que 
\begin_inset Formula $[\lnot\varphi_{0}]_{T}\not=0^{T}$
\end_inset

.
 Por el lema anterior hay una infinitupla 
\begin_inset Formula $(\gamma_{1},\gamma_{2},...)\in F^{\tau\mathbf{N}}$
\end_inset

 tal que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\left\vert Li(\gamma_{j})\right\vert \leq1$
\end_inset

, para cada 
\begin_inset Formula $j=1,2,...$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Si 
\begin_inset Formula $\left\vert Li(\gamma)\right\vert \leq1$
\end_inset

, entonces 
\begin_inset Formula $\gamma=\gamma_{j}$
\end_inset

, para algun 
\begin_inset Formula $j\in\mathbf{N}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Para cada 
\begin_inset Formula $j\in\mathbf{N}$
\end_inset

, sea 
\begin_inset Formula $w_{j}\in Var$
\end_inset

 tal que 
\begin_inset Formula $Li(\gamma_{j})\subseteq\{w_{j}\}$
\end_inset

.
 Para cada 
\begin_inset Formula $j$
\end_inset

, declaremos 
\begin_inset Formula $\gamma_{j}=_{d}\gamma_{j}(w_{j})$
\end_inset

.
 Notese que por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "lema-del-infimo"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $\inf\{[\gamma_{j}(t)]_{T}:t\in T_{c}^{\tau}\}=[\forall w_{j}\gamma_{j}(w_{j})]_{T}$
\end_inset

, para cada 
\begin_inset Formula $j=1,2,...$
\end_inset

.
 Por el Teorema de Rasiova y Sikorski tenemos que hay un filtro primo 
\begin_inset Formula $\mathcal{U}$
\end_inset

 de 
\begin_inset Formula $\mathcal{A}_{T}$
\end_inset

, el cual cumple:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $[\lnot\varphi_{0}]_{T}\in\mathcal{U}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $j\in\mathbf{N}$
\end_inset

, 
\begin_inset Formula $\{[\gamma_{j}(t)]_{T}:t\in T_{c}^{\tau}\}\subseteq\mathcal{U}$
\end_inset

 implica que 
\begin_inset Formula $[\forall w_{j}\gamma_{j}(w_{j})]_{T}\in\mathcal{U}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Ya que la infinitupla 
\begin_inset Formula $(\gamma_{1},\gamma_{2},...)$
\end_inset

 cubre todas las formulas con a lo sumo una variable libre, podemos reescribir
 la propiedad (b) de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\begin_inset Formula $^{\prime}$
\end_inset


\end_layout

\end_inset

Para cada 
\begin_inset Formula $\varphi=_{d}\varphi(v)\in F^{\tau}$
\end_inset

, si 
\begin_inset Formula $\{[\varphi(t)]_{T}:t\in T_{c}^{\tau}\}\subseteq\mathcal{U}$
\end_inset

 entonces 
\begin_inset Formula $[\forall v\varphi(v)]_{T}\in\mathcal{U}$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Definamos sobre 
\begin_inset Formula $T_{c}^{\tau}$
\end_inset

 la siguiente relacion:
\begin_inset Formula 
\[
t\bowtie s\text{ si y solo si }[(t\equiv s)]_{T}\in\mathcal{U}\text{.}
\]

\end_inset

Veamos entonces que:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\bowtie$
\end_inset

 es de equivalencia.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})\in F^{\tau}$
\end_inset

, 
\begin_inset Formula $t_{1},...,t_{n},s_{1},...,s_{n}\in T_{c}^{\tau}$
\end_inset

, si 
\begin_inset Formula $t_{1}\bowtie s_{1}$
\end_inset

, 
\begin_inset Formula $t_{2}\bowtie s_{2}$
\end_inset

, 
\begin_inset Formula $...$
\end_inset

, 
\begin_inset Formula $t_{n}\bowtie s_{n}$
\end_inset

, entonces 
\begin_inset Formula $[\varphi(t_{1},...,t_{n})]_{T}\in\mathcal{U}$
\end_inset

 si y solo si 
\begin_inset Formula $[\varphi(s_{1},...,s_{n})]_{T}\in\mathcal{U}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $t_{1},...,t_{n},s_{1},...,s_{n}\in T_{c}^{\tau}$
\end_inset

,
\begin_inset Formula 
\[
t_{1}\bowtie s_{1},t_{2}\bowtie s_{2},...,\;t_{n}\bowtie s_{n}\text{ implica }f(t_{1},...,t_{n})\bowtie f(s_{1},...,s_{n}).
\]

\end_inset


\end_layout

\begin_layout Standard
Probaremos (2).
 Notese que
\begin_inset Formula 
\[
T\vdash\left((t_{1}\equiv s_{1})\wedge(t_{2}\equiv s_{2})\wedge...\wedge(t_{n}\equiv s_{n})\wedge\varphi(t_{1},...,t_{n})\right)\rightarrow\varphi(s_{1},...,s_{n})
\]

\end_inset

lo cual nos dice que
\begin_inset Formula 
\[
[(t_{1}\equiv s_{1})]_{T}\;\mathsf{i}^{T}\mathsf{\;}[(t_{2}\equiv s_{2})]_{T}\;\mathsf{i}^{T}\mathsf{\;}...\;\mathsf{i}^{T}\mathsf{\;}[(t_{n}\equiv s_{n})]_{T}\;\mathsf{i}^{T}\mathsf{\;}[\varphi(t_{1},...,t_{n})]_{T}\leq^{T}[\varphi(s_{1},...,s_{n})]_{T}
\]

\end_inset

de lo cual se desprende que
\begin_inset Formula 
\[
[\varphi(t_{1},...,t_{n})]_{T}\in\mathcal{U}\text{ implica }[\varphi(s_{1},...,s_{n})]_{T}\in\mathcal{U}
\]

\end_inset

ya que 
\begin_inset Formula $\mathcal{U}$
\end_inset

 es un filtro.
 La otra implicacion es analoga.
\end_layout

\begin_layout Standard
Para probar (3) podemos tomar 
\begin_inset Formula $\varphi=\left(f(v_{1},...,v_{n})\equiv f(s_{1},...,s_{n})\right)$
\end_inset

 y aplicar (2).
\end_layout

\begin_layout Standard
Definamos ahora un modelo 
\begin_inset Formula $\mathbf{A}_{\mathcal{U}}$
\end_inset

 de tipo 
\begin_inset Formula $\tau$
\end_inset

 de la siguiente manera:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Universo de 
\begin_inset Formula $\mathbf{A}_{\mathcal{U}}=T_{c}^{\tau}/\mathrm{\bowtie}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{A}_{\mathcal{U}}}=c/\mathrm{\bowtie}$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{A}_{\mathcal{U}}}(t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie})=f(t_{1},...,t_{n})/\mathrm{\bowtie}$
\end_inset

, para cada 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $t_{1},...,t_{n}\in T_{c}^{\tau}\;$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $r^{\mathbf{A}_{\mathcal{U}}}=\{(t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie}):[r(t_{1},...,t_{n})]_{T}\in\mathcal{U}\}$
\end_inset

, para cada 
\begin_inset Formula $r\in\mathcal{R}_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Notese que la definicion de 
\begin_inset Formula $f^{\mathbf{A}_{\mathcal{U}}}$
\end_inset

 es inambigua por (3).
 Probaremos las siguientes propiedades basicas:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $t=_{d}t(v_{1},...,v_{n})\in T^{\tau}$
\end_inset

, 
\begin_inset Formula $t_{1},...,t_{n}\in T_{c}^{\tau}$
\end_inset

, tenemos que
\begin_inset Formula 
\[
t^{\mathbf{A}_{\mathcal{U}}}[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie}]=t(t_{1},...,t_{n})/\mathrm{\bowtie}
\]

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})\in F^{\tau}$
\end_inset

, 
\begin_inset Formula $t_{1},...,t_{n}\in T_{c}^{\tau}$
\end_inset

, tenemos que
\begin_inset Formula 
\[
\mathbf{A}_{\mathcal{U}}\models\varphi[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie}]\text{ si y solo si }[\varphi(t_{1},...,t_{n})]_{T}\in\mathcal{U}.
\]

\end_inset


\end_layout

\begin_layout Standard
La prueba de (4) es directa por induccion.
 Probaremos (5) por induccion en el 
\begin_inset Formula $k$
\end_inset

 tal que 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

.
 El caso 
\begin_inset Formula $k=0$
\end_inset

 es dejado al lector.
 Supongamos (5) vale para 
\begin_inset Formula $\varphi\in F_{k}^{\tau}$
\end_inset

.
 Sea 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})\in F_{k+1}^{\tau}-F_{k}^{\tau}$
\end_inset

.
 Hay varios casos:
\end_layout

\begin_layout Standard
CASO 
\begin_inset Formula $\varphi=\left(\varphi_{1}\vee\varphi_{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Notese que por la Convencion Notacional 6, tenemos que 
\begin_inset Formula $\varphi_{i}=_{d}\varphi_{i}(v_{1},...,v_{n})$
\end_inset

.
 Tenemos entonces
\begin_inset Formula 
\[
\begin{array}{c}
\mathbf{A}_{\mathcal{U}}\models\varphi[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie}]\\
\Updownarrow\\
\mathbf{A}_{\mathcal{U}}\models\varphi_{1}[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie}]\text{ o }\mathbf{A}_{\mathcal{U}}\models\varphi_{2}[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie}]\\
\Updownarrow\\{}
[\varphi_{1}(t_{1},...,t_{n})]_{T}\in\mathcal{U}\text{ o }[\varphi_{2}(t_{1},...,t_{n})]_{T}\in\mathcal{U}\\
\Updownarrow\\{}
[\varphi_{1}(t_{1},...,t_{n})]_{T}\ \mathsf{s}^{T}\mathsf{\ }[\varphi_{2}(t_{1},...,t_{n})]_{T}\in\mathcal{U}\\
\Updownarrow\\{}
[\left(\varphi_{1}(t_{1},...,t_{n})\vee\varphi_{2}(t_{1},...,t_{n})\right)]_{T}\in\mathcal{U}\\
\Updownarrow\\{}
[\varphi(t_{1},...,t_{n})]_{T}\in\mathcal{U}.
\end{array}
\]

\end_inset

CASO 
\begin_inset Formula $\varphi=\forall v\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $v\in Var-\{v_{1},...,v_{n}\}$
\end_inset

.
 Notese que por la Convencion Notacional 6, tenemos que 
\begin_inset Formula $\varphi_{1}=_{d}\varphi_{1}(v_{1},...,v_{n},v)$
\end_inset

.
 Tenemos entonces
\begin_inset Formula 
\[
\begin{array}{c}
\mathbf{A}_{\mathcal{U}}\models\varphi[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie}]\\
\Updownarrow\\
\mathbf{A}_{\mathcal{U}}\models\varphi_{1}[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie},t/\mathrm{\bowtie}]\text{, para todo }t\in T_{c}^{\tau}\\
\Updownarrow\\{}
[\varphi_{1}(t_{1},...,t_{n},t)]_{T}\in\mathcal{U}\text{, para todo }t\in T_{c}^{\tau}\\
\Updownarrow\\{}
[\forall v\varphi_{1}(t_{1},...,t_{n},v)]_{T}\in\mathcal{U}\\
\Updownarrow\\{}
[\varphi(t_{1},...,t_{n})]_{T}\in\mathcal{U}.
\end{array}
\]

\end_inset

CASO 
\begin_inset Formula $\varphi=\exists v\varphi_{1}$
\end_inset

, con 
\begin_inset Formula $v\in Var-\{v_{1},...,v_{n}\}$
\end_inset

.
 Notese que por la Convencion Notacional 6, tenemos que 
\begin_inset Formula $\varphi_{1}=_{d}\varphi_{1}(v_{1},...,v_{n},v)$
\end_inset

.
 Tenemos entonces
\begin_inset Formula 
\[
\begin{array}{c}
\mathbf{A}_{\mathcal{U}}\models\varphi[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie}]\\
\Updownarrow\\
\mathbf{A}_{\mathcal{U}}\models\varphi_{1}[t_{1}/\mathrm{\bowtie},...,t_{n}/\mathrm{\bowtie},t/\mathrm{\bowtie}]\text{, para algun }t\in T_{c}^{\tau}\\
\Updownarrow\\{}
[\varphi_{1}(t_{1},...,t_{n},t)]_{T}\in\mathcal{U}\text{, para algun }t\in T_{c}^{\tau}\\
\Updownarrow\\
([\varphi_{1}(t_{1},...,t_{n},t)]_{T})^{\mathsf{c}^{T}}\not\in\mathcal{U}\text{, para algun }t\in T_{c}^{\tau}\\
\Updownarrow\\{}
[\lnot\varphi_{1}(t_{1},...,t_{n},t)]_{T}\not\in\mathcal{U}\text{, para algun }t\in T_{c}^{\tau}\\
\Updownarrow\\{}
[\forall v\;\lnot\varphi_{1}(t_{1},...,t_{n},v)]_{T}\not\in\mathcal{U}\\
\Updownarrow\\
([\forall v\;\lnot\varphi_{1}(t_{1},...,t_{n},v)]_{T})^{\mathsf{c}^{T}}\in\mathcal{U}\\
\Updownarrow\\{}
[\lnot\forall v\;\lnot\varphi_{1}(t_{1},...,t_{n},v)]_{T}\in\mathcal{U}\\
\Updownarrow\\{}
[\varphi(t_{1},...,t_{n})]_{T}\in\mathcal{U}.
\end{array}
\]

\end_inset

Pero ahora notese que (5) en particular nos dice que para cada sentencia
 
\begin_inset Formula $\psi\in S^{\tau}$
\end_inset

, 
\begin_inset Formula $\mathbf{A}_{\mathcal{U}}\models\psi$
\end_inset

 si y solo si 
\begin_inset Formula $[\psi]_{T}\in\mathcal{U}.$
\end_inset

 De esta forma llegamos a que 
\begin_inset Formula $\mathbf{A}_{\mathcal{U}}\models\Sigma$
\end_inset

 y 
\begin_inset Formula $\mathbf{A}_{\mathcal{U}}\models\lnot\varphi_{0}$
\end_inset

, lo cual contradice la suposicion de que 
\begin_inset Formula $T\models\varphi_{0}.$
\end_inset


\end_layout

\begin_layout Standard
Ahora supongamos que 
\begin_inset Formula $\tau$
\end_inset

 es cualquier tipo.
 Sean 
\begin_inset Formula $s_{1}$
\end_inset

 y 
\begin_inset Formula $s_{2}$
\end_inset

 un par de simbolos no pertenecientes a la lista
\begin_inset Formula 
\[
\forall\ \ \exists\ \ \lnot\ \ \vee\ \ \wedge\ \ \rightarrow\ \ \leftrightarrow\ \ (\ \ )\ \ ,\ \equiv\ \ \mathsf{X}\ \ \mathit{0}\ \ \mathit{1}\ \ ...\ \ \mathit{9}\ \ \mathbf{0}\ \ \mathbf{1}\ \ ...\ \ \mathbf{9}
\]

\end_inset

y tales que ninguno ocurra en alguna palabra de 
\begin_inset Formula $\mathcal{C}\cup\mathcal{F}\cup\mathcal{R}.$
\end_inset

 Si 
\begin_inset Formula $T\models\varphi$
\end_inset

, entonces usando el Lema de Coincidencia se puede ver que 
\begin_inset Formula $(\Sigma,(\mathcal{C}\cup\{s_{1}s_{2}s_{1},s_{1}s_{2}s_{2}s_{1},...\},\mathcal{F},\mathcal{R},a))\models\varphi$
\end_inset

, por lo cual
\begin_inset Formula 
\[
(\Sigma,(\mathcal{C}\cup\{s_{1}s_{2}s_{1},s_{1}s_{2}s_{2}s_{1},...\},\mathcal{F},\mathcal{R},a))\vdash\varphi.
\]

\end_inset

Pero por Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "tipos-parecidos"
plural "false"
caps "false"
noprefix "false"

\end_inset

, tenemos que 
\begin_inset Formula $T\vdash\varphi.$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Toda teoria consistente tiene un modelo.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es consistente y no tiene modelos.
 Entonces 
\begin_inset Formula $(\Sigma,\tau)\models\left(\varphi\wedge\lnot\varphi\right)$
\end_inset

, con lo cual por completitud 
\begin_inset Formula $(\Sigma,\tau)\vdash\left(\varphi\wedge\lnot\varphi\right)$
\end_inset

, lo cual es absurdo.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "wiki-teorema.de.compacidad"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Teorema de Compacidad
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset

Sea 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 una teoria.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es tal que 
\begin_inset Formula $(\Sigma_{0},\tau)$
\end_inset

 tiene un modelo, para cada subconjunto finito 
\begin_inset Formula $\Sigma_{0}\subseteq\Sigma$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 tiene un modelo
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset

Si 
\begin_inset Formula $(\Sigma,\tau)\models\varphi$
\end_inset

, entonces hay un subconjunto finito 
\begin_inset Formula $\Sigma_{0}\subseteq\Sigma$
\end_inset

 tal que 
\begin_inset Formula $(\Sigma_{0},\tau)\models\varphi$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (a) Veamos que 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es consistente.
 Supongamos lo contrario, es decir supongamos 
\begin_inset Formula $(\Sigma,\tau)\vdash\left(\varphi\wedge\lnot\varphi\right)$
\end_inset

, para alguna sentencia 
\begin_inset Formula $\varphi$
\end_inset

.
 Notese que entonces hay un subconjunto finito 
\begin_inset Formula $\Sigma_{0}\subseteq\Sigma$
\end_inset

 tal que la teoria 
\begin_inset Formula $(\Sigma_{0},\tau)\vdash\left(\varphi\wedge\lnot\varphi\right)$
\end_inset

 (
\begin_inset Formula $\Sigma_{0}$
\end_inset

 puede ser formado con los axiomas de 
\begin_inset Formula $\Sigma$
\end_inset

 usados en una prueba formal que atestigue que 
\begin_inset Formula $(\Sigma,\tau)\vdash\left(\varphi\wedge\lnot\varphi\right)$
\end_inset

).
 Pero esto es absurdo ya que por hypotesis dicha teoria 
\begin_inset Formula $(\Sigma_{0},\tau)$
\end_inset

 tiene un modelo.
 O sea que 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es consistente por lo cual tiene un modelo.
\end_layout

\begin_layout Standard
(b) Si 
\begin_inset Formula $(\Sigma,\tau)\models\varphi$
\end_inset

, entonces por completitud, 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

.
 Pero entonces hay un subconjunto finito 
\begin_inset Formula $\Sigma_{0}\subseteq\Sigma$
\end_inset

 tal que 
\begin_inset Formula $(\Sigma_{0},\tau)\vdash\varphi$
\end_inset

, es decir tal que 
\begin_inset Formula $(\Sigma_{0},\tau)\models\varphi$
\end_inset

 (correccion).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
Interpretacion semantica del algebra de Lindembaum
\end_layout

\begin_layout Standard
Usando lo teoremas de correccion y completitud podemos dar una representacion
 semantica del algebra de Lindembaum.
 Sea 
\begin_inset Formula $T=(\Sigma,\tau)$
\end_inset

 una teoria.
 Dada 
\begin_inset Formula $\varphi\in S^{\tau}$
\end_inset

 definamos
\begin_inset Formula 
\[
\mathrm{Mod}_{T}(\varphi)=\{\mathbf{A}:\mathbf{A}\text{ es modelo de }T\text{ y }\mathbf{A}\vDash\varphi\}
\]

\end_inset

Definamos tambien
\begin_inset Formula 
\[
\mathrm{Mod}_{T}=\{\mathbf{A}:\mathbf{A}\text{ es modelo de }T\}
\]

\end_inset

Dado 
\begin_inset Formula $S\subseteq\mathrm{Mod}_{T}$
\end_inset

 definamos
\begin_inset Formula 
\[
S^{c}=\mathrm{Mod}_{T}-S
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "bolcitas"

\end_inset


\begin_inset Formula $\{\mathrm{Mod}_{T}(\varphi):\varphi\in S^{\tau}\}$
\end_inset

 es un subuniverso del algebra de Boole 
\begin_inset Formula $(\mathcal{P}(\mathrm{Mod}_{T}),\cup,\cap,^{c},\emptyset,\mathrm{Mod}_{T})$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que
\begin_inset Formula 
\begin{align*}
\emptyset & =\mathrm{Mod}_{T}(\exists x_{1}\lnot(x_{1}\equiv x_{1}))\\
\mathrm{Mod}_{T} & =\mathrm{Mod}_{T}(\forall x_{1}(x_{1}\equiv x_{1}))\\
\mathrm{Mod}_{T}(\varphi)\cap\mathrm{Mod}_{T}(\psi) & =\mathrm{Mod}_{T}((\varphi\wedge\psi))\\
\mathrm{Mod}_{T}(\varphi)\cup\mathrm{Mod}_{T}(\psi) & =\mathrm{Mod}_{T}((\varphi\vee\psi))\\
\mathrm{Mod}_{T}(\varphi)^{c} & =\mathrm{Mod}_{T}(\lnot\varphi)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Dadas 
\begin_inset Formula $\varphi,\psi\in S^{\tau}$
\end_inset

 se tiene:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $[\varphi]_{T}\leq^{T}[\psi]_{T}$
\end_inset

 sii 
\begin_inset Formula $\mathrm{Mod}_{T}(\varphi)\subseteq\mathrm{Mod}_{T}(\psi)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $[\varphi]_{T}=[\psi]_{T}$
\end_inset

 sii 
\begin_inset Formula $\mathrm{Mod}_{T}(\varphi)=\mathrm{Mod}_{T}(\psi)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $[\varphi]_{T}<^{T}[\psi]_{T}$
\end_inset

 sii 
\begin_inset Formula $\mathrm{Mod}_{T}(\varphi)\subsetneqq\mathrm{Mod}_{T}(\psi)$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) Dejamos al lector justificar las siguientes equivalencias:
\begin_inset Formula 
\[
[\varphi]_{T}\leq^{T}[\psi]_{T}\text{ sii }T\vdash(\varphi\rightarrow\psi)\text{ sii }T\models(\varphi\rightarrow\psi)\text{ sii }\mathrm{Mod}_{T}(\varphi)\subseteq\mathrm{Mod}_{T}(\psi)
\]

\end_inset

(2) y (3) siguen de (1) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $\{\mathrm{Mod}_{T}(\varphi):\varphi\in S^{\tau}\}$
\end_inset

 es un subuniverso de 
\begin_inset Formula $(\mathcal{P}(\mathrm{Mod}_{T}),\cup,\cap,^{c},\emptyset,\mathrm{Mod}_{T})$
\end_inset

, tenemos que 
\begin_inset Formula $(\{\mathrm{Mod}_{T}(\varphi):\varphi\in S^{\tau}\},\cup,\cap,^{c},\emptyset,\mathrm{Mod}_{T})$
\end_inset

 es un algebra de Boole.
 Notese que (2) del lema anterior nos asegura que
\begin_inset Formula 
\[
\begin{array}{rcl}
S^{\tau}/\mathrm{\dashv\vdash}_{T} & \rightarrow & \{\mathrm{Mod}_{T}(\varphi):\varphi\in S^{\tau}\}\\{}
[\varphi]_{T} & \rightarrow & \mathrm{Mod}_{T}(\varphi)
\end{array}
\]

\end_inset

define en forma inhambigua una funcion.
 Tenemos entonces el siguiente
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
 La funcion
\begin_inset Formula 
\[
\begin{array}{rcl}
S^{\tau}/\mathrm{\dashv\vdash}_{T} & \rightarrow & \{\mathrm{Mod}_{T}(\varphi):\varphi\in S^{\tau}\}\\{}
[\varphi]_{T} & \rightarrow & \mathrm{Mod}_{T}(\varphi)
\end{array}
\]

\end_inset

es un isomorfismo de 
\begin_inset Formula $\mathcal{A}_{T}$
\end_inset

 en 
\begin_inset Formula $(\{\mathrm{Mod}_{T}(\varphi):\varphi\in S^{\tau}\},\cup,\cap,^{c},\emptyset,\mathrm{Mod}_{T})$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Llamemosle 
\begin_inset Formula $f$
\end_inset

 a la funcion del enunciado.
 Es claro que 
\begin_inset Formula $f$
\end_inset

 es sobre.
 Ademas (2) del lema anterior nos dice que 
\begin_inset Formula $f$
\end_inset

 es inyectiva.
 Ademas usando las igualdades de la prueba del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "bolcitas"
plural "false"
caps "false"
noprefix "false"

\end_inset

, facilmente podemos ver que 
\begin_inset Formula $f$
\end_inset

 es un homomorfismo por lo cual es un isomorfismo.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Teorias completas
\end_layout

\begin_layout Standard
Una teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera llamada 
\shape italic
completa
\shape default
 cuando para cada 
\begin_inset Formula $\varphi\in S^{\tau}$
\end_inset

 se de que 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

 o 
\begin_inset Formula $(\Sigma,\tau)\vdash\lnot\varphi$
\end_inset

.
 Es poco frecuente que una teoria consistente sea completa y esto lo veremos
 claro despues del siguiente resultado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 Sea 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 una teoria consistente.
 Son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es completa
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Todos los modelos de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 son elementalmente equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Hay una estructura 
\begin_inset Formula $\mathbf{A}$
\end_inset

 tal que los teoremas de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 son exactamente las sentencias verdaderas en 
\begin_inset Formula $\mathbf{A}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $\mathcal{A}_{(\Sigma,\tau)}$
\end_inset

 tiene exactamente dos elementos 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos vale (1).
 Probaremos (2).
 Supongamos 
\begin_inset Formula $\mathbf{A},\mathbf{B}$
\end_inset

 son modelos de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 y supongamos 
\begin_inset Formula $\mathbf{A}\models\varphi$
\end_inset

.
 Entonces no puede darse 
\begin_inset Formula $(\Sigma,\tau)\vdash\lnot\varphi$
\end_inset

 (use correccion) por lo cual tenemos que 
\begin_inset Formula $(\Sigma,\tau)\vdash\varphi$
\end_inset

.
 Ya que 
\begin_inset Formula $\mathbf{B}$
\end_inset

 es modelo de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 tenemos entonces que 
\begin_inset Formula $\mathbf{B}\models\varphi$
\end_inset

.
 Esto prueba que 
\begin_inset Formula $\mathbf{A}$
\end_inset

 y 
\begin_inset Formula $\mathbf{B}$
\end_inset

 son elementalmente equivalentes.
\end_layout

\begin_layout Standard
Ahora supongamos vale (2).
 Probaremos (3).
 Ya que 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es consistente, tiene al menos un modelo.
 Sea 
\begin_inset Formula $\mathbf{A}$
\end_inset

 uno de ellos.
 Por correccion todo teorema es verdadero en 
\begin_inset Formula $\mathbf{A}$
\end_inset

.
 Reciprocamente si 
\begin_inset Formula $\mathbf{A}\models\varphi$
\end_inset

, entonces, por (2), todo modelo de 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 satisface 
\begin_inset Formula $\varphi$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $\varphi$
\end_inset

 es un teorema.
\end_layout

\begin_layout Standard
Obviamente (3) impica que toda sentencia es o un teorema o refutable y esto
 nos dice que 
\begin_inset Formula $0^{(\Sigma,\tau)}\cup1^{(\Sigma,\tau)}=S^{\tau}$
\end_inset

.
 Ya que 
\begin_inset Formula $0^{(\Sigma,\tau)}\cap1^{(\Sigma,\tau)}=\emptyset$
\end_inset

 puesto que 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 es consistente, tenemos que vale (4).
\end_layout

\begin_layout Standard
Es trivial que (4) implica (1).
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ya que lo mas comun es que una teoria tenga un par de modelos no elementalmente
 equivalentes, la mayoria de las teorias no son completas.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
La aritmetica de Peano
\end_layout

\begin_layout Standard
En esta seccion desarrollaremos las propiedades basicas de 
\begin_inset Formula $Arit$
\end_inset

, una teoria de primer orden la cual modeliza a la aritmetica.
 Esta teoria ha sido paradigmatica en el desarrollo de la logica.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\tau_{A}=(\{0,1\},\{+^{2},.^{2}\},\{\leq^{2}\},a)$
\end_inset

.
 Denotemos con 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

 a la estructura de tipo 
\begin_inset Formula $\tau_{A}$
\end_inset

 que tiene a 
\begin_inset Formula $\omega$
\end_inset

 como universo e interpreta los nombres de 
\begin_inset Formula $\tau_{A}$
\end_inset

 en la manera usual, es decir
\begin_inset Formula 
\[
\begin{array}{l}
0^{\mathbf{\omega}}=0\\
1^{\mathbf{\omega}}=1\\
\leq^{\mathbf{\omega}}=\{(n,m)\in\omega^{2}:n\leq m\}\\
+^{\mathbf{\omega}}(n,m)=n+m\text{, para cada }n,m\in\omega\\
.^{\mathbf{\omega}}(n,m)=n.m\text{, para cada }n,m\in\omega
\end{array}
\]

\end_inset

Sea 
\begin_inset Formula $\Sigma$
\end_inset

 el conjunto formado por las siguientes sentencias:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\forall x_{3}\;x_{1}+(x_{2}+x_{3})\equiv(x_{1}+x_{2})+x_{3}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\;x_{1}+x_{2}\equiv x_{2}+x_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\forall x_{3}\;x_{1}.(x_{2}.x_{3})\equiv(x_{1}.x_{2}).x_{3}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\;x_{1}.x_{2}\equiv x_{2}.x_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\;x_{1}+0\equiv x_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\;x_{1}.0\equiv0$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\;x_{1}.1\equiv x_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\forall x_{3}\;x_{1}.(x_{2}+x_{3})\equiv(x_{1}.x_{2})+(x_{1}.x_{3})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\forall x_{3}\;(x_{1}+x_{3}\equiv x_{2}+x_{3}\rightarrow x_{1}\equiv x_{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\;x_{1}\leq x_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\forall x_{3}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{3})\rightarrow x_{1}\leq x_{3})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\;(x_{1}\leq x_{2}\vee x_{2}\leq x_{1})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall x_{1}\forall x_{2}\;(x_{1}\leq x_{2}\leftrightarrow\exists x_{3}\;x_{2}\equiv x_{1}+x_{3})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $0<1$
\end_inset

 
\end_layout

\begin_layout Standard
Es facil ver que todas estas sentencias son satisfechas por 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

 por lo cual 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

 es un modelo de la teoria 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

.
 Definamos
\begin_inset Formula 
\[
Verd_{\mathbf{\omega}}=\{\varphi\in S^{\tau_{A}}:\mathbf{\omega}\models\varphi\}
\]

\end_inset

Es claro que todo teorema de 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

 pertenece a 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 (por que?).
 Un pregunta interesante es si toda sentencia 
\begin_inset Formula $\varphi\in Verd_{\mathbf{\omega}}$
\end_inset

 es un teorema de 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

, es decir puede ser probada en forma elemental partiendo de los axiomas
 de 
\begin_inset Formula $\Sigma$
\end_inset

.
 La respuesta es no y lo explicaremos a continuacion.
 Sea 
\begin_inset Formula $\mathbf{Q}^{\geq0}$
\end_inset

 la estructura de tipo 
\begin_inset Formula $\tau_{A}$
\end_inset

 que tiene a 
\begin_inset Formula $\{r\in\mathbf{Q}:r\geq0\}$
\end_inset

 como universo e interpreta los nombres de 
\begin_inset Formula $\tau_{A}$
\end_inset

 en la manera usual.
 Note que 
\begin_inset Formula $\mathbf{Q}^{\geq0}$
\end_inset

 tambien es un modelo de 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

.
 Pero entonces todo teorema de 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

 debe ser verdadero en 
\begin_inset Formula $\mathbf{Q}^{\geq0}$
\end_inset

.
 Pero la sentencia 
\begin_inset Formula $\forall x\ (x\leq1\rightarrow(x\equiv0\vee x\equiv1))$
\end_inset

 es falsa en 
\begin_inset Formula $\mathbf{Q}^{\geq0}$
\end_inset

 por lo cual no es un teorema de 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

 y sin envargo pertenece a 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

.
 Es decir los axiomas de 
\begin_inset Formula $\Sigma$
\end_inset

 son demaciado generales y deberiamos agregarle axiomas que sean mas caracterist
icos de la estructura particular de 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

.
 En esa direccion, a continuacion extenderemos el conjunto 
\begin_inset Formula $\Sigma$
\end_inset

 con axiomas que nos permitiran hacer pruebas por induccion tal como se
 lo hace en la aritmetica basica.
\end_layout

\begin_layout Standard
Dada una formula 
\begin_inset Formula $\psi\in F^{\tau_{A}}$
\end_inset

 y variables 
\begin_inset Formula $v_{1},...,v_{n+1}$
\end_inset

, con 
\begin_inset Formula $n\geq0$
\end_inset

, tales que 
\begin_inset Formula $Li(\psi)\subseteq\{v_{1},...,v_{n+1}\}$
\end_inset

 y 
\begin_inset Formula $v_{i}\neq v_{j}$
\end_inset

 siempre que 
\begin_inset Formula $i\neq j$
\end_inset

, denotaremos con 
\begin_inset Formula $Ind_{\psi,v_{1},...,v_{n+1}}$
\end_inset

 a la siguiente sentencia de tipo 
\begin_inset Formula $\tau_{A}$
\end_inset


\begin_inset Formula 
\[
\forall v_{1}...\forall v_{n}\ ((\psi(\vec{v},0)\wedge\forall v_{n+1}\ (\psi(\vec{v},v_{n+1})\rightarrow\psi(\vec{v},+(v_{n+1},1))))\rightarrow\forall v_{n+1}\ \psi(\vec{v},v_{n+1}))
\]

\end_inset

donde suponemos que hemos declarado 
\begin_inset Formula $\psi=_{d}\psi(v_{1},...,v_{n+1})$
\end_inset

.
 Notese que si por ejemplo 
\begin_inset Formula $Li(\psi)\subseteq\{x_{1},x_{2},x_{3}\}$
\end_inset

, entonces las seis sentencias
\begin_inset Formula 
\[
Ind_{\psi,x_{1},x_{2},x_{3}}\ \ Ind_{\psi,x_{1},x_{3},x_{2}}\ \ Ind_{\psi,x_{2},x_{1},x_{3}}\ \ Ind_{\psi,x_{2},x_{3},x_{1}}\ \ Ind_{\psi,x_{3},x_{1},x_{2}}\ \ Ind_{\psi,x_{3},x_{2},x_{1}}
\]

\end_inset

son todas distintas.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\Sigma_{A}$
\end_inset

 el conjunto que resulta de agregarle a 
\begin_inset Formula $\Sigma$
\end_inset

 todas las sentencias de la forma 
\begin_inset Formula $Ind_{\psi,v_{1},...,v_{n+1}}$
\end_inset

.
 Notese que el conjunto 
\begin_inset Formula $\Sigma_{A}$
\end_inset

 es infinito.
\end_layout

\begin_layout Standard
La teoria 
\begin_inset Formula $(\Sigma_{A},\tau_{A})$
\end_inset

 sera llamada 
\shape italic
Aritmetica de Peano
\shape default
 y la denotaremos con 
\begin_inset Formula $Arit$
\end_inset

.
 Es intuitivamente claro que
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

 es un modelo de 
\begin_inset Formula $Arit$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sean 
\begin_inset Formula $\psi\in F^{\tau_{A}}$
\end_inset

 y 
\begin_inset Formula $v_{1},...,v_{n+1}$
\end_inset

, con 
\begin_inset Formula $n\geq0$
\end_inset

, tales que 
\begin_inset Formula $Li(\psi)\subseteq\{v_{1},...,v_{n+1}\}$
\end_inset

 y 
\begin_inset Formula $v_{i}\neq v_{j}$
\end_inset

 siempre que 
\begin_inset Formula $i\neq j$
\end_inset

.
 Veremos que 
\begin_inset Formula $\mathbf{\omega}\vDash Ind_{\psi,v_{1},...,v_{n+1}}$
\end_inset

.
 Declaremos 
\begin_inset Formula $\psi=_{d}\psi(v_{1},...,v_{n},v_{n+1})$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\varphi=((\psi(\vec{v},0)\wedge\forall v_{n+1}\ (\psi(\vec{v},v_{n+1})\rightarrow\psi(\vec{v},+(v_{n+1},1)))\rightarrow\forall v_{n+1}\ \psi(\vec{v},v_{n+1}))
\]

\end_inset

Declaremos 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n})$
\end_inset

.
 Notese que 
\begin_inset Formula $\mathbf{\omega}\vDash Ind_{\psi,v_{1},...,v_{n+1}}$
\end_inset

 si y solo si para cada 
\begin_inset Formula $a_{1},...,a_{n}\in\omega$
\end_inset

 se tiene que 
\begin_inset Formula $\mathbf{\omega}\vDash\varphi[\vec{a}]$
\end_inset

.
 Sean 
\begin_inset Formula $a_{1},...,a_{n}\in\omega$
\end_inset

 fijos.
 Probaremos que 
\begin_inset Formula $\mathbf{\omega}\vDash\varphi[\vec{a}]$
\end_inset

.
 Notar que si
\begin_inset Formula 
\[
\mathbf{\omega}\nvDash(\psi(\vec{v},0)\wedge\forall v_{n+1}\ (\psi(\vec{v},v_{n+1})\rightarrow\psi(\vec{v},+(v_{n+1},1)))[\vec{a}]
\]

\end_inset

entonces 
\begin_inset Formula $\mathbf{\omega}\vDash\varphi[\vec{a}]$
\end_inset

 por lo cual podemos hacer solo el caso en que
\begin_inset Formula 
\[
\mathbf{\omega}\vDash(\psi(\vec{v},0)\wedge\forall v_{n+1}\ (\psi(\vec{v},v_{n+1})\rightarrow\psi(\vec{v},+(v_{n+1},1)))[\vec{a}]
\]

\end_inset

Para probar que 
\begin_inset Formula $\mathbf{\omega}\vDash\varphi[\vec{a}]$
\end_inset

, deberemos probar entonces que 
\begin_inset Formula $\mathbf{\omega}\vDash\forall v_{n+1}\ \psi(\vec{v},v_{n+1})[\vec{a}]$
\end_inset

.
 Sea 
\begin_inset Formula $S=\{a\in\omega:\mathbf{\omega}\vDash\psi(\vec{v},v_{n+1})[\vec{a},a]\}$
\end_inset

.
 Ya que 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},0)[\vec{a}]$
\end_inset

, es facil ver usando el lema de reemplazo que 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},v_{n+1})[\vec{a},0]$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $0\in S$
\end_inset

.
 Ya que 
\begin_inset Formula $\mathbf{\omega}\vDash\forall v_{n+1}\ (\psi(\vec{v},v_{n+1})\rightarrow\psi(\vec{v},+(v_{n+1},1))[\vec{a}]$
\end_inset

, tenemos que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $a\in\omega$
\end_inset

, si 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},v_{n+1})[\vec{a},a]$
\end_inset

, entonces 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},+(v_{n+1},1))[\vec{a},a]$
\end_inset

.
 
\end_layout

\begin_layout Standard
Pero por el lema de reemplazo, tenemos que 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},+(v_{n+1},1))[\vec{a},a]$
\end_inset

 sii 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},v_{n+1})[\vec{a},a+1]$
\end_inset

, lo cual nos dice que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $a\in\omega$
\end_inset

, si 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},v_{n+1})[\vec{a},a]$
\end_inset

, entonces 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},v_{n+1})[\vec{a},a+1]$
\end_inset

.
 
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $0\in S$
\end_inset

 y (2) nos dice que 
\begin_inset Formula $a\in S$
\end_inset

 implica 
\begin_inset Formula $a+1\in S$
\end_inset

, tenemos que 
\begin_inset Formula $S=\omega$
\end_inset

.
 Es decir que para cada 
\begin_inset Formula $a\in\omega$
\end_inset

, se da que 
\begin_inset Formula $\mathbf{\omega}\vDash\psi(\vec{v},v_{n+1})[\vec{a},a]$
\end_inset

 lo cual nos dice que 
\begin_inset Formula $\mathbf{\omega}\vDash\forall v_{n+1}\ \psi(\vec{v},v_{n+1})[\vec{a}]$
\end_inset

.
\end_layout

\begin_layout Standard
Es rutina probar que 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

 satisface los otros 15 axiomas de 
\begin_inset Formula $Arit$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El modelo 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

 es llamado el 
\shape italic
modelo standard
\shape default
 de 
\begin_inset Formula $Arit$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejercicio:
\end_layout

\end_inset

Pruebe que 
\begin_inset Formula $\mathbf{Q}^{\geq0}$
\end_inset

 no es un modelo de 
\begin_inset Formula $Arit$
\end_inset

, dando una 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

propiedad inductiva que no cumpla
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Definamos el mapeo 
\begin_inset Formula $\widehat{\ \ \ }:\omega\rightarrow\{(\;)\;,\;+\;0\;1\}^{\ast}$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\begin{align*}
\widehat{0} & =0\\
\widehat{1} & =1\\
\widehat{n+1} & =+(\widehat{n},1)\text{, para cada }n\geq1
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 Hay un modelo de 
\begin_inset Formula $Arit$
\end_inset

 el cual no es isomorfo a 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $\tau=(\{0,1,\blacktriangle\},\{+^{2},.^{2}\},\{\leq^{2}\},a)$
\end_inset

 y sea 
\begin_inset Formula $\Sigma=\Sigma_{A}\cup\{\lnot(\widehat{n}\equiv\blacktriangle):n\in\omega\}$
\end_inset

.
 Por el Teorema de Compacidad la teoria 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 tiene un modelo 
\begin_inset Formula $\mathbf{A}=(A,i)$
\end_inset

.
 Ya que
\begin_inset Formula 
\[
\mathbf{A}\vDash\lnot(\widehat{n}\equiv\blacktriangle)\text{, para cada }n\in\omega
\]

\end_inset

tenemos que
\begin_inset Formula 
\[
i(\blacktriangle)\neq\widehat{n}^{\mathbf{A}}\text{, para cada }n\in\omega
\]

\end_inset

Por el Lema de Coincidencia la estructura 
\begin_inset Formula $\mathbf{B}=(A,i|_{\{0,1,+,.,\leq\}})$
\end_inset

 es un modelo de 
\begin_inset Formula $Arit$
\end_inset

.
 Ademas dicho lema nos garantiza que 
\begin_inset Formula $\widehat{n}^{\mathbf{B}}=\widehat{n}^{\mathbf{A}}$
\end_inset

, para cada 
\begin_inset Formula $n\in\omega$
\end_inset

, por lo cual tenemos que
\begin_inset Formula 
\[
i(\blacktriangle)\neq\widehat{n}^{\mathbf{B}}\text{, para cada }n\in\omega
\]

\end_inset

Veamos que 
\begin_inset Formula $\mathbf{B}$
\end_inset

 no es isomorfo a 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

.
 Supongamos 
\begin_inset Formula $F:\omega\rightarrow A$
\end_inset

 es un isomorfismo de 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

 en 
\begin_inset Formula $\mathbf{B}$
\end_inset

.
 Es facil de probar por induccion en 
\begin_inset Formula $n$
\end_inset

 que 
\begin_inset Formula $F(n)=\widehat{n}^{\mathbf{B}}$
\end_inset

, para cada 
\begin_inset Formula $n\in\omega$
\end_inset

.
 Pero esto produce un absurdo ya que nos dice que 
\begin_inset Formula $i(\blacktriangle)$
\end_inset

 no esta en la imagen de 
\begin_inset Formula $F$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Ejercicio:
\end_layout

\end_inset

Dado un modelo 
\begin_inset Formula $\mathbf{A}$
\end_inset

 de 
\begin_inset Formula $Arit$
\end_inset

 y elementos 
\begin_inset Formula $a,b\in A$
\end_inset

, diremos que 
\begin_inset Formula $a$
\end_inset

 
\shape italic
divide a 
\shape default

\begin_inset Formula $b$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $\mathbf{A}$
\end_inset

 cuando haya un 
\begin_inset Formula $c\in A$
\end_inset

 tal que 
\begin_inset Formula $b=.^{\mathbf{A}}(c,a).$
\end_inset

 Un elemento 
\begin_inset Formula $a\in A$
\end_inset

 sera llamado 
\shape italic
primo en 
\shape default

\begin_inset Formula $\mathbf{A}$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset


\shape default
si 
\begin_inset Formula $a\neq1^{\mathbf{A}}$
\end_inset

 y sus unicos divisores son 
\begin_inset Formula $1^{\mathbf{A}}$
\end_inset

 y 
\begin_inset Formula $a$
\end_inset

.
 Pruebe que hay un modelo de 
\begin_inset Formula $Arit$
\end_inset

, 
\begin_inset Formula $\mathbf{A}$
\end_inset

, en el cual hay infinitos primos no pertenecientes a 
\begin_inset Formula $\{\widehat{n}^{\mathbf{A}}:n\in\omega\}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Las siguientes sentencias son teoremas de la aritmetica de Peano:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $\forall x\;0\leq x$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $\forall x\;(x\leq0\rightarrow x\equiv0)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\;(x+y\equiv0\rightarrow(x\equiv0\wedge y\equiv0))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(4)
\end_layout

\end_inset


\begin_inset Formula $\forall x\;(\lnot(x\equiv0)\rightarrow\exists z\ (x\equiv z+1))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(5)
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\;(x<y\rightarrow x+1\leq y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(6)
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\;(x<y+1\rightarrow x\leq y)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(7)
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\;(x\leq y+1\rightarrow(x\leq y\vee x\equiv y+1))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(8)
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\;((x\leq y\wedge y\leq x+1)\rightarrow(x\equiv y\vee x\equiv y+1))$
\end_inset

 (use (7))
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(9)
\end_layout

\end_inset


\begin_inset Formula $\forall x\forall y\;(\lnot y\equiv0\rightarrow\exists q\exists r\;x\equiv q.y+r\wedge r<y)$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 (1) es dejada al lector.
\end_layout

\begin_layout Standard
(2)
\begin_inset Formula 
\[
\begin{array}{lllll}
\;1. & x_{0}\leq0 &  &  & \text{HIPOTESIS}1\\
\;2. & \forall x\;0\leq x &  &  & \text{TEOREMA}\\
\;3. & 0\leq x_{0} &  &  & \text{PARTICULARIZACION}(2)\\
\;4. & x_{0}\leq0\wedge0\leq x_{0} &  &  & \text{CONJUNCIONINTRODUCCION}(1,3)\\
\;5. & \forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2}) &  &  & \text{AXIOMAPROPIO}\\
\;6. & \forall x_{2}\;((x_{0}\leq x_{2}\wedge x_{2}\leq x_{0})\rightarrow x_{0}\equiv x_{2}) &  &  & \text{PARTICULARIZACION}(5)\\
\;7. & ((x_{0}\leq0\wedge0\leq x_{0})\rightarrow x_{0}\equiv0) &  &  & \text{PARTICULARIZACION}(6)\\
\;8. & x_{0}\equiv0 &  &  & \text{TESIS}1\text{MODUSPONENS}(4,7)\\
\;9. & x_{0}\leq0\rightarrow x_{0}\equiv0 &  &  & \text{CONCLUSION}\\
10. & \forall x\ (x\leq0\rightarrow x\equiv0) &  &  & \text{GENERALIZACION}(9)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
(3)
\begin_inset Formula 
\[
\begin{array}{lllll}
\;1. & x_{0}+y_{0}\equiv0 &  &  & \text{HIPOTESIS}1\\
\;2. & 0\equiv x_{0}+y_{0} &  &  & \text{COMMUTATIVIDAD}(1)\\
\;3. & \exists x_{3}\ (0\equiv x_{0}+x_{3}) &  &  & \text{EXISTENCIAL}(2)\\
\;4. & \forall x_{1}\forall x_{2}\;(x_{1}\leq x_{2}\leftrightarrow\exists x_{3}\;x_{2}\equiv x_{1}+x_{3}) &  &  & \text{AXIOMAPROPIO}\\
\;5. & x_{0}\leq0\leftrightarrow\exists x_{3}\;0\equiv x_{0}+x_{3}) &  &  & \text{PARTICULARIZACION}^{2}(5)\\
\;6. & x_{0}\leq0 &  &  & \text{REEMPLAZO}(5,3)\\
\;7. & \forall x\ 0\leq x &  &  & \text{TEOREMA}\\
\;8. & 0\leq x_{0} &  &  & \text{PARTICULARIZACION}(7)\\
\;9. & x_{0}\leq0\wedge0\leq x_{0} &  &  & \text{CONJUNCIONINTRODUCCION}(6,8)\\
10. & \forall x_{1}\forall x_{2}\;((x_{1}\leq x_{2}\wedge x_{2}\leq x_{1})\rightarrow x_{1}\equiv x_{2}) &  &  & \text{AXIOMAPROPIO}\\
11. & ((x_{0}\leq0\wedge0\leq x_{0})\rightarrow x_{0}\equiv0) &  &  & \text{PARTICULARIZACION}^{2}(10)\\
12. & x_{0}\equiv0 &  &  & \text{MODUSPONENS}(9,11)\\
13. & 0+y_{0}\equiv0 &  &  & \text{REEMPLAZO}(12,1)\\
14. & \forall y\ y\equiv0+y &  &  & \text{TEOREMA}\\
15. & y_{0}\equiv0+y_{0} &  &  & \text{PARTICULARIZACION}(14)\\
16. & y_{0}\equiv0 &  &  & \text{TRANSITIVIDAD}(15,13)\\
17. & x_{0}\equiv0\wedge y_{0}\equiv0 &  &  & \text{TESIS}1\text{CONJUNCIONINTRODUCCION}(12,16)\\
18. & x_{0}+y_{0}\equiv0\rightarrow(x_{0}\equiv0\wedge y_{0}\equiv0) &  &  & \text{CONCLUSION}\\
19. & \forall x\forall y\;(x+y\equiv0\rightarrow(x\equiv0\wedge y\equiv0)) &  &  & \text{GENERALIZACION}^{2}(18)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sean 
\begin_inset Formula $n,m\in\omega$
\end_inset

 y sea 
\begin_inset Formula $t\in T_{c}^{\tau_{A}}$
\end_inset

.
 Las siguientes sentencias son teoremas de la aritmetica de Peano:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $(+(\widehat{n},\widehat{m})\equiv\widehat{n+m})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $(.(\widehat{n},\widehat{m})\equiv\widehat{n.m})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset


\begin_inset Formula $\forall x\;(x\leq\widehat{n}\rightarrow(x\equiv\widehat{0}\vee x\equiv\widehat{1}\vee...\vee x\equiv\widehat{n}))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(d)
\end_layout

\end_inset


\begin_inset Formula $(t\equiv\widehat{t^{\mathbf{\omega}}})$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $\varphi$
\end_inset

 es una sentencia atomica o negacion de atomica y 
\begin_inset Formula $\mathbf{\omega}\models\varphi$
\end_inset

, entonces 
\begin_inset Formula $Arit\vdash\varphi$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Hay cuatro casos.
\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $\varphi=(t\equiv s)$
\end_inset

, con 
\begin_inset Formula $t,s$
\end_inset

 terminos cerrados.
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $\mathbf{\omega}\models\varphi$
\end_inset

, tenemos que 
\begin_inset Formula $t^{\mathbf{\omega}}=s^{\mathbf{\omega}}$
\end_inset

 y por lo tanto 
\begin_inset Formula $\widehat{t^{\mathbf{\omega}}}=\widehat{s^{\mathbf{\omega}}}$
\end_inset

.
 Por el lema anterior tenemos que 
\begin_inset Formula $Arit\vdash(t\equiv\widehat{t^{\mathbf{\omega}}}),(s\equiv\widehat{s^{\mathbf{\omega}}})$
\end_inset

 lo cual, ya que 
\begin_inset Formula $\widehat{t^{\mathbf{\omega}}}$
\end_inset

 y 
\begin_inset Formula $\widehat{s^{\mathbf{\omega}}}$
\end_inset

 son el mismo termino nos dice por la regla de transitividad que 
\begin_inset Formula $Arit\vdash(t\equiv s)$
\end_inset

.
\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $\varphi=(t\leq s)$
\end_inset

, con 
\begin_inset Formula $t,s$
\end_inset

 terminos cerrados.
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $\mathbf{\omega}\models\varphi$
\end_inset

, tenemos que 
\begin_inset Formula $t^{\mathbf{\omega}}\leq s^{\mathbf{\omega}}$
\end_inset

 y por lo tanto hay un 
\begin_inset Formula $k\in\omega$
\end_inset

 tal que 
\begin_inset Formula $t^{\mathbf{\omega}}+k=s^{\mathbf{\omega}}$
\end_inset

.
 Se tiene entonces que 
\begin_inset Formula $\widehat{t^{\mathbf{\omega}}+k}=\widehat{s^{\mathbf{\omega}}}$
\end_inset

.
 Por el lema anterior tenemos que 
\begin_inset Formula $Arit\vdash+(\widehat{t^{\mathbf{\omega}}},\widehat{k})\equiv\widehat{t^{\mathbf{\omega}}+k}$
\end_inset

 lo cual nos dice que
\begin_inset Formula 
\[
Arit\vdash+(\widehat{t^{\mathbf{\omega}}},\widehat{k})\equiv\widehat{s^{\mathbf{\omega}}}
\]

\end_inset

Pero el lema anterior nos dice que
\begin_inset Formula 
\[
Arit\vdash(t\equiv\widehat{t^{\mathbf{\omega}}}),(s\equiv\widehat{s^{\mathbf{\omega}}})
\]

\end_inset

y por lo tanto la regla de reemplazo nos asegura que 
\begin_inset Formula $Arit\vdash+(t,\widehat{k})\equiv s$
\end_inset

.
 Ya que
\begin_inset Formula 
\[
\forall x_{1}\forall x_{2}\;(x_{1}\leq x_{2}\leftrightarrow\exists x_{3}\;x_{2}\equiv x_{1}+x_{3})
\]

\end_inset

es un axioma de 
\begin_inset Formula $Arit$
\end_inset

, tenemos que 
\begin_inset Formula $Arit\vdash(t\leq s)$
\end_inset

.
\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $\varphi=\lnot(t\equiv s)$
\end_inset

, con 
\begin_inset Formula $t,s$
\end_inset

 terminos cerrados.
\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $\varphi=\lnot(t\leq s)$
\end_inset

, con 
\begin_inset Formula $t,s$
\end_inset

 terminos cerrados.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El siguiente lema muestra que en 
\begin_inset Formula $Arit$
\end_inset

 se pueden probar ciertas sentencias las cuales emulan el principio de induccion
 completa.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\varphi=_{d}\varphi(\vec{v},v)\in F^{\tau_{A}}$
\end_inset

.
 Supongamos 
\begin_inset Formula $v$
\end_inset

 es sustituible por 
\begin_inset Formula $w$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 y 
\begin_inset Formula $w\notin\{v_{1},...,v_{n}\}$
\end_inset

.
 Entonces:
\begin_inset Formula 
\[
Arit\vdash\forall\vec{v}((\varphi(\vec{v},0)\wedge\forall v(\forall w(w<v\rightarrow\varphi(\vec{v},w))\rightarrow\varphi(\vec{v},v)))\rightarrow\forall v\varphi(\vec{v},v))
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $\tilde{\varphi}=\forall w(w\leq v\rightarrow\varphi(\vec{v},w))$
\end_inset

.
 Notar que 
\begin_inset Formula $Li(\tilde{\varphi})\subseteq\{v_{1},...,v_{n},v\}$
\end_inset

.
 Declaremos 
\begin_inset Formula $\tilde{\varphi}=_{d}\tilde{\varphi}(\vec{v},v)$
\end_inset

.
 Para hacer la prueba formal usaremos el axioma 
\begin_inset Formula $Ind_{\tilde{\varphi},v_{1},...,v_{n},v}$
\end_inset

.
 Salvo por el uso de algunos teoremas simples y el uso simultaneo de las
 reglas de particularizacion y generalizacion, la siguiente es la prueba
 formal buscada.
\begin_inset Formula 
\[
\begin{array}{lllll}
\;1. & (\varphi(\vec{c},0)\wedge\forall v(\forall w(w<v\rightarrow\varphi(\vec{c},w))\rightarrow\varphi(\vec{c},v)) &  &  & \text{HIPOTESIS}1\\
\;2. & \;\;\;w_{0}\leq0 &  &  & \text{HIPOTESIS}2\\
\;3. & \;\;\;\forall x\;(x\leq0\rightarrow x\equiv0) &  &  & \text{TEOREMA}\\
\;4. & \;\;\;w_{0}\leq0\rightarrow w_{0}\equiv0 &  &  & \text{PARTICULARIZACION}(3)\\
\;5. & \;\;\;w_{0}\equiv0 &  &  & \text{MODUSPONENS}(2,4)\\
\;6. & \;\;\;\varphi(\vec{c},0) &  &  & \text{CONJUNCIONELIMINACION}(1)\\
\;7. & \;\;\;\varphi(\vec{c},w_{0}) &  &  & \text{TESIS}2\text{REEMPLAZO}(5,6)\\
\;8. & w_{0}\leq0\rightarrow\varphi(\vec{c},w_{0}) &  &  & \text{CONCLUSION}\\
\;9. & \tilde{\varphi}(\vec{c},0) &  &  & \text{GENERALIZACION}(8)\\
10. & \;\;\;\tilde{\varphi}(\vec{c},v_{0}) &  &  & \text{HIPOTESIS}3\\
11. & \;\;\;\;\;\;w_{0}<v_{0}+1 &  &  & \text{HIPOTESIS}4\\
12. & \;\;\;\;\;\;\forall x,y\;x<y+1\rightarrow x\leq y &  &  & \text{TEOREMA}\\
13. & \;\;\;\;\;\;w_{0}<v_{0}+1\rightarrow w_{0}\leq v_{0} &  &  & \text{PARTICULARIZACION}(12)\\
14. & \;\;\;\;\;\;w_{0}\leq v_{0} &  &  & \text{MODUSPONENS}(11,13)\\
15. & \;\;\;\;\;\;w_{0}\leq v_{0}\rightarrow\varphi(\vec{c},w_{0}) &  &  & \text{PARTICULARIZACION}(10)\\
16. & \;\;\;\;\;\;\varphi(\vec{c},w_{0}) &  &  & \text{TESIS}4\text{MODUSPONENS}(14,15)\\
17. & \;\;\;w_{0}<v_{0}+1\rightarrow\varphi(\vec{c},w_{0}) &  &  & \text{CONCLUSION}\\
18. & \;\;\;\forall w\;w<v_{0}+1\rightarrow\varphi(\vec{c},w) &  &  & \text{GENERALIZACION}(17)\\
19. & \;\;\;\forall v(\forall w(w<v\rightarrow\varphi(\vec{c},w))\rightarrow\varphi(\vec{c},v)) &  &  & \text{CONJUNCIONELIMINACION}(1)\\
20. & \;\;\;(\forall w(w<v_{0}+1\rightarrow\varphi(\vec{c},w))\rightarrow\varphi(\vec{c},v_{0}+1)) &  &  & \text{PARTICULARIZACION}(19)\\
21. & \;\;\;\varphi(\vec{c},v_{0}+1) &  &  & \text{MODUSPONENS}(18,20)\\
22. & \;\;\;\;\;\;w_{0}\leq v_{0}+1 &  &  & \text{HIPOTESIS}5\\
23. & \;\;\;\;\;\;\forall x,y\;x\leq y+1\rightarrow(x\leq y\vee x\equiv y+1) &  &  & \text{TEOREMA}\\
24. & \;\;\;\;\;\;w_{0}\leq v_{0}+1\rightarrow(w_{0}\leq v_{0}\vee w_{0}\equiv v_{0}+1) &  &  & \text{PARTICULARIZACION}(23)\\
25. & \;\;\;\;\;\;(w_{0}\leq v_{0}\vee w_{0}\equiv v_{0}+1) &  &  & \text{MODUSPONENS}(22,24)\\
26. & \;\;\;\;\;\;w_{0}\leq v_{0}\rightarrow\varphi(\vec{c},w_{0}) &  &  & \text{PARTICULARIZACION}(10)\\
27. & \;\;\;\;\;\;\;\;\;w_{0}\equiv v_{0}+1 &  &  & \text{HIPOTESIS}6\\
28. & \;\;\;\;\;\;\;\;\;\varphi(\vec{c},w_{0}) &  &  & \text{TESIS}6\text{REEMPLAZO}(21,27)\\
29. & \;\;\;w_{0}\equiv v_{0}+1\rightarrow\varphi(\vec{c},w_{0}) &  &  & \text{CONCLUSION}\\
30. & \;\;\;\;\;\;\varphi(\vec{c},w_{0}) &  &  & \text{TESIS}5\text{DISJUNCIONELIM}(25,26,29)\\
31. & \;\;\;w_{0}\leq v_{0}+1\rightarrow\varphi(\vec{c},w_{0}) &  &  & \text{CONCLUSION}\\
32. & \;\;\;\tilde{\varphi}(\vec{c},v_{0}+1) &  &  & \text{TESIS}3\text{GENERALIZACION}(31)\\
33. & \tilde{\varphi}(\vec{c},v_{0})\rightarrow\tilde{\varphi}(\vec{c},v_{0}+1) &  &  & \text{CONCLUSION}\\
34. & \forall v\tilde{\varphi}(\vec{c},v)\rightarrow\tilde{\varphi}(\vec{c},v+1) &  &  & \text{GENERALIZACION}(33)\\
35. & \tilde{\varphi}(\vec{c},0)\wedge\forall v\tilde{\varphi}(\vec{c},v)\rightarrow\tilde{\varphi}(\vec{c},v+1) &  &  & \text{CONJUNCIONINTRODUCCION}(9,34)\\
36. & Ind_{\tilde{\varphi},v_{1},...,v_{n},v} &  &  & \text{AXIOMAPROPIO}\\
37. & (\tilde{\varphi}(\vec{c},0)\wedge\forall v(\tilde{\varphi}(\vec{c},v)\rightarrow\tilde{\varphi}(\vec{c},v+1))\rightarrow\forall v\tilde{\varphi}(\vec{c},v) &  &  & \text{PARTICULARIZACION}(36)\\
38. & \forall v\tilde{\varphi}(\vec{c},v) &  &  & \text{MODUSPONENS}(35,37)\\
39. & \tilde{\varphi}(\vec{c},v_{0}) &  &  & \text{PARTICULARIZACION}(38)\\
40. & v_{0}\leq v_{0}\rightarrow\varphi(\vec{c},v_{0}) &  &  & \text{PARTICULARIZACION}(39)\\
41. & \forall x\;x\leq x &  &  & \text{AXIOMAPROPIO}\\
42. & v_{0}\leq v_{0} &  &  & \text{PARTICULARIZACION}(41)\\
43. & \varphi(\vec{c},v_{0}) &  &  & \text{MODUSPONENS}(40,42)\\
44. & \forall v\varphi(\vec{c},v) &  &  & \text{TESIS}1\text{GENERALIZACION}(43)\\
45. & (\varphi(\vec{c},0)\wedge\forall v(\forall w(w<v\rightarrow\varphi(\vec{c},w))\rightarrow\varphi(\vec{c},v)))\rightarrow\forall v\varphi(\vec{c},v) &  &  & \text{CONCLUSION}\\
46. & \forall\vec{v}((\varphi(\vec{v},0)\wedge\forall v(\forall w(w<v\rightarrow\varphi(\vec{v},w))\rightarrow\varphi(\vec{v},v)))\rightarrow\forall v\varphi(\vec{v},v)) &  &  & \text{GENERALIZACION}(45)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Logica ecuacional
\end_layout

\begin_layout Standard
Dados 
\begin_inset Formula $t,s\in T^{\tau}$
\end_inset

, con 
\begin_inset Formula $t\approx s$
\end_inset

 denotaremos la siguiente sentencia de tipo 
\begin_inset Formula $\tau$
\end_inset

:
\begin_inset Formula 
\[
\forall x_{1}...\forall x_{n}\;(t\equiv s)
\]

\end_inset

donde 
\begin_inset Formula $n$
\end_inset

 es el menor 
\begin_inset Formula $j$
\end_inset

 tal que 
\begin_inset Formula $\{x_{1},...,x_{j}\}$
\end_inset

 contiene a todas las variables que ocurren en 
\begin_inset Formula $t$
\end_inset

 y 
\begin_inset Formula $s$
\end_inset

.
 Notese que este 
\begin_inset Formula $n$
\end_inset

 es 
\begin_inset Formula $0$
\end_inset

 cuando 
\begin_inset Formula $t$
\end_inset

 y 
\begin_inset Formula $s$
\end_inset

 son terminos cerrados, es decir que 
\begin_inset Formula $t\approx s$
\end_inset

 denota a la sentencia 
\begin_inset Formula $(t\equiv s)$
\end_inset

, cuando 
\begin_inset Formula $t,s\in T_{c}^{\tau}$
\end_inset

.
 Las sentencias 
\begin_inset Formula $t\approx s$
\end_inset

, con 
\begin_inset Formula $t,s\in T^{\tau}$
\end_inset

, seran llamadas 
\shape italic
identidades de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

.
 Notese que 
\begin_inset Formula $\mathbf{A}\models t\approx s$
\end_inset

 sii 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=s^{\mathbf{A}}[\vec{a}]$
\end_inset

, para cada 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

.
 Tambien, si 
\begin_inset Formula $t=_{d}t(x_{1},...,x_{m})$
\end_inset

 y 
\begin_inset Formula $s=_{d}s(x_{1},...,x_{m})$
\end_inset

, entonces dado una 
\begin_inset Formula $\tau$
\end_inset

-algebra 
\begin_inset Formula $\mathbf{A}$
\end_inset

, tenemos que 
\begin_inset Formula $\mathbf{A}\models t\approx s$
\end_inset

 sii 
\begin_inset Formula $t^{\mathbf{A}}\left[a_{1},...,a_{m}\right]=s^{\mathbf{A}}\left[a_{1},...,a_{m}\right]$
\end_inset

, para cada 
\begin_inset Formula $(a_{1},...,a_{m})\in A^{m}$
\end_inset

.
 (Independientemente de que 
\begin_inset Formula $m$
\end_inset

 sea el menor 
\begin_inset Formula $j$
\end_inset

 tal que 
\begin_inset Formula $\{x_{1},...,x_{j}\}$
\end_inset

 contiene a las variables que ocurren en 
\begin_inset Formula $t$
\end_inset

 y 
\begin_inset Formula $s$
\end_inset

.)
\end_layout

\begin_layout Standard
Una teoria de primer orden 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera llamada 
\shape italic
ecuacional
\shape default
 si 
\begin_inset Formula $\tau$
\end_inset

 es un tipo algebraico y cada elemento de 
\begin_inset Formula $\Sigma$
\end_inset

 es una identidad de tipo 
\begin_inset Formula $\tau$
\end_inset

.
 Por supuesto, el teorema de completitud de Godel nos garantiza que si 
\begin_inset Formula $T$
\end_inset

 es una teoria ecuacional y 
\begin_inset Formula $T\vDash t\approx s$
\end_inset

, entonces hay una prueba formal de 
\begin_inset Formula $t\approx s$
\end_inset

 en 
\begin_inset Formula $T$
\end_inset

.
 Sin envargo, en dicha prueba formal puede haber sentencias las cuales no
 sean identidades.
 Una pregunta interesante es la siguiente:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
Pregunta:
\end_layout

\end_inset

Hay una nocion de 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

prueba ecuacional
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 la cual sea:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Correcta: si hay una prueba ecuacional de 
\begin_inset Formula $t\approx s$
\end_inset

 en 
\begin_inset Formula $T$
\end_inset

, entonces 
\begin_inset Formula $t\approx s$
\end_inset

 es verdadera en cada modelo de 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Completa: si 
\begin_inset Formula $T\vDash t\approx s$
\end_inset

, entonces hay una prueba ecuacional de 
\begin_inset Formula $t\approx s$
\end_inset

 en 
\begin_inset Formula $T$
\end_inset

? 
\end_layout

\begin_layout Standard
En esta seccion veremos que, tal como lo probo Birkhoff, esto es posible
 y que la nocion de prueba ecuacional que se puede dar es muy natural y
 simple, es decir si sabemos que en una teoria todos los axiomas son identidades
, entonces a los fines de probar identidades las pruebas de primer orden
 clasicas pueden ser reemplazadas por pruebas con un formato mucho mas amigable.
\end_layout

\begin_layout Subsection
Pruebas ecuacionales
\end_layout

\begin_layout Standard
Primero introducimos una serie de conjuntos los cuales poseen informacion
 deductiva ecuacional basica.
 Sea
\begin_inset Formula 
\[
TransEc^{\tau}=\{(t\approx s,s\approx p,t\approx p):t,s,p\in T^{\tau}\}
\]

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi_{1}$
\end_inset

y 
\begin_inset Formula $\psi_{2}$
\end_inset

 
\shape italic
por la regla de transitividad ecuacional, respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi_{1},\psi_{2},\varphi)\in TransEc^{\tau}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
SimEc^{\tau}=\{(t\approx s,s\approx t):t,s\in T^{\tau}\}
\]

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi_{1}$
\end_inset

 
\shape italic
por la regla de simetria ecuacional, respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi_{1},\varphi)\in SimEc^{\tau}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\begin{array}{c}
SubsEc^{\tau}=\{(t\approx s,t(p_{1},...,p_{n})\approx s(p_{1},...,p_{n})):t=_{d}t(x_{1},...,x_{n})\\
s=_{d}s(x_{1},...,x_{n})\ \mathrm{y}\ p_{1},...,p_{n}\in T^{\tau}\}
\end{array}
\]

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi_{1}$
\end_inset

 
\shape italic
por la regla de substitucion ecuacional, respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi_{1},\varphi)\in SubsEc^{\tau}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\begin{array}{c}
ReempEc^{\tau}=\{(t\approx s,r\approx\tilde{r}):t,s,r\in T^{\tau}\ \text{\textrm{y}}\ \tilde{r}=\mathrm{resultado}\\
\mathrm{de\ reemplazar\ algunas\ ocurrencias\ de\ }t\ \mathrm{en\ }r\ \mathrm{por\ }s\}
\end{array}
\]

\end_inset

Diremos que 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
se deduce de 
\shape default

\begin_inset Formula $\psi_{1}$
\end_inset

 
\shape italic
por la regla de reemplazo ecuacional, respecto a 
\shape default

\begin_inset Formula $\tau$
\end_inset

 para expresar que 
\begin_inset Formula $(\psi_{1},\varphi)\in ReempEc^{\tau}$
\end_inset

.
\end_layout

\begin_layout Standard
La identidad 
\begin_inset Formula $x_{1}\approx x_{1}$
\end_inset

 sera llamada 
\shape italic
axioma logico ecuacional de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

.
 Notese que dicha identidad no es ni mas ni menos que la sentencia 
\begin_inset Formula $\forall x_{1}(x_{1}\equiv x_{1})$
\end_inset

 la cual es universalmente valida.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "wiki-prueba.ecuacional"

\end_inset


\end_layout

\begin_layout Subsubsection
Definicion de prueba ecuacional
\end_layout

\begin_layout Standard
Dada una teoria ecuacional 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 y una identidad 
\begin_inset Formula $p\approx q$
\end_inset

 de tipo 
\begin_inset Formula $\tau$
\end_inset

, una 
\shape italic
prueba ecuacional
\shape default
 de 
\begin_inset Formula $p\approx q$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 sera una palabra 
\begin_inset Formula $\mathbf{\varphi}\in S^{\tau+}$
\end_inset

 tal que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset

Cada 
\begin_inset Formula $\mathbf{\varphi}_{k}$
\end_inset

, con 
\begin_inset Formula $k=1,...,n(\mathbf{\varphi})$
\end_inset

, es una identidad de tipo 
\begin_inset Formula $\tau$
\end_inset

 y 
\begin_inset Formula $\mathbf{\varphi}_{n(\mathbf{\varphi})}=p\approx q$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Para cada 
\begin_inset Formula $k=1,...,n(\mathbf{\varphi})$
\end_inset

, se da alguna de las siguientes
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(a)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{\varphi}_{k}=x_{1}\approx x_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(b)
\end_layout

\end_inset


\begin_inset Formula $\mathbf{\varphi}_{k}\in\Sigma$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(c)
\end_layout

\end_inset

hay 
\begin_inset Formula $i,j<k$
\end_inset

 tales que 
\begin_inset Formula $\mathbf{\varphi}_{k}$
\end_inset

 se deduce por la regla de transitividad ecuacional a partir de 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 y 
\begin_inset Formula $\mathbf{\varphi}_{j}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(d)
\end_layout

\end_inset

hay 
\begin_inset Formula $i<k$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{\varphi}_{k}$
\end_inset

 se deduce por la regla de simetria ecuacional a partir de 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(e)
\end_layout

\end_inset

hay 
\begin_inset Formula $i<k$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{\varphi}_{k}$
\end_inset

 se deduce por la regla de substitucion ecuacional a partir de 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(f)
\end_layout

\end_inset

hay 
\begin_inset Formula $i<k$
\end_inset

 tal que 
\begin_inset Formula $\mathbf{\varphi}_{k}$
\end_inset

 se deduce por la regla de reemplazo ecuacional a partir de 
\begin_inset Formula $\mathbf{\varphi}_{i}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Escribiremos 
\begin_inset Formula $(\Sigma,\tau)\vdash_{ec}p\approx q$
\end_inset

 cuando haya una prueba ecuacional de 
\begin_inset Formula $p\approx q$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Correccion ecuacional
\end_layout

\begin_layout Standard
Para probar que el concepto de prueba ecuacional es correcto nos hara falta
 el siguiente lema.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Todas las reglas introducidas en la seccion anterior son universales en
 el sentido que si 
\begin_inset Formula $\varphi$
\end_inset

 se deduce de 
\begin_inset Formula $\psi_{1},...,\psi_{k}$
\end_inset

 por alguna de estas reglas, entonces 
\begin_inset Formula $\left((\psi_{1}\wedge...\wedge\psi_{k})\rightarrow\varphi\right)$
\end_inset

 es una sentencia universalmente valida.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Veamos que la regla de reemplazo es universal.
 Basta con ver por induccion en 
\begin_inset Formula $k$
\end_inset

 que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Teo
\begin_inset Formula $_{k}$
\end_inset

: Sean 
\begin_inset Formula $t,s\in T^{\tau}$
\end_inset

, 
\begin_inset Formula $r\in T_{k}^{\tau}$
\end_inset

 y sea 
\begin_inset Formula $\mathbf{A}$
\end_inset

 una 
\begin_inset Formula $\tau$
\end_inset

-algebra tal que 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=s^{\mathbf{A}}[\vec{a}]$
\end_inset

, para cada 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

.
 Entonces 
\begin_inset Formula $r^{\mathbf{A}}[\vec{a}]=\tilde{r}^{\mathbf{A}}[\vec{a}]$
\end_inset

, para cada 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

, donde 
\begin_inset Formula $\tilde{r}$
\end_inset

 es el resultado de reemplazar algunas ocurrencias de 
\begin_inset Formula $t$
\end_inset

 en 
\begin_inset Formula $r$
\end_inset

 por 
\begin_inset Formula $s.$
\end_inset

 
\end_layout

\begin_layout Standard
La prueba de Teo
\begin_inset Formula $_{0}$
\end_inset

 es dejada al lector.
 Asumamos que vale Teo
\begin_inset Formula $_{k}$
\end_inset

 y probemos que vale Teo
\begin_inset Formula $_{k+1}$
\end_inset

.
 Sean 
\begin_inset Formula $t,s\in T^{\tau}$
\end_inset

, 
\begin_inset Formula $r\in T_{k+1}^{\tau}-T_{k}^{\tau}$
\end_inset

 y sea 
\begin_inset Formula $\mathbf{A}$
\end_inset

 una 
\begin_inset Formula $\tau$
\end_inset

-algebra tal que 
\begin_inset Formula $t^{\mathbf{A}}[\vec{a}]=s^{\mathbf{A}}[\vec{a}]$
\end_inset

, para cada 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

.
 Sea 
\begin_inset Formula $\tilde{r}$
\end_inset

 el resultado de reemplazar algunas ocurrencias de 
\begin_inset Formula $t$
\end_inset

 en 
\begin_inset Formula $r$
\end_inset

 por 
\begin_inset Formula $s$
\end_inset

.
 El caso 
\begin_inset Formula $t=r$
\end_inset

 es trivial.
 Supongamos entonces que 
\begin_inset Formula $t\neq r$
\end_inset

.
 Supongamos 
\begin_inset Formula $r=f(r_{1},...,r_{n})$
\end_inset

, con 
\begin_inset Formula $r_{1},...,r_{n}\in T_{k}^{\tau}$
\end_inset

 y 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

.
 Notese que por Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "reemp-ter-en-ter"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $\tilde{r}=f(\tilde{r}_{1},...,\tilde{r}_{n})$
\end_inset

, donde cada 
\begin_inset Formula $\tilde{r}_{i}$
\end_inset

 es el resultado de reemplazar algunas ocurrencias de 
\begin_inset Formula $t$
\end_inset

 en 
\begin_inset Formula $r_{i}$
\end_inset

 por 
\begin_inset Formula $s$
\end_inset

.
 Para 
\begin_inset Formula $\vec{a}\in A^{\mathbf{N}}$
\end_inset

 se tiene que
\begin_inset Formula 
\[
\begin{array}{cclll}
r^{\mathbf{A}}[\vec{a}] & = & f(r_{1},...,r_{n})^{\mathbf{A}}[\vec{a}]\\
 & = & f^{\mathbf{A}}(r_{1}^{\mathbf{A}}[\vec{a}],...,r_{n}^{\mathbf{A}}[\vec{a}])\\
 & = & f^{\mathbf{A}}(\tilde{r}_{1}^{\mathbf{A}}[\vec{a}],...,\tilde{r}_{n}^{\mathbf{A}}[\vec{a}]) &  & \text{por Teo}_{k}\\
 & = & f(\tilde{r}_{1},...,\tilde{r}_{n})^{\mathbf{A}}[\vec{a}]\\
 & = & \tilde{r}^{\mathbf{A}}[\vec{a}]
\end{array}
\]

\end_inset

lo cual prueba Teo
\begin_inset Formula $_{k+1}$
\end_inset


\end_layout

\begin_layout Standard
Veamos que la regla de substitucion es universal.
 Supongamos 
\begin_inset Formula $\mathbf{A}\models t\approx s$
\end_inset

, con 
\begin_inset Formula $t=_{d}t(x_{1},...,x_{n})$
\end_inset

 y 
\begin_inset Formula $s=_{d}s(x_{1},...,x_{n})$
\end_inset

.
 Veremos que entonces 
\begin_inset Formula $\mathbf{A}\models t(p_{1},...,p_{n})\approx s(p_{1},...,p_{n}).$
\end_inset

 Supongamos que 
\begin_inset Formula $p_{i}=_{d}p_{i}(x_{1},...,x_{m})$
\end_inset

, para cada 
\begin_inset Formula $i=1,...,n.$
\end_inset

 Por (a) del Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "reemp-term"
plural "false"
caps "false"
noprefix "false"

\end_inset

, tenemos que
\begin_inset Formula 
\begin{align*}
t(p_{1},...,p_{n}) & =_{d}t(p_{1},...,p_{n})(x_{1},...,x_{m})\\
s(p_{1},...,p_{n}) & =_{d}s(p_{1},...,p_{n})(x_{1},...,x_{m})
\end{align*}

\end_inset

Sea 
\begin_inset Formula $\vec{a}\in A^{m}$
\end_inset

.
 Tenemos que
\begin_inset Formula 
\[
\begin{array}{rcl}
t(p_{1},...,p_{n})^{\mathbf{A}}\left[\vec{a}\right] & = & t^{\mathbf{A}}\left[p_{1}^{\mathbf{A}}\left[\vec{a}\right],...,p_{n}^{\mathbf{A}}\left[\vec{a}\right]\right]\\
 & = & s^{\mathbf{A}}\left[p_{1}^{\mathbf{A}}\left[\vec{a}\right],...,p_{n}^{\mathbf{A}}\left[\vec{a}\right]\right]\\
 & = & s(p_{1},...,p_{n})^{\mathbf{A}}\left[\vec{a}\right]
\end{array}
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $\mathbf{A}\models t(p_{1},...,p_{n})\approx s(p_{1},...,p_{n})$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
Si 
\begin_inset Formula $(\Sigma,\tau)\vdash_{ec}p\approx q$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma,\tau)\models p\approx q$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $\mathbf{\varphi}$
\end_inset

 una prueba ecuacional de 
\begin_inset Formula $p\approx q$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

.
 Usando el lema anterior se puede probar facilmente por induccion en 
\begin_inset Formula $i$
\end_inset

 que 
\begin_inset Formula $(\Sigma,\tau)\models\mathbf{\varphi}_{i}$
\end_inset

, por lo cual 
\begin_inset Formula $(\Sigma,\tau)\models p\approx q$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Completitud ecuacional
\end_layout

\begin_layout Standard
Para probar que el concepto de prueba ecuacional es completo nos haran falta
 algunos resultados basicos que tienen interes por si mismos.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsubsection
El algebra de terminos
\end_layout

\begin_layout Standard
Dado un tipo algebraico 
\begin_inset Formula $\tau$
\end_inset

, hay una forma natural de definir un algebra 
\begin_inset Formula $\mathbf{T}^{\tau}$
\end_inset

 cuyo universo es 
\begin_inset Formula $T^{\tau}$
\end_inset

, de la siguiente manera
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $c^{\mathbf{T}^{\tau}}=c$
\end_inset

, para cada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $f^{\mathbf{T}^{\tau}}(t_{1},...,t_{n})=f(t_{1},...,t_{n})$
\end_inset

, para todo 
\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset

, 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
Llamaremos a 
\begin_inset Formula $\mathbf{T}^{\tau}$
\end_inset

 el 
\shape italic
algebra de terminos de tipo 
\shape default

\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\begin_layout Example
Supongamos 
\begin_inset Formula $\tau=(\emptyset,\{f\},\emptyset,\{(f,1)\}).$
\end_inset

 Entonces el universo de 
\begin_inset Formula $\mathbf{T}^{\tau}$
\end_inset

 es
\end_layout

\begin_layout Example
\begin_inset Formula $\{x_{1},f(x_{1}),f(f(x_{1})),...\}\cup$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\{x_{2},f(x_{2}),f(f(x_{2})),...\}\cup$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\{x_{3},f(x_{3}),f(f(x_{3})),...\}\cup$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\;\;\;\;\;\;\;\;\;\;\vdots$
\end_inset


\end_layout

\begin_layout Example
\noindent
La funcion que interpreta a 
\begin_inset Formula $f$
\end_inset

 en 
\begin_inset Formula $\mathbf{T}^{\tau}$
\end_inset

 es la que a cada elemento del conjunto anterior le asigna el primer elemento
 que esta a su derecha.
 Notese entonces que 
\begin_inset Formula $\mathbf{T}^{\tau}$
\end_inset

 resulta isomorfa al algebra 
\begin_inset Formula $\mathbf{A}$
\end_inset

 definida por
\begin_inset Formula 
\begin{align*}
A & =\mathbf{N}\times\mathbf{N}\\
f^{\mathbf{A}}((n,m)) & =(n,m+1)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "v(t,t1,t2,...)"

\end_inset

Dados 
\begin_inset Formula $t_{1},...,t_{n}$
\end_inset

,
\begin_inset Formula $\;t=_{d}t(x_{1},...,x_{n})\in T^{\tau}$
\end_inset

, se tiene que 
\begin_inset Formula $t^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}]=t(t_{1},...,t_{n})$
\end_inset


\series bold
.

\series default
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Para cada 
\begin_inset Formula $k\geq0$
\end_inset

, sea
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Teo
\begin_inset Formula $_{k}$
\end_inset

: Dados 
\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset

 y 
\begin_inset Formula $t=_{d}t(x_{1},...,x_{n})\in T_{k}^{\tau}$
\end_inset

, se tiene que 
\begin_inset Formula $t^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}]=t(t_{1},...,t_{n})$
\end_inset


\series bold
.

\series default
 
\end_layout

\begin_layout Standard
Veamos que es cierto Teo
\begin_inset Formula $_{0}$
\end_inset

.
 Hay dos casos
\end_layout

\begin_layout Standard
\noindent
Caso 
\begin_inset Formula $t=_{d}t(x_{1},...,x_{n})=c\in\mathcal{C}$
\end_inset

.
\end_layout

\begin_layout Standard
Entonces tenemos
\begin_inset Formula 
\[
\begin{array}{cll}
t^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}] & = & c^{\mathbf{T}^{\tau}}\\
 & = & c\\
 & = & t(t_{1},...,t_{n})
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Caso 
\begin_inset Formula $t=_{d}t(x_{1},...,x_{n})=x_{i}$
\end_inset

, para algun 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
Entonces tenemos
\begin_inset Formula 
\[
\begin{array}{cll}
t^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}] & = & t_{i}\\
 & = & t(t_{1},...,t_{n})
\end{array}
\]

\end_inset

Veamos que Teo
\begin_inset Formula $_{k}$
\end_inset

 implica Teo
\begin_inset Formula $_{k+1}$
\end_inset

.
 Supongamos que vale Teo
\begin_inset Formula $_{k}$
\end_inset

.
 Sean 
\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset

 y 
\begin_inset Formula $t=_{d}t(x_{1},...,x_{n})\in T_{k+1}^{\tau}-T_{k}^{\tau}$
\end_inset

.
 Hay 
\begin_inset Formula $f\in\mathcal{F}_{m}$
\end_inset

, con 
\begin_inset Formula $m\geq1$
\end_inset

, y terminos 
\begin_inset Formula $s_{1},...,s_{m}\in T_{k}^{\tau}$
\end_inset

 tales que 
\begin_inset Formula $t=f(s_{1},...,s_{m})$
\end_inset

.
 Notese que 
\begin_inset Formula $s_{i}=_{d}s_{i}(x_{1},...,x_{n})$
\end_inset

, 
\begin_inset Formula $i=1,...,m$
\end_inset

.
 Tenemos entonces que
\begin_inset Formula 
\[
\begin{array}{lll}
t^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}] & = & f(s_{1},...,s_{m})^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}]\\
 & = & f^{\mathbf{T}^{\tau}}(s_{1}^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}],...,s_{m}^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}])\\
 & = & f^{\mathbf{T}^{\tau}}(s_{1}(t_{1},...,t_{n}),...,s_{m}(t_{1},...,t_{n}))\\
 & = & f(s_{1}(t_{1},...,t_{n}),...,s_{m}(t_{1},...,t_{n}))\\
 & = & t(t_{1},...,t_{n})
\end{array}
\]

\end_inset

con lo cual vale Teo
\begin_inset Formula $_{k+1}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El algebra de terminos tiene la siguiente propiedad fundamental:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

[
\end_layout

\end_inset

[Universal Maping Property
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

]
\end_layout

\end_inset

Si 
\begin_inset Formula $\mathbf{A}$
\end_inset

 es cualquier 
\begin_inset Formula $\tau$
\end_inset

-algebra y 
\begin_inset Formula $F:Var\rightarrow A$
\end_inset

, es una funcion cualquiera, entonces 
\begin_inset Formula $F$
\end_inset

 puede ser extendida a un homomorfismo 
\begin_inset Formula $\bar{F}:\mathbf{T}^{\tau}\rightarrow\mathbf{A}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Definamos 
\begin_inset Formula $\bar{F}$
\end_inset

 de la siguiente manera:
\begin_inset Formula 
\[
\bar{F}(t)=t^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)]
\]

\end_inset

Es claro que 
\begin_inset Formula $\bar{F}$
\end_inset

 extiende a 
\begin_inset Formula $F$
\end_inset

.
 Veamos que es un homomorfismo.
 Dada 
\begin_inset Formula $c\in\mathcal{C}$
\end_inset

, tenemos que
\begin_inset Formula 
\[
\begin{array}{lll}
\bar{F}(c^{\mathbf{T}^{\tau}}) & = & \bar{F}(c)\\
 & = & c^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)]\\
 & = & c^{\mathbf{A}}
\end{array}
\]

\end_inset

Dados 
\begin_inset Formula $f\in\mathcal{F}_{n}$
\end_inset

, 
\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset

 tenemos que
\begin_inset Formula 
\[
\begin{array}{lll}
\bar{F}(f^{\mathbf{T}^{\tau}}(t_{1},...,t_{n})) & = & \bar{F}(f(t_{1},...,t_{n}))\\
 & = & f(t_{1},...,t_{n})^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)]\\
 & = & f^{\mathbf{A}}(t_{1}^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)],...,t_{n}^{\mathbf{A}}[(F(x_{1}),F(x_{2}),...)])\\
 & = & f^{\mathbf{A}}(\bar{F}(t_{1}),...,\bar{F}(t_{n}))
\end{array}
\]

\end_inset

con lo cual hemos probado que 
\begin_inset Formula $\bar{F}$
\end_inset

 es un homomorfismo 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
Sea 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 una teoria ecuacional.
 Si 
\begin_inset Formula $(\Sigma,\tau)\models p\approx q$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma,\tau)\vdash_{ec}p\approx q.$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $(\Sigma,\tau)\models p\approx q.$
\end_inset

 Sea 
\begin_inset Formula $\theta$
\end_inset

 la siguiente relacion binaria sobre 
\begin_inset Formula $T^{\tau}$
\end_inset

:
\begin_inset Formula 
\[
\theta=\{(t,s):(\Sigma,\tau)\vdash_{ec}t\approx s\}.
\]

\end_inset

Dejamos al lector probar que 
\begin_inset Formula $\theta$
\end_inset

 es una congruencia de 
\begin_inset Formula $\mathbf{T}^{\tau}$
\end_inset

.
 Veamos que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(*)
\end_layout

\end_inset


\begin_inset Formula $t^{\mathbf{T}^{\tau}/\theta}[t_{1}/\theta,...,t_{n}/\theta]=t(t_{1},...,t_{n})/\theta$
\end_inset

, para todo 
\begin_inset Formula $t_{1},...,t_{n}$
\end_inset

, 
\begin_inset Formula $t=_{d}t(x_{1},...,x_{n})$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Por Corolario 
\begin_inset CommandInset ref
LatexCommand ref
reference "v(t,a1,...)/tita"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que
\begin_inset Formula 
\[
t^{\mathbf{T}^{\tau}/\theta}[t_{1}/\theta,...,t_{n}/\theta]=t^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}]/\theta
\]

\end_inset

Pero por Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "v(t,t1,t2,...)"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $t^{\mathbf{T}^{\tau}}[t_{1},...,t_{n}]=t(t_{1},...,t_{n})$
\end_inset

 por lo cual (*) es verdadera.
\end_layout

\begin_layout Standard
Veamos que 
\begin_inset Formula $\mathbf{T}^{\tau}/\theta\models\Sigma.$
\end_inset

 Sea 
\begin_inset Formula $t\approx s$
\end_inset

 un elemento de 
\begin_inset Formula $\Sigma$
\end_inset

, con 
\begin_inset Formula $t=_{d}t(x_{1},...,x_{n})$
\end_inset

 y 
\begin_inset Formula $s=_{d}s(x_{1},...,x_{n}).$
\end_inset

 Veremos que 
\begin_inset Formula $\mathbf{T}^{\tau}/\theta\models t\approx s$
\end_inset

, es decir veremos que
\begin_inset Formula 
\[
t^{\mathbf{T}^{\tau}/\theta}[t_{1}/\theta,...,t_{n}/\theta]=s^{\mathbf{T}^{\tau}/\theta}[t_{1}/\theta,...,t_{n}/\theta]
\]

\end_inset

para todo 
\begin_inset Formula $t_{1}/\theta,...,t_{n}/\theta\in T^{\tau}/\theta$
\end_inset

.
 Notese que
\begin_inset Formula 
\[
(\Sigma,\tau)\vdash_{ec}t(t_{1},...,t_{n})\approx s(t_{1},...,t_{n})
\]

\end_inset

por lo cual 
\begin_inset Formula $t(t_{1},...,t_{n})/\theta=s(t_{1},...,t_{n})/\theta.$
\end_inset

 Por (*) tenemos entonces
\begin_inset Formula 
\[
t^{\mathbf{T}^{\tau}/\theta}[t_{1}/\theta,...,t_{n}/\theta]=t(t_{1},...,t_{n})/\theta=s(t_{1},...,t_{n})/\theta=s^{\mathbf{T}^{\tau}/\theta}[t_{1}/\theta,...,t_{n}/\theta],
\]

\end_inset

lo cual nos dice que 
\begin_inset Formula $\mathbf{T}^{\tau}/\theta$
\end_inset

 satisface la identidad 
\begin_inset Formula $t\approx s.$
\end_inset


\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $\mathbf{T}^{\tau}/\theta\models\Sigma$
\end_inset

, por hipotesis tenemos que 
\begin_inset Formula $\mathbf{T}^{\tau}/\theta\models p\approx q.$
\end_inset

 Es decir que si 
\begin_inset Formula $p=_{d}p(x_{1},...,x_{n})$
\end_inset

 y 
\begin_inset Formula $q=_{d}q(x_{1},...,x_{n})$
\end_inset

 tenemos que 
\begin_inset Formula $p^{\mathbf{T}^{\tau}/\theta}[t_{1}/\theta,...,t_{n}/\theta]=q^{\mathbf{T}^{\tau}/\theta}[t_{1}/\theta,...,t_{n}/\theta]$
\end_inset

, para todo 
\begin_inset Formula $t_{1},...,t_{n}\in T^{\tau}$
\end_inset

.
 En particular, tomando 
\begin_inset Formula $t_{i}=x_{i}$
\end_inset

, 
\begin_inset Formula $i=1,...,n$
\end_inset

 tenemos que
\begin_inset Formula 
\[
p^{\mathbf{T}^{\tau}/\theta}[x_{1}/\theta,...,x_{n}/\theta]=q^{\mathbf{T}^{\tau}/\theta}[x_{1}/\theta,...,x_{n}/\theta]
\]

\end_inset

lo cual por (*) nos dice que 
\begin_inset Formula $p/\theta=q/\theta$
\end_inset

, produciendo 
\begin_inset Formula $(\Sigma,\tau)\vdash_{ec}p\approx q$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Sea 
\begin_inset Formula $(\Sigma,\tau)$
\end_inset

 una teoria ecuacional.
 Si 
\begin_inset Formula $(\Sigma,\tau)\vdash p\approx q$
\end_inset

, entonces 
\begin_inset Formula $(\Sigma,\tau)\vdash_{ec}p\approx q$
\end_inset

.
 
\end_layout

\begin_layout Standard
@@finpagina@@
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "wiki-aritmetica.de.peano"

\end_inset


\end_layout

\begin_layout Section
Teorema de incompletitud
\end_layout

\begin_layout Standard
Sea
\begin_inset Formula 
\[
Verd_{\mathbf{\omega}}=\{\varphi\in S^{\tau_{A}}:\mathbf{\omega}\models\varphi\}.
\]

\end_inset

Notese que por el teorema de correccion tenemos que todo teorema de 
\begin_inset Formula $Arit$
\end_inset

 pertenece a 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

.
 Como puede notarse a medida que uno se va familiarizando con la teoria
 
\begin_inset Formula $Arit$
\end_inset

, todos los resultados clasicos de la aritmetica los cuales pueden ser enunciado
s por medio de una sentencia de 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 son en realidad teoremas de 
\begin_inset Formula $Arit$
\end_inset

.
 Sin envargo Godel probo en su famoso teorema de incompletitud (1931) que
 hay una sentencia de 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 la cual no es un teorema de 
\begin_inset Formula $Arit$
\end_inset

.
 Por aos nadie fue capaz de dar una sentencia de 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 la cual tenga un genuino interes aritmetico y la cual no sea un teorema
 de 
\begin_inset Formula $Arit$
\end_inset

.
 Recien en 1977 Paris y Harrington dieron el primer ejemplo de una tal sentencia.
 Una ves sabido que los axiomas de 
\begin_inset Formula $Arit$
\end_inset

 no son suficientemente poderosos como para probar toda sentencia verdadera
 en 
\begin_inset Formula $\mathbf{\omega}$
\end_inset

, una pregunta interesante es
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Hay un conjunto 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

razonable
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 de axiomas 
\begin_inset Formula $\Gamma\subseteq Verd_{\mathbf{\omega}}$
\end_inset

 tal que toda sentencia de 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 es un teorema de 
\begin_inset Formula $(\Gamma,\tau_{A})$
\end_inset

 
\end_layout

\begin_layout Standard
Una respuesta negativa a este problema tambien es dada por el teorema de
 incompletitud de Godel.
 En esta seccion daremos una prueba basada en las ideas de la computabilidad.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Analisis de recursividad del lenguaje de primer orden
\end_layout

\begin_layout Standard
En esta seccion estudiaremos la recursividad de la sintaxis de 
\begin_inset Formula $\tau_{A}$
\end_inset

.
 Los resultados obtenidos valen para un tipo cualquiera y hemos elejido
 a 
\begin_inset Formula $\tau_{A}$
\end_inset

 solo para facilitar la exposicion.
\end_layout

\begin_layout Standard
Analizaremos la recursividad del concepto de prueba formal en una teoria
 de la forma 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

, donde 
\begin_inset Formula $\Sigma$
\end_inset

 es un conjunto recursivamente enumerable.
 Para hacer mas concreto el tratamiento supondremos que los nombres de constante
 auxiliares en las pruebas formales estaran siempre en el conjunto
\begin_inset Formula 
\[
Aux=\{\triangle\Box\triangle,\triangle\Box\Box\triangle,\triangle\Box\Box\Box\triangle,...\}
\]

\end_inset

Esto no afectara nuestro analisis ya que es claro que toda prueba formal
 de una teoria de la forma 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

 puede ser reemplazada por una que sus nombres de constante auxiliares esten
 en 
\begin_inset Formula $Aux$
\end_inset

.
 Es decir que las sentencias involucradas en las pruebas formales que considerar
emos seran sentencias de tipo 
\begin_inset Formula $\tau_{A}^{e}$
\end_inset

 donde
\begin_inset Formula 
\[
\tau_{A}^{e}=(\{0,1\}\cup Aux,\{+^{2},.^{2}\},\{\leq^{2}\},a)
\]

\end_inset

Sea 
\begin_inset Formula $\mathcal{A}$
\end_inset

 el alfabeto formado por los siguientes simbolos
\begin_inset Formula 
\[
\forall\ \ \exists\ \ \lnot\ \ \vee\ \ \wedge\ \ \rightarrow\ \ \leftrightarrow\ \ (\ \ )\ \ ,\ \ \equiv\ \ 0\ \ 1\ \ +\ \ .\ \ \leq\ \ \triangle\ \ \Box\ \ \mathsf{X}\ \ \mathit{0}\ \ \mathit{1}\ \ ...\ \ \mathit{9}\ \ \mathbf{0}\ \ \mathbf{1}\ \ ...\ \ \mathbf{9}
\]

\end_inset

Notese que los simbolos del alfabeto 
\begin_inset Formula $\mathcal{A}$
\end_inset

 son justamente los simbolos que ocurren en las formulas de tipo 
\begin_inset Formula $\tau_{A}^{e}$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Los conjuntos 
\begin_inset Formula $T^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $F^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $T^{\tau_{A}}$
\end_inset

 y 
\begin_inset Formula $F^{\tau_{A}}$
\end_inset

 son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivos.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que los conjuntos 
\begin_inset Formula $T^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $F^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $T^{\tau_{A}}$
\end_inset

 y 
\begin_inset Formula $F^{\tau_{A}}$
\end_inset

 son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computables (justifique).
 Entonces la Tesis de Church nos garantiza que dichos conjuntos son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivos.
\end_layout

\begin_layout Standard
A continuacion daremos una prueba de que dichos conjuntos son en realidad
 
\begin_inset Formula $\mathcal{A}$
\end_inset

-primitivos recursivos.
 Veamos por ejemplo que 
\begin_inset Formula $T^{\tau_{A}^{e}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-primitivo recursivo.
 Fijemos un orden total 
\begin_inset Formula $\leq$
\end_inset

 sobre 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
 Sea 
\begin_inset Formula $P=\lambda x[\ast^{\leq}(x)\in T^{\tau_{A}^{e}}]$
\end_inset

.
 Notese que 
\begin_inset Formula $P(0)=0$
\end_inset

 y 
\begin_inset Formula $P(x+1)=1$
\end_inset

 si y solo si se da alguna de las siguientes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\ast^{\leq}(x+1)\in\{0,1\}\cup Aux$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\exists u,v\in\omega)\ast^{\leq}(x+1)=+(\ast^{\leq}(u),\ast^{\leq}(v))\wedge(P^{\downarrow}(x))_{u+1}\wedge(P^{\downarrow}(x))_{v+1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\exists u,v\in\omega)\ast^{\leq}(x+1)=\mathrm{.}(\ast^{\leq}(u),\ast^{\leq}(v))\wedge(P^{\downarrow}(x))_{u+1}\wedge(P^{\downarrow}(x))_{v+1}$
\end_inset

 
\end_layout

\begin_layout Standard
Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "f-flecha"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r., por lo cual 
\begin_inset Formula $\chi_{T^{\tau_{A}^{e}}}^{\mathcal{A}^{\ast}}=P\circ\#^{\leq}$
\end_inset

 lo es.
 Notese que
\begin_inset Formula 
\[
t\in T^{\tau_{A}}\text{ sii }t\in T^{\tau_{A}^{e}}\wedge\triangle\text{ no ocurre en }t\wedge\Box\text{ no ocurre en }t
\]

\end_inset

por lo cual 
\begin_inset Formula $T^{\tau_{A}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que en la Subseccion 
\begin_inset CommandInset ref
LatexCommand ref
reference "VariablesLibres"
plural "false"
caps "false"
noprefix "false"

\end_inset

 definimos cuando 
\begin_inset Formula $"v\mathit{\ ocurre\ libremente\ en\ }\varphi\mathit{\ a\ partir\ de\ }i"$
\end_inset

, para el caso en que 
\begin_inset Formula $v\in Var$
\end_inset

, 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

 y 
\begin_inset Formula $i\in\{1,...,\left\vert \varphi\right\vert \}$
\end_inset

.
 Extendamos esta definicion diciendo que cuando 
\begin_inset Formula $v\in Var$
\end_inset

, 
\begin_inset Formula $\varphi\in F^{\tau}$
\end_inset

 y 
\begin_inset Formula $i\in\omega-\{1,...,\left\vert \varphi\right\vert \}$
\end_inset

, se da que 
\begin_inset Formula $v\mathit{\ no\ ocurre\ libremente\ en\ }\varphi\mathit{\ a\ partir\ de\ }i$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Los siguientes predicados son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $"v$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset


\shape default
ocurre libremente en
\shape italic

\begin_inset space \space{}
\end_inset


\shape default

\begin_inset Formula $\varphi$
\end_inset

 a partir de 
\begin_inset Formula $i":\omega\times Var\times F^{\tau_{A}^{e}}\rightarrow\omega$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset


\begin_inset Formula $"v\in Li(\varphi)":Var\times F^{\tau_{A}^{e}}\rightarrow\omega$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset


\begin_inset Formula $"v$
\end_inset

 es sustituible por 
\begin_inset Formula $t$
\end_inset

 
\shape italic
en
\shape default
 
\begin_inset Formula $\varphi":Var\times T^{\tau_{A}^{e}}\times F^{\tau_{A}^{e}}\rightarrow\omega$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que los predicados dados en (1), (2) y (3) son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computables (justifique).
 Entonces la Tesis de Church nos garantiza que dichos predicados son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivos.
\end_layout

\begin_layout Standard
En realidad dichos predicados son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r..
 Veamos por ejemplo que 
\begin_inset Formula $P:\omega\times Var\times F^{\tau_{A}^{e}}\rightarrow\omega$
\end_inset

, dado por
\begin_inset Formula 
\[
P(i,v,\varphi)=\left\{ \begin{array}{ccl}
1 &  & \text{si }v\mathit{\ }\text{ocurre libremente en}\mathit{\ }\varphi\text{ a partir de }i\\
0 &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $R:\mathbf{N}\times Var\rightarrow\omega$
\end_inset

 el predicado dado por 
\begin_inset Formula $R(x,v)=1$
\end_inset

 si y solo si 
\begin_inset Formula $\ast^{\leq}((x)_{1})\in F^{\tau_{A}^{e}}$
\end_inset

 y 
\begin_inset Formula $v\mathit{\ }$
\end_inset

ocurre libremente en
\begin_inset Formula $\mathit{\ }\ast^{\leq}((x)_{1})$
\end_inset

 a partir de 
\begin_inset Formula $(x)_{2}$
\end_inset

.
 Sea 
\begin_inset Formula $\bar{R}=R\cup C_{0}^{1,1}|_{\{0\}\times Var}$
\end_inset

.
 
\begin_inset Formula $\mathrm{Nex}=\{\wedge,\vee,\rightarrow,\leftrightarrow\}$
\end_inset

.
 Notese que 
\begin_inset Formula $F_{0}^{\tau_{A}^{e}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 ya que
\begin_inset Formula 
\[
F_{0}^{\tau_{A}^{e}}=F^{\tau_{A}^{e}}\cap(\mathcal{A}-\{\forall,\exists,\lnot,\vee,\wedge,\rightarrow,\leftrightarrow\})^{\ast}
\]

\end_inset

Notese que 
\begin_inset Formula $\bar{R}(0,v)=0$
\end_inset

, para cada 
\begin_inset Formula $v\in Var$
\end_inset

 y que 
\begin_inset Formula $\bar{R}(x+1,v)=1$
\end_inset

 si y solo si 
\begin_inset Formula $(x+1)_{2}\geq1$
\end_inset

 y se da alguna de las siguientes:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\ast^{\leq}((x+1)_{1})\in F_{0}^{\tau_{A}^{e}}\wedge v$
\end_inset

 ocurre en 
\begin_inset Formula $\ast^{\leq}((x+1)_{1})$
\end_inset

 a partir de 
\begin_inset Formula $(x+1)_{2}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\exists\varphi_{1},\varphi_{2}\in F^{\tau_{A}^{e}})(\exists\eta\in\mathrm{Nex})\ast^{\leq}((x+1)_{1})=(\varphi_{1}\eta\varphi_{2})\wedge$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \left((\bar{R}^{\downarrow}(x,v))_{\left\langle \#^{\leq}(\varphi_{1}),(x+1)_{2}-1\right\rangle +1}=1\vee(\bar{R}^{\downarrow}(x,v))_{\left\langle \#^{\leq}(\varphi_{2}),(x+1)_{2}-\left\vert (\varphi_{1}\eta\right\vert \right\rangle +1}=1\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\exists\varphi_{1}\in F^{\tau_{A}^{e}})\ast^{\leq}((x+1)_{1})=\lnot\varphi_{1}\wedge(\bar{R}^{\downarrow}(x,v))_{\left\langle \#^{\leq}(\varphi_{1}),(x+1)_{2}-1\right\rangle +1}=1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\exists\varphi_{1}\in F^{\tau_{A}^{e}})(\exists w\in Var)(Q\in\{\forall,\exists\})\;w\neq v\wedge$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ast^{\leq}((x+1)_{1})=Qw\varphi_{1}\wedge(\bar{R}^{\downarrow}(x,v))_{\left\langle \#^{\leq}(\varphi_{1}),(x+1)_{2}-\left\vert (Qw\right\vert \right\rangle +1}=1$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Es decir que por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "f-flecha"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que 
\begin_inset Formula $\bar{R}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r..
 Notese que para 
\begin_inset Formula $(i,v,\varphi)\in\omega\times Var\times F^{\tau_{A}^{e}}$
\end_inset

, tenemos 
\begin_inset Formula $P(i,v,\varphi)=\bar{R}(\left\langle \#^{\leq}(\varphi),i\right\rangle ,v)$
\end_inset

.
 Ahora es facil obtener la funcion 
\begin_inset Formula $P$
\end_inset

 haciendo composiciones adecuadas con 
\begin_inset Formula $\bar{R}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dados 
\begin_inset Formula $v\in Var$
\end_inset

 y 
\begin_inset Formula $t,s\in T^{\tau_{A}^{e}}$
\end_inset

, usaremos 
\begin_inset Formula $\downarrow_{v}^{t}(s)$
\end_inset

 para denotar el resultado de reemplazar simultaneamente cada ocurrencia
 de 
\begin_inset Formula $v$
\end_inset

 en 
\begin_inset Formula $s$
\end_inset

 por 
\begin_inset Formula $t$
\end_inset

.
 Similarmente, si 
\begin_inset Formula $\varphi\in F^{\tau_{A}^{e}}$
\end_inset

, usaremos 
\begin_inset Formula $\downarrow_{v}^{t}(\varphi)$
\end_inset

 para denotar el resultado de reemplazar simultaneamente cada ocurrencia
 libre de 
\begin_inset Formula $v$
\end_inset

 en 
\begin_inset Formula $\varphi$
\end_inset

 por 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Las funciones 
\begin_inset Formula $\lambda svt[\downarrow_{v}^{t}(s)]$
\end_inset

 y 
\begin_inset Formula $\lambda\varphi vt[\downarrow_{v}^{t}(\varphi)]$
\end_inset

 son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que las funciones 
\begin_inset Formula $\lambda svt[\downarrow_{v}^{t}(s)]$
\end_inset

 y 
\begin_inset Formula $\lambda\varphi vt[\downarrow_{v}^{t}(\varphi)]$
\end_inset

 son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computables (justifique).
 Entonces la Tesis de Church nos garantiza que dichas funciones son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivas.
\end_layout

\begin_layout Standard
En realidad son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r..
 Veamos por ejemplo que 
\begin_inset Formula $\lambda svt[\downarrow_{v}^{t}(s)]$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
 Sea 
\begin_inset Formula $h:\omega\times Var\times T^{\tau_{A}^{e}}\rightarrow\omega$
\end_inset

 dada por
\begin_inset Formula 
\[
h(x,v,t)=\left\{ \begin{array}{ccc}
\#^{\leq}(\downarrow_{v}^{t}(\ast^{\leq}(x))) &  & \text{si }\ast^{\leq}(x)\in T^{\tau_{A}^{e}}\\
0 &  & \text{caso contrario}
\end{array}\right.
\]

\end_inset

Sea 
\begin_inset Formula $P:\mathbf{N}\times\omega\times Var\times T^{\tau_{A}^{e}}\times\mathcal{A}^{\ast}\rightarrow\omega$
\end_inset

 tal que 
\begin_inset Formula $P(A,x,v,t,\alpha)=1$
\end_inset

 si y solo si se da alguna de las siguientes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\ast^{\leq}(x+1)\notin T^{\tau_{A}^{e}}\wedge\alpha=\varepsilon$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\ast^{\leq}(x+1)=v\wedge\alpha=t$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\ast^{\leq}(x+1)\in(\{0,1\}\cup Aux)-\{v\}\wedge\alpha=\ast^{\leq}(x+1)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\exists r,s\in T^{\tau_{A}^{e}})\ast^{\leq}(x+1)=+(r,s)\wedge\alpha=+(\ast^{\leq}((A)_{\#^{\leq}(r)+1}),\ast^{\leq}((A)_{\#^{\leq}(s)+1}))$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $(\exists r,s\in T^{\tau_{A}^{e}})\ast^{\leq}(x+1)=\mathrm{.}(r,s)\wedge\alpha=\mathrm{.}(\ast^{\leq}((A)_{\#^{\leq}(r)+1}),\ast^{\leq}((A)_{\#^{\leq}(s)+1}))$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Sea 
\begin_inset Formula $\bar{P}=P\cup C_{0}^{2,2}|_{\{0\}\times\omega\times Var\times T^{\tau_{A}^{e}}\times\mathcal{A}^{\ast}}$
\end_inset

.
 Notese que 
\begin_inset Formula $\bar{P}(h^{\downarrow}(x,v,t),x,v,t,\alpha)=1$
\end_inset

 si y solo si ya sea 
\begin_inset Formula $\ast^{\leq}(x+1)\notin T^{\tau_{A}^{e}}$
\end_inset

 y 
\begin_inset Formula $\alpha=\varepsilon$
\end_inset

 o 
\begin_inset Formula $\ast^{\leq}(x+1)\in T^{\tau_{A}^{e}}$
\end_inset

 y 
\begin_inset Formula $\alpha=\mathrm{\downarrow}_{v}^{t}(\ast^{\leq}(x+1))$
\end_inset

.
 Tenemos entonces
\begin_inset Formula 
\begin{align*}
h(0,v,t) & =0\\
h(x+1,v,t) & =\#^{\leq}(\min_{\alpha}^{\leq}\bar{P}(h^{\downarrow}(x,v,t),x,v,t,\alpha)),
\end{align*}

\end_inset

por lo cual el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "f-flecha"
plural "false"
caps "false"
noprefix "false"

\end_inset

 nos dice que 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 Ahora es facil obtener la funcion 
\begin_inset Formula $\lambda svt[\downarrow_{v}^{t}(s)]:T^{\tau_{A}^{e}}\times Var\times T^{\tau_{A}^{e}}\rightarrow T^{\tau_{A}^{e}}$
\end_inset

 haciendo composiciones adecuadas con 
\begin_inset Formula $h$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "reemp-formulas"

\end_inset

El predicado 
\begin_inset Formula $R:\mathcal{A}^{4}\rightarrow\omega$
\end_inset

, dado por
\begin_inset Formula 
\[
R(\alpha,\beta,\gamma,\zeta)=\left\{ \begin{array}{cccl}
\begin{array}{c}
1\\
\;\ 
\end{array} &  &  & \begin{array}{cl}
\text{si }\beta= & \text{resultado de reemplazar una}\\
 & \text{ocurrencia de }\gamma\text{ en }\alpha\text{ por }\zeta
\end{array}\\
0 &  &  & \text{ caso contrario}
\end{array}\right.
\]

\end_inset

es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Notese que el predicado 
\begin_inset Formula $R$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computable.
 Entonces la Tesis de Church nos garantiza que 
\begin_inset Formula $R$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivo.
\end_layout

\begin_layout Standard
En realidad 
\begin_inset Formula $R$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 y esto puede verse facilmente ya que 
\begin_inset Formula $R(\alpha,\beta,\gamma,\zeta)=1$
\end_inset

 sii existen 
\begin_inset Formula $\alpha_{1},\alpha_{2}$
\end_inset

 tales que 
\begin_inset Formula $\alpha=\alpha_{1}\gamma\alpha_{2}$
\end_inset

 y 
\begin_inset Formula $\beta=\alpha_{1}\zeta\alpha_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Los conjuntos 
\begin_inset Formula $ModPon^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Elec^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Reem^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $ConjInt^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $ConjElim^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $EquivInt^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $DisjElim^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $DisjInt^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $EquivElim^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Generaliz^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Commut^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Trans^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Exist^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Evoc^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Absur^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $DivPorCas^{\tau_{A}^{e}}$
\end_inset

, 
\begin_inset Formula $Partic^{\tau_{A}^{e}}$
\end_inset

 son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dejamos al lector una prueba via la Tesis de Church.
 En realidad dichos conjuntos son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r..
 Veremos, por ejemplo que 
\begin_inset Formula $Reem^{\tau_{A}^{e}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r..
 Basta con ver que 
\begin_inset Formula $Reem1^{\tau_{A}^{e}}$
\end_inset

 y 
\begin_inset Formula $Reem2^{\tau_{A}^{e}}$
\end_inset

 lo son.
 Veremos que 
\begin_inset Formula $Reem2^{\tau_{A}^{e}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $Q:F^{\tau_{A}^{e}}\times F^{\tau_{A}^{e}}\times F^{\tau_{A}^{e}}\rightarrow\omega$
\end_inset

 el predicado tal que 
\begin_inset Formula $Q(\psi,\varphi,\sigma)=1$
\end_inset

 si y solo si
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $(\exists\alpha\in(\forall Var)^{\ast})(\exists\psi_{1},\psi_{2}\in F^{\tau_{A}^{e}})\ \psi=\alpha(\psi_{1}\leftrightarrow\psi_{2})\wedge$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\ \ \ \ \ Li(\psi_{1})=Li(\psi_{2})\wedge\left((\forall v\in Var)\ v\notin Li(\psi_{1})\vee v\text{ ocurre en }\alpha\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Formula $\left((\forall v\in Var)\ v\text{ no ocurre en }\alpha\vee v\in Li(\psi_{1})\right)\wedge R(\varphi,\sigma,\psi_{1},\psi_{2})$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
(
\begin_inset Formula $R$
\end_inset

 es el predicado dado por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "reemp-formulas"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Es facil ver que 
\begin_inset Formula $Q$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 y que 
\begin_inset Formula $\chi_{Reem2^{\tau_{A}^{e}}}^{\mathcal{A}^{4}}=Q|_{S^{\tau_{A}^{e}}\times S^{\tau_{A}^{e}}\times S^{\tau_{A}^{e}}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 El predicado 
\begin_inset Formula $"\psi$
\end_inset

 se deduce de 
\begin_inset Formula $\varphi$
\end_inset

 por generalizacion con constante 
\begin_inset Formula $c$
\end_inset

, con respecto a 
\begin_inset Formula $\tau_{A}^{e}":S^{\tau_{A}^{e}}\times S^{\tau_{A}^{e}}\times Aux\rightarrow\omega$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que el predicado en cuestion es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computable (justifique).
 Por la Tesis de Church tenemos entonces que dicho predicado es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
\end_layout

\begin_layout Standard
Para probar que en realidad dicho predicado es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r., notese que: 
\begin_inset Formula $\psi$
\end_inset

 se deduce de 
\begin_inset Formula $\varphi$
\end_inset

 por generalizacion con constante 
\begin_inset Formula $c$
\end_inset

 si y solo si hay una formula 
\begin_inset Formula $\gamma$
\end_inset

 y una variable 
\begin_inset Formula $v$
\end_inset

 tales que
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $Li(\gamma)=\{v\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $c$
\end_inset

 no ocurre en 
\begin_inset Formula $\gamma$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\begin_inset Formula $\varphi=\mathrm{\downarrow}_{v}^{c}(\gamma)\wedge\psi=\forall v\gamma$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 El predicado 
\begin_inset Formula $"\psi$
\end_inset

 se deduce de 
\begin_inset Formula $\varphi$
\end_inset

 por eleccion con constante 
\begin_inset Formula $e$
\end_inset

, con respecto a 
\begin_inset Formula $\tau_{A}^{e}":S^{\tau_{A}^{e}}\times S^{\tau_{A}^{e}}\times Aux\rightarrow\omega$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que el predicado en cuestion es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computable (justifique).
 Por la Tesis de Church tenemos entonces que dicho predicado es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
\end_layout

\begin_layout Standard
Dejamos al lector probar que en realidad dicho predicado es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que
\begin_inset Formula 
\[
AxLog^{\tau_{A}^{e}}=\{\varphi\in S^{\tau_{A}^{e}}:\varphi\text{ es un axioma logico de tipo }\tau_{A}^{e}\}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $AxLog^{\tau_{A}^{e}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que el conjunto en cuestion es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computable (justifique).
 Por la Tesis de Church tenemos entonces que dicho conjunto es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
\end_layout

\begin_layout Standard
Dejamos al lector probar que en realidad dicho conjunto es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 La prueba es completamente analoga a la prueba de que 
\begin_inset Formula $\mathrm{Ins}^{\Sigma}$
\end_inset

 es un conjunto 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "Ins-es-pr"
plural "false"
caps "false"
noprefix "false"

\end_inset

) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $\Sigma$
\end_inset

 un alfabeto finito.
 Sea 
\begin_inset Formula $S\subseteq\Sigma^{\ast}$
\end_inset

 un conjunto 
\begin_inset Formula $\Sigma$
\end_inset

-r..
 El conjunto 
\begin_inset Formula $S^{+}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-r., tenemos que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Es facil ver que entonces 
\begin_inset Formula $S^{+}$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-efectivamente computable.
 Por la Tesis de Church tenemos entonces que 
\begin_inset Formula $S$
\end_inset

 es 
\begin_inset Formula $\Sigma$
\end_inset

-recursivo.
\end_layout

\begin_layout Standard
Ya que 
\begin_inset Formula $\alpha\in S^{+}$
\end_inset

 si y solo si
\begin_inset Formula 
\[
(\exists z\in\mathbf{N})(\forall i\in\mathbf{N})_{i\leq Lt(z)}\ast^{\leq}((z)_{i})\in S\wedge\alpha=\mathrm{\subset}_{i=1}^{Lt(z)}\ast^{\leq}((z)_{i})
\]

\end_inset

se puede probar tambien este lema sin usar la Tesis de Church.
 Dejamos al lector los detalles.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que dada 
\begin_inset Formula $\mathbf{\varphi}\in S^{\tau_{A}^{e}+}$
\end_inset

, usamos 
\begin_inset Formula $n(\mathbf{\varphi})$
\end_inset

 y 
\begin_inset Formula $\mathbf{\varphi}_{1},...,\mathbf{\varphi}_{n(\mathbf{\varphi})}$
\end_inset

 para denotar los unicos 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $\varphi_{1},...,\varphi_{n}$
\end_inset

 tales que 
\begin_inset Formula $\mathbf{\varphi}=\varphi_{1}...\varphi_{n}$
\end_inset

 (la unicidad es garantizada en Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "secuencia de sentencias"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Extendamos esta notacion definiendo 
\begin_inset Formula $\mathbf{\varphi}_{i}=\varepsilon$
\end_inset

 para 
\begin_inset Formula $i=0$
\end_inset

 o 
\begin_inset Formula $i>n(\mathbf{\varphi})$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Las funciones
\begin_inset Formula 
\[
\begin{array}{ccc}
S^{\tau_{A}^{e}+} & \rightarrow & \omega\\
\mathbf{\varphi} & \rightarrow & n(\mathbf{\varphi})
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{ccc}
\omega\times S^{\tau_{A}^{e}+} & \rightarrow & S^{\tau_{A}^{e}}\cup\{\varepsilon\}\\
(i,\mathbf{\varphi}) & \rightarrow & \mathbf{\varphi}_{i}
\end{array}
\]

\end_inset

son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que la funciones en cuestion son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computables (justifique).
 Por la Tesis de Church tenemos entonces que son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
\end_layout

\begin_layout Standard
Dejamos al lector probar que en realidad dicho conjunto es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 La prueba es completamente analoga a la prueba de que 
\begin_inset Formula $\lambda\mathcal{P}\left[n(\mathcal{P})\right]$
\end_inset

 y 
\begin_inset Formula $\lambda i\mathcal{P}\left[I_{i}^{\mathcal{P}}\right]$
\end_inset

 son funciones 
\begin_inset Formula $(\Sigma\cup\Sigma_{p})$
\end_inset

-p.r.
 (Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "Pro-es-pr"
plural "false"
caps "false"
noprefix "false"

\end_inset

) 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que dada 
\begin_inset Formula $\mathbf{J}\in Just^{+}$
\end_inset

, usamos 
\begin_inset Formula $n(\mathbf{J})$
\end_inset

 y 
\begin_inset Formula $\mathbf{J}_{1},...,\mathbf{J}_{n(\mathbf{J})}$
\end_inset

 para denotar los unicos 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $J_{1},...,J_{n}$
\end_inset

 tales que 
\begin_inset Formula $\mathbf{J}=J_{1}...J_{n}$
\end_inset

 (la unicidad es garantizada en Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "secuencia de justificaciones"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Extendamos esta notacion definiendo 
\begin_inset Formula $\mathbf{J}_{i}=\varepsilon$
\end_inset

 para 
\begin_inset Formula $i=0$
\end_inset

 o 
\begin_inset Formula $i>n(\mathbf{J})$
\end_inset

.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $\mathcal{B}$
\end_inset

 el alfabeto que consiste en todos los simbolos que ocurren en alguna palabra
 de 
\begin_inset Formula $Just$
\end_inset

.
 Es decir 
\begin_inset Formula $\mathcal{B}$
\end_inset

 consiste de los simbolos
\begin_inset Formula 
\[
(\ )\ ,\ 0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ \text{A\ B\ C\ D\ E\ G\ H\ I\ J\ L\ M\ N\ O\ P\ Q\ R\ S\ T\ U\ V\ X Z}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset Formula $Just$
\end_inset

 es 
\begin_inset Formula $\mathcal{B}$
\end_inset

-r.
 Las funciones
\begin_inset Formula 
\[
\begin{array}{ccc}
Just^{+} & \rightarrow & \omega\\
\mathbf{J} & \rightarrow & n(\mathbf{J})
\end{array}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{ccc}
\omega\times Just^{+} & \rightarrow & Just\cup\{\varepsilon\}\\
(i,\mathbf{J}) & \rightarrow & \mathbf{J}_{i}
\end{array}
\]

\end_inset

son 
\begin_inset Formula $\mathcal{B}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que la funciones en cuestion son 
\begin_inset Formula $\mathcal{B}$
\end_inset

-efectivamente computables (justifique).
 Por la Tesis de Church tenemos entonces que son 
\begin_inset Formula $\mathcal{B}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 El predicado 
\begin_inset Formula $"\left\langle i,j\right\rangle \in\mathcal{B}^{\mathbf{J}}":\omega\times\omega\times Just^{+}\rightarrow\omega$
\end_inset

 es 
\begin_inset Formula $\mathcal{B}$
\end_inset

-r 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que dicho predicado es 
\begin_inset Formula $\mathcal{B}$
\end_inset

-efectivamente computable (justifique).
 Por la Tesis de Church tenemos entonces que es 
\begin_inset Formula $\mathcal{B}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 El conjunto 
\begin_inset Formula $\{\mathbf{J}\in Just^{+}:\mathbf{J}$
\end_inset

 es balanceada
\begin_inset Formula $\}$
\end_inset

 es 
\begin_inset Formula $\mathcal{B}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que dicho conjunto es 
\begin_inset Formula $\mathcal{B}$
\end_inset

-efectivamente computable (justifique).
 Por la Tesis de Church tenemos entonces que es 
\begin_inset Formula $\mathcal{B}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Los predicados
\begin_inset Formula 
\[
\begin{array}{rcl}
\omega\times S^{\tau_{A}^{e}}\times S^{\tau_{A}^{e}+}\times Just^{+} & \rightarrow & \omega\\
(i,\varphi,\mathbf{\varphi},\mathbf{J}) & \rightarrow & \left\{ \begin{array}{ccl}
1 &  & \text{si }(\mathbf{\varphi},\mathbf{J})\text{ es adecuado y }\varphi\text{ es hipotesis de }\mathbf{\varphi}_{i}\text{ en }(\mathbf{\varphi},\mathbf{J})\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset


\begin_inset Formula 
\[
\begin{array}{rcl}
\omega\times\omega\times S^{\tau_{A}^{e}+}\times Just^{+} & \rightarrow & \omega\\
(i,\varphi,\mathbf{\varphi},\mathbf{J}) & \rightarrow & \left\{ \begin{array}{ccl}
1 &  & \text{si }(\mathbf{\varphi},\mathbf{J})\text{ es adecuado y }i\text{ es anterior a }j\text{ en }(\mathbf{\varphi},\mathbf{J})\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset

son 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que los predicados en cuestion son 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-efectivamente computables (justifique).
 Por la Tesis de Church tenemos entonces que dichos predicados son 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 El predicado
\begin_inset Formula 
\[
\begin{array}{rcl}
Aux\times Aux\times S^{\tau_{A}^{e}+}\times Just^{+} & \rightarrow & \omega\\
(e,d,\mathbf{\varphi},\mathbf{J}) & \rightarrow & \left\{ \begin{array}{ccl}
1 &  & \text{si }(\mathbf{\varphi},\mathbf{J})\text{ es adecuado y }e\text{ depende de }d\text{ en }(\mathbf{\varphi},\mathbf{J})\\
0 &  & \text{caso contrario}
\end{array}\right.
\end{array}
\]

\end_inset

es 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r..
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Es claro que el predicado en cuestion es 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-efectivamente computable (justifique).
 Por la Tesis de Church tenemos entonces que dicho predicado es 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dada una teoria de la forma 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

, diremos que una prueba formal 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 de 
\begin_inset Formula $\varphi$
\end_inset

 en 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

 es 
\shape italic
normal
\shape default
 si solo usa nombres de ctes auxiliares de 
\begin_inset Formula $Aux$
\end_inset

, es decir si 
\begin_inset Formula $\mathbf{\varphi}\in S^{\tau_{A}^{e}+}$
\end_inset

.
 Definamos
\begin_inset Formula 
\[
Pruebas_{(\Sigma,\tau_{A})}=\{(\mathbf{\varphi},\mathbf{J}):\exists\varphi\ (\mathbf{\varphi},\mathbf{J})\text{ es una prueba normal de }\varphi\text{ en }(\Sigma,\tau_{A})\}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Sea 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

 una teoria tal que 
\begin_inset Formula $\Sigma$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e.
 (resp.
 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivo).
 Entonces 
\begin_inset Formula $Pruebas_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r.e.
 (resp.
 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-recursivo).
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos que 
\begin_inset Formula $\Sigma$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e..
 Claramente entonces 
\begin_inset Formula $\Sigma$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computable por lo cual hay una funcion 
\begin_inset Formula $g:\omega\rightarrow\Sigma$
\end_inset

 la cual es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente computable y suryectiva.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\mathcal{A}\cup\mathcal{B}$
\end_inset

.
 A continuacion describimos como hacer un procedimiento efectivo enumere
 a 
\begin_inset Formula $Pruebas_{(\Sigma,\tau_{A})}$
\end_inset

.
 Dejamos al lector completar los detalles.
 Dada una prueba formal 
\begin_inset Formula $(\mathbf{\varphi},\mathbf{J})$
\end_inset

 cualquiera, definamos
\begin_inset Formula 
\[
Ax((\mathbf{\varphi},\mathbf{J}))=\{\mathbf{\varphi}_{i}:\text{existe }\alpha\text{ tal que }\mathbf{J}_{i}=\alpha\mathrm{AXIOMAPROPIO}\}
\]

\end_inset


\end_layout

\begin_layout Standard
Etapa 1
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $x=0$
\end_inset

, detenerse y dar como salida 
\begin_inset Formula $((0\equiv0),\mathrm{AXIOMALOGICO})$
\end_inset

.
 En caso contrario ir a Etapa 2
\end_layout

\begin_layout Standard
Etapa 2.
\end_layout

\begin_layout Standard
\noindent
Si 
\begin_inset Formula $(\ast^{\leq}((x)_{1}),\ast^{\leq}((x)_{2}))$
\end_inset

 es una prueba formal y 
\begin_inset Formula $Ax((\ast^{\leq}((x)_{1}),\ast^{\leq}((x)_{2})))\subseteq\{g(0),...,g((x)_{3})\}$
\end_inset

, entonces detenerse y dar como salida 
\begin_inset Formula $(\ast^{\leq}((x)_{1}),\ast^{\leq}((x)_{2}))$
\end_inset

.
 Caso contrario detenerse y dar como salida 
\begin_inset Formula $((0\equiv0),\mathrm{AXIOMALOGICO})$
\end_inset


\end_layout

\begin_layout Standard
Por la Tesis de Church tenemos entonces que 
\begin_inset Formula $Pruebas_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r.e.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Dada una teoria 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

, definamos
\begin_inset Formula 
\[
Teo_{(\Sigma,\tau_{A})}=\{\varphi\in S^{\tau_{A}}:(\Sigma,\tau_{A})\vdash\varphi\}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "teoremas son r.e."

\end_inset

Si 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

 es una teoria tal que 
\begin_inset Formula $\Sigma$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e., entonces 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Como se vio en el lema anterior, tenemos que 
\begin_inset Formula $Pruebas_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-efectivamente enumerable.
 Es facil ahora, usando un procedimiento efectivo que enumere a 
\begin_inset Formula $Pruebas_{(\Sigma,\tau_{A})}$
\end_inset

, disear un procedimiento efectivo que enumere a 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}$
\end_inset

.
 Es decir que 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-efectivamente enumerable, lo cual por la Tesis de Church nos dice que es
 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e.
\end_layout

\begin_layout Standard
A continuacion daremos una prueba que no usa la Tesis de Church.
 Ya que 
\begin_inset Formula $Pruebas_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r.e.
 (lema anterior) tenemos que hay una funcion 
\begin_inset Formula $F:\omega\rightarrow S^{\tau_{A}^{e}+}\times Just^{+}$
\end_inset

 la cual cumple que 
\begin_inset Formula $p_{1}^{0,2}\circ F$
\end_inset

 y 
\begin_inset Formula $p_{2}^{0,2}\circ F$
\end_inset

 son 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r.
 y ademas 
\begin_inset Formula $I_{F}=Pruebas_{(\Sigma,\tau_{A})}$
\end_inset

.
 Sea
\begin_inset Formula 
\[
\begin{array}{rcl}
g:S^{\tau_{A}^{e}+} & \rightarrow & S^{\tau_{A}^{e}}\\
\mathbf{\varphi} & \rightarrow & \mathbf{\varphi}_{n(\mathbf{\varphi})}
\end{array}
\]

\end_inset

Por lemas anteriores 
\begin_inset Formula $g$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r..
 Notese que 
\begin_inset Formula $I_{(g\circ p_{1}^{0,2}\circ F)}=Teo_{(\Sigma,\tau_{A})}$
\end_inset

, lo cual dice que 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{B})$
\end_inset

-r.e.
 (Teorema 
\begin_inset CommandInset ref
LatexCommand ref
reference "equivalencias-r.e."
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Por el teorema de independencia del alfabeto tenemos que 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Funciones representables
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $n\geq1$
\end_inset

.
 Una funcion 
\begin_inset Formula $f:D_{f}\subseteq\omega^{n}\rightarrow\omega$
\end_inset

 sera llamada 
\shape italic
representable
\shape default
 si hay una formula 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n},v)\in F^{\tau_{A}}$
\end_inset

, la cual cumpla
\begin_inset Formula 
\[
\mathbf{\omega}\models\varphi\left[k_{1},...,k_{n},k\right]\mathrm{\ si\ y\ solo\ si\ }f(k_{1},...,k_{n})=k
\]

\end_inset

cualesquiera sean 
\begin_inset Formula $k_{1},...,k_{n},k\in\omega$
\end_inset

.
 En tal caso diremos que la formula 
\begin_inset Formula $\varphi$
\end_inset

 
\shape italic
representa
\shape default
 a la funcion 
\begin_inset Formula $f$
\end_inset

, con respecto a la declaracion 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},...,v_{n},v)$
\end_inset

.
 Notese que cuando 
\begin_inset Formula $(k_{1},...,k_{n})\notin D_{f}$
\end_inset

 entonces debera suceder que 
\begin_inset Formula $\mathbf{\omega}\nvDash\varphi\left[k_{1},...,k_{n},k\right]$
\end_inset

, cualquiera sea 
\begin_inset Formula $k\in\omega$
\end_inset

.
 Cabe destacar que una formula 
\begin_inset Formula $\varphi$
\end_inset

 puede representar a 
\begin_inset Formula $f$
\end_inset

, con respecto a una declaracion y con respecto a otra declaracion puede
 no representarla.
 Por ejemplo la formula 
\begin_inset Formula $(x_{3}\equiv x_{1}+x_{2})$
\end_inset

 representa a la operacion suma con respecto a las declaraciones 
\begin_inset Formula $\varphi=_{d}\varphi(x_{1},x_{2},x_{3})$
\end_inset

 y 
\begin_inset Formula $\varphi=_{d}\varphi(x_{2},x_{1},x_{3})$
\end_inset

 pero con respecto a la declaracion 
\begin_inset Formula $\varphi=_{d}\varphi(x_{3},x_{2},x_{1})$
\end_inset

 no representa a dicha operacion.
 Para dar otro ejemplo, tomemos 
\begin_inset Formula $\varphi=(x_{5}\equiv1)$
\end_inset

.
 Entonces
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Con respecto a la declaracion 
\begin_inset Formula $\varphi=_{d}\varphi(x_{2},x_{5})$
\end_inset

 la formula 
\begin_inset Formula $\varphi$
\end_inset

 representa a la funcion con dominio 
\begin_inset Formula $\omega$
\end_inset

 y valor constantemente 1
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Con respecto a la declaracion 
\begin_inset Formula $\varphi=_{d}\varphi(x_{10},x_{5})$
\end_inset

 la formula 
\begin_inset Formula $\varphi$
\end_inset

 representa a la funcion con dominio 
\begin_inset Formula $\omega$
\end_inset

 y valor constantemente 1
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Con respecto a la declaracion 
\begin_inset Formula $\varphi=_{d}\varphi(x_{2},x_{6},x_{5})$
\end_inset

 la formula 
\begin_inset Formula $\varphi$
\end_inset

 representa a la funcion con dominio 
\begin_inset Formula $\omega^{2}$
\end_inset

 y valor constantemente 1 
\end_layout

\begin_layout Standard
El concepto de funcion representable sera clave en nuestra prueba del teorema
 de incompletitud.
 El resultado clave desde el cual sale facilmente el teorema de incompletitud
 es la Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "verd no es r.e."
plural "false"
caps "false"
noprefix "false"

\end_inset

 en la que se prueba que el conjunto 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 no es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e..Para probar dicha proposicion primero probaremos que toda funcion 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva es representable.
 Aqui es clave una funcion introducida por Godel.
 Sea
\begin_inset Formula 
\[
\beta=\lambda xyi[R(x,y(i+1)+1)]
\]

\end_inset

donde
\begin_inset Formula 
\[
\begin{array}[t]{rll}
R:\omega\times\mathbf{N} & \rightarrow & \omega\\
(x,y) & \rightarrow & \text{resto de la division de }x\text{ por }y
\end{array}
\]

\end_inset

Notese que 
\begin_inset Formula $D_{\beta}=\omega^{3}$
\end_inset

.
 Esta funcion, conocida como la 
\shape italic
funcion 
\shape default

\begin_inset Formula $\beta$
\end_inset


\shape italic

\begin_inset space \space{}
\end_inset

de Godel
\shape default
, es representable ya que por ejemplo la formula
\begin_inset Formula 
\[
\varphi=\exists x_{5}\;(x_{1}\equiv x_{5}.(x_{2}.(x_{3}+1)+1)+x_{4}\wedge x_{4}<x_{2}.(x_{3}+1)+1)
\]

\end_inset

la representa, con respecto a la declaracion 
\begin_inset Formula $\varphi=_{d}\varphi(x_{1},x_{2},x_{3},x_{4})$
\end_inset

.
 Ahora veremos un lema que muestra que la funcion 
\begin_inset Formula $\beta$
\end_inset

 tiene una propiedad sorprendente en el sentido de que cualquier sucesion
 finita de elementos de 
\begin_inset Formula $\omega$
\end_inset

 es producida por 
\begin_inset Formula $\beta$
\end_inset

 si fijamos adecuadamente sus dos primeras entradas.
 Dados 
\begin_inset Formula $x,y\in\omega$
\end_inset

, diremos que 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 son 
\shape italic
coprimos
\shape default
 cuando 
\begin_inset Formula $1$
\end_inset

 sea el unico elemento de 
\begin_inset Formula $\omega$
\end_inset

 que divide a ambos.
 Notese que 
\begin_inset Formula $x$
\end_inset

 e 
\begin_inset Formula $y$
\end_inset

 no son son coprimos sii existe un numero primo 
\begin_inset Formula $p\in\omega$
\end_inset

 que los divide a ambos
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Cualesquiera sean 
\begin_inset Formula $z_{0},...,z_{n}\in\omega$
\end_inset

, 
\begin_inset Formula $n\geq0$
\end_inset

, hay 
\begin_inset Formula $x,y\in\omega$
\end_inset

, tales que 
\begin_inset Formula $\beta(x,y,i)=z_{i}$
\end_inset

, 
\begin_inset Formula $i=0,...,n$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dados 
\begin_inset Formula $x,y,m\in\omega$
\end_inset

 con 
\begin_inset Formula $m\geq1$
\end_inset

, usaremos 
\begin_inset Formula $x\equiv y(m)$
\end_inset

 para expresar que 
\begin_inset Formula $x$
\end_inset

 es congruente a 
\begin_inset Formula $y$
\end_inset

 modulo 
\begin_inset Formula $m$
\end_inset

, es decir para expresar que 
\begin_inset Formula $x-y$
\end_inset

 es divisible por 
\begin_inset Formula $m$
\end_inset

.
 Usaremos en esta prueba el Teorema Chino del Resto:
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset

Dados 
\begin_inset Formula $m_{0},...,m_{n},z_{0},...,z_{n}\in\omega$
\end_inset

 tales que 
\begin_inset Formula $m_{0},...,m_{n}$
\end_inset

 son coprimos de a pares, hay un 
\begin_inset Formula $x\in\omega$
\end_inset

 tal que 
\begin_inset Formula $x\equiv z_{i}(m_{i})$
\end_inset

, para 
\begin_inset Formula $i=0,...,n.$
\end_inset

 
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $y=\max(z_{0},...,z_{n},n)!$
\end_inset

.
 Sean 
\begin_inset Formula $m_{i}=y(i+1)+1$
\end_inset

, 
\begin_inset Formula $i=0,...,n$
\end_inset

.
 Veamos que 
\begin_inset Formula $m_{0},...,m_{n}$
\end_inset

 son coprimos de a pares.
 Supongamos 
\begin_inset Formula $p$
\end_inset

 divide a 
\begin_inset Formula $m_{i}$
\end_inset

 y a 
\begin_inset Formula $m_{j}$
\end_inset

 con 
\begin_inset Formula $i<j$
\end_inset

.
 Entonces 
\begin_inset Formula $p$
\end_inset

 divide a 
\begin_inset Formula $m_{j}-m_{i}=y(j-i)$
\end_inset

 y ya que 
\begin_inset Formula $p$
\end_inset

 no puede dividir a 
\begin_inset Formula $y$
\end_inset

, tenemos que 
\begin_inset Formula $p$
\end_inset

 divide a 
\begin_inset Formula $j-i$
\end_inset

.
 Pero ya que 
\begin_inset Formula $j-i<n$
\end_inset

 tenemos que 
\begin_inset Formula $p<n$
\end_inset

 lo cual es absurdo ya que implicaria que 
\begin_inset Formula $p$
\end_inset

 divide 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Standard
Por el Teorema Chino del Resto hay un 
\begin_inset Formula $x$
\end_inset

 tal que 
\begin_inset Formula $x\equiv z_{i}(m_{i})$
\end_inset

, para 
\begin_inset Formula $i=0,...,n$
\end_inset

.
 Ya que 
\begin_inset Formula $z_{i}<m_{i}$
\end_inset

, tenemos que
\begin_inset Formula 
\[
\beta(x,y,i)=R(x,y(i+1)+1)=R(x,m_{i})=z_{i}\text{, }i=0,...,n\text{.}
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
El lema anterior nos permite probar:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 Si 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva, entonces 
\begin_inset Formula $h$
\end_inset

 es representable 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $f:S_{1}\times...\times S_{n}\rightarrow\omega$
\end_inset

 y 
\begin_inset Formula $g:\omega\times\omega\times S_{1}\times...\times S_{n}\rightarrow\omega$
\end_inset

 son representables, con 
\begin_inset Formula $S_{1},...,S_{n}\subseteq\omega$
\end_inset

 y 
\begin_inset Formula $n\geq0$
\end_inset

.
 Probaremos que entonces 
\begin_inset Formula $R(f,g):\omega\times S_{1}\times...\times S_{n}\rightarrow\omega$
\end_inset

 lo es.
 Para esto primero notese que para 
\begin_inset Formula $t,x_{1},...,x_{n},z\in\omega$
\end_inset

, las siguientes son equivalentes
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(1)
\end_layout

\end_inset


\begin_inset Formula $R(f,g)(t,\vec{x})=z$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(2)
\end_layout

\end_inset

Hay 
\begin_inset Formula $z_{0},...,z_{t}\in\omega$
\end_inset

 tales que
\begin_inset Formula 
\begin{align*}
z_{0} & =f(\vec{x})\\
z_{i+1} & =g(z_{i},i,\vec{x})\text{, }i=0,...,t-1\\
z_{t} & =z
\end{align*}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
(3)
\end_layout

\end_inset

Hay 
\begin_inset Formula $x,y\in\omega$
\end_inset

 tales que
\begin_inset Formula 
\begin{align*}
\beta(x,y,0) & =f(\vec{x})\\
\beta(x,y,i+1) & =g(\beta(x,y,i),i,\vec{x})\text{, }i=0,...,t-1\\
\beta(x,y,t) & =z
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Sean 
\begin_inset Formula $\varphi_{\beta}$
\end_inset

, 
\begin_inset Formula $\varphi_{f}$
\end_inset

 y 
\begin_inset Formula $\varphi_{g}$
\end_inset

 formulas que representen a las funciones 
\begin_inset Formula $\beta$
\end_inset

, 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $g$
\end_inset

, con respecto a las declaraciones
\begin_inset Formula 
\begin{align*}
\varphi_{\beta} & =_{d}\varphi_{\beta}(x_{1},x_{2},x_{3},x_{4})\\
\varphi_{f} & =_{d}\varphi_{f}(x_{1},...,x_{n},x_{n+1})\\
\varphi_{g} & =_{d}\varphi_{g}(x_{1},...,x_{n+2},x_{n+3})
\end{align*}

\end_inset

respectivamente.
 Sean 
\begin_inset Formula $v_{1},...,v_{n+1},v$
\end_inset

, 
\begin_inset Formula $y_{1},y_{2},y_{3},y_{4},z_{1},z_{2}$
\end_inset

 variables todas distintas y tales que cada una de las variebles libres
 de 
\begin_inset Formula $\varphi_{\beta}$
\end_inset

, 
\begin_inset Formula $\varphi_{f}$
\end_inset

 y 
\begin_inset Formula $\varphi_{g}$
\end_inset

 es sustituible por cada una de las variables 
\begin_inset Formula $v_{1},...,v_{n+1},v$
\end_inset

, 
\begin_inset Formula $y_{1},y_{2},y_{3},y_{4},z_{1},z_{2}$
\end_inset

.
 Sea 
\begin_inset Formula $\varphi_{R(f,g)}$
\end_inset

 la siguiente formula
\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\exists z_{1},z_{2}\;(\exists y_{1}\varphi_{\beta}(z_{1},z_{2},0,y_{1})\wedge\varphi_{f}(v_{2},...,v_{n+1},y_{1}))\wedge$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\ \ \ \ \ \ \ \ \ \varphi_{\beta}(z_{1},z_{2},v_{1},v)\wedge\forall y_{2}(y_{2}<v_{1}\rightarrow\exists y_{3},y_{4}\;\varphi_{\beta}(z_{1},z_{2},y_{2}+1,y_{3})\wedge$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Argument item:1
status collapsed

\begin_layout Plain Layout
 
\end_layout

\end_inset


\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \varphi_{\beta}(z_{1},z_{2},y_{2},y_{4})\wedge\varphi_{g}(y_{4},y_{2},v_{2},...,v_{n+1},y_{3}))$
\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Es facil usando (3) ver que la formula 
\begin_inset Formula $\varphi_{R(f,g)}$
\end_inset

 representa a 
\begin_inset Formula $R(f,g)$
\end_inset

, con respecto a la declaracion 
\begin_inset Formula $\varphi_{R(f,g)}=_{d}\varphi_{R(f,g)}(v_{1},...,v_{n+1},v)$
\end_inset

.
\end_layout

\begin_layout Standard
En forma analoga se puede probar que las reglas de composicion y minimizacion
 preservan representabilidad por lo cual ya que los elementos de 
\begin_inset Formula $\mathrm{R}_{0}^{\emptyset}$
\end_inset

 son representables, por induccion tenemos que lo es toda funcion 
\begin_inset Formula $\emptyset$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
Prueba del teorema de incompletitud
\end_layout

\begin_layout Standard
Nuestra estrategia sera probar que 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 no es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e., para lo cual necesitamos los siguientes dos lemas.
 El primero consiste en dar una funcion total numerica la cual codifique
 al predicado 
\begin_inset Formula $"$
\end_inset

el programa 
\begin_inset Formula $\mathcal{P}$
\end_inset

 se detiene luego de 
\begin_inset Formula $t$
\end_inset

 pasos, partiendo del estado 
\begin_inset Formula $((0,0,...),(\mathcal{P},\varepsilon,...))"$
\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 
\begin_inset CommandInset label
LatexCommand label
name "halt-codificado"

\end_inset

Hay un predicado 
\begin_inset Formula $P:\omega\times\omega\rightarrow\omega$
\end_inset

 el cual es 
\begin_inset Formula $\emptyset$
\end_inset

-p.r.
 y tal que el predicado 
\begin_inset Formula $Q=\lambda x\left[(\exists t\in\omega)P(t,x)\right]:\omega\rightarrow\omega$
\end_inset

 no es 
\begin_inset Formula $\emptyset$
\end_inset

-r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Sea 
\begin_inset Formula $\Sigma=\Sigma_{p}$
\end_inset

.
 Recordemos que el predicado
\begin_inset Formula 
\[
P_{1}=\lambda t\mathcal{P}\left[i^{0,1}(t,\mathcal{P},\mathcal{P})=n(\mathcal{P})+1\right]
\]

\end_inset

es 
\begin_inset Formula $\Sigma_{p}$
\end_inset

-p.r.
 ya que la funcion 
\begin_inset Formula $i^{0,1}$
\end_inset

 lo es.
 Notese que el dominio de 
\begin_inset Formula $P_{1}$
\end_inset

 es 
\begin_inset Formula $\omega\times\mathrm{Pro}^{\Sigma_{p}}$
\end_inset

.
 Por Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "autohalt"
plural "false"
caps "false"
noprefix "false"

\end_inset

 tenemos que
\begin_inset Formula 
\[
AutoHalt^{\Sigma_{p}}=\lambda\mathcal{P}\left[(\exists t\in\omega)\;P_{1}(t,\mathcal{P})\right]
\]

\end_inset

no es 
\begin_inset Formula $\Sigma_{p}$
\end_inset

-recursivo.
 Sea 
\begin_inset Formula $\leq$
\end_inset

 un orden total sobre 
\begin_inset Formula $\Sigma_{p}$
\end_inset

.
 Definamos 
\begin_inset Formula $P:\omega\times\omega\rightarrow\omega$
\end_inset

 de la siguiente manera
\begin_inset Formula 
\[
P(t,x)=\left\{ \begin{array}{ccc}
P_{1}(t,\ast^{\leq}(x)) & \text{si} & \ast^{\leq}(x)\in\mathrm{Pro}^{\Sigma_{p}}\\
0 & \text{si} & \ast^{\leq}(x)\notin\mathrm{Pro}^{\Sigma_{p}}
\end{array}\right.
\]

\end_inset

Claramente 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\Sigma_{p}$
\end_inset

-p.r., por lo cual el teorema de independencia del alfabeto nos dice que 
\begin_inset Formula $P$
\end_inset

 es 
\begin_inset Formula $\emptyset$
\end_inset

-p.r..
 Sea 
\begin_inset Formula $Q=\lambda x\left[(\exists t\in\omega)P(t,x)\right]$
\end_inset

.
 Notese que
\begin_inset Formula 
\[
AutoHalt^{\Sigma_{p}}=Q\circ\#^{\leq}\mathrm{|}_{\mathrm{Pro}^{\Sigma_{p}}}
\]

\end_inset

lo cual dice que 
\begin_inset Formula $Q$
\end_inset

 no es 
\begin_inset Formula $\Sigma_{p}$
\end_inset

-r.
 ya que de serlo, el predicado 
\begin_inset Formula $AutoHalt^{\Sigma_{p}}$
\end_inset

 lo seria.
 Por el teorema de independencia del alfabeto tenemos entonces que 
\begin_inset Formula $Q$
\end_inset

 no es 
\begin_inset Formula $\emptyset$
\end_inset

-recursivo.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 No toda funcion representable es 
\begin_inset Formula $\emptyset$
\end_inset

-recursiva 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dejamos como ejercicio para el lector probar que el predicado 
\begin_inset Formula $Q$
\end_inset

 del lema anterior es representable, lo cual completa la prueba de este
 corolario ya que 
\begin_inset Formula $Q$
\end_inset

 no es 
\begin_inset Formula $\emptyset$
\end_inset

-recursivo.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Recordemos que para 
\begin_inset Formula $\alpha\in\Sigma^{\ast}$
\end_inset

, definimos
\begin_inset Formula 
\[
^{\curvearrowright}\alpha=\left\{ \begin{array}{lll}
\left[\alpha\right]_{2}...\left[\alpha\right]_{\left\vert \alpha\right\vert } & \text{si} & \left\vert \alpha\right\vert \geq2\\
\varepsilon & \text{si} & \left\vert \alpha\right\vert \leq1
\end{array}\right.
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
 Si 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e., entonces es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Supongamos 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
 e.
 Sea 
\begin_inset Formula $f:\omega\rightarrow Verd_{\mathbf{\omega}}$
\end_inset

 una funcion sobre y 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
 Sea 
\begin_inset Formula $g:S^{\tau_{A}}\rightarrow S^{\tau_{A}}$
\end_inset

, dada por
\begin_inset Formula 
\[
g(\varphi)=\left\{ \begin{array}{ccc}
^{\curvearrowright}\varphi & \;\; & \text{si }\left[\varphi\right]_{1}=\lnot\\
\lnot\varphi & \;\; & \text{caso contrario}
\end{array}\right.
\]

\end_inset

Notar que 
\begin_inset Formula $g$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-p.r.
 por lo cual 
\begin_inset Formula $g\circ f$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
 Ya que 
\begin_inset Formula $I_{g\circ f}=S^{\tau_{A}}-Verd_{\mathbf{\omega}}$
\end_inset

 (justifique), tenemos que 
\begin_inset Formula $S^{\tau_{A}}-Verd_{\mathbf{\omega}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
 e., por lo cual
\begin_inset Formula 
\[
\mathcal{A}^{\ast}-Verd_{\mathbf{\omega}}=(\mathcal{A}^{\ast}-S^{\tau_{A}})\cup(S^{\tau_{A}}-Verd_{\mathbf{\omega}})
\]

\end_inset

lo es.
 Es decir que 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 y su complemento son 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e.
 por lo cual 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora podemos probar el importante resultado anunciado.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proposition
 
\begin_inset CommandInset label
LatexCommand label
name "verd no es r.e."

\end_inset


\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 no es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Por el Lema 
\begin_inset CommandInset ref
LatexCommand ref
reference "halt-codificado"
plural "false"
caps "false"
noprefix "false"

\end_inset

 hay un predicado 
\begin_inset Formula $\emptyset$
\end_inset

-p.r., 
\begin_inset Formula $P:\omega\times\omega\rightarrow\omega$
\end_inset

 tal que el predicado 
\begin_inset Formula $Q=\lambda x\left[(\exists t\in\omega)P(t,x)\right]:\omega\rightarrow\omega$
\end_inset

 no es 
\begin_inset Formula $\emptyset$
\end_inset

-recursivo.
 Notese que 
\begin_inset Formula $Q$
\end_inset

 tampoco es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivo.
 Ya que 
\begin_inset Formula $P$
\end_inset

 es representable, hay una formula 
\begin_inset Formula $\varphi=_{d}\varphi(v_{1},v_{2},v)\in F^{\tau_{A}}$
\end_inset

 la cual cumple
\begin_inset Formula 
\[
\mathbf{\omega}\models\varphi\left[t,x,k\right]\text{ si y solo si }P(t,x)=k
\]

\end_inset

cualesquiera sean 
\begin_inset Formula $t,x,k\in\omega.$
\end_inset

 Sea 
\begin_inset Formula $\psi=\varphi(v_{1},v_{2},1)$
\end_inset

.
 Declaremos 
\begin_inset Formula $\psi=_{d}\psi(v_{1},v_{2})$
\end_inset

.
 Tenemos entonces
\begin_inset Formula 
\[
\mathbf{\omega}\models\psi\left[t,x\right]\text{ si y solo si }P(t,x)=1
\]

\end_inset

cualesquiera sean 
\begin_inset Formula $t,x\in\omega.$
\end_inset

 Sea 
\begin_inset Formula $\psi_{0}=\exists v_{1}\ \psi(v_{1},v_{2})$
\end_inset

.
 Declaremos 
\begin_inset Formula $\psi_{0}=_{d}\psi_{0}(v_{2})$
\end_inset

.
 Tenemos entonces
\begin_inset Formula 
\[
\mathbf{\omega}\models\psi_{0}\left[x\right]\text{ si y solo si }Q(x)=1
\]

\end_inset

cualesquiera sea 
\begin_inset Formula $x\in\omega$
\end_inset

.
 Por el lema de reemplazo tenemos que para 
\begin_inset Formula $x\in\omega$
\end_inset

,
\begin_inset Formula 
\[
\mathbf{\omega}\models\psi_{0}\left[x\right]\text{ si y solo si }\mathbf{\omega}\models\psi_{0}(\widehat{x})
\]

\end_inset

(justifique), por lo cual
\begin_inset Formula 
\[
\mathbf{\omega}\models\psi_{0}(\widehat{x})\text{ si y solo si }Q(x)=1
\]

\end_inset

cualesquiera sea 
\begin_inset Formula $x\in\omega$
\end_inset

.
 Ya que 
\begin_inset Formula $\psi_{0}(\widehat{x})$
\end_inset

 es una sentencia,
\begin_inset Formula 
\[
\psi_{0}(\widehat{x})\in Verd_{\mathbf{\omega}}\text{ si y solo si }Q(x)=1
\]

\end_inset

Sea 
\begin_inset Formula $h:\omega\rightarrow\mathcal{A}^{\ast}$
\end_inset

, dada por 
\begin_inset Formula $h(x)=\psi_{0}(\widehat{x})$
\end_inset

.
 Es facil ver que 
\begin_inset Formula $h$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursiva.
 Ya que 
\begin_inset Formula $Q=\chi_{Verd_{\mathbf{\omega}}}^{\mathcal{A}^{\ast}}\circ h$
\end_inset

 y 
\begin_inset Formula $Q$
\end_inset

 no es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivo, tenemos que 
\begin_inset Formula $\chi_{Verd_{\mathbf{\omega}}}^{\mathcal{A}^{\ast}}$
\end_inset

 no es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursiva, es decir que 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 es un conjunto no 
\begin_inset Formula $\mathcal{A}$
\end_inset

-recursivo.
 El lema anterior nos dice entonces que es 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 no es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e..
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Ahora si, estamos en condiciones de probar facilmente el famoso resultado
 de Godel.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Theorem
Si 
\begin_inset Formula $\Sigma\subseteq Verd_{\mathbf{\omega}}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e., entonces 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}\subsetneq Verd_{\mathbf{\omega}}$
\end_inset

 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Ya que 
\begin_inset Formula $\mathbf{\omega}$
\end_inset


\begin_inset space \space{}
\end_inset

es un modelo de 
\begin_inset Formula $(\Sigma,\tau_{A})$
\end_inset

, por el Teorema de Correccion, tenemos que 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}\subseteq Verd_{\mathbf{\omega}}$
\end_inset

.
 Ya que 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e (Proposicion 
\begin_inset CommandInset ref
LatexCommand ref
reference "teoremas son r.e."
plural "false"
caps "false"
noprefix "false"

\end_inset

) y 
\begin_inset Formula $Verd_{\mathbf{\omega}}$
\end_inset

 no lo es, tenemos que 
\begin_inset Formula $Teo_{(\Sigma,\tau_{A})}\neq Verd_{\mathbf{\omega}}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Corollary
 Existe 
\begin_inset Formula $\varphi\in S^{\tau_{A}}$
\end_inset

 tal que 
\begin_inset Formula $Arit\nvdash\varphi$
\end_inset

 y 
\begin_inset Formula $Arit\nvdash\lnot\varphi$
\end_inset

.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Proof
 Dejamos al lector la prueba de que el conjunto 
\begin_inset Formula $\Sigma_{A}$
\end_inset

 es 
\begin_inset Formula $\mathcal{A}$
\end_inset

-r.e..
 Una ves probado esto, podemos aplicar el teorema anterior a la teoria 
\begin_inset Formula $Arit=(\Sigma_{A},\tau_{A})$
\end_inset

, lo cual nos dice que 
\begin_inset Formula $Teo_{Arit}\subsetneq Verd_{\mathbf{\omega}}$
\end_inset

.
 Sea 
\begin_inset Formula $\varphi\in Verd_{\mathbf{\omega}}-Teo_{Arit}$
\end_inset

.
 O sea que 
\begin_inset Formula $Arit\nvdash\varphi$
\end_inset

 y 
\begin_inset Formula $\varphi\in Verd_{\mathbf{\omega}}$
\end_inset

.
 Ya que 
\begin_inset Formula $\lnot\varphi\notin Verd_{\mathbf{\omega}}$
\end_inset

, tenemos que 
\begin_inset Formula $\lnot\varphi\notin Teo_{Arit}$
\end_inset

, es decir 
\begin_inset Formula $Arit\nvdash\lnot\varphi$
\end_inset

.
 
\end_layout

\end_body
\end_document
